{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"909a2b39bf012a9bb70865f9ba4569a08b165adb","modified":1483674706000},{"_id":"themes/next/README.en.md","hash":"3b0c7998cf17f9cf9e1a5bfcd65679a43a00c817","modified":1483546612000},{"_id":"themes/next/_config.yml","hash":"769f6ff9aec45a639fd75869b17183a080450d14","modified":1483683162000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1483546612000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1483546612000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1483546612000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1483546612000},{"_id":"source/_posts/AMS中的进程管理部分－上.md","hash":"3d2b0da4ac2a4975678da4bb02e93be7a7300a0d","modified":1483680578000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1483680474000},{"_id":"source/_posts/Activity启动流程.md","hash":"ef2aab43d1b87033d5f9a1a1b5bae4cf925992e3","modified":1483680570000},{"_id":"source/_posts/AndroidJNI学习笔记（四）－数据类型映射以及native调用java.md","hash":"7388d15fe23f97aa85e8b4e0c395dd6cb85f7842","modified":1483680627000},{"_id":"source/_posts/Android消息机制浅析.md","hash":"675c21f26b0c25a6696c9ebf1d4cd653d23fd4e3","modified":1483680602000},{"_id":"source/_posts/Android应用程序是如何安装的.md","hash":"0b3049fbe8d508eddbd15ce4f8a521ed8393a440","modified":1483680611000},{"_id":"source/_posts/ContentProvider水文(凑四大组件).md","hash":"6a856c5040a9aef9740b188a22d0efc5da11bc38","modified":1483680639000},{"_id":"source/_posts/JNI学习笔记（三）－编译文件makefile以及cmake.md","hash":"70668277a50c6a184ce43eefc667a42961ab1904","modified":1483680726000},{"_id":"source/_posts/JNI学习笔记（二）－动态注册native函数.md","hash":"0c08a3d39e0701c0f46fdd366ca2898f87fe5b4e","modified":1483680718000},{"_id":"source/_posts/Android消息机制－native层.md","hash":"dcd430a1ca7d62713fcd011d405caddaa5e77dd5","modified":1483680591000},{"_id":"source/_posts/PMS初始化做了什么.md","hash":"1672898ed16260bf87cfabc425b39ec1bcc0264f","modified":1483679965000},{"_id":"source/_posts/Service启动流程.md","hash":"6fdbc33d6ac1587fa4e691b9c65b42441229485c","modified":1483680735000},{"_id":"source/_posts/broadcast流程浅析.md","hash":"15a47e19e294fb5e3a53235fa70f87da22973d24","modified":1483680633000},{"_id":"source/_posts/android应用进程是如何启动的.md","hash":"1cb1a9952941c85f862e6d43d0152b9cbc5dded6","modified":1483680621000},{"_id":"source/_posts/fresco内存管理.md","hash":"d58bb150cd2f5a7394657e8d477cd771f4ddcc30","modified":1483680679000},{"_id":"source/_posts/fresco初始化过程.md","hash":"9cc9df11e84f0b3b66eebbf772a38c0f756a6f26","modified":1483680645000},{"_id":"source/_posts/fresco加载数据.md","hash":"71d61529d677c8df34235c33761223caeae373ea","modified":1483680651000},{"_id":"source/_posts/fresco图片decode的大体流程.md","hash":"8016e66635a183f7b0b9a5ba367015322f92cf85","modified":1483680695000},{"_id":"source/_posts/fresco生产者Producer.md","hash":"86ce013cceeb66093edc71bf91b45e93fc516ed0","modified":1483680688000},{"_id":"source/_posts/fresco用法.md","hash":"c3da8578cc189ebbcbec6773a1750e0663c088db","modified":1483680702000},{"_id":"source/_posts/hexo+github pages搭建个人博客.md","hash":"f4db4b00099d5ab860be2aa5091c59f88d2f437e","modified":1483680711000},{"_id":"source/_posts/了解gradle（一）.md","hash":"3509f74abd6714e5c4ef268ffed3ab08d70878cf","modified":1483680550000},{"_id":"source/_posts/了解gradle（二）-扩展gradle.md","hash":"46b5dfe16bd4945b35c1998488fe70f85124c4aa","modified":1483680540000},{"_id":"source/_posts/消息机制在多进程的应用.md","hash":"ac65b256632a1415b80655ff9c67c91e3ce0dad4","modified":1483680558000},{"_id":"source/_posts/记不住adb命令？试试shell吧.md","hash":"e14559eb93162d67ce53a651e61f9dc35291d8a7","modified":1483680522000},{"_id":"source/_posts/脚本打怪-shell篇.md","hash":"5eeff851e10ad3eebc42c1cc956932c2d5ddf961","modified":1483680532000},{"_id":"source/categories/index.md","hash":"d24696dbb2f94391363d5cf384c115a00b9a68b0","modified":1483674417000},{"_id":"source/tags/index.md","hash":"32ec9646ff7f68226c93fb8b8d1aca5daab69378","modified":1483674279000},{"_id":"source/tags/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1483674056000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1483546612000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1483546612000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1483546612000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1483546612000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1483546612000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1483546612000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1483546612000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1483546612000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1483546612000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1483546612000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1483546612000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1483546612000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1483546612000},{"_id":"themes/next/layout/_layout.swig","hash":"2fa3c74066843a859fac77803324a1de51044da9","modified":1483546612000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1483546612000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1483546612000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1483546612000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1483546612000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1483546612000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1483546612000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1483546612000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1483546612000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1483546612000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1483546612000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1483546612000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1483546612000},{"_id":"themes/next/layout/_macro/post.swig","hash":"e6016def9b512188f4c2725399c9adc7bc41cdae","modified":1483546612000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1483546612000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1483546612000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1483546612000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1483546612000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1483546612000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"78ccfc1dc915247c1fec3c86d742e0f4c2f6d99c","modified":1483546612000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1483546612000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1483546612000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1483546612000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1483546612000},{"_id":"themes/next/layout/_partials/header.swig","hash":"adab5c3f7b173f1b45454787f39dde07aea03483","modified":1483546612000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1483546612000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1483546612000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1483546612000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1483546612000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1483546612000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1483546612000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1483546612000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1483546612000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1483546612000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1483546612000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1483546612000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1483546612000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483546612000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483546612000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483546612000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1483546612000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1483546612000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483546612000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1483546612000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1483546612000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1483546612000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1483546612000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1483546612000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1483546612000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1483546612000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1483546612000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1483546612000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1483546612000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1483546612000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1483546612000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1483546612000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1483546612000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1483546612000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"4abc01bc870e1d7a783cdbd26166edc782a6a4f4","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1483546612000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1483546612000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c459aa6d607d8bcb747544e74f6ad0b8374aa3b1","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1483546612000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fc185c6cec79593775d1c2440dbe2a71cfbe2e99","modified":1483546612000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1483546612000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1483546612000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1483546612000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1483546612000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1483546612000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1483546612000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1483546612000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1483546612000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1483546612000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1483546612000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1483546612000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1483546612000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"ea8078fa9e10be2bb042749d8b6a97adc38f914c","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1483546612000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1408209dfb9a22a0982a30bdbd14842c2b53f264","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1483546612000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1483546612000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1483546612000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"fdfadbb4483043c7e0afd541ee9712389e633517","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"c0c81317c8ef6fa5d2799fefe05d701b6ea0f039","modified":1483680135000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1483546612000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1483546612000},{"_id":"public/404.html","hash":"0838c1cd3cf1f66031a389718c9c174de0b64473","modified":1483683206400},{"_id":"public/categories/index.html","hash":"359f99616615c7181eb1500d7ef63a701324d6a4","modified":1483683206400},{"_id":"public/tags/index.html","hash":"22e5f4c4f0b196b85d62823af88b398d4779440d","modified":1483683206400},{"_id":"public/archives/page/3/index.html","hash":"ba45912d1d9fb57d5e1eed11476dec92eb25f9ae","modified":1483683206400},{"_id":"public/archives/2016/11/index.html","hash":"0bca72ad09bdd1aabc156be2334a6ee052d135e9","modified":1483683206401},{"_id":"public/archives/2017/index.html","hash":"5067b044560ee9ea54d07b379910890c841f7efd","modified":1483683206401},{"_id":"public/archives/2016/12/page/2/index.html","hash":"b3e8e16e3270cbbda1c975a8d9e58b475bf1a5ea","modified":1483683206403},{"_id":"public/archives/2017/01/index.html","hash":"e451c759bb866b2f478bed5c64f140cc3468df95","modified":1483683206401},{"_id":"public/tags/jni/index.html","hash":"664567faa3c2645a47278154297eabab3f832ebf","modified":1483683206401},{"_id":"public/tags/fresco/index.html","hash":"d51440aef7438e0e77e262261a5177feda6dccc7","modified":1483683206401},{"_id":"public/tags/hexo/index.html","hash":"89411ade6113e692e751d22d34cc3cc1081f492d","modified":1483683206401},{"_id":"public/tags/gradle/index.html","hash":"a5ca66f68997b1d722a0e85dbefd7960197d808e","modified":1483683206401},{"_id":"public/tags/android/index.html","hash":"86cb84e59af25790f1667fbcd5fc0d97319927be","modified":1483683206401},{"_id":"public/tags/消息机制/index.html","hash":"af6fdefd352ac455b6b70ec9bf0bbccebfec48b7","modified":1483683206401},{"_id":"public/tags/shell/index.html","hash":"b48513544126f0f12b1bdab405eef61324261cb3","modified":1483683206401},{"_id":"public/categories/hexo/index.html","hash":"f4ea8cab81f08297f042a2513bee00f313a63b4d","modified":1483683206401},{"_id":"public/categories/Gradle/index.html","hash":"4fb4297f9491694f66caaa219635a9a89040b55e","modified":1483683206401},{"_id":"public/categories/shell/index.html","hash":"28394068bf89f4647d455808a9e37537316f9f70","modified":1483683206401},{"_id":"public/2017/01/05/PMS初始化做了什么/index.html","hash":"d46e467db72dacda1a72286f6f74d9b53ed387c3","modified":1483683206401},{"_id":"public/2017/01/05/AMS中的进程管理部分－上/index.html","hash":"ea3323f93e322908af51c4342ed0b08366a20ec8","modified":1483683206401},{"_id":"public/2017/01/04/Android应用程序是如何安装的/index.html","hash":"9027bbb59bfdf90e870a87e71cc8727e74704221","modified":1483683206401},{"_id":"public/2017/01/02/android应用进程是如何启动的/index.html","hash":"f7614969b6c6e86823d43bb2cccb685918a2f1e4","modified":1483683206401},{"_id":"public/2017/01/01/消息机制在多进程的应用/index.html","hash":"972ed4e47f7fae744edaf46603c143f6217e70d9","modified":1483683206401},{"_id":"public/2016/12/29/ContentProvider水文(凑四大组件)/index.html","hash":"e9782f1da4be423f4eaa1eec2b9f53c52b7cf495","modified":1483683206401},{"_id":"public/2016/12/27/broadcast流程浅析/index.html","hash":"b095b83e6ab53ad4877d21a1f25b91ab58f60ce7","modified":1483683206401},{"_id":"public/2016/12/26/Service启动流程/index.html","hash":"ea01a2946110f1e10c001c44b305bc431360c7d7","modified":1483683206401},{"_id":"public/2016/12/25/Activity启动流程/index.html","hash":"d9d0e246e8c48c89a8472199e6864b65f9e871bb","modified":1483683206401},{"_id":"public/2016/12/24/Android消息机制－native层/index.html","hash":"4288396ab715815b4685ce805be8ac5e2c39b49e","modified":1483683206402},{"_id":"public/2016/12/21/Android消息机制浅析/index.html","hash":"366c0935c567826e5bfb569ba715285e46152121","modified":1483683206402},{"_id":"public/2016/12/20/记不住adb命令？试试shell吧/index.html","hash":"671d0479234a033dbc8816c8e1d748b77143a89a","modified":1483683206402},{"_id":"public/2016/12/14/fresco内存管理/index.html","hash":"96871e9b2fa00140c754bedf42a98624fd21b125","modified":1483683206402},{"_id":"public/2016/12/13/fresco图片decode的大体流程/index.html","hash":"2b9f2732c3ca67e1ecd3f06d9f79b7dad0b0b00d","modified":1483683206402},{"_id":"public/2016/12/13/fresco生产者Producer/index.html","hash":"89148e42a81841c37a97c011aff66860a030ef15","modified":1483683206402},{"_id":"public/2016/12/12/fresco加载数据/index.html","hash":"9c536640eb20dabcf98107c6aca2efc17f0bb81f","modified":1483683206402},{"_id":"public/2016/12/12/fresco初始化过程/index.html","hash":"d6d4b710ff516f8a1839dd25f17e2fc93f8f3e1b","modified":1483683206402},{"_id":"public/2016/12/12/fresco用法/index.html","hash":"3cfccf1c740dbb0510aa4c954f1fdd5981cb3066","modified":1483683206402},{"_id":"public/2016/12/06/了解gradle（二）-扩展gradle/index.html","hash":"db74df9cd196f35cbc375ded9a2b9c8cf3da3f3b","modified":1483683206402},{"_id":"public/2016/12/05/了解gradle（一）/index.html","hash":"f7a0cdb3520dda0d13eb0fb022d25b36de7b417c","modified":1483683206402},{"_id":"public/2016/12/03/脚本打怪-shell篇/index.html","hash":"830d937dc3cafbf2f62325be2dcd8e300d3797db","modified":1483683206402},{"_id":"public/2016/11/30/AndroidJNI学习笔记（四）－数据类型映射以及native调用java/index.html","hash":"6a7fa24547d6faea4649813c068edbc4ac840307","modified":1483683206402},{"_id":"public/2016/11/29/JNI学习笔记（三）－编译文件makefile以及cmake/index.html","hash":"80c1740ab7ff88ae8eec8e5a8db9573e128e4c48","modified":1483683206402},{"_id":"public/2016/11/29/JNI学习笔记（二）－动态注册native函数/index.html","hash":"6b5b17f8fdedb1dbd8c2c4ba99afc7a48e73c09b","modified":1483683206402},{"_id":"public/2016/11/29/hexo+github pages搭建个人博客/index.html","hash":"6ae29e4628865e15397ac410225adfe3049e37b0","modified":1483683206402},{"_id":"public/archives/index.html","hash":"8a68fd207957a82af0c8e48a3423eb57065aeffb","modified":1483683206402},{"_id":"public/archives/page/2/index.html","hash":"3da02ec295b5830dd0548506c858bca56562e56a","modified":1483683206403},{"_id":"public/archives/2016/index.html","hash":"8270f0502dbffafb1846a62977d9dcb1479776f5","modified":1483683206403},{"_id":"public/archives/2016/page/2/index.html","hash":"ce3c423060ae4554e9bf71b950cdaaa7c4a3adf2","modified":1483683206403},{"_id":"public/archives/2016/12/index.html","hash":"6df86d5ac98093130e7e4de1ca4f6aa4f6f39673","modified":1483683206403},{"_id":"public/tags/framework/index.html","hash":"2cbc5eaacef7bf3f6cb3c778a0f9e9b94d920797","modified":1483683206403},{"_id":"public/categories/Android/index.html","hash":"a8e810665218713cb4f95ac296038e5099471517","modified":1483683206403},{"_id":"public/categories/Android/page/2/index.html","hash":"95efc6920589d5474a6927194c0fbc3aa9f3ea2e","modified":1483683206403},{"_id":"public/page/2/index.html","hash":"760431ac3bc138c4ead0e5606a51322d3b4f245b","modified":1483683206403},{"_id":"public/page/3/index.html","hash":"d407a7c7bbd52cea310685a90a0b62ed045dcfb5","modified":1483683206403},{"_id":"public/index.html","hash":"6d8e7c9169d48b6f9281694a21a67031d60c65aa","modified":1483683336733},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1483680779898},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483680779898},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483680779900},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1483680779900},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483680779900},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483680779901},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483680779901},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483680779901},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1483680779901},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1483680779901},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483680779901},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1483680779901},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1483680779901},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1483680779901},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1483680779901},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1483680779901},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483680779901},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483680779901},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483680779901},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483680779901},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483680779901},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483680779901},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1483680779902},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483680779902},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1483680780659},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1483680780662},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1483680780666},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1483680780666},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1483680780668},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1483680780668},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1483680780668},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1483680780668},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1483680780669},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1483680780669},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1483680780669},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1483680780669},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1483680780669},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1483680780669},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1483680780669},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1483680780669},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1483680780669},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1483680780669},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1483680780669},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1483680780669},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1483680780669},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1483680780669},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1483680780669},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1483680780669},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1483680780669},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1483680780669},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1483680780669},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1483680780669},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1483680780669},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1483680780669},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483680780670},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1483680780670},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1483680780670},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483680780670},{"_id":"public/css/main.css","hash":"9d62437b19ec6ceec9da1d85bf64b30afbe086bf","modified":1483680780670},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1483680780670},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1483680780670},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1483680780670},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1483680780670},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1483680780670},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1483680780670},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1483680780670},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1483680780671},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1483680780671},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1483680780671},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1483680780671},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1483680780678}],"Category":[{"name":"Android","_id":"cixld85xl0003uaxadw08nb5a"},{"name":"hexo","_id":"cixld85yu001quaxaz0q2j2ai"},{"name":"Gradle","_id":"cixld85yx0021uaxag1gtoo3d"},{"name":"shell","_id":"cixld85z1002cuaxajhw3jntg"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>","date":"2017-01-06T03:51:46.000Z","updated":"2017-01-06T03:51:46.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cixld85vw0000uaxae75levcn","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\">\n</script>\n\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>"},{"title":"categories","date":"2017-01-06T03:45:57.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-01-06 11:45:57\ntype: \"categories\"\ncomments: false\n\n---\n","updated":"2017-01-06T03:46:57.000Z","path":"categories/index.html","layout":"page","_id":"cixld863a002quaxadhqfo85v","content":"","excerpt":"","more":""},{"title":"All tags","type":"tags","comments":0,"date":"2017-01-06T03:43:49.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ntype: \"tags\"\ncomments: false\ndate: 2017-01-06 11:43:49\n\n---\n","updated":"2017-01-06T03:44:39.000Z","path":"tags/index.html","layout":"page","_id":"cixld863b002ruaxau3l095jx","content":"","excerpt":"","more":""}],"Post":[{"title":"AMS中的进程管理部分－上","date":"2017-01-05T03:41:01.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1.前言\n\nActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 新建进程\n* 调整进程在mLruProcesses的位置\n* 调整进程OomAdj值\n* 杀进程\n\n而新建进程在前面有说到过，今天就来介绍下剩下的三个。\n\n### 2.调整位置的updateLruProcessLocked方法\n\n代码比较长，分段看。\n\n```\n        final boolean hasActivity = app.activities.size() > 0 || app.hasClientActivities\n                || app.treatLikeActivity;\n        final boolean hasService = false; // not impl yet. app.services.size() > 0;\n        if (!activityChange && hasActivity) {\n            // The process has activities, so we are only allowing activity-based adjustments\n            // to move it.  It should be kept in the front of the list with other\n            // processes that have activities, and we don't want those to change their\n            // order except due to activity operations.\n            return;\n        }\n\n        mLruSeq++;\n        final long now = SystemClock.uptimeMillis();\n        app.lastActivityTime = now;\n\n        // First a quick reject: if the app is already at the position we will\n        // put it, then there is nothing to do.\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (N > 0 && mLruProcesses.get(N-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top activity: \" + app);\n                return;\n            }\n        } else {\n            if (mLruProcessServiceStart > 0\n                    && mLruProcesses.get(mLruProcessServiceStart-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top other: \" + app);\n                return;\n            }\n        }\n\n        int lrui = mLruProcesses.lastIndexOf(app);\n\n        if (app.persistent && lrui >= 0) {\n            // We don't care about the position of persistent processes, as long as\n            // they are in the list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, persistent: \" + app);\n            return;\n        }\n```\n\n* 如果有activity，并且进程中activity没有发生变化，不需要调整\n* 如果有activity，但是当前进程就是在最后，不需要调整\n* 如果没有activity，但是在合适的位置，不需要调整\n* 如果有persistent标志，不需要调整\n* lrui 为当前进程在list中的索引(最后一个的索引)\n\n```\n        if (lrui >= 0) {\n            if (lrui < mLruProcessActivityStart) {\n                mLruProcessActivityStart--;\n            }\n            if (lrui < mLruProcessServiceStart) {\n                mLruProcessServiceStart--;\n            }\n            /*\n            if (addIndex > lrui) {\n                addIndex--;\n            }\n            if (nextIndex > lrui) {\n                nextIndex--;\n            }\n            */\n            mLruProcesses.remove(lrui);\n        }\n\n```\n\n如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。\n\n```\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (app.activities.size() == 0 && mLruProcessActivityStart < (N - 1)) {\n                // Process doesn't have activities, but has clients with\n                // activities...  move it up, but one below the top (the top\n                // should always have a real activity).\n                if (DEBUG_LRU) Slog.d(TAG_LRU,\n                        \"Adding to second-top of LRU activity list: \" + app);\n                mLruProcesses.add(N - 1, app);\n                // To keep it from spamming the LRU list (by making a bunch of clients),\n                // we will push down any other entries owned by the app.\n                final int uid = app.info.uid;\n                for (int i = N - 2; i > mLruProcessActivityStart; i--) {\n                    ProcessRecord subProc = mLruProcesses.get(i);\n                    if (subProc.info.uid == uid) {\n                        // We want to push this one down the list.  If the process after\n                        // it is for the same uid, however, don't do so, because we don't\n                        // want them internally to be re-ordered.\n                        if (mLruProcesses.get(i - 1).info.uid != uid) {\n                            if (DEBUG_LRU) Slog.d(TAG_LRU,\n                                    \"Pushing uid \" + uid + \" swapping at \" + i + \": \"\n                                    + mLruProcesses.get(i) + \" : \" + mLruProcesses.get(i - 1));\n                            ProcessRecord tmp = mLruProcesses.get(i);\n                            mLruProcesses.set(i, mLruProcesses.get(i - 1));\n                            mLruProcesses.set(i - 1, tmp);\n                            i--;\n                        }\n                    } else {\n                        // A gap, we can stop here.\n                        break;\n                    }\n                }\n            } else {\n                // Process has activities, put it at the very tipsy-top.\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU activity list: \" + app);\n                mLruProcesses.add(app);\n            }\n            nextIndex = mLruProcessServiceStart;\n        } else if (hasService) {\n            // Process has services, put it at the top of the service list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU service list: \" + app);\n            mLruProcesses.add(mLruProcessActivityStart, app);\n            nextIndex = mLruProcessServiceStart;\n            mLruProcessActivityStart++;\n        } else  {\n            // Process not otherwise of interest, it goes to the top of the non-service area.\n            int index = mLruProcessServiceStart;\n            if (client != null) {\n                // If there is a client, don't allow the process to be moved up higher\n                // in the list than that client.\n                int clientIndex = mLruProcesses.lastIndexOf(client);\n                if (DEBUG_LRU && clientIndex < 0) Slog.d(TAG_LRU, \"Unknown client \" + client\n                        + \" when updating \" + app);\n                if (clientIndex <= lrui) {\n                    // Don't allow the client index restriction to push it down farther in the\n                    // list than it already is.\n                    clientIndex = lrui;\n                }\n                if (clientIndex >= 0 && index > clientIndex) {\n                    index = clientIndex;\n                }\n            }\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding at \" + index + \" of LRU list: \" + app);\n            mLruProcesses.add(index, app);\n            nextIndex = index-1;\n            mLruProcessActivityStart++;\n            mLruProcessServiceStart++;\n        }\n\n```\n\n* hasActivity为true\n\t* 没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。\n\t* 直接添加到最后一个\n* hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置\n* 因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处\n\n\n```\n        for (int j=app.connections.size()-1; j>=0; j--) {\n            ConnectionRecord cr = app.connections.valueAt(j);\n            if (cr.binding != null && !cr.serviceDead && cr.binding.service != null\n                    && cr.binding.service.app != null\n                    && cr.binding.service.app.lruSeq != mLruSeq\n                    && !cr.binding.service.app.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,\n                        \"service connection\", cr, app);\n            }\n        }\n        for (int j=app.conProviders.size()-1; j>=0; j--) {\n            ContentProviderRecord cpr = app.conProviders.get(j).provider;\n            if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq && !cpr.proc.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,\n                        \"provider reference\", cpr, app);\n            }\n        }\n```\n\n把和这个进程关联的service和contentprovider调整到这个进程之后。\n\n### 3. 调整OomAdj值的updateOomAdjLocked方法\n\n方法较长，分段看。\n\n```\n        final ActivityRecord TOP_ACT = resumedAppLocked();\n        final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;\n        final long now = SystemClock.uptimeMillis();\n        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;\n        final int N = mLruProcesses.size();\n\n        if (false) {\n            RuntimeException e = new RuntimeException();\n            e.fillInStackTrace();\n            Slog.i(TAG, \"updateOomAdj: top=\" + TOP_ACT, e);\n        }\n\n        // Reset state in all uid records.\n        for (int i=mActiveUids.size()-1; i>=0; i--) {\n            final UidRecord uidRec = mActiveUids.valueAt(i);\n            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,\n                    \"Starting update of \" + uidRec);\n            uidRec.reset();\n        }\n\n        mAdjSeq++;\n        mNewNumServiceProcs = 0;\n        mNewNumAServiceProcs = 0;\n\n        final int emptyProcessLimit;\n        final int cachedProcessLimit;\n        if (mProcessLimit <= 0) {\n            emptyProcessLimit = cachedProcessLimit = 0;\n        } else if (mProcessLimit == 1) {\n            emptyProcessLimit = 1;\n            cachedProcessLimit = 0;\n        } else {\n            emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);\n            cachedProcessLimit = mProcessLimit - emptyProcessLimit;\n        }\n\n        // Let's determine how many processes we have running vs.\n        // how many slots we have for background processes; we may want\n        // to put multiple processes in a slot of there are enough of\n        // them.\n        int numSlots = (ProcessList.CACHED_APP_MAX_ADJ\n                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;\n        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;\n        if (numEmptyProcs > cachedProcessLimit) {\n            // If there are more empty processes than our limit on cached\n            // processes, then use the cached process limit for the factor.\n            // This ensures that the really old empty processes get pushed\n            // down to the bottom, so if we are running low on memory we will\n            // have a better chance at keeping around more cached processes\n            // instead of a gazillion empty processes.\n            numEmptyProcs = cachedProcessLimit;\n        }\n        int emptyFactor = numEmptyProcs/numSlots;\n        if (emptyFactor < 1) emptyFactor = 1;\n        int cachedFactor = (mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1)/numSlots;\n        if (cachedFactor < 1) cachedFactor = 1;\n        int stepCached = 0;\n        int stepEmpty = 0;\n        int numCached = 0;\n        int numEmpty = 0;\n        int numTrimming = 0;\n\n        mNumNonCachedProcs = 0;\n        mNumCachedHiddenProcs = 0;\n\n```\n\n这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。\n\n\n```\n int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextCachedAdj = curCachedAdj+1;\n        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextEmptyAdj = curEmptyAdj+2;\n        for (int i=N-1; i>=0; i--) {\n            ProcessRecord app = mLruProcesses.get(i);\n            if (!app.killedByAm && app.thread != null) {\n                app.procStateChanged = false;\n                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);\n\n                // If we haven't yet assigned the final cached adj\n                // to the process, do that now.\n                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {\n                    switch (app.curProcState) {\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                            // This process is a cached process holding activities...\n                            // assign it the next cached value for that type, and then\n                            // step that cached level.\n                            app.curRawAdj = curCachedAdj;\n                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning activity LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curCachedAdj=\" + curCachedAdj\n                                    + \")\");\n                            if (curCachedAdj != nextCachedAdj) {\n                                stepCached++;\n                                if (stepCached >= cachedFactor) {\n                                    stepCached = 0;\n                                    curCachedAdj = nextCachedAdj;\n                                    nextCachedAdj += 2;\n                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                        default:\n                            // For everything else, assign next empty cached process\n                            // level and bump that up.  Note that this means that\n                            // long-running services that have dropped down to the\n                            // cached level will be treated as empty (since their process\n                            // state is still as a service), which is what we want.\n                            app.curRawAdj = curEmptyAdj;\n                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning empty LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curEmptyAdj=\" + curEmptyAdj\n                                    + \")\");\n                            if (curEmptyAdj != nextEmptyAdj) {\n                                stepEmpty++;\n                                if (stepEmpty >= emptyFactor) {\n                                    stepEmpty = 0;\n                                    curEmptyAdj = nextEmptyAdj;\n                                    nextEmptyAdj += 2;\n                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                    }\n                }\n\n                applyOomAdjLocked(app, true, now);\n\n                // Count the number of process types.\n                switch (app.curProcState) {\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                        mNumCachedHiddenProcs++;\n                        numCached++;\n                        if (numCached > cachedProcessLimit) {\n                            app.kill(\"cached #\" + numCached, true);\n                        }\n                        break;\n                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:\n                        if (numEmpty > ProcessList.TRIM_EMPTY_APPS\n                                && app.lastActivityTime < oldTime) {\n                            app.kill(\"empty for \"\n                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)\n                                    / 1000) + \"s\", true);\n                        } else {\n                            numEmpty++;\n                            if (numEmpty > emptyProcessLimit) {\n                                app.kill(\"empty #\" + numEmpty, true);\n                            }\n                        }\n                        break;\n                    default:\n                        mNumNonCachedProcs++;\n                        break;\n                }\n\n                if (app.isolated && app.services.size() <= 0) {\n                    // If this is an isolated process, and there are no\n                    // services running in it, then the process is no longer\n                    // needed.  We agressively kill these because we can by\n                    // definition not re-use the same process again, and it is\n                    // good to avoid having whatever code was running in them\n                    // left sitting around after no longer needed.\n                    app.kill(\"isolated not needed\", true);\n                } else {\n                    // Keeping this process, update its uid.\n                    final UidRecord uidRec = app.uidRecord;\n                    if (uidRec != null && uidRec.curProcState > app.curProcState) {\n                        uidRec.curProcState = app.curProcState;\n                    }\n                }\n\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    numTrimming++;\n                }\n            }\n        }\n```\n\n\n上面代码的逻辑是更新进程oomadj值。\n\n* 首先通过computeOomAdjLocked计算oomadj值\n* 当进程未分配adj值是，更新adj值(if (app.curAdj >= ProcessList.UNKNOWN_ADJ))\n\t* 当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值\n\t* 不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值\n* applyOomAdjLocked,使更新生效\n* 根据进程状态，选择策略\n\t* PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程\n\t* PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程\n* 如果是孤立进程 并且没有service，直接杀掉\n\n\n```\n        final int numCachedAndEmpty = numCached + numEmpty;\n        int memFactor;\n        if (numCached <= ProcessList.TRIM_CACHED_APPS\n                && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {\n            if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n            } else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n            } else {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n            }\n        } else {\n            memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n        }\n        // We always allow the memory level to go up (better).  We only allow it to go\n        // down if we are in a state where that is allowed, *and* the total number of processes\n        // has gone down since last time.\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"oom: memFactor=\" + memFactor\n                + \" last=\" + mLastMemoryLevel + \" allowLow=\" + mAllowLowerMemLevel\n                + \" numProcs=\" + mLruProcesses.size() + \" last=\" + mLastNumProcesses);\n        if (memFactor > mLastMemoryLevel) {\n            if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {\n                memFactor = mLastMemoryLevel;\n                if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"Keeping last mem factor!\");\n            }\n        }\n        mLastMemoryLevel = memFactor;\n        mLastNumProcesses = mLruProcesses.size();\n        boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\n        final int trackerMemFactor = mProcessStats.getMemFactorLocked();\n        if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n            if (mLowRamStartTime == 0) {\n                mLowRamStartTime = now;\n            }\n            int step = 0;\n            int fgTrimLevel;\n            switch (memFactor) {\n                case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n                    break;\n                case ProcessStats.ADJ_MEM_FACTOR_LOW:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n                    break;\n                default:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n                    break;\n            }\n            int factor = numTrimming/3;\n            int minFactor = 2;\n            if (mHomeProcess != null) minFactor++;\n            if (mPreviousProcess != null) minFactor++;\n            if (factor < minFactor) factor = minFactor;\n            int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    if (app.trimMemoryLevel < curLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of \" + app.processName + \" to \" + curLevel);\n                            app.thread.scheduleTrimMemory(curLevel);\n                        } catch (RemoteException e) {\n                        }\n                        if (false) {\n                            // For now we won't do this; our memory trimming seems\n                            // to be good enough at this point that destroying\n                            // activities causes more harm than good.\n                            if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                                    && app != mHomeProcess && app != mPreviousProcess) {\n                                // Need to do this on its own message because the stack may not\n                                // be in a consistent state at this point.\n                                // For these apps we will also finish their activities\n                                // to help them free memory.\n                                mStackSupervisor.scheduleDestroyAllActivities(app, \"trim\");\n                            }\n                        }\n                    }\n                    app.trimMemoryLevel = curLevel;\n                    step++;\n                    if (step >= factor) {\n                        step = 0;\n                        switch (curLevel) {\n                            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                                break;\n                            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                                break;\n                        }\n                    }\n                } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of heavy-weight \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                } else {\n                    if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                            || app.systemNoUi) && app.pendingUiClean) {\n                        // If this application is now in the background and it\n                        // had done UI, then give it the special trim level to\n                        // have it free UI resources.\n                        final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                        if (app.trimMemoryLevel < level && app.thread != null) {\n                            try {\n                                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                        \"Trimming memory of bg-ui \" + app.processName\n                                        + \" to \" + level);\n                                app.thread.scheduleTrimMemory(level);\n                            } catch (RemoteException e) {\n                            }\n                        }\n                        app.pendingUiClean = false;\n                    }\n                    if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of fg \" + app.processName\n                                    + \" to \" + fgTrimLevel);\n                            app.thread.scheduleTrimMemory(fgTrimLevel);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = fgTrimLevel;\n                }\n            }\n        } else {\n            if (mLowRamStartTime != 0) {\n                mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n                mLowRamStartTime = 0;\n            }\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                        || app.systemNoUi) && app.pendingUiClean) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of ui hidden \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.pendingUiClean = false;\n                }\n                app.trimMemoryLevel = 0;\n            }\n        }\n```\t\n\n* 先调整内存因子memFactor\n* 如果内存因子不为0\n\t* 根据内存因子 初始化fgTrimLevel\n\t* 循环处理进程\n\t\t* curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel\n\t\t* curProcState等于9，且满足条件，进行TrimMemory\n\t\t* 其他情况下，根据条件进行TrimMemory操作\n\t \n* 内存因子为0,也是根据跳进进行TrimMemory操作\n\n整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。\n\ncomputeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。\n\n### 4.杀进程\n\n杀进程这里就略过了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\t","source":"_posts/AMS中的进程管理部分－上.md","raw":"---\ntitle: AMS中的进程管理部分－上\ndate: 2017-01-05 11:41:01\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1.前言\n\nActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 新建进程\n* 调整进程在mLruProcesses的位置\n* 调整进程OomAdj值\n* 杀进程\n\n而新建进程在前面有说到过，今天就来介绍下剩下的三个。\n\n### 2.调整位置的updateLruProcessLocked方法\n\n代码比较长，分段看。\n\n```\n        final boolean hasActivity = app.activities.size() > 0 || app.hasClientActivities\n                || app.treatLikeActivity;\n        final boolean hasService = false; // not impl yet. app.services.size() > 0;\n        if (!activityChange && hasActivity) {\n            // The process has activities, so we are only allowing activity-based adjustments\n            // to move it.  It should be kept in the front of the list with other\n            // processes that have activities, and we don't want those to change their\n            // order except due to activity operations.\n            return;\n        }\n\n        mLruSeq++;\n        final long now = SystemClock.uptimeMillis();\n        app.lastActivityTime = now;\n\n        // First a quick reject: if the app is already at the position we will\n        // put it, then there is nothing to do.\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (N > 0 && mLruProcesses.get(N-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top activity: \" + app);\n                return;\n            }\n        } else {\n            if (mLruProcessServiceStart > 0\n                    && mLruProcesses.get(mLruProcessServiceStart-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top other: \" + app);\n                return;\n            }\n        }\n\n        int lrui = mLruProcesses.lastIndexOf(app);\n\n        if (app.persistent && lrui >= 0) {\n            // We don't care about the position of persistent processes, as long as\n            // they are in the list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, persistent: \" + app);\n            return;\n        }\n```\n\n* 如果有activity，并且进程中activity没有发生变化，不需要调整\n* 如果有activity，但是当前进程就是在最后，不需要调整\n* 如果没有activity，但是在合适的位置，不需要调整\n* 如果有persistent标志，不需要调整\n* lrui 为当前进程在list中的索引(最后一个的索引)\n\n```\n        if (lrui >= 0) {\n            if (lrui < mLruProcessActivityStart) {\n                mLruProcessActivityStart--;\n            }\n            if (lrui < mLruProcessServiceStart) {\n                mLruProcessServiceStart--;\n            }\n            /*\n            if (addIndex > lrui) {\n                addIndex--;\n            }\n            if (nextIndex > lrui) {\n                nextIndex--;\n            }\n            */\n            mLruProcesses.remove(lrui);\n        }\n\n```\n\n如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。\n\n```\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (app.activities.size() == 0 && mLruProcessActivityStart < (N - 1)) {\n                // Process doesn't have activities, but has clients with\n                // activities...  move it up, but one below the top (the top\n                // should always have a real activity).\n                if (DEBUG_LRU) Slog.d(TAG_LRU,\n                        \"Adding to second-top of LRU activity list: \" + app);\n                mLruProcesses.add(N - 1, app);\n                // To keep it from spamming the LRU list (by making a bunch of clients),\n                // we will push down any other entries owned by the app.\n                final int uid = app.info.uid;\n                for (int i = N - 2; i > mLruProcessActivityStart; i--) {\n                    ProcessRecord subProc = mLruProcesses.get(i);\n                    if (subProc.info.uid == uid) {\n                        // We want to push this one down the list.  If the process after\n                        // it is for the same uid, however, don't do so, because we don't\n                        // want them internally to be re-ordered.\n                        if (mLruProcesses.get(i - 1).info.uid != uid) {\n                            if (DEBUG_LRU) Slog.d(TAG_LRU,\n                                    \"Pushing uid \" + uid + \" swapping at \" + i + \": \"\n                                    + mLruProcesses.get(i) + \" : \" + mLruProcesses.get(i - 1));\n                            ProcessRecord tmp = mLruProcesses.get(i);\n                            mLruProcesses.set(i, mLruProcesses.get(i - 1));\n                            mLruProcesses.set(i - 1, tmp);\n                            i--;\n                        }\n                    } else {\n                        // A gap, we can stop here.\n                        break;\n                    }\n                }\n            } else {\n                // Process has activities, put it at the very tipsy-top.\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU activity list: \" + app);\n                mLruProcesses.add(app);\n            }\n            nextIndex = mLruProcessServiceStart;\n        } else if (hasService) {\n            // Process has services, put it at the top of the service list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU service list: \" + app);\n            mLruProcesses.add(mLruProcessActivityStart, app);\n            nextIndex = mLruProcessServiceStart;\n            mLruProcessActivityStart++;\n        } else  {\n            // Process not otherwise of interest, it goes to the top of the non-service area.\n            int index = mLruProcessServiceStart;\n            if (client != null) {\n                // If there is a client, don't allow the process to be moved up higher\n                // in the list than that client.\n                int clientIndex = mLruProcesses.lastIndexOf(client);\n                if (DEBUG_LRU && clientIndex < 0) Slog.d(TAG_LRU, \"Unknown client \" + client\n                        + \" when updating \" + app);\n                if (clientIndex <= lrui) {\n                    // Don't allow the client index restriction to push it down farther in the\n                    // list than it already is.\n                    clientIndex = lrui;\n                }\n                if (clientIndex >= 0 && index > clientIndex) {\n                    index = clientIndex;\n                }\n            }\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding at \" + index + \" of LRU list: \" + app);\n            mLruProcesses.add(index, app);\n            nextIndex = index-1;\n            mLruProcessActivityStart++;\n            mLruProcessServiceStart++;\n        }\n\n```\n\n* hasActivity为true\n\t* 没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。\n\t* 直接添加到最后一个\n* hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置\n* 因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处\n\n\n```\n        for (int j=app.connections.size()-1; j>=0; j--) {\n            ConnectionRecord cr = app.connections.valueAt(j);\n            if (cr.binding != null && !cr.serviceDead && cr.binding.service != null\n                    && cr.binding.service.app != null\n                    && cr.binding.service.app.lruSeq != mLruSeq\n                    && !cr.binding.service.app.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,\n                        \"service connection\", cr, app);\n            }\n        }\n        for (int j=app.conProviders.size()-1; j>=0; j--) {\n            ContentProviderRecord cpr = app.conProviders.get(j).provider;\n            if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq && !cpr.proc.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,\n                        \"provider reference\", cpr, app);\n            }\n        }\n```\n\n把和这个进程关联的service和contentprovider调整到这个进程之后。\n\n### 3. 调整OomAdj值的updateOomAdjLocked方法\n\n方法较长，分段看。\n\n```\n        final ActivityRecord TOP_ACT = resumedAppLocked();\n        final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;\n        final long now = SystemClock.uptimeMillis();\n        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;\n        final int N = mLruProcesses.size();\n\n        if (false) {\n            RuntimeException e = new RuntimeException();\n            e.fillInStackTrace();\n            Slog.i(TAG, \"updateOomAdj: top=\" + TOP_ACT, e);\n        }\n\n        // Reset state in all uid records.\n        for (int i=mActiveUids.size()-1; i>=0; i--) {\n            final UidRecord uidRec = mActiveUids.valueAt(i);\n            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,\n                    \"Starting update of \" + uidRec);\n            uidRec.reset();\n        }\n\n        mAdjSeq++;\n        mNewNumServiceProcs = 0;\n        mNewNumAServiceProcs = 0;\n\n        final int emptyProcessLimit;\n        final int cachedProcessLimit;\n        if (mProcessLimit <= 0) {\n            emptyProcessLimit = cachedProcessLimit = 0;\n        } else if (mProcessLimit == 1) {\n            emptyProcessLimit = 1;\n            cachedProcessLimit = 0;\n        } else {\n            emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);\n            cachedProcessLimit = mProcessLimit - emptyProcessLimit;\n        }\n\n        // Let's determine how many processes we have running vs.\n        // how many slots we have for background processes; we may want\n        // to put multiple processes in a slot of there are enough of\n        // them.\n        int numSlots = (ProcessList.CACHED_APP_MAX_ADJ\n                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;\n        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;\n        if (numEmptyProcs > cachedProcessLimit) {\n            // If there are more empty processes than our limit on cached\n            // processes, then use the cached process limit for the factor.\n            // This ensures that the really old empty processes get pushed\n            // down to the bottom, so if we are running low on memory we will\n            // have a better chance at keeping around more cached processes\n            // instead of a gazillion empty processes.\n            numEmptyProcs = cachedProcessLimit;\n        }\n        int emptyFactor = numEmptyProcs/numSlots;\n        if (emptyFactor < 1) emptyFactor = 1;\n        int cachedFactor = (mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1)/numSlots;\n        if (cachedFactor < 1) cachedFactor = 1;\n        int stepCached = 0;\n        int stepEmpty = 0;\n        int numCached = 0;\n        int numEmpty = 0;\n        int numTrimming = 0;\n\n        mNumNonCachedProcs = 0;\n        mNumCachedHiddenProcs = 0;\n\n```\n\n这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。\n\n\n```\n int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextCachedAdj = curCachedAdj+1;\n        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextEmptyAdj = curEmptyAdj+2;\n        for (int i=N-1; i>=0; i--) {\n            ProcessRecord app = mLruProcesses.get(i);\n            if (!app.killedByAm && app.thread != null) {\n                app.procStateChanged = false;\n                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);\n\n                // If we haven't yet assigned the final cached adj\n                // to the process, do that now.\n                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {\n                    switch (app.curProcState) {\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                            // This process is a cached process holding activities...\n                            // assign it the next cached value for that type, and then\n                            // step that cached level.\n                            app.curRawAdj = curCachedAdj;\n                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning activity LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curCachedAdj=\" + curCachedAdj\n                                    + \")\");\n                            if (curCachedAdj != nextCachedAdj) {\n                                stepCached++;\n                                if (stepCached >= cachedFactor) {\n                                    stepCached = 0;\n                                    curCachedAdj = nextCachedAdj;\n                                    nextCachedAdj += 2;\n                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                        default:\n                            // For everything else, assign next empty cached process\n                            // level and bump that up.  Note that this means that\n                            // long-running services that have dropped down to the\n                            // cached level will be treated as empty (since their process\n                            // state is still as a service), which is what we want.\n                            app.curRawAdj = curEmptyAdj;\n                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning empty LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curEmptyAdj=\" + curEmptyAdj\n                                    + \")\");\n                            if (curEmptyAdj != nextEmptyAdj) {\n                                stepEmpty++;\n                                if (stepEmpty >= emptyFactor) {\n                                    stepEmpty = 0;\n                                    curEmptyAdj = nextEmptyAdj;\n                                    nextEmptyAdj += 2;\n                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                    }\n                }\n\n                applyOomAdjLocked(app, true, now);\n\n                // Count the number of process types.\n                switch (app.curProcState) {\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                        mNumCachedHiddenProcs++;\n                        numCached++;\n                        if (numCached > cachedProcessLimit) {\n                            app.kill(\"cached #\" + numCached, true);\n                        }\n                        break;\n                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:\n                        if (numEmpty > ProcessList.TRIM_EMPTY_APPS\n                                && app.lastActivityTime < oldTime) {\n                            app.kill(\"empty for \"\n                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)\n                                    / 1000) + \"s\", true);\n                        } else {\n                            numEmpty++;\n                            if (numEmpty > emptyProcessLimit) {\n                                app.kill(\"empty #\" + numEmpty, true);\n                            }\n                        }\n                        break;\n                    default:\n                        mNumNonCachedProcs++;\n                        break;\n                }\n\n                if (app.isolated && app.services.size() <= 0) {\n                    // If this is an isolated process, and there are no\n                    // services running in it, then the process is no longer\n                    // needed.  We agressively kill these because we can by\n                    // definition not re-use the same process again, and it is\n                    // good to avoid having whatever code was running in them\n                    // left sitting around after no longer needed.\n                    app.kill(\"isolated not needed\", true);\n                } else {\n                    // Keeping this process, update its uid.\n                    final UidRecord uidRec = app.uidRecord;\n                    if (uidRec != null && uidRec.curProcState > app.curProcState) {\n                        uidRec.curProcState = app.curProcState;\n                    }\n                }\n\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    numTrimming++;\n                }\n            }\n        }\n```\n\n\n上面代码的逻辑是更新进程oomadj值。\n\n* 首先通过computeOomAdjLocked计算oomadj值\n* 当进程未分配adj值是，更新adj值(if (app.curAdj >= ProcessList.UNKNOWN_ADJ))\n\t* 当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值\n\t* 不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值\n* applyOomAdjLocked,使更新生效\n* 根据进程状态，选择策略\n\t* PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程\n\t* PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程\n* 如果是孤立进程 并且没有service，直接杀掉\n\n\n```\n        final int numCachedAndEmpty = numCached + numEmpty;\n        int memFactor;\n        if (numCached <= ProcessList.TRIM_CACHED_APPS\n                && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {\n            if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n            } else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n            } else {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n            }\n        } else {\n            memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n        }\n        // We always allow the memory level to go up (better).  We only allow it to go\n        // down if we are in a state where that is allowed, *and* the total number of processes\n        // has gone down since last time.\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"oom: memFactor=\" + memFactor\n                + \" last=\" + mLastMemoryLevel + \" allowLow=\" + mAllowLowerMemLevel\n                + \" numProcs=\" + mLruProcesses.size() + \" last=\" + mLastNumProcesses);\n        if (memFactor > mLastMemoryLevel) {\n            if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {\n                memFactor = mLastMemoryLevel;\n                if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"Keeping last mem factor!\");\n            }\n        }\n        mLastMemoryLevel = memFactor;\n        mLastNumProcesses = mLruProcesses.size();\n        boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\n        final int trackerMemFactor = mProcessStats.getMemFactorLocked();\n        if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n            if (mLowRamStartTime == 0) {\n                mLowRamStartTime = now;\n            }\n            int step = 0;\n            int fgTrimLevel;\n            switch (memFactor) {\n                case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n                    break;\n                case ProcessStats.ADJ_MEM_FACTOR_LOW:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n                    break;\n                default:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n                    break;\n            }\n            int factor = numTrimming/3;\n            int minFactor = 2;\n            if (mHomeProcess != null) minFactor++;\n            if (mPreviousProcess != null) minFactor++;\n            if (factor < minFactor) factor = minFactor;\n            int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    if (app.trimMemoryLevel < curLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of \" + app.processName + \" to \" + curLevel);\n                            app.thread.scheduleTrimMemory(curLevel);\n                        } catch (RemoteException e) {\n                        }\n                        if (false) {\n                            // For now we won't do this; our memory trimming seems\n                            // to be good enough at this point that destroying\n                            // activities causes more harm than good.\n                            if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                                    && app != mHomeProcess && app != mPreviousProcess) {\n                                // Need to do this on its own message because the stack may not\n                                // be in a consistent state at this point.\n                                // For these apps we will also finish their activities\n                                // to help them free memory.\n                                mStackSupervisor.scheduleDestroyAllActivities(app, \"trim\");\n                            }\n                        }\n                    }\n                    app.trimMemoryLevel = curLevel;\n                    step++;\n                    if (step >= factor) {\n                        step = 0;\n                        switch (curLevel) {\n                            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                                break;\n                            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                                break;\n                        }\n                    }\n                } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of heavy-weight \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                } else {\n                    if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                            || app.systemNoUi) && app.pendingUiClean) {\n                        // If this application is now in the background and it\n                        // had done UI, then give it the special trim level to\n                        // have it free UI resources.\n                        final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                        if (app.trimMemoryLevel < level && app.thread != null) {\n                            try {\n                                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                        \"Trimming memory of bg-ui \" + app.processName\n                                        + \" to \" + level);\n                                app.thread.scheduleTrimMemory(level);\n                            } catch (RemoteException e) {\n                            }\n                        }\n                        app.pendingUiClean = false;\n                    }\n                    if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of fg \" + app.processName\n                                    + \" to \" + fgTrimLevel);\n                            app.thread.scheduleTrimMemory(fgTrimLevel);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = fgTrimLevel;\n                }\n            }\n        } else {\n            if (mLowRamStartTime != 0) {\n                mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n                mLowRamStartTime = 0;\n            }\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                        || app.systemNoUi) && app.pendingUiClean) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of ui hidden \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.pendingUiClean = false;\n                }\n                app.trimMemoryLevel = 0;\n            }\n        }\n```\t\n\n* 先调整内存因子memFactor\n* 如果内存因子不为0\n\t* 根据内存因子 初始化fgTrimLevel\n\t* 循环处理进程\n\t\t* curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel\n\t\t* curProcState等于9，且满足条件，进行TrimMemory\n\t\t* 其他情况下，根据条件进行TrimMemory操作\n\t \n* 内存因子为0,也是根据跳进进行TrimMemory操作\n\n整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。\n\ncomputeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。\n\n### 4.杀进程\n\n杀进程这里就略过了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\t","slug":"AMS中的进程管理部分－上","published":1,"updated":"2017-01-06T05:29:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85xd0001uaxaimf50nhj","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>ActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n</the></li>\n</ul>\n<ul>\n<li>新建进程</li>\n<li>调整进程在mLruProcesses的位置</li>\n<li>调整进程OomAdj值</li>\n<li>杀进程</li>\n</ul>\n<p>而新建进程在前面有说到过，今天就来介绍下剩下的三个。</p>\n<h3 id=\"2-调整位置的updateLruProcessLocked方法\"><a href=\"#2-调整位置的updateLruProcessLocked方法\" class=\"headerlink\" title=\"2.调整位置的updateLruProcessLocked方法\"></a>2.调整位置的updateLruProcessLocked方法</h3><p>代码比较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean hasActivity = app.activities.size() &gt; 0 || app.hasClientActivities</div><div class=\"line\">        || app.treatLikeActivity;</div><div class=\"line\">final boolean hasService = false; // not impl yet. app.services.size() &gt; 0;</div><div class=\"line\">if (!activityChange &amp;&amp; hasActivity) &#123;</div><div class=\"line\">    // The process has activities, so we are only allowing activity-based adjustments</div><div class=\"line\">    // to move it.  It should be kept in the front of the list with other</div><div class=\"line\">    // processes that have activities, and we don&apos;t want those to change their</div><div class=\"line\">    // order except due to activity operations.</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mLruSeq++;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">app.lastActivityTime = now;</div><div class=\"line\"></div><div class=\"line\">// First a quick reject: if the app is already at the position we will</div><div class=\"line\">// put it, then there is nothing to do.</div><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (N &gt; 0 &amp;&amp; mLruProcesses.get(N-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top activity: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    if (mLruProcessServiceStart &gt; 0</div><div class=\"line\">            &amp;&amp; mLruProcesses.get(mLruProcessServiceStart-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top other: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int lrui = mLruProcesses.lastIndexOf(app);</div><div class=\"line\"></div><div class=\"line\">if (app.persistent &amp;&amp; lrui &gt;= 0) &#123;</div><div class=\"line\">    // We don&apos;t care about the position of persistent processes, as long as</div><div class=\"line\">    // they are in the list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, persistent: &quot; + app);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果有activity，并且进程中activity没有发生变化，不需要调整</li>\n<li>如果有activity，但是当前进程就是在最后，不需要调整</li>\n<li>如果没有activity，但是在合适的位置，不需要调整</li>\n<li>如果有persistent标志，不需要调整</li>\n<li>lrui 为当前进程在list中的索引(最后一个的索引)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (lrui &gt;= 0) &#123;</div><div class=\"line\">    if (lrui &lt; mLruProcessActivityStart) &#123;</div><div class=\"line\">        mLruProcessActivityStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (lrui &lt; mLruProcessServiceStart) &#123;</div><div class=\"line\">        mLruProcessServiceStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">    if (addIndex &gt; lrui) &#123;</div><div class=\"line\">        addIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (nextIndex &gt; lrui) &#123;</div><div class=\"line\">        nextIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    */</div><div class=\"line\">    mLruProcesses.remove(lrui);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (app.activities.size() == 0 &amp;&amp; mLruProcessActivityStart &lt; (N - 1)) &#123;</div><div class=\"line\">        // Process doesn&apos;t have activities, but has clients with</div><div class=\"line\">        // activities...  move it up, but one below the top (the top</div><div class=\"line\">        // should always have a real activity).</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                &quot;Adding to second-top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(N - 1, app);</div><div class=\"line\">        // To keep it from spamming the LRU list (by making a bunch of clients),</div><div class=\"line\">        // we will push down any other entries owned by the app.</div><div class=\"line\">        final int uid = app.info.uid;</div><div class=\"line\">        for (int i = N - 2; i &gt; mLruProcessActivityStart; i--) &#123;</div><div class=\"line\">            ProcessRecord subProc = mLruProcesses.get(i);</div><div class=\"line\">            if (subProc.info.uid == uid) &#123;</div><div class=\"line\">                // We want to push this one down the list.  If the process after</div><div class=\"line\">                // it is for the same uid, however, don&apos;t do so, because we don&apos;t</div><div class=\"line\">                // want them internally to be re-ordered.</div><div class=\"line\">                if (mLruProcesses.get(i - 1).info.uid != uid) &#123;</div><div class=\"line\">                    if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                            &quot;Pushing uid &quot; + uid + &quot; swapping at &quot; + i + &quot;: &quot;</div><div class=\"line\">                            + mLruProcesses.get(i) + &quot; : &quot; + mLruProcesses.get(i - 1));</div><div class=\"line\">                    ProcessRecord tmp = mLruProcesses.get(i);</div><div class=\"line\">                    mLruProcesses.set(i, mLruProcesses.get(i - 1));</div><div class=\"line\">                    mLruProcesses.set(i - 1, tmp);</div><div class=\"line\">                    i--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // A gap, we can stop here.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Process has activities, put it at the very tipsy-top.</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(app);</div><div class=\"line\">    &#125;</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">&#125; else if (hasService) &#123;</div><div class=\"line\">    // Process has services, put it at the top of the service list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU service list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(mLruProcessActivityStart, app);</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">&#125; else  &#123;</div><div class=\"line\">    // Process not otherwise of interest, it goes to the top of the non-service area.</div><div class=\"line\">    int index = mLruProcessServiceStart;</div><div class=\"line\">    if (client != null) &#123;</div><div class=\"line\">        // If there is a client, don&apos;t allow the process to be moved up higher</div><div class=\"line\">        // in the list than that client.</div><div class=\"line\">        int clientIndex = mLruProcesses.lastIndexOf(client);</div><div class=\"line\">        if (DEBUG_LRU &amp;&amp; clientIndex &lt; 0) Slog.d(TAG_LRU, &quot;Unknown client &quot; + client</div><div class=\"line\">                + &quot; when updating &quot; + app);</div><div class=\"line\">        if (clientIndex &lt;= lrui) &#123;</div><div class=\"line\">            // Don&apos;t allow the client index restriction to push it down farther in the</div><div class=\"line\">            // list than it already is.</div><div class=\"line\">            clientIndex = lrui;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (clientIndex &gt;= 0 &amp;&amp; index &gt; clientIndex) &#123;</div><div class=\"line\">            index = clientIndex;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding at &quot; + index + &quot; of LRU list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(index, app);</div><div class=\"line\">    nextIndex = index-1;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">    mLruProcessServiceStart++;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>hasActivity为true<ul>\n<li>没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。</li>\n<li>直接添加到最后一个</li>\n</ul>\n</li>\n<li>hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置</li>\n<li>因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j=app.connections.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ConnectionRecord cr = app.connections.valueAt(j);</div><div class=\"line\">    if (cr.binding != null &amp;&amp; !cr.serviceDead &amp;&amp; cr.binding.service != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app.lruSeq != mLruSeq</div><div class=\"line\">            &amp;&amp; !cr.binding.service.app.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,</div><div class=\"line\">                &quot;service connection&quot;, cr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">for (int j=app.conProviders.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ContentProviderRecord cpr = app.conProviders.get(j).provider;</div><div class=\"line\">    if (cpr.proc != null &amp;&amp; cpr.proc.lruSeq != mLruSeq &amp;&amp; !cpr.proc.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,</div><div class=\"line\">                &quot;provider reference&quot;, cpr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>把和这个进程关联的service和contentprovider调整到这个进程之后。</p>\n<h3 id=\"3-调整OomAdj值的updateOomAdjLocked方法\"><a href=\"#3-调整OomAdj值的updateOomAdjLocked方法\" class=\"headerlink\" title=\"3. 调整OomAdj值的updateOomAdjLocked方法\"></a>3. 调整OomAdj值的updateOomAdjLocked方法</h3><p>方法较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ActivityRecord TOP_ACT = resumedAppLocked();</div><div class=\"line\">final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">final long oldTime = now - ProcessList.MAX_EMPTY_TIME;</div><div class=\"line\">final int N = mLruProcesses.size();</div><div class=\"line\"></div><div class=\"line\">if (false) &#123;</div><div class=\"line\">    RuntimeException e = new RuntimeException();</div><div class=\"line\">    e.fillInStackTrace();</div><div class=\"line\">    Slog.i(TAG, &quot;updateOomAdj: top=&quot; + TOP_ACT, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Reset state in all uid records.</div><div class=\"line\">for (int i=mActiveUids.size()-1; i&gt;=0; i--) &#123;</div><div class=\"line\">    final UidRecord uidRec = mActiveUids.valueAt(i);</div><div class=\"line\">    if (false &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</div><div class=\"line\">            &quot;Starting update of &quot; + uidRec);</div><div class=\"line\">    uidRec.reset();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mAdjSeq++;</div><div class=\"line\">mNewNumServiceProcs = 0;</div><div class=\"line\">mNewNumAServiceProcs = 0;</div><div class=\"line\"></div><div class=\"line\">final int emptyProcessLimit;</div><div class=\"line\">final int cachedProcessLimit;</div><div class=\"line\">if (mProcessLimit &lt;= 0) &#123;</div><div class=\"line\">    emptyProcessLimit = cachedProcessLimit = 0;</div><div class=\"line\">&#125; else if (mProcessLimit == 1) &#123;</div><div class=\"line\">    emptyProcessLimit = 1;</div><div class=\"line\">    cachedProcessLimit = 0;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);</div><div class=\"line\">    cachedProcessLimit = mProcessLimit - emptyProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Let&apos;s determine how many processes we have running vs.</div><div class=\"line\">// how many slots we have for background processes; we may want</div><div class=\"line\">// to put multiple processes in a slot of there are enough of</div><div class=\"line\">// them.</div><div class=\"line\">int numSlots = (ProcessList.CACHED_APP_MAX_ADJ</div><div class=\"line\">        - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;</div><div class=\"line\">int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</div><div class=\"line\">if (numEmptyProcs &gt; cachedProcessLimit) &#123;</div><div class=\"line\">    // If there are more empty processes than our limit on cached</div><div class=\"line\">    // processes, then use the cached process limit for the factor.</div><div class=\"line\">    // This ensures that the really old empty processes get pushed</div><div class=\"line\">    // down to the bottom, so if we are running low on memory we will</div><div class=\"line\">    // have a better chance at keeping around more cached processes</div><div class=\"line\">    // instead of a gazillion empty processes.</div><div class=\"line\">    numEmptyProcs = cachedProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\">int emptyFactor = numEmptyProcs/numSlots;</div><div class=\"line\">if (emptyFactor &lt; 1) emptyFactor = 1;</div><div class=\"line\">int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1)/numSlots;</div><div class=\"line\">if (cachedFactor &lt; 1) cachedFactor = 1;</div><div class=\"line\">int stepCached = 0;</div><div class=\"line\">int stepEmpty = 0;</div><div class=\"line\">int numCached = 0;</div><div class=\"line\">int numEmpty = 0;</div><div class=\"line\">int numTrimming = 0;</div><div class=\"line\"></div><div class=\"line\">mNumNonCachedProcs = 0;</div><div class=\"line\">mNumCachedHiddenProcs = 0;</div></pre></td></tr></table></figure>\n<p>这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextCachedAdj = curCachedAdj+1;</div><div class=\"line\">       int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextEmptyAdj = curEmptyAdj+2;</div><div class=\"line\">       for (int i=N-1; i&gt;=0; i--) &#123;</div><div class=\"line\">           ProcessRecord app = mLruProcesses.get(i);</div><div class=\"line\">           if (!app.killedByAm &amp;&amp; app.thread != null) &#123;</div><div class=\"line\">               app.procStateChanged = false;</div><div class=\"line\">               computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);</div><div class=\"line\"></div><div class=\"line\">               // If we haven&apos;t yet assigned the final cached adj</div><div class=\"line\">               // to the process, do that now.</div><div class=\"line\">               if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</div><div class=\"line\">                   switch (app.curProcState) &#123;</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                           // This process is a cached process holding activities...</div><div class=\"line\">                           // assign it the next cached value for that type, and then</div><div class=\"line\">                           // step that cached level.</div><div class=\"line\">                           app.curRawAdj = curCachedAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curCachedAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning activity LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curCachedAdj=&quot; + curCachedAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curCachedAdj != nextCachedAdj) &#123;</div><div class=\"line\">                               stepCached++;</div><div class=\"line\">                               if (stepCached &gt;= cachedFactor) &#123;</div><div class=\"line\">                                   stepCached = 0;</div><div class=\"line\">                                   curCachedAdj = nextCachedAdj;</div><div class=\"line\">                                   nextCachedAdj += 2;</div><div class=\"line\">                                   if (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                       default:</div><div class=\"line\">                           // For everything else, assign next empty cached process</div><div class=\"line\">                           // level and bump that up.  Note that this means that</div><div class=\"line\">                           // long-running services that have dropped down to the</div><div class=\"line\">                           // cached level will be treated as empty (since their process</div><div class=\"line\">                           // state is still as a service), which is what we want.</div><div class=\"line\">                           app.curRawAdj = curEmptyAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning empty LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curEmptyAdj=&quot; + curEmptyAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curEmptyAdj != nextEmptyAdj) &#123;</div><div class=\"line\">                               stepEmpty++;</div><div class=\"line\">                               if (stepEmpty &gt;= emptyFactor) &#123;</div><div class=\"line\">                                   stepEmpty = 0;</div><div class=\"line\">                                   curEmptyAdj = nextEmptyAdj;</div><div class=\"line\">                                   nextEmptyAdj += 2;</div><div class=\"line\">                                   if (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               applyOomAdjLocked(app, true, now);</div><div class=\"line\"></div><div class=\"line\">               // Count the number of process types.</div><div class=\"line\">               switch (app.curProcState) &#123;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                       mNumCachedHiddenProcs++;</div><div class=\"line\">                       numCached++;</div><div class=\"line\">                       if (numCached &gt; cachedProcessLimit) &#123;</div><div class=\"line\">                           app.kill(&quot;cached #&quot; + numCached, true);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_EMPTY:</div><div class=\"line\">                       if (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS</div><div class=\"line\">                               &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</div><div class=\"line\">                           app.kill(&quot;empty for &quot;</div><div class=\"line\">                                   + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)</div><div class=\"line\">                                   / 1000) + &quot;s&quot;, true);</div><div class=\"line\">                       &#125; else &#123;</div><div class=\"line\">                           numEmpty++;</div><div class=\"line\">                           if (numEmpty &gt; emptyProcessLimit) &#123;</div><div class=\"line\">                               app.kill(&quot;empty #&quot; + numEmpty, true);</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   default:</div><div class=\"line\">                       mNumNonCachedProcs++;</div><div class=\"line\">                       break;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.isolated &amp;&amp; app.services.size() &lt;= 0) &#123;</div><div class=\"line\">                   // If this is an isolated process, and there are no</div><div class=\"line\">                   // services running in it, then the process is no longer</div><div class=\"line\">                   // needed.  We agressively kill these because we can by</div><div class=\"line\">                   // definition not re-use the same process again, and it is</div><div class=\"line\">                   // good to avoid having whatever code was running in them</div><div class=\"line\">                   // left sitting around after no longer needed.</div><div class=\"line\">                   app.kill(&quot;isolated not needed&quot;, true);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Keeping this process, update its uid.</div><div class=\"line\">                   final UidRecord uidRec = app.uidRecord;</div><div class=\"line\">                   if (uidRec != null &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123;</div><div class=\"line\">                       uidRec.curProcState = app.curProcState;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</div><div class=\"line\">                       &amp;&amp; !app.killedByAm) &#123;</div><div class=\"line\">                   numTrimming++;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>上面代码的逻辑是更新进程oomadj值。</p>\n<ul>\n<li>首先通过computeOomAdjLocked计算oomadj值</li>\n<li>当进程未分配adj值是，更新adj值(if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ))<ul>\n<li>当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值</li>\n<li>不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值</li>\n</ul>\n</li>\n<li>applyOomAdjLocked,使更新生效</li>\n<li>根据进程状态，选择策略<ul>\n<li>PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程</li>\n<li>PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程</li>\n</ul>\n</li>\n<li>如果是孤立进程 并且没有service，直接杀掉</li>\n</ul>\n<pre><code>final int numCachedAndEmpty = numCached + numEmpty;\nint memFactor;\nif (numCached &lt;= ProcessList.TRIM_CACHED_APPS\n        &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) {\n    if (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n    } else if (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n    } else {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n    }\n} else {\n    memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n}\n// We always allow the memory level to go up (better).  We only allow it to go\n// down if we are in a state where that is allowed, *and* the total number of processes\n// has gone down since last time.\nif (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;oom: memFactor=&quot; + memFactor\n        + &quot; last=&quot; + mLastMemoryLevel + &quot; allowLow=&quot; + mAllowLowerMemLevel\n        + &quot; numProcs=&quot; + mLruProcesses.size() + &quot; last=&quot; + mLastNumProcesses);\nif (memFactor &gt; mLastMemoryLevel) {\n    if (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) {\n        memFactor = mLastMemoryLevel;\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;Keeping last mem factor!&quot;);\n    }\n}\nmLastMemoryLevel = memFactor;\nmLastNumProcesses = mLruProcesses.size();\nboolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\nfinal int trackerMemFactor = mProcessStats.getMemFactorLocked();\nif (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n    if (mLowRamStartTime == 0) {\n        mLowRamStartTime = now;\n    }\n    int step = 0;\n    int fgTrimLevel;\n    switch (memFactor) {\n        case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n            break;\n        case ProcessStats.ADJ_MEM_FACTOR_LOW:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n            break;\n        default:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n            break;\n    }\n    int factor = numTrimming/3;\n    int minFactor = 2;\n    if (mHomeProcess != null) minFactor++;\n    if (mPreviousProcess != null) minFactor++;\n    if (factor &lt; minFactor) factor = minFactor;\n    int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME\n                &amp;&amp; !app.killedByAm) {\n            if (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of &quot; + app.processName + &quot; to &quot; + curLevel);\n                    app.thread.scheduleTrimMemory(curLevel);\n                } catch (RemoteException e) {\n                }\n                if (false) {\n                    // For now we won&apos;t do this; our memory trimming seems\n                    // to be good enough at this point that destroying\n                    // activities causes more harm than good.\n                    if (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                            &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) {\n                        // Need to do this on its own message because the stack may not\n                        // be in a consistent state at this point.\n                        // For these apps we will also finish their activities\n                        // to help them free memory.\n                        mStackSupervisor.scheduleDestroyAllActivities(app, &quot;trim&quot;);\n                    }\n                }\n            }\n            app.trimMemoryLevel = curLevel;\n            step++;\n            if (step &gt;= factor) {\n                step = 0;\n                switch (curLevel) {\n                    case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                        break;\n                    case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                        break;\n                }\n            }\n        } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of heavy-weight &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n        } else {\n            if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                    || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n                // If this application is now in the background and it\n                // had done UI, then give it the special trim level to\n                // have it free UI resources.\n                final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                if (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != null) {\n                    try {\n                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                &quot;Trimming memory of bg-ui &quot; + app.processName\n                                + &quot; to &quot; + level);\n                        app.thread.scheduleTrimMemory(level);\n                    } catch (RemoteException e) {\n                    }\n                }\n                app.pendingUiClean = false;\n            }\n            if (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of fg &quot; + app.processName\n                            + &quot; to &quot; + fgTrimLevel);\n                    app.thread.scheduleTrimMemory(fgTrimLevel);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = fgTrimLevel;\n        }\n    }\n} else {\n    if (mLowRamStartTime != 0) {\n        mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n        mLowRamStartTime = 0;\n    }\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of ui hidden &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                } catch (RemoteException e) {\n                }\n            }\n            app.pendingUiClean = false;\n        }\n        app.trimMemoryLevel = 0;\n    }\n}\n</code></pre><ul>\n<li>先调整内存因子memFactor</li>\n<li><p>如果内存因子不为0</p>\n<ul>\n<li>根据内存因子 初始化fgTrimLevel</li>\n<li>循环处理进程<ul>\n<li>curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel</li>\n<li>curProcState等于9，且满足条件，进行TrimMemory</li>\n<li>其他情况下，根据条件进行TrimMemory操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内存因子为0,也是根据跳进进行TrimMemory操作</p>\n</li>\n</ul>\n<p>整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。</p>\n<p>computeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。</p>\n<h3 id=\"4-杀进程\"><a href=\"#4-杀进程\" class=\"headerlink\" title=\"4.杀进程\"></a>4.杀进程</h3><p>杀进程这里就略过了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n</excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>ActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n</li>\n</ul>\n<ul>\n<li>新建进程</li>\n<li>调整进程在mLruProcesses的位置</li>\n<li>调整进程OomAdj值</li>\n<li>杀进程</li>\n</ul>\n<p>而新建进程在前面有说到过，今天就来介绍下剩下的三个。</p>\n<h3 id=\"2-调整位置的updateLruProcessLocked方法\"><a href=\"#2-调整位置的updateLruProcessLocked方法\" class=\"headerlink\" title=\"2.调整位置的updateLruProcessLocked方法\"></a>2.调整位置的updateLruProcessLocked方法</h3><p>代码比较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean hasActivity = app.activities.size() &gt; 0 || app.hasClientActivities</div><div class=\"line\">        || app.treatLikeActivity;</div><div class=\"line\">final boolean hasService = false; // not impl yet. app.services.size() &gt; 0;</div><div class=\"line\">if (!activityChange &amp;&amp; hasActivity) &#123;</div><div class=\"line\">    // The process has activities, so we are only allowing activity-based adjustments</div><div class=\"line\">    // to move it.  It should be kept in the front of the list with other</div><div class=\"line\">    // processes that have activities, and we don&apos;t want those to change their</div><div class=\"line\">    // order except due to activity operations.</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mLruSeq++;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">app.lastActivityTime = now;</div><div class=\"line\"></div><div class=\"line\">// First a quick reject: if the app is already at the position we will</div><div class=\"line\">// put it, then there is nothing to do.</div><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (N &gt; 0 &amp;&amp; mLruProcesses.get(N-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top activity: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    if (mLruProcessServiceStart &gt; 0</div><div class=\"line\">            &amp;&amp; mLruProcesses.get(mLruProcessServiceStart-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top other: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int lrui = mLruProcesses.lastIndexOf(app);</div><div class=\"line\"></div><div class=\"line\">if (app.persistent &amp;&amp; lrui &gt;= 0) &#123;</div><div class=\"line\">    // We don&apos;t care about the position of persistent processes, as long as</div><div class=\"line\">    // they are in the list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, persistent: &quot; + app);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果有activity，并且进程中activity没有发生变化，不需要调整</li>\n<li>如果有activity，但是当前进程就是在最后，不需要调整</li>\n<li>如果没有activity，但是在合适的位置，不需要调整</li>\n<li>如果有persistent标志，不需要调整</li>\n<li>lrui 为当前进程在list中的索引(最后一个的索引)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (lrui &gt;= 0) &#123;</div><div class=\"line\">    if (lrui &lt; mLruProcessActivityStart) &#123;</div><div class=\"line\">        mLruProcessActivityStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (lrui &lt; mLruProcessServiceStart) &#123;</div><div class=\"line\">        mLruProcessServiceStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">    if (addIndex &gt; lrui) &#123;</div><div class=\"line\">        addIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (nextIndex &gt; lrui) &#123;</div><div class=\"line\">        nextIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    */</div><div class=\"line\">    mLruProcesses.remove(lrui);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (app.activities.size() == 0 &amp;&amp; mLruProcessActivityStart &lt; (N - 1)) &#123;</div><div class=\"line\">        // Process doesn&apos;t have activities, but has clients with</div><div class=\"line\">        // activities...  move it up, but one below the top (the top</div><div class=\"line\">        // should always have a real activity).</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                &quot;Adding to second-top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(N - 1, app);</div><div class=\"line\">        // To keep it from spamming the LRU list (by making a bunch of clients),</div><div class=\"line\">        // we will push down any other entries owned by the app.</div><div class=\"line\">        final int uid = app.info.uid;</div><div class=\"line\">        for (int i = N - 2; i &gt; mLruProcessActivityStart; i--) &#123;</div><div class=\"line\">            ProcessRecord subProc = mLruProcesses.get(i);</div><div class=\"line\">            if (subProc.info.uid == uid) &#123;</div><div class=\"line\">                // We want to push this one down the list.  If the process after</div><div class=\"line\">                // it is for the same uid, however, don&apos;t do so, because we don&apos;t</div><div class=\"line\">                // want them internally to be re-ordered.</div><div class=\"line\">                if (mLruProcesses.get(i - 1).info.uid != uid) &#123;</div><div class=\"line\">                    if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                            &quot;Pushing uid &quot; + uid + &quot; swapping at &quot; + i + &quot;: &quot;</div><div class=\"line\">                            + mLruProcesses.get(i) + &quot; : &quot; + mLruProcesses.get(i - 1));</div><div class=\"line\">                    ProcessRecord tmp = mLruProcesses.get(i);</div><div class=\"line\">                    mLruProcesses.set(i, mLruProcesses.get(i - 1));</div><div class=\"line\">                    mLruProcesses.set(i - 1, tmp);</div><div class=\"line\">                    i--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // A gap, we can stop here.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Process has activities, put it at the very tipsy-top.</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(app);</div><div class=\"line\">    &#125;</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">&#125; else if (hasService) &#123;</div><div class=\"line\">    // Process has services, put it at the top of the service list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU service list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(mLruProcessActivityStart, app);</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">&#125; else  &#123;</div><div class=\"line\">    // Process not otherwise of interest, it goes to the top of the non-service area.</div><div class=\"line\">    int index = mLruProcessServiceStart;</div><div class=\"line\">    if (client != null) &#123;</div><div class=\"line\">        // If there is a client, don&apos;t allow the process to be moved up higher</div><div class=\"line\">        // in the list than that client.</div><div class=\"line\">        int clientIndex = mLruProcesses.lastIndexOf(client);</div><div class=\"line\">        if (DEBUG_LRU &amp;&amp; clientIndex &lt; 0) Slog.d(TAG_LRU, &quot;Unknown client &quot; + client</div><div class=\"line\">                + &quot; when updating &quot; + app);</div><div class=\"line\">        if (clientIndex &lt;= lrui) &#123;</div><div class=\"line\">            // Don&apos;t allow the client index restriction to push it down farther in the</div><div class=\"line\">            // list than it already is.</div><div class=\"line\">            clientIndex = lrui;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (clientIndex &gt;= 0 &amp;&amp; index &gt; clientIndex) &#123;</div><div class=\"line\">            index = clientIndex;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding at &quot; + index + &quot; of LRU list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(index, app);</div><div class=\"line\">    nextIndex = index-1;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">    mLruProcessServiceStart++;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>hasActivity为true<ul>\n<li>没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。</li>\n<li>直接添加到最后一个</li>\n</ul>\n</li>\n<li>hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置</li>\n<li>因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j=app.connections.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ConnectionRecord cr = app.connections.valueAt(j);</div><div class=\"line\">    if (cr.binding != null &amp;&amp; !cr.serviceDead &amp;&amp; cr.binding.service != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app.lruSeq != mLruSeq</div><div class=\"line\">            &amp;&amp; !cr.binding.service.app.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,</div><div class=\"line\">                &quot;service connection&quot;, cr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">for (int j=app.conProviders.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ContentProviderRecord cpr = app.conProviders.get(j).provider;</div><div class=\"line\">    if (cpr.proc != null &amp;&amp; cpr.proc.lruSeq != mLruSeq &amp;&amp; !cpr.proc.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,</div><div class=\"line\">                &quot;provider reference&quot;, cpr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>把和这个进程关联的service和contentprovider调整到这个进程之后。</p>\n<h3 id=\"3-调整OomAdj值的updateOomAdjLocked方法\"><a href=\"#3-调整OomAdj值的updateOomAdjLocked方法\" class=\"headerlink\" title=\"3. 调整OomAdj值的updateOomAdjLocked方法\"></a>3. 调整OomAdj值的updateOomAdjLocked方法</h3><p>方法较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ActivityRecord TOP_ACT = resumedAppLocked();</div><div class=\"line\">final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">final long oldTime = now - ProcessList.MAX_EMPTY_TIME;</div><div class=\"line\">final int N = mLruProcesses.size();</div><div class=\"line\"></div><div class=\"line\">if (false) &#123;</div><div class=\"line\">    RuntimeException e = new RuntimeException();</div><div class=\"line\">    e.fillInStackTrace();</div><div class=\"line\">    Slog.i(TAG, &quot;updateOomAdj: top=&quot; + TOP_ACT, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Reset state in all uid records.</div><div class=\"line\">for (int i=mActiveUids.size()-1; i&gt;=0; i--) &#123;</div><div class=\"line\">    final UidRecord uidRec = mActiveUids.valueAt(i);</div><div class=\"line\">    if (false &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</div><div class=\"line\">            &quot;Starting update of &quot; + uidRec);</div><div class=\"line\">    uidRec.reset();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mAdjSeq++;</div><div class=\"line\">mNewNumServiceProcs = 0;</div><div class=\"line\">mNewNumAServiceProcs = 0;</div><div class=\"line\"></div><div class=\"line\">final int emptyProcessLimit;</div><div class=\"line\">final int cachedProcessLimit;</div><div class=\"line\">if (mProcessLimit &lt;= 0) &#123;</div><div class=\"line\">    emptyProcessLimit = cachedProcessLimit = 0;</div><div class=\"line\">&#125; else if (mProcessLimit == 1) &#123;</div><div class=\"line\">    emptyProcessLimit = 1;</div><div class=\"line\">    cachedProcessLimit = 0;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);</div><div class=\"line\">    cachedProcessLimit = mProcessLimit - emptyProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Let&apos;s determine how many processes we have running vs.</div><div class=\"line\">// how many slots we have for background processes; we may want</div><div class=\"line\">// to put multiple processes in a slot of there are enough of</div><div class=\"line\">// them.</div><div class=\"line\">int numSlots = (ProcessList.CACHED_APP_MAX_ADJ</div><div class=\"line\">        - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;</div><div class=\"line\">int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</div><div class=\"line\">if (numEmptyProcs &gt; cachedProcessLimit) &#123;</div><div class=\"line\">    // If there are more empty processes than our limit on cached</div><div class=\"line\">    // processes, then use the cached process limit for the factor.</div><div class=\"line\">    // This ensures that the really old empty processes get pushed</div><div class=\"line\">    // down to the bottom, so if we are running low on memory we will</div><div class=\"line\">    // have a better chance at keeping around more cached processes</div><div class=\"line\">    // instead of a gazillion empty processes.</div><div class=\"line\">    numEmptyProcs = cachedProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\">int emptyFactor = numEmptyProcs/numSlots;</div><div class=\"line\">if (emptyFactor &lt; 1) emptyFactor = 1;</div><div class=\"line\">int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1)/numSlots;</div><div class=\"line\">if (cachedFactor &lt; 1) cachedFactor = 1;</div><div class=\"line\">int stepCached = 0;</div><div class=\"line\">int stepEmpty = 0;</div><div class=\"line\">int numCached = 0;</div><div class=\"line\">int numEmpty = 0;</div><div class=\"line\">int numTrimming = 0;</div><div class=\"line\"></div><div class=\"line\">mNumNonCachedProcs = 0;</div><div class=\"line\">mNumCachedHiddenProcs = 0;</div></pre></td></tr></table></figure>\n<p>这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextCachedAdj = curCachedAdj+1;</div><div class=\"line\">       int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextEmptyAdj = curEmptyAdj+2;</div><div class=\"line\">       for (int i=N-1; i&gt;=0; i--) &#123;</div><div class=\"line\">           ProcessRecord app = mLruProcesses.get(i);</div><div class=\"line\">           if (!app.killedByAm &amp;&amp; app.thread != null) &#123;</div><div class=\"line\">               app.procStateChanged = false;</div><div class=\"line\">               computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);</div><div class=\"line\"></div><div class=\"line\">               // If we haven&apos;t yet assigned the final cached adj</div><div class=\"line\">               // to the process, do that now.</div><div class=\"line\">               if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</div><div class=\"line\">                   switch (app.curProcState) &#123;</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                           // This process is a cached process holding activities...</div><div class=\"line\">                           // assign it the next cached value for that type, and then</div><div class=\"line\">                           // step that cached level.</div><div class=\"line\">                           app.curRawAdj = curCachedAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curCachedAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning activity LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curCachedAdj=&quot; + curCachedAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curCachedAdj != nextCachedAdj) &#123;</div><div class=\"line\">                               stepCached++;</div><div class=\"line\">                               if (stepCached &gt;= cachedFactor) &#123;</div><div class=\"line\">                                   stepCached = 0;</div><div class=\"line\">                                   curCachedAdj = nextCachedAdj;</div><div class=\"line\">                                   nextCachedAdj += 2;</div><div class=\"line\">                                   if (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                       default:</div><div class=\"line\">                           // For everything else, assign next empty cached process</div><div class=\"line\">                           // level and bump that up.  Note that this means that</div><div class=\"line\">                           // long-running services that have dropped down to the</div><div class=\"line\">                           // cached level will be treated as empty (since their process</div><div class=\"line\">                           // state is still as a service), which is what we want.</div><div class=\"line\">                           app.curRawAdj = curEmptyAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning empty LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curEmptyAdj=&quot; + curEmptyAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curEmptyAdj != nextEmptyAdj) &#123;</div><div class=\"line\">                               stepEmpty++;</div><div class=\"line\">                               if (stepEmpty &gt;= emptyFactor) &#123;</div><div class=\"line\">                                   stepEmpty = 0;</div><div class=\"line\">                                   curEmptyAdj = nextEmptyAdj;</div><div class=\"line\">                                   nextEmptyAdj += 2;</div><div class=\"line\">                                   if (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               applyOomAdjLocked(app, true, now);</div><div class=\"line\"></div><div class=\"line\">               // Count the number of process types.</div><div class=\"line\">               switch (app.curProcState) &#123;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                       mNumCachedHiddenProcs++;</div><div class=\"line\">                       numCached++;</div><div class=\"line\">                       if (numCached &gt; cachedProcessLimit) &#123;</div><div class=\"line\">                           app.kill(&quot;cached #&quot; + numCached, true);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_EMPTY:</div><div class=\"line\">                       if (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS</div><div class=\"line\">                               &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</div><div class=\"line\">                           app.kill(&quot;empty for &quot;</div><div class=\"line\">                                   + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)</div><div class=\"line\">                                   / 1000) + &quot;s&quot;, true);</div><div class=\"line\">                       &#125; else &#123;</div><div class=\"line\">                           numEmpty++;</div><div class=\"line\">                           if (numEmpty &gt; emptyProcessLimit) &#123;</div><div class=\"line\">                               app.kill(&quot;empty #&quot; + numEmpty, true);</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   default:</div><div class=\"line\">                       mNumNonCachedProcs++;</div><div class=\"line\">                       break;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.isolated &amp;&amp; app.services.size() &lt;= 0) &#123;</div><div class=\"line\">                   // If this is an isolated process, and there are no</div><div class=\"line\">                   // services running in it, then the process is no longer</div><div class=\"line\">                   // needed.  We agressively kill these because we can by</div><div class=\"line\">                   // definition not re-use the same process again, and it is</div><div class=\"line\">                   // good to avoid having whatever code was running in them</div><div class=\"line\">                   // left sitting around after no longer needed.</div><div class=\"line\">                   app.kill(&quot;isolated not needed&quot;, true);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Keeping this process, update its uid.</div><div class=\"line\">                   final UidRecord uidRec = app.uidRecord;</div><div class=\"line\">                   if (uidRec != null &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123;</div><div class=\"line\">                       uidRec.curProcState = app.curProcState;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</div><div class=\"line\">                       &amp;&amp; !app.killedByAm) &#123;</div><div class=\"line\">                   numTrimming++;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>上面代码的逻辑是更新进程oomadj值。</p>\n<ul>\n<li>首先通过computeOomAdjLocked计算oomadj值</li>\n<li>当进程未分配adj值是，更新adj值(if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ))<ul>\n<li>当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值</li>\n<li>不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值</li>\n</ul>\n</li>\n<li>applyOomAdjLocked,使更新生效</li>\n<li>根据进程状态，选择策略<ul>\n<li>PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程</li>\n<li>PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程</li>\n</ul>\n</li>\n<li>如果是孤立进程 并且没有service，直接杀掉</li>\n</ul>\n<pre><code>final int numCachedAndEmpty = numCached + numEmpty;\nint memFactor;\nif (numCached &lt;= ProcessList.TRIM_CACHED_APPS\n        &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) {\n    if (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n    } else if (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n    } else {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n    }\n} else {\n    memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n}\n// We always allow the memory level to go up (better).  We only allow it to go\n// down if we are in a state where that is allowed, *and* the total number of processes\n// has gone down since last time.\nif (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;oom: memFactor=&quot; + memFactor\n        + &quot; last=&quot; + mLastMemoryLevel + &quot; allowLow=&quot; + mAllowLowerMemLevel\n        + &quot; numProcs=&quot; + mLruProcesses.size() + &quot; last=&quot; + mLastNumProcesses);\nif (memFactor &gt; mLastMemoryLevel) {\n    if (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) {\n        memFactor = mLastMemoryLevel;\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;Keeping last mem factor!&quot;);\n    }\n}\nmLastMemoryLevel = memFactor;\nmLastNumProcesses = mLruProcesses.size();\nboolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\nfinal int trackerMemFactor = mProcessStats.getMemFactorLocked();\nif (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n    if (mLowRamStartTime == 0) {\n        mLowRamStartTime = now;\n    }\n    int step = 0;\n    int fgTrimLevel;\n    switch (memFactor) {\n        case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n            break;\n        case ProcessStats.ADJ_MEM_FACTOR_LOW:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n            break;\n        default:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n            break;\n    }\n    int factor = numTrimming/3;\n    int minFactor = 2;\n    if (mHomeProcess != null) minFactor++;\n    if (mPreviousProcess != null) minFactor++;\n    if (factor &lt; minFactor) factor = minFactor;\n    int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME\n                &amp;&amp; !app.killedByAm) {\n            if (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of &quot; + app.processName + &quot; to &quot; + curLevel);\n                    app.thread.scheduleTrimMemory(curLevel);\n                } catch (RemoteException e) {\n                }\n                if (false) {\n                    // For now we won&apos;t do this; our memory trimming seems\n                    // to be good enough at this point that destroying\n                    // activities causes more harm than good.\n                    if (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                            &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) {\n                        // Need to do this on its own message because the stack may not\n                        // be in a consistent state at this point.\n                        // For these apps we will also finish their activities\n                        // to help them free memory.\n                        mStackSupervisor.scheduleDestroyAllActivities(app, &quot;trim&quot;);\n                    }\n                }\n            }\n            app.trimMemoryLevel = curLevel;\n            step++;\n            if (step &gt;= factor) {\n                step = 0;\n                switch (curLevel) {\n                    case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                        break;\n                    case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                        break;\n                }\n            }\n        } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of heavy-weight &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n        } else {\n            if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                    || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n                // If this application is now in the background and it\n                // had done UI, then give it the special trim level to\n                // have it free UI resources.\n                final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                if (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != null) {\n                    try {\n                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                &quot;Trimming memory of bg-ui &quot; + app.processName\n                                + &quot; to &quot; + level);\n                        app.thread.scheduleTrimMemory(level);\n                    } catch (RemoteException e) {\n                    }\n                }\n                app.pendingUiClean = false;\n            }\n            if (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of fg &quot; + app.processName\n                            + &quot; to &quot; + fgTrimLevel);\n                    app.thread.scheduleTrimMemory(fgTrimLevel);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = fgTrimLevel;\n        }\n    }\n} else {\n    if (mLowRamStartTime != 0) {\n        mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n        mLowRamStartTime = 0;\n    }\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of ui hidden &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                } catch (RemoteException e) {\n                }\n            }\n            app.pendingUiClean = false;\n        }\n        app.trimMemoryLevel = 0;\n    }\n}\n</code></pre><ul>\n<li>先调整内存因子memFactor</li>\n<li><p>如果内存因子不为0</p>\n<ul>\n<li>根据内存因子 初始化fgTrimLevel</li>\n<li>循环处理进程<ul>\n<li>curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel</li>\n<li>curProcState等于9，且满足条件，进行TrimMemory</li>\n<li>其他情况下，根据条件进行TrimMemory操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内存因子为0,也是根据跳进进行TrimMemory操作</p>\n</li>\n</ul>\n<p>整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。</p>\n<p>computeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。</p>\n<h3 id=\"4-杀进程\"><a href=\"#4-杀进程\" class=\"headerlink\" title=\"4.杀进程\"></a>4.杀进程</h3><p>杀进程这里就略过了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"AndroidJNI学习笔记（四）－数据类型映射以及native调用java","date":"2016-11-29T16:05:36.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 2. 数据类型映射 \n\n首先是我们的基本数据类型，其关系如下表描述这样。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225511135)\n\n上面关系的相关代码在jni.h的44－51行，如下\n\n```\ntypedef unsigned char   jboolean;       /* unsigned 8 bits */\ntypedef signed char     jbyte;          /* signed 8 bits */\ntypedef unsigned short  jchar;          /* unsigned 16 bits */\ntypedef short           jshort;         /* signed 16 bits */\ntypedef int             jint;           /* signed 32 bits */\ntypedef long long       jlong;          /* signed 64 bits */\ntypedef float           jfloat;         /* 32-bit IEEE 754 */\ntypedef double          jdouble;        /* 64-bit IEEE 754 */\n```\n\n\n而jni层的引用类型则是下面这个样子。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225901230)\n\n对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。\n\n```\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n```\n\n### 3. native 如何调用c\n\n我们这里的调用包括许多方面，如：\n\n* 调用静态方法\n* 调用实例方法\n* 获取字段值\n* 修改字段值\n* 构造对象\n* 等等\n\n而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：\n\n*  根据全限定名在jvm中找到想要的类\n* 从jclass中获取到method、或者field\n* 执行获取值、修改值、调用方法或者其他的操作\n* 释放局部引用\n\n举个调用静态方法的例子看看。\n\n```\nvoid callJavaStatic(JNIEnv *env,jobject jobj){\n  char* str = \"call from c++\";\n\n  jclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n  if (clazz == NULL) {\n    LOGE(\"class is null\");\n    return;\n  }\n\n  jmethodID method = env->GetStaticMethodID(clazz,\"javaStaticMethod\",\"(Ljava/lang/String;)V\");\n  if (method == NULL) {\n    LOGE(\"not find method\");\n  }\n\n  jstring  jstr = env->NewStringUTF(str);\n  env->CallStaticVoidMethod(clazz,method,jstr);\n  env->DeleteLocalRef(clazz);\n  env->DeleteLocalRef(jstr);\n}\n```\n\n\n#### 3.1 如何找到类\n\n很简单，我们可以通过FindClass方法去查找类。\n\n```\njclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n```\n\n#### 3.2  如何获取方法、或者字段\n大致为以下四种方法\n\n```\n env->GetxxxField()\n env->GetStaticxxxField()\n env->GetMethodID()\n env->GetxxxMethodID()\n```\n\n上面没有列出参数，但是仍然很明白，这里就不多说了。\n\n\n#### 3.3 如何调用方法\n\n这里呢。大致分为以下四种：\n\n```\n  env->CallXXXMethod();\n  env->CallxxxMethodA();\n  env->CallxxxMethodV();\n  env->CallNonvirtualBooleanMethod()\n```\n\n同样，我这里没给出方法的参数，同学们自己看jni.h吧\n\n* 调用方法（这里的方法可能使静态的、也可能是非静态的）\n* 和上面的区别就在于对应的java层参数，在这里以数组的形式传进入\n* 和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。\n* 调用构造函数初始化一个对象，这个，马上说道。\n\n#### 3.4 如何修改字段的值\n\n相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。\n\n\n#### 3.5 如何构造一个对象出来\n\n有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。\n\n*  NewObject方法 \n*  CallNonvirtualxxMethod\n\n先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是< init >（md语法的原因，注意尖括号之间没有空格），别问为什么。\n\n在来说说第二种，第二中使用时这样的\n\n```\n  jobject  jo = env->AllocObject(clazz);\n  env->CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )\n```\n\n* 第一行代码 创建未初始化的对象，并分配内存\n* 第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。\n\n\n### 4. 总结\n\n现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/AndroidJNI学习笔记（四）－数据类型映射以及native调用java.md","raw":"---\ntitle: AndroidJNI学习笔记（四）－数据类型映射以及native调用java\ndate: 2016-11-30 00:05:36\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 2. 数据类型映射 \n\n首先是我们的基本数据类型，其关系如下表描述这样。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225511135)\n\n上面关系的相关代码在jni.h的44－51行，如下\n\n```\ntypedef unsigned char   jboolean;       /* unsigned 8 bits */\ntypedef signed char     jbyte;          /* signed 8 bits */\ntypedef unsigned short  jchar;          /* unsigned 16 bits */\ntypedef short           jshort;         /* signed 16 bits */\ntypedef int             jint;           /* signed 32 bits */\ntypedef long long       jlong;          /* signed 64 bits */\ntypedef float           jfloat;         /* 32-bit IEEE 754 */\ntypedef double          jdouble;        /* 64-bit IEEE 754 */\n```\n\n\n而jni层的引用类型则是下面这个样子。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225901230)\n\n对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。\n\n```\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n```\n\n### 3. native 如何调用c\n\n我们这里的调用包括许多方面，如：\n\n* 调用静态方法\n* 调用实例方法\n* 获取字段值\n* 修改字段值\n* 构造对象\n* 等等\n\n而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：\n\n*  根据全限定名在jvm中找到想要的类\n* 从jclass中获取到method、或者field\n* 执行获取值、修改值、调用方法或者其他的操作\n* 释放局部引用\n\n举个调用静态方法的例子看看。\n\n```\nvoid callJavaStatic(JNIEnv *env,jobject jobj){\n  char* str = \"call from c++\";\n\n  jclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n  if (clazz == NULL) {\n    LOGE(\"class is null\");\n    return;\n  }\n\n  jmethodID method = env->GetStaticMethodID(clazz,\"javaStaticMethod\",\"(Ljava/lang/String;)V\");\n  if (method == NULL) {\n    LOGE(\"not find method\");\n  }\n\n  jstring  jstr = env->NewStringUTF(str);\n  env->CallStaticVoidMethod(clazz,method,jstr);\n  env->DeleteLocalRef(clazz);\n  env->DeleteLocalRef(jstr);\n}\n```\n\n\n#### 3.1 如何找到类\n\n很简单，我们可以通过FindClass方法去查找类。\n\n```\njclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n```\n\n#### 3.2  如何获取方法、或者字段\n大致为以下四种方法\n\n```\n env->GetxxxField()\n env->GetStaticxxxField()\n env->GetMethodID()\n env->GetxxxMethodID()\n```\n\n上面没有列出参数，但是仍然很明白，这里就不多说了。\n\n\n#### 3.3 如何调用方法\n\n这里呢。大致分为以下四种：\n\n```\n  env->CallXXXMethod();\n  env->CallxxxMethodA();\n  env->CallxxxMethodV();\n  env->CallNonvirtualBooleanMethod()\n```\n\n同样，我这里没给出方法的参数，同学们自己看jni.h吧\n\n* 调用方法（这里的方法可能使静态的、也可能是非静态的）\n* 和上面的区别就在于对应的java层参数，在这里以数组的形式传进入\n* 和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。\n* 调用构造函数初始化一个对象，这个，马上说道。\n\n#### 3.4 如何修改字段的值\n\n相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。\n\n\n#### 3.5 如何构造一个对象出来\n\n有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。\n\n*  NewObject方法 \n*  CallNonvirtualxxMethod\n\n先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是< init >（md语法的原因，注意尖括号之间没有空格），别问为什么。\n\n在来说说第二种，第二中使用时这样的\n\n```\n  jobject  jo = env->AllocObject(clazz);\n  env->CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )\n```\n\n* 第一行代码 创建未初始化的对象，并分配内存\n* 第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。\n\n\n### 4. 总结\n\n现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"AndroidJNI学习笔记（四）－数据类型映射以及native调用java","published":1,"updated":"2017-01-06T05:30:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85xi0002uaxakpckexi1","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n</the></li>\n</ul>\n<h3 id=\"2-数据类型映射\"><a href=\"#2-数据类型映射\" class=\"headerlink\" title=\"2. 数据类型映射\"></a>2. 数据类型映射</h3><p>首先是我们的基本数据类型，其关系如下表描述这样。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225511135\" alt=\"这里写图片描述\"></p>\n<p>上面关系的相关代码在jni.h的44－51行，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char   jboolean;       /* unsigned 8 bits */</div><div class=\"line\">typedef signed char     jbyte;          /* signed 8 bits */</div><div class=\"line\">typedef unsigned short  jchar;          /* unsigned 16 bits */</div><div class=\"line\">typedef short           jshort;         /* signed 16 bits */</div><div class=\"line\">typedef int             jint;           /* signed 32 bits */</div><div class=\"line\">typedef long long       jlong;          /* signed 64 bits */</div><div class=\"line\">typedef float           jfloat;         /* 32-bit IEEE 754 */</div><div class=\"line\">typedef double          jdouble;        /* 64-bit IEEE 754 */</div></pre></td></tr></table></figure>\n<p>而jni层的引用类型则是下面这个样子。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225901230\" alt=\"这里写图片描述\"></p>\n<p>对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class _jobject &#123;&#125;;</div><div class=\"line\">class _jclass : public _jobject &#123;&#125;;</div><div class=\"line\">class _jstring : public _jobject &#123;&#125;;</div><div class=\"line\">class _jarray : public _jobject &#123;&#125;;</div><div class=\"line\">class _jobjectArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbooleanArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbyteArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jcharArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jshortArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jintArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jlongArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jfloatArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jdoubleArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jthrowable : public _jobject &#123;&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-native-如何调用c\"><a href=\"#3-native-如何调用c\" class=\"headerlink\" title=\"3. native 如何调用c\"></a>3. native 如何调用c</h3><p>我们这里的调用包括许多方面，如：</p>\n<ul>\n<li>调用静态方法</li>\n<li>调用实例方法</li>\n<li>获取字段值</li>\n<li>修改字段值</li>\n<li>构造对象</li>\n<li>等等</li>\n</ul>\n<p>而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：</p>\n<ul>\n<li>根据全限定名在jvm中找到想要的类</li>\n<li>从jclass中获取到method、或者field</li>\n<li>执行获取值、修改值、调用方法或者其他的操作</li>\n<li>释放局部引用</li>\n</ul>\n<p>举个调用静态方法的例子看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void callJavaStatic(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;call from c++&quot;;</div><div class=\"line\"></div><div class=\"line\">  jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div><div class=\"line\">  if (clazz == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;class is null&quot;);</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jmethodID method = env-&gt;GetStaticMethodID(clazz,&quot;javaStaticMethod&quot;,&quot;(Ljava/lang/String;)V&quot;);</div><div class=\"line\">  if (method == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;not find method&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jstring  jstr = env-&gt;NewStringUTF(str);</div><div class=\"line\">  env-&gt;CallStaticVoidMethod(clazz,method,jstr);</div><div class=\"line\">  env-&gt;DeleteLocalRef(clazz);</div><div class=\"line\">  env-&gt;DeleteLocalRef(jstr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-如何找到类\"><a href=\"#3-1-如何找到类\" class=\"headerlink\" title=\"3.1 如何找到类\"></a>3.1 如何找到类</h4><p>很简单，我们可以通过FindClass方法去查找类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div></pre></td></tr></table></figure>\n<h4 id=\"3-2-如何获取方法、或者字段\"><a href=\"#3-2-如何获取方法、或者字段\" class=\"headerlink\" title=\"3.2  如何获取方法、或者字段\"></a>3.2  如何获取方法、或者字段</h4><p>大致为以下四种方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;GetxxxField()</div><div class=\"line\">env-&gt;GetStaticxxxField()</div><div class=\"line\">env-&gt;GetMethodID()</div><div class=\"line\">env-&gt;GetxxxMethodID()</div></pre></td></tr></table></figure>\n<p>上面没有列出参数，但是仍然很明白，这里就不多说了。</p>\n<h4 id=\"3-3-如何调用方法\"><a href=\"#3-3-如何调用方法\" class=\"headerlink\" title=\"3.3 如何调用方法\"></a>3.3 如何调用方法</h4><p>这里呢。大致分为以下四种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;CallXXXMethod();</div><div class=\"line\">env-&gt;CallxxxMethodA();</div><div class=\"line\">env-&gt;CallxxxMethodV();</div><div class=\"line\">env-&gt;CallNonvirtualBooleanMethod()</div></pre></td></tr></table></figure>\n<p>同样，我这里没给出方法的参数，同学们自己看jni.h吧</p>\n<ul>\n<li>调用方法（这里的方法可能使静态的、也可能是非静态的）</li>\n<li>和上面的区别就在于对应的java层参数，在这里以数组的形式传进入</li>\n<li>和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。</li>\n<li>调用构造函数初始化一个对象，这个，马上说道。</li>\n</ul>\n<h4 id=\"3-4-如何修改字段的值\"><a href=\"#3-4-如何修改字段的值\" class=\"headerlink\" title=\"3.4 如何修改字段的值\"></a>3.4 如何修改字段的值</h4><p>相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。</p>\n<h4 id=\"3-5-如何构造一个对象出来\"><a href=\"#3-5-如何构造一个对象出来\" class=\"headerlink\" title=\"3.5 如何构造一个对象出来\"></a>3.5 如何构造一个对象出来</h4><p>有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。</p>\n<ul>\n<li>NewObject方法 </li>\n<li>CallNonvirtualxxMethod</li>\n</ul>\n<p>先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是&lt; init &gt;（md语法的原因，注意尖括号之间没有空格），别问为什么。</p>\n<p>在来说说第二种，第二中使用时这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jobject  jo = env-&gt;AllocObject(clazz);</div><div class=\"line\">env-&gt;CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )</div></pre></td></tr></table></figure>\n<ul>\n<li>第一行代码 创建未初始化的对象，并分配内存</li>\n<li>第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n</li>\n</ul>\n<h3 id=\"2-数据类型映射\"><a href=\"#2-数据类型映射\" class=\"headerlink\" title=\"2. 数据类型映射\"></a>2. 数据类型映射</h3><p>首先是我们的基本数据类型，其关系如下表描述这样。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225511135\" alt=\"这里写图片描述\"></p>\n<p>上面关系的相关代码在jni.h的44－51行，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char   jboolean;       /* unsigned 8 bits */</div><div class=\"line\">typedef signed char     jbyte;          /* signed 8 bits */</div><div class=\"line\">typedef unsigned short  jchar;          /* unsigned 16 bits */</div><div class=\"line\">typedef short           jshort;         /* signed 16 bits */</div><div class=\"line\">typedef int             jint;           /* signed 32 bits */</div><div class=\"line\">typedef long long       jlong;          /* signed 64 bits */</div><div class=\"line\">typedef float           jfloat;         /* 32-bit IEEE 754 */</div><div class=\"line\">typedef double          jdouble;        /* 64-bit IEEE 754 */</div></pre></td></tr></table></figure>\n<p>而jni层的引用类型则是下面这个样子。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225901230\" alt=\"这里写图片描述\"></p>\n<p>对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class _jobject &#123;&#125;;</div><div class=\"line\">class _jclass : public _jobject &#123;&#125;;</div><div class=\"line\">class _jstring : public _jobject &#123;&#125;;</div><div class=\"line\">class _jarray : public _jobject &#123;&#125;;</div><div class=\"line\">class _jobjectArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbooleanArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbyteArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jcharArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jshortArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jintArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jlongArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jfloatArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jdoubleArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jthrowable : public _jobject &#123;&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-native-如何调用c\"><a href=\"#3-native-如何调用c\" class=\"headerlink\" title=\"3. native 如何调用c\"></a>3. native 如何调用c</h3><p>我们这里的调用包括许多方面，如：</p>\n<ul>\n<li>调用静态方法</li>\n<li>调用实例方法</li>\n<li>获取字段值</li>\n<li>修改字段值</li>\n<li>构造对象</li>\n<li>等等</li>\n</ul>\n<p>而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：</p>\n<ul>\n<li>根据全限定名在jvm中找到想要的类</li>\n<li>从jclass中获取到method、或者field</li>\n<li>执行获取值、修改值、调用方法或者其他的操作</li>\n<li>释放局部引用</li>\n</ul>\n<p>举个调用静态方法的例子看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void callJavaStatic(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;call from c++&quot;;</div><div class=\"line\"></div><div class=\"line\">  jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div><div class=\"line\">  if (clazz == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;class is null&quot;);</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jmethodID method = env-&gt;GetStaticMethodID(clazz,&quot;javaStaticMethod&quot;,&quot;(Ljava/lang/String;)V&quot;);</div><div class=\"line\">  if (method == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;not find method&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jstring  jstr = env-&gt;NewStringUTF(str);</div><div class=\"line\">  env-&gt;CallStaticVoidMethod(clazz,method,jstr);</div><div class=\"line\">  env-&gt;DeleteLocalRef(clazz);</div><div class=\"line\">  env-&gt;DeleteLocalRef(jstr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-如何找到类\"><a href=\"#3-1-如何找到类\" class=\"headerlink\" title=\"3.1 如何找到类\"></a>3.1 如何找到类</h4><p>很简单，我们可以通过FindClass方法去查找类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div></pre></td></tr></table></figure>\n<h4 id=\"3-2-如何获取方法、或者字段\"><a href=\"#3-2-如何获取方法、或者字段\" class=\"headerlink\" title=\"3.2  如何获取方法、或者字段\"></a>3.2  如何获取方法、或者字段</h4><p>大致为以下四种方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;GetxxxField()</div><div class=\"line\">env-&gt;GetStaticxxxField()</div><div class=\"line\">env-&gt;GetMethodID()</div><div class=\"line\">env-&gt;GetxxxMethodID()</div></pre></td></tr></table></figure>\n<p>上面没有列出参数，但是仍然很明白，这里就不多说了。</p>\n<h4 id=\"3-3-如何调用方法\"><a href=\"#3-3-如何调用方法\" class=\"headerlink\" title=\"3.3 如何调用方法\"></a>3.3 如何调用方法</h4><p>这里呢。大致分为以下四种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;CallXXXMethod();</div><div class=\"line\">env-&gt;CallxxxMethodA();</div><div class=\"line\">env-&gt;CallxxxMethodV();</div><div class=\"line\">env-&gt;CallNonvirtualBooleanMethod()</div></pre></td></tr></table></figure>\n<p>同样，我这里没给出方法的参数，同学们自己看jni.h吧</p>\n<ul>\n<li>调用方法（这里的方法可能使静态的、也可能是非静态的）</li>\n<li>和上面的区别就在于对应的java层参数，在这里以数组的形式传进入</li>\n<li>和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。</li>\n<li>调用构造函数初始化一个对象，这个，马上说道。</li>\n</ul>\n<h4 id=\"3-4-如何修改字段的值\"><a href=\"#3-4-如何修改字段的值\" class=\"headerlink\" title=\"3.4 如何修改字段的值\"></a>3.4 如何修改字段的值</h4><p>相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。</p>\n<h4 id=\"3-5-如何构造一个对象出来\"><a href=\"#3-5-如何构造一个对象出来\" class=\"headerlink\" title=\"3.5 如何构造一个对象出来\"></a>3.5 如何构造一个对象出来</h4><p>有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。</p>\n<ul>\n<li>NewObject方法 </li>\n<li>CallNonvirtualxxMethod</li>\n</ul>\n<p>先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是&lt; init &gt;（md语法的原因，注意尖括号之间没有空格），别问为什么。</p>\n<p>在来说说第二种，第二中使用时这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jobject  jo = env-&gt;AllocObject(clazz);</div><div class=\"line\">env-&gt;CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )</div></pre></td></tr></table></figure>\n<ul>\n<li>第一行代码 创建未初始化的对象，并分配内存</li>\n<li>第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Activity启动流程","date":"2016-12-25T07:20:05.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。\n\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n### 2.从startActivity说起\n\n不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：\n\n```java\nInstrumentation.ActivityResult ar =\n    mInstrumentation.execStartActivity(\n        this, mMainThread.getApplicationThread(), mToken, this,\n        intent, requestCode, options);\nif (ar != null) {\n    mMainThread.sendActivityResult(\n        mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n        r.getResultData());\n}\n```\n\n* 通过Instrumentation去启动activiy，\n\n### 3.Instrumentation#execStartActivity\n\nInstrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。\n\n```java\n            int result = ActivityManagerNative.getDefault()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n                        token, target != null ? target.mEmbeddedID : null,\n                        requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n```\n\n* 通过AMS启动activity\n* 检查结果\n\nActivityManagerNative.getDefault()如下：\n\n```java\n    static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n```\n\n其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。\n\n### 4.ActivityManagerService#startActivity\n\n而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。\n\n```java\n    @Override\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n        enforceNotIsolatedCaller(\"startActivity\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                false, ALLOW_FULL_ONLY, \"startActivity\", null);\n        // TODO: Switch to user app stacks here.\n        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n                profilerInfo, null, null, options, false, userId, null, null);\n    }\n```\n\n这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。\n\n### 5.ActivityStackSupervisor#startActivityMayWait\n\n这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：\n\n```java\n            int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n                    voiceSession, voiceInteractor, resultTo, resultWho,\n                    requestCode, callingPid, callingUid, callingPackage,\n                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,\n                    componentSpecified, null, container, inTask);\n```\n\n而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：\n\n```java\n        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n                startFlags, true, options, inTask);\n```\n\nstartActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:\n\n```java\n        targetStack.mLastPausedActivity = null;\n        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n```\n\n* 其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as\n\n### 6.ActivityStack#startActivityLocked\n\n而这个方法的最下面有如下代码。\n\n```java\n        if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n```\n\n这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as\n\n```java\n result = targetStack.resumeTopActivityLocked(target, targetOptions);\n```\n\n绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked->resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用\n\n```java\nmStackSupervisor.startSpecificActivityLocked(next, true, false); \n```\n回到as，好吧，好绕。\n\n而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。\n\n```java\nrealStartActivityLocked(r, app, andResume, checkConfig);\n```\n\n在这个方法中做了什么呢？\n\n```java\n            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                    new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n```\n\n通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。\n\n\n### 7.ApplicationThread#scheduleLaunchActivity\n\n在这个方法中，发送一个消息，然后ActivityThread的H类去处理。\n\n```java\nsendMessage(H.LAUNCH_ACTIVITY, r);\n```\n\n接收到这个消息之后，调用handleLaunchActivity方法去处理。\n\n```java\nActivity a = performLaunchActivity(r, customIntent);\n```\n\n\n在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。\n\n```java\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n                    ...\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n```\n\n### 8.Instrumentation\n\n在这里，先是通过类加载器去构造类对象，\n\n```java\n(Activity)cl.loadClass(className).newInstance()\n```\n\n然后通过callActivityOnCreate方法，\n\n```java\n    public void callActivityOnCreate(Activity activity, Bundle icicle) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle);\n        postPerformCreate(activity);\n    }\n```\n调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。\n\n### 9.给张图吧。\n\n流程图不一定画的对。😢\n\n![](/images/framework/activity/Activity启动流程图.png)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/Activity启动流程.md","raw":"---\ntitle: Activity启动流程\ndate: 2016-12-25 15:20:05\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。\n\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n### 2.从startActivity说起\n\n不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：\n\n```java\nInstrumentation.ActivityResult ar =\n    mInstrumentation.execStartActivity(\n        this, mMainThread.getApplicationThread(), mToken, this,\n        intent, requestCode, options);\nif (ar != null) {\n    mMainThread.sendActivityResult(\n        mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n        r.getResultData());\n}\n```\n\n* 通过Instrumentation去启动activiy，\n\n### 3.Instrumentation#execStartActivity\n\nInstrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。\n\n```java\n            int result = ActivityManagerNative.getDefault()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n                        token, target != null ? target.mEmbeddedID : null,\n                        requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n```\n\n* 通过AMS启动activity\n* 检查结果\n\nActivityManagerNative.getDefault()如下：\n\n```java\n    static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n```\n\n其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。\n\n### 4.ActivityManagerService#startActivity\n\n而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。\n\n```java\n    @Override\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n        enforceNotIsolatedCaller(\"startActivity\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                false, ALLOW_FULL_ONLY, \"startActivity\", null);\n        // TODO: Switch to user app stacks here.\n        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n                profilerInfo, null, null, options, false, userId, null, null);\n    }\n```\n\n这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。\n\n### 5.ActivityStackSupervisor#startActivityMayWait\n\n这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：\n\n```java\n            int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n                    voiceSession, voiceInteractor, resultTo, resultWho,\n                    requestCode, callingPid, callingUid, callingPackage,\n                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,\n                    componentSpecified, null, container, inTask);\n```\n\n而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：\n\n```java\n        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n                startFlags, true, options, inTask);\n```\n\nstartActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:\n\n```java\n        targetStack.mLastPausedActivity = null;\n        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n```\n\n* 其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as\n\n### 6.ActivityStack#startActivityLocked\n\n而这个方法的最下面有如下代码。\n\n```java\n        if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n```\n\n这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as\n\n```java\n result = targetStack.resumeTopActivityLocked(target, targetOptions);\n```\n\n绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked->resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用\n\n```java\nmStackSupervisor.startSpecificActivityLocked(next, true, false); \n```\n回到as，好吧，好绕。\n\n而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。\n\n```java\nrealStartActivityLocked(r, app, andResume, checkConfig);\n```\n\n在这个方法中做了什么呢？\n\n```java\n            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                    new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n```\n\n通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。\n\n\n### 7.ApplicationThread#scheduleLaunchActivity\n\n在这个方法中，发送一个消息，然后ActivityThread的H类去处理。\n\n```java\nsendMessage(H.LAUNCH_ACTIVITY, r);\n```\n\n接收到这个消息之后，调用handleLaunchActivity方法去处理。\n\n```java\nActivity a = performLaunchActivity(r, customIntent);\n```\n\n\n在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。\n\n```java\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n                    ...\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n```\n\n### 8.Instrumentation\n\n在这里，先是通过类加载器去构造类对象，\n\n```java\n(Activity)cl.loadClass(className).newInstance()\n```\n\n然后通过callActivityOnCreate方法，\n\n```java\n    public void callActivityOnCreate(Activity activity, Bundle icicle) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle);\n        postPerformCreate(activity);\n    }\n```\n调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。\n\n### 9.给张图吧。\n\n流程图不一定画的对。😢\n\n![](/images/framework/activity/Activity启动流程图.png)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"Activity启动流程","published":1,"updated":"2017-01-06T05:29:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85xn0005uaxa1ftr06ng","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n</the></li>\n</ul>\n<h3 id=\"2-从startActivity说起\"><a href=\"#2-从startActivity说起\" class=\"headerlink\" title=\"2.从startActivity说起\"></a>2.从startActivity说起</h3><p>不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Instrumentation.ActivityResult ar =</div><div class=\"line\">    mInstrumentation.execStartActivity(</div><div class=\"line\">        <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</div><div class=\"line\">        intent, requestCode, options);</div><div class=\"line\"><span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    mMainThread.sendActivityResult(</div><div class=\"line\">        mToken, mEmbeddedID, requestCode, ar.getResultCode(),</div><div class=\"line\">        r.getResultData());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Instrumentation去启动activiy，</li>\n</ul>\n<h3 id=\"3-Instrumentation-execStartActivity\"><a href=\"#3-Instrumentation-execStartActivity\" class=\"headerlink\" title=\"3.Instrumentation#execStartActivity\"></a>3.Instrumentation#execStartActivity</h3><p>Instrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</div><div class=\"line\">    .startActivity(whoThread, who.getBasePackageName(), intent,</div><div class=\"line\">            intent.resolveTypeIfNeeded(who.getContentResolver()),</div><div class=\"line\">            token, target != <span class=\"keyword\">null</span> ? target.mEmbeddedID : <span class=\"keyword\">null</span>,</div><div class=\"line\">            requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</div><div class=\"line\">checkStartActivityResult(result, intent);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过AMS启动activity</li>\n<li>检查结果</li>\n</ul>\n<p>ActivityManagerNative.getDefault()如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。</p>\n<h3 id=\"4-ActivityManagerService-startActivity\"><a href=\"#4-ActivityManagerService-startActivity\" class=\"headerlink\" title=\"4.ActivityManagerService#startActivity\"></a>4.ActivityManagerService#startActivity</h3><p>而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></div><div class=\"line\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</div><div class=\"line\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class=\"keyword\">int</span> userId) &#123;</div><div class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</div><div class=\"line\">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</div><div class=\"line\">            <span class=\"keyword\">false</span>, ALLOW_FULL_ONLY, <span class=\"string\">\"startActivity\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class=\"number\">1</span>, callingPackage, intent,</div><div class=\"line\">            resolvedType, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, resultTo, resultWho, requestCode, startFlags,</div><div class=\"line\">            profilerInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, options, <span class=\"keyword\">false</span>, userId, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。</p>\n<h3 id=\"5-ActivityStackSupervisor-startActivityMayWait\"><a href=\"#5-ActivityStackSupervisor-startActivityMayWait\" class=\"headerlink\" title=\"5.ActivityStackSupervisor#startActivityMayWait\"></a>5.ActivityStackSupervisor#startActivityMayWait</h3><p>这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> res = startActivityLocked(caller, intent, resolvedType, aInfo,</div><div class=\"line\">        voiceSession, voiceInteractor, resultTo, resultWho,</div><div class=\"line\">        requestCode, callingPid, callingUid, callingPackage,</div><div class=\"line\">        realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</div><div class=\"line\">        componentSpecified, <span class=\"keyword\">null</span>, container, inTask);</div></pre></td></tr></table></figure>\n<p>而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</div><div class=\"line\">        startFlags, <span class=\"keyword\">true</span>, options, inTask);</div></pre></td></tr></table></figure>\n<p>startActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">targetStack.mLastPausedActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as</li>\n</ul>\n<h3 id=\"6-ActivityStack-startActivityLocked\"><a href=\"#6-ActivityStack-startActivityLocked\" class=\"headerlink\" title=\"6.ActivityStack#startActivityLocked\"></a>6.ActivityStack#startActivityLocked</h3><p>而这个方法的最下面有如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (doResume) &#123;</div><div class=\"line\">    mStackSupervisor.resumeTopActivitiesLocked(<span class=\"keyword\">this</span>, r, options);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">result = targetStack.resumeTopActivityLocked(target, targetOptions);</div></pre></td></tr></table></figure>\n<p>绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked-&gt;resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>回到as，好吧，好绕。</p>\n<p>而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">realStartActivityLocked(r, app, andResume, checkConfig);</div></pre></td></tr></table></figure>\n<p>在这个方法中做了什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleLaunchActivity(<span class=\"keyword\">new</span> Intent(r.intent), r.appToken,</div><div class=\"line\">        System.identityHashCode(r), r.info, <span class=\"keyword\">new</span> Configuration(mService.mConfiguration),</div><div class=\"line\">        <span class=\"keyword\">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</div><div class=\"line\">        task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</div><div class=\"line\">        newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</div></pre></td></tr></table></figure>\n<p>通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。</p>\n<h3 id=\"7-ApplicationThread-scheduleLaunchActivity\"><a href=\"#7-ApplicationThread-scheduleLaunchActivity\" class=\"headerlink\" title=\"7.ApplicationThread#scheduleLaunchActivity\"></a>7.ApplicationThread#scheduleLaunchActivity</h3><p>在这个方法中，发送一个消息，然后ActivityThread的H类去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendMessage(H.LAUNCH_ACTIVITY, r);</div></pre></td></tr></table></figure>\n<p>接收到这个消息之后，调用handleLaunchActivity方法去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Activity a = performLaunchActivity(r, customIntent);</div></pre></td></tr></table></figure>\n<p>在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">activity = mInstrumentation.newActivity(</div><div class=\"line\">        cl, component.getClassName(), r.intent);</div><div class=\"line\">        ...</div><div class=\"line\">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div></pre></td></tr></table></figure>\n<h3 id=\"8-Instrumentation\"><a href=\"#8-Instrumentation\" class=\"headerlink\" title=\"8.Instrumentation\"></a>8.Instrumentation</h3><p>在这里，先是通过类加载器去构造类对象，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Activity)cl.loadClass(className).newInstance()</div></pre></td></tr></table></figure>\n<p>然后通过callActivityOnCreate方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle)</span> </span>&#123;</div><div class=\"line\">    prePerformCreate(activity);</div><div class=\"line\">    activity.performCreate(icicle);</div><div class=\"line\">    postPerformCreate(activity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。</p>\n<h3 id=\"9-给张图吧。\"><a href=\"#9-给张图吧。\" class=\"headerlink\" title=\"9.给张图吧。\"></a>9.给张图吧。</h3><p>流程图不一定画的对。😢</p>\n<p><img src=\"/images/framework/activity/Activity启动流程图.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n</li>\n</ul>\n<h3 id=\"2-从startActivity说起\"><a href=\"#2-从startActivity说起\" class=\"headerlink\" title=\"2.从startActivity说起\"></a>2.从startActivity说起</h3><p>不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Instrumentation.ActivityResult ar =</div><div class=\"line\">    mInstrumentation.execStartActivity(</div><div class=\"line\">        <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</div><div class=\"line\">        intent, requestCode, options);</div><div class=\"line\"><span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    mMainThread.sendActivityResult(</div><div class=\"line\">        mToken, mEmbeddedID, requestCode, ar.getResultCode(),</div><div class=\"line\">        r.getResultData());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Instrumentation去启动activiy，</li>\n</ul>\n<h3 id=\"3-Instrumentation-execStartActivity\"><a href=\"#3-Instrumentation-execStartActivity\" class=\"headerlink\" title=\"3.Instrumentation#execStartActivity\"></a>3.Instrumentation#execStartActivity</h3><p>Instrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</div><div class=\"line\">    .startActivity(whoThread, who.getBasePackageName(), intent,</div><div class=\"line\">            intent.resolveTypeIfNeeded(who.getContentResolver()),</div><div class=\"line\">            token, target != <span class=\"keyword\">null</span> ? target.mEmbeddedID : <span class=\"keyword\">null</span>,</div><div class=\"line\">            requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</div><div class=\"line\">checkStartActivityResult(result, intent);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过AMS启动activity</li>\n<li>检查结果</li>\n</ul>\n<p>ActivityManagerNative.getDefault()如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。</p>\n<h3 id=\"4-ActivityManagerService-startActivity\"><a href=\"#4-ActivityManagerService-startActivity\" class=\"headerlink\" title=\"4.ActivityManagerService#startActivity\"></a>4.ActivityManagerService#startActivity</h3><p>而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</div><div class=\"line\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</div><div class=\"line\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class=\"keyword\">int</span> userId)</span> </span>&#123;</div><div class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</div><div class=\"line\">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</div><div class=\"line\">            <span class=\"keyword\">false</span>, ALLOW_FULL_ONLY, <span class=\"string\">\"startActivity\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class=\"number\">1</span>, callingPackage, intent,</div><div class=\"line\">            resolvedType, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, resultTo, resultWho, requestCode, startFlags,</div><div class=\"line\">            profilerInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, options, <span class=\"keyword\">false</span>, userId, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。</p>\n<h3 id=\"5-ActivityStackSupervisor-startActivityMayWait\"><a href=\"#5-ActivityStackSupervisor-startActivityMayWait\" class=\"headerlink\" title=\"5.ActivityStackSupervisor#startActivityMayWait\"></a>5.ActivityStackSupervisor#startActivityMayWait</h3><p>这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> res = startActivityLocked(caller, intent, resolvedType, aInfo,</div><div class=\"line\">        voiceSession, voiceInteractor, resultTo, resultWho,</div><div class=\"line\">        requestCode, callingPid, callingUid, callingPackage,</div><div class=\"line\">        realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</div><div class=\"line\">        componentSpecified, <span class=\"keyword\">null</span>, container, inTask);</div></pre></td></tr></table></figure>\n<p>而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</div><div class=\"line\">        startFlags, <span class=\"keyword\">true</span>, options, inTask);</div></pre></td></tr></table></figure>\n<p>startActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">targetStack.mLastPausedActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as</li>\n</ul>\n<h3 id=\"6-ActivityStack-startActivityLocked\"><a href=\"#6-ActivityStack-startActivityLocked\" class=\"headerlink\" title=\"6.ActivityStack#startActivityLocked\"></a>6.ActivityStack#startActivityLocked</h3><p>而这个方法的最下面有如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (doResume) &#123;</div><div class=\"line\">    mStackSupervisor.resumeTopActivitiesLocked(<span class=\"keyword\">this</span>, r, options);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">result = targetStack.resumeTopActivityLocked(target, targetOptions);</div></pre></td></tr></table></figure>\n<p>绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked-&gt;resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>回到as，好吧，好绕。</p>\n<p>而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">realStartActivityLocked(r, app, andResume, checkConfig);</div></pre></td></tr></table></figure>\n<p>在这个方法中做了什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleLaunchActivity(<span class=\"keyword\">new</span> Intent(r.intent), r.appToken,</div><div class=\"line\">        System.identityHashCode(r), r.info, <span class=\"keyword\">new</span> Configuration(mService.mConfiguration),</div><div class=\"line\">        <span class=\"keyword\">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</div><div class=\"line\">        task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</div><div class=\"line\">        newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</div></pre></td></tr></table></figure>\n<p>通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。</p>\n<h3 id=\"7-ApplicationThread-scheduleLaunchActivity\"><a href=\"#7-ApplicationThread-scheduleLaunchActivity\" class=\"headerlink\" title=\"7.ApplicationThread#scheduleLaunchActivity\"></a>7.ApplicationThread#scheduleLaunchActivity</h3><p>在这个方法中，发送一个消息，然后ActivityThread的H类去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendMessage(H.LAUNCH_ACTIVITY, r);</div></pre></td></tr></table></figure>\n<p>接收到这个消息之后，调用handleLaunchActivity方法去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Activity a = performLaunchActivity(r, customIntent);</div></pre></td></tr></table></figure>\n<p>在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">activity = mInstrumentation.newActivity(</div><div class=\"line\">        cl, component.getClassName(), r.intent);</div><div class=\"line\">        ...</div><div class=\"line\">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div></pre></td></tr></table></figure>\n<h3 id=\"8-Instrumentation\"><a href=\"#8-Instrumentation\" class=\"headerlink\" title=\"8.Instrumentation\"></a>8.Instrumentation</h3><p>在这里，先是通过类加载器去构造类对象，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Activity)cl.loadClass(className).newInstance()</div></pre></td></tr></table></figure>\n<p>然后通过callActivityOnCreate方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle)</span> </span>&#123;</div><div class=\"line\">    prePerformCreate(activity);</div><div class=\"line\">    activity.performCreate(icicle);</div><div class=\"line\">    postPerformCreate(activity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。</p>\n<h3 id=\"9-给张图吧。\"><a href=\"#9-给张图吧。\" class=\"headerlink\" title=\"9.给张图吧。\"></a>9.给张图吧。</h3><p>流程图不一定画的对。😢</p>\n<p><img src=\"/images/framework/activity/Activity启动流程图.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android消息机制浅析","date":"2016-12-21T15:32:56.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.Looper、Handler、MessageQueue的关系\n* Looper 用于线程的消息循环,一个线程只能有一个Looper对象\n* Handler\n * 执行任务调度和发生一些操作（在未来某时刻）\n * 执行其他线程中的队列消息\n* MessageQueue 消息队列\n\n>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.Looper\n以主线程为例。Looper的初始化过程是这样的。\n代码地址： \n/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)\n```\nLooper.prepareMainLooper();\nxxxx\nLooper.loop();\n```\n而非UI线程的初始化过程\n```\nLooper.prepare()\nxxx\nLooper.loop();\n```\n不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。\n```\n\tprivate static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n接下来看Looper的构造方法\n```\n\tprivate Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。\n那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法\n```\nfinal Looper me = myLooper();\n```\n```\n\tpublic static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n```\n取出和当前线程对应的Looper对象\n```\n\tfor (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            msg.recycleUnchecked();\n        }\n    }\n```\n上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。\n\n### 3.Handler\n既然知道了Looper，那么我们需要知道消息是怎么来的。\n```\nMessage msg = new Message();\nmsg.what = xxx;\nmsg.obj = xxx;\nhandler.sendMessage(msg);\n```\n我们通常都是通过上面的步骤去发送的，所以，追踪下代码。\n\nsendMessage->sendMessageDelayed->sendMessageAtTime->enqueueMessage\n到这里就来到了一个关键点了，我们看下代码。\n```\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n   msg.target = this;\n   if (mAsynchronous) {\n        msg.setAsynchronous(true);\n   }\n   return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。\n```\nHandler target\n```\n好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。\n```\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n调用关系和初始化的关系有关。\n\n  *  Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法\n  * 初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法\n  * 否则，调用handlerMessage(msg)方法。\n\n回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。\n### 4.MessageQueue\n消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：\n```\n    boolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n上面的步骤是这样子的。\n\n* 判断是否关联了handler\n* 判断是否用过(已经插入到链表中的)\n* 当前队列是否处在退出状态\n * 退出状态  回收资源，插入链表失败\n * 不是退出状态\n \t * 改变Message的状态为已经use，并获取message的when时间\n \t * 在链表中找到合适的位置插入\n \t \t* 和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点\n \t \t* 死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾\n\n在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。\n```\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\n```\n * 假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message\n * 如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis\n * 不小于的话\n \t* 假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息\n \t* 否则，将mMessages(表头)指向msg.next(也是移除了该消息) \n\n * 下面的代码忽略(ps:我看不懂...)\n\n### 5.总结\n当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。\nAndroid中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n","source":"_posts/Android消息机制浅析.md","raw":"---\ntitle: Android消息机制浅析\ndate: 2016-12-21 23:32:56\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.Looper、Handler、MessageQueue的关系\n* Looper 用于线程的消息循环,一个线程只能有一个Looper对象\n* Handler\n * 执行任务调度和发生一些操作（在未来某时刻）\n * 执行其他线程中的队列消息\n* MessageQueue 消息队列\n\n>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.Looper\n以主线程为例。Looper的初始化过程是这样的。\n代码地址： \n/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)\n```\nLooper.prepareMainLooper();\nxxxx\nLooper.loop();\n```\n而非UI线程的初始化过程\n```\nLooper.prepare()\nxxx\nLooper.loop();\n```\n不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。\n```\n\tprivate static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n接下来看Looper的构造方法\n```\n\tprivate Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。\n那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法\n```\nfinal Looper me = myLooper();\n```\n```\n\tpublic static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n```\n取出和当前线程对应的Looper对象\n```\n\tfor (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            msg.recycleUnchecked();\n        }\n    }\n```\n上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。\n\n### 3.Handler\n既然知道了Looper，那么我们需要知道消息是怎么来的。\n```\nMessage msg = new Message();\nmsg.what = xxx;\nmsg.obj = xxx;\nhandler.sendMessage(msg);\n```\n我们通常都是通过上面的步骤去发送的，所以，追踪下代码。\n\nsendMessage->sendMessageDelayed->sendMessageAtTime->enqueueMessage\n到这里就来到了一个关键点了，我们看下代码。\n```\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n   msg.target = this;\n   if (mAsynchronous) {\n        msg.setAsynchronous(true);\n   }\n   return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。\n```\nHandler target\n```\n好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。\n```\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n调用关系和初始化的关系有关。\n\n  *  Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法\n  * 初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法\n  * 否则，调用handlerMessage(msg)方法。\n\n回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。\n### 4.MessageQueue\n消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：\n```\n    boolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n上面的步骤是这样子的。\n\n* 判断是否关联了handler\n* 判断是否用过(已经插入到链表中的)\n* 当前队列是否处在退出状态\n * 退出状态  回收资源，插入链表失败\n * 不是退出状态\n \t * 改变Message的状态为已经use，并获取message的when时间\n \t * 在链表中找到合适的位置插入\n \t \t* 和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点\n \t \t* 死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾\n\n在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。\n```\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\n```\n * 假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message\n * 如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis\n * 不小于的话\n \t* 假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息\n \t* 否则，将mMessages(表头)指向msg.next(也是移除了该消息) \n\n * 下面的代码忽略(ps:我看不懂...)\n\n### 5.总结\n当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。\nAndroid中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n","slug":"Android消息机制浅析","published":1,"updated":"2017-01-06T05:30:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85xo0006uaxab7cvtd30","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-Looper、Handler、MessageQueue的关系\"><a href=\"#1-Looper、Handler、MessageQueue的关系\" class=\"headerlink\" title=\"1.Looper、Handler、MessageQueue的关系\"></a>1.Looper、Handler、MessageQueue的关系</h3><ul>\n<li>Looper 用于线程的消息循环,一个线程只能有一个Looper对象</li>\n<li>Handler<ul>\n<li>执行任务调度和发生一些操作（在未来某时刻）</li>\n<li>执行其他线程中的队列消息</li>\n</ul>\n</li>\n<li>MessageQueue 消息队列</li>\n</ul>\n<blockquote>\n<p>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。</p>\n</blockquote>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<h3 id=\"2-Looper\"><a href=\"#2-Looper\" class=\"headerlink\" title=\"2.Looper\"></a>2.Looper</h3><p>以主线程为例。Looper的初始化过程是这样的。<br>代码地址：<br>/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepareMainLooper();</div><div class=\"line\">xxxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>而非UI线程的初始化过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepare()</div><div class=\"line\">xxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void prepare(boolean quitAllowed) &#123;</div><div class=\"line\">       if (sThreadLocal.get() != null) &#123;</div><div class=\"line\">           throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       sThreadLocal.set(new Looper(quitAllowed));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>接下来看Looper的构造方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Looper(boolean quitAllowed) &#123;</div><div class=\"line\">       mQueue = new MessageQueue(quitAllowed);</div><div class=\"line\">       mThread = Thread.currentThread();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。<br>那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Looper me = myLooper();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static @Nullable Looper myLooper() &#123;</div><div class=\"line\">       return sThreadLocal.get();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>取出和当前线程对应的Looper对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">           Message msg = queue.next(); // might block</div><div class=\"line\">           if (msg == null) &#123;</div><div class=\"line\">               // No message indicates that the message queue is quitting.</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">           if (logging != null) &#123;</div><div class=\"line\">               logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Make sure that during the course of dispatching the</div><div class=\"line\">           // identity of the thread wasn&apos;t corrupted.</div><div class=\"line\">           final long newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">           msg.recycleUnchecked();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。</p>\n<h3 id=\"3-Handler\"><a href=\"#3-Handler\" class=\"headerlink\" title=\"3.Handler\"></a>3.Handler</h3><p>既然知道了Looper，那么我们需要知道消息是怎么来的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Message msg = new Message();</div><div class=\"line\">msg.what = xxx;</div><div class=\"line\">msg.obj = xxx;</div><div class=\"line\">handler.sendMessage(msg);</div></pre></td></tr></table></figure></p>\n<p>我们通常都是通过上面的步骤去发送的，所以，追踪下代码。</p>\n<p>sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage<br>到这里就来到了一个关键点了，我们看下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class=\"line\">   msg.target = this;</div><div class=\"line\">   if (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(true);</div><div class=\"line\">   &#125;</div><div class=\"line\">   return queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Handler target</div></pre></td></tr></table></figure></p>\n<p>好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void dispatchMessage(Message msg) &#123;</div><div class=\"line\">    if (msg.callback != null) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (mCallback != null) &#123;</div><div class=\"line\">            if (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用关系和初始化的关系有关。</p>\n<ul>\n<li>Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法</li>\n<li>初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法</li>\n<li>否则，调用handlerMessage(msg)方法。</li>\n</ul>\n<p>回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。</p>\n<h3 id=\"4-MessageQueue\"><a href=\"#4-MessageQueue\" class=\"headerlink\" title=\"4.MessageQueue\"></a>4.MessageQueue</h3><p>消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean enqueueMessage(Message msg, long when) &#123;</div><div class=\"line\">    if (msg.target == null) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg.isInUse()) &#123;</div><div class=\"line\">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        if (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = new IllegalStateException(</div><div class=\"line\">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class=\"line\">            Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        boolean needWake;</div><div class=\"line\">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class=\"line\">            // New head, wake up the event queue if blocked.</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class=\"line\">            // up the event queue unless there is a barrier at the head of the queue</div><div class=\"line\">            // and the message is the earliest asynchronous message in the queue.</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">            for (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">                if (p == null || when &lt; p.when) &#123;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = p; // invariant: p == prev.next</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We can assume mPtr != 0 because mQuitting is false.</div><div class=\"line\">        if (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的步骤是这样子的。</p>\n<ul>\n<li>判断是否关联了handler</li>\n<li>判断是否用过(已经插入到链表中的)</li>\n<li>当前队列是否处在退出状态<ul>\n<li>退出状态  回收资源，插入链表失败</li>\n<li>不是退出状态<ul>\n<li>改变Message的状态为已经use，并获取message的when时间</li>\n<li>在链表中找到合适的位置插入<ul>\n<li>和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点</li>\n<li>死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">Message prevMsg = null;</div><div class=\"line\">Message msg = mMessages;</div><div class=\"line\">if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class=\"line\">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class=\"line\">    do &#123;</div><div class=\"line\">        prevMsg = msg;</div><div class=\"line\">        msg = msg.next;</div><div class=\"line\">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg != null) &#123;</div><div class=\"line\">    if (now &lt; msg.when) &#123;</div><div class=\"line\">        // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class=\"line\">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Got a message.</div><div class=\"line\">        mBlocked = false;</div><div class=\"line\">        if (prevMsg != null) &#123;</div><div class=\"line\">            prevMsg.next = msg.next;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mMessages = msg.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg.next = null;</div><div class=\"line\">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        return msg;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // No more messages.</div><div class=\"line\">    nextPollTimeoutMillis = -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message</li>\n<li>如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis</li>\n<li><p>不小于的话</p>\n<ul>\n<li>假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息</li>\n<li>否则，将mMessages(表头)指向msg.next(也是移除了该消息) </li>\n</ul>\n</li>\n<li><p>下面的代码忽略(ps:我看不懂…)</p>\n</li>\n</ul>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><p>当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。<br>Android中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-Looper、Handler、MessageQueue的关系\"><a href=\"#1-Looper、Handler、MessageQueue的关系\" class=\"headerlink\" title=\"1.Looper、Handler、MessageQueue的关系\"></a>1.Looper、Handler、MessageQueue的关系</h3><ul>\n<li>Looper 用于线程的消息循环,一个线程只能有一个Looper对象</li>\n<li>Handler<ul>\n<li>执行任务调度和发生一些操作（在未来某时刻）</li>\n<li>执行其他线程中的队列消息</li>\n</ul>\n</li>\n<li>MessageQueue 消息队列</li>\n</ul>\n<blockquote>\n<p>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。</p>\n</blockquote>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<h3 id=\"2-Looper\"><a href=\"#2-Looper\" class=\"headerlink\" title=\"2.Looper\"></a>2.Looper</h3><p>以主线程为例。Looper的初始化过程是这样的。<br>代码地址：<br>/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepareMainLooper();</div><div class=\"line\">xxxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>而非UI线程的初始化过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepare()</div><div class=\"line\">xxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void prepare(boolean quitAllowed) &#123;</div><div class=\"line\">       if (sThreadLocal.get() != null) &#123;</div><div class=\"line\">           throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       sThreadLocal.set(new Looper(quitAllowed));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>接下来看Looper的构造方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Looper(boolean quitAllowed) &#123;</div><div class=\"line\">       mQueue = new MessageQueue(quitAllowed);</div><div class=\"line\">       mThread = Thread.currentThread();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。<br>那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Looper me = myLooper();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static @Nullable Looper myLooper() &#123;</div><div class=\"line\">       return sThreadLocal.get();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>取出和当前线程对应的Looper对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">           Message msg = queue.next(); // might block</div><div class=\"line\">           if (msg == null) &#123;</div><div class=\"line\">               // No message indicates that the message queue is quitting.</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">           if (logging != null) &#123;</div><div class=\"line\">               logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Make sure that during the course of dispatching the</div><div class=\"line\">           // identity of the thread wasn&apos;t corrupted.</div><div class=\"line\">           final long newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">           msg.recycleUnchecked();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。</p>\n<h3 id=\"3-Handler\"><a href=\"#3-Handler\" class=\"headerlink\" title=\"3.Handler\"></a>3.Handler</h3><p>既然知道了Looper，那么我们需要知道消息是怎么来的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Message msg = new Message();</div><div class=\"line\">msg.what = xxx;</div><div class=\"line\">msg.obj = xxx;</div><div class=\"line\">handler.sendMessage(msg);</div></pre></td></tr></table></figure></p>\n<p>我们通常都是通过上面的步骤去发送的，所以，追踪下代码。</p>\n<p>sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage<br>到这里就来到了一个关键点了，我们看下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class=\"line\">   msg.target = this;</div><div class=\"line\">   if (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(true);</div><div class=\"line\">   &#125;</div><div class=\"line\">   return queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Handler target</div></pre></td></tr></table></figure></p>\n<p>好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void dispatchMessage(Message msg) &#123;</div><div class=\"line\">    if (msg.callback != null) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (mCallback != null) &#123;</div><div class=\"line\">            if (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用关系和初始化的关系有关。</p>\n<ul>\n<li>Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法</li>\n<li>初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法</li>\n<li>否则，调用handlerMessage(msg)方法。</li>\n</ul>\n<p>回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。</p>\n<h3 id=\"4-MessageQueue\"><a href=\"#4-MessageQueue\" class=\"headerlink\" title=\"4.MessageQueue\"></a>4.MessageQueue</h3><p>消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean enqueueMessage(Message msg, long when) &#123;</div><div class=\"line\">    if (msg.target == null) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg.isInUse()) &#123;</div><div class=\"line\">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        if (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = new IllegalStateException(</div><div class=\"line\">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class=\"line\">            Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        boolean needWake;</div><div class=\"line\">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class=\"line\">            // New head, wake up the event queue if blocked.</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class=\"line\">            // up the event queue unless there is a barrier at the head of the queue</div><div class=\"line\">            // and the message is the earliest asynchronous message in the queue.</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">            for (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">                if (p == null || when &lt; p.when) &#123;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = p; // invariant: p == prev.next</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We can assume mPtr != 0 because mQuitting is false.</div><div class=\"line\">        if (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的步骤是这样子的。</p>\n<ul>\n<li>判断是否关联了handler</li>\n<li>判断是否用过(已经插入到链表中的)</li>\n<li>当前队列是否处在退出状态<ul>\n<li>退出状态  回收资源，插入链表失败</li>\n<li>不是退出状态<ul>\n<li>改变Message的状态为已经use，并获取message的when时间</li>\n<li>在链表中找到合适的位置插入<ul>\n<li>和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点</li>\n<li>死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">Message prevMsg = null;</div><div class=\"line\">Message msg = mMessages;</div><div class=\"line\">if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class=\"line\">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class=\"line\">    do &#123;</div><div class=\"line\">        prevMsg = msg;</div><div class=\"line\">        msg = msg.next;</div><div class=\"line\">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg != null) &#123;</div><div class=\"line\">    if (now &lt; msg.when) &#123;</div><div class=\"line\">        // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class=\"line\">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Got a message.</div><div class=\"line\">        mBlocked = false;</div><div class=\"line\">        if (prevMsg != null) &#123;</div><div class=\"line\">            prevMsg.next = msg.next;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mMessages = msg.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg.next = null;</div><div class=\"line\">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        return msg;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // No more messages.</div><div class=\"line\">    nextPollTimeoutMillis = -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message</li>\n<li>如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis</li>\n<li><p>不小于的话</p>\n<ul>\n<li>假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息</li>\n<li>否则，将mMessages(表头)指向msg.next(也是移除了该消息) </li>\n</ul>\n</li>\n<li><p>下面的代码忽略(ps:我看不懂…)</p>\n</li>\n</ul>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><p>当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。<br>Android中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android应用程序是如何安装的","date":"2017-01-04T12:24:27.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，\n\n### 2.安装器\n\n显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。\n\n```\n        if (v == mOk) {\n            if (mOkCanInstall || mScrollView == null) {\n                mInstallFlowAnalytics.setInstallButtonClicked();\n                if (mSessionId != -1) {\n                    mInstaller.setPermissionsResult(mSessionId, true);\n\n                    // We're only confirming permissions, so we don't really know how the\n                    // story ends; assume success.\n                    mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(\n                            PackageManager.INSTALL_SUCCEEDED);\n                    finish();\n                } else {\n                    startInstall();\n                }\n            } else {\n                mScrollView.pageScroll(View.FOCUS_DOWN);\n            }\n        }\n```\n\n虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。\n\n```\n        if (\"package\".equals(mPackageURI.getScheme())) {\n            try {\n                pm.installExistingPackage(mAppInfo.packageName);\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_SUCCEEDED);\n            } catch (PackageManager.NameNotFoundException e) {\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_FAILED_INVALID_APK);\n            }\n        } else {\n            pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,\n                    installerPackageName, verificationParams, null);\n        }\n```\n\n* mPackageURI，安装应用的话，应该是file\n* pm 为ApplicationPackageManager\n\n因此，我们看installPackageWithVerificationAndEncryption方法。\n\n### 3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\n\n\n在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。\n\n```\n    public static IPackageManager getPackageManager() {\n        if (sPackageManager != null) {\n            //Slog.v(\"PackageManager\", \"returning cur default = \" + sPackageManager);\n            return sPackageManager;\n        }\n        IBinder b = ServiceManager.getService(\"package\");\n        //Slog.v(\"PackageManager\", \"default service binder = \" + b);\n        sPackageManager = IPackageManager.Stub.asInterface(b);\n        //Slog.v(\"PackageManager\", \"default service = \" + sPackageManager);\n        return sPackageManager;\n    }\n```\n\n从中可以看出，其binder服务端为PackageManagerService.\n\n### 4.PackageManagerService#installPackage\n\n在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy\n\n```\n        final Message msg = mHandler.obtainMessage(INIT_COPY);\n        msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,\n                null, verificationParams, user, packageAbiOverride, null);\n        mHandler.sendMessage(msg);\n```\n\n这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？\n\n```\n                case INIT_COPY: {\n                    HandlerParams params = (HandlerParams) msg.obj;\n                    int idx = mPendingInstalls.size();\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy idx=\" + idx + \": \" + params);\n                    // If a bind was already initiated we dont really\n                    // need to do anything. The pending install\n                    // will be processed later on.\n                    if (!mBound) {\n                        // If this is the only one pending we might\n                        // have to bind to the service again.\n                        if (!connectToService()) {\n                            Slog.e(TAG, \"Failed to bind to media container service\");\n                            params.serviceError();\n                            return;\n                        } else {\n                            // Once we bind to the service, the first\n                            // pending request will be processed.\n                            mPendingInstalls.add(idx, params);\n                        }\n                    } else {\n                        mPendingInstalls.add(idx, params);\n                        // Already bound to the service. Just make\n                        // sure we trigger off processing the first request.\n                        if (idx == 0) {\n                            mHandler.sendEmptyMessage(MCS_BOUND);\n                        }\n                    }\n                    break;\n                }\n```\n\n如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。\n在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，\n\n```\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_bound\");\n                    if (msg.obj != null) {\n                        mContainerService = (IMediaContainerService) msg.obj;\n                    }\n                    if (mContainerService == null) {\n                        if (!mBound) {\n                            // Something seriously wrong since we are not bound and we are not\n                            // waiting for connection. Bail out.\n                            Slog.e(TAG, \"Cannot bind to media container service\");\n                            for (HandlerParams params : mPendingInstalls) {\n                                // Indicate service bind error\n                                params.serviceError();\n                            }\n                            mPendingInstalls.clear();\n                        } else {\n                            Slog.w(TAG, \"Waiting to connect to media container service\");\n                        }\n                    } else if (mPendingInstalls.size() > 0) {\n                        HandlerParams params = mPendingInstalls.get(0);\n                        if (params != null) {\n                            if (params.startCopy()) {\n                                // We are done...  look for more work or to\n                                // go idle.\n                                if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                        \"Checking for more work or unbind...\");\n                                // Delete pending install\n                                if (mPendingInstalls.size() > 0) {\n                                    mPendingInstalls.remove(0);\n                                }\n                                if (mPendingInstalls.size() == 0) {\n                                    if (mBound) {\n                                        if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                                \"Posting delayed MCS_UNBIND\");\n                                        removeMessages(MCS_UNBIND);\n                                        Message ubmsg = obtainMessage(MCS_UNBIND);\n                                        // Unbind after a little delay, to avoid\n                                        // continual thrashing.\n                                        sendMessageDelayed(ubmsg, 10000);\n                                    }\n                                } else {\n                                    // There are more pending requests in queue.\n                                    // Just post MCS_BOUND message to trigger processing\n                                    // of next pending install.\n                                    if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                            \"Posting MCS_BOUND for next work\");\n                                    mHandler.sendEmptyMessage(MCS_BOUND);\n                                }\n                            }\n                        }\n                    } else {\n                        // Should never happen ideally.\n                        Slog.w(TAG, \"Empty queue\");\n                    }\n                    break;\n```\n\n从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。\n\n### 5.HandlerParams#startCopy\n\n```\n        final boolean startCopy() {\n            boolean res;\n            try {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"startCopy \" + mUser + \": \" + this);\n\n                if (++mRetries > MAX_RETRIES) {\n                    Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\");\n                    mHandler.sendEmptyMessage(MCS_GIVE_UP);\n                    handleServiceError();\n                    return false;\n                } else {\n                    handleStartCopy();\n                    res = true;\n                }\n            } catch (RemoteException e) {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\");\n                mHandler.sendEmptyMessage(MCS_RECONNECT);\n                res = false;\n            }\n            handleReturnCode();\n            return res;\n        }\n```\n\n这里有重试机制。而handleStartCopy的实现在InstallParams中。\n\n### 6.InstallParams#handleStartCopy\n\n这个方法比较长，分段来看。\n\n```\n                    final StorageManager storage = StorageManager.from(mContext);\n                    final long lowThreshold = storage.getStorageLowBytes(\n                            Environment.getDataDirectory());\n\n                    final long sizeBytes = mContainerService.calculateInstalledSize(\n                            origin.resolvedPath, isForwardLocked(), packageAbiOverride);\n\n                    if (mInstaller.freeCache(null, sizeBytes + lowThreshold) >= 0) {\n                        pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,\n                                installFlags, packageAbiOverride);\n                    }\n```\n\n首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。\n\n这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。\n\n中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。\n\n```\nif (ret == PackageManager.INSTALL_SUCCEEDED) {\n                 /*\n                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by\n                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.\n                 */\n                int userIdentifier = getUser().getIdentifier();\n                if (userIdentifier == UserHandle.USER_ALL\n                        && ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0)) {\n                    userIdentifier = UserHandle.USER_OWNER;\n                }\n\n                /*\n                 * Determine if we have any installed package verifiers. If we\n                 * do, then we'll defer to them to verify the packages.\n                 */\n                final int requiredUid = mRequiredVerifierPackage == null ? -1\n                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);\n                if (!origin.existing && requiredUid != -1\n                        && isVerificationEnabled(userIdentifier, installFlags)) {\n                    final Intent verification = new Intent(\n                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);\n                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),\n                            PACKAGE_MIME_TYPE);\n                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n                    final List<ResolveInfo> receivers = queryIntentReceivers(verification,\n                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,\n                            0 /* TODO: Which userId? */);\n\n                    if (DEBUG_VERIFY) {\n                        Slog.d(TAG, \"Found \" + receivers.size() + \" verifiers for intent \"\n                                + verification.toString() + \" with \" + pkgLite.verifiers.length\n                                + \" optional verifiers\");\n                    }\n\n                    final int verificationId = mPendingVerificationToken++;\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,\n                            installerPackageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,\n                            installFlags);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,\n                            pkgLite.packageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,\n                            pkgLite.versionCode);\n\n                    if (verificationParams != null) {\n                        if (verificationParams.getVerificationURI() != null) {\n                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,\n                                 verificationParams.getVerificationURI());\n                        }\n                        if (verificationParams.getOriginatingURI() != null) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,\n                                  verificationParams.getOriginatingURI());\n                        }\n                        if (verificationParams.getReferrer() != null) {\n                            verification.putExtra(Intent.EXTRA_REFERRER,\n                                  verificationParams.getReferrer());\n                        }\n                        if (verificationParams.getOriginatingUid() >= 0) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,\n                                  verificationParams.getOriginatingUid());\n                        }\n                        if (verificationParams.getInstallerUid() >= 0) {\n                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,\n                                  verificationParams.getInstallerUid());\n                        }\n                    }\n\n                    final PackageVerificationState verificationState = new PackageVerificationState(\n                            requiredUid, args);\n\n                    mPendingVerification.append(verificationId, verificationState);\n\n                    final List<ComponentName> sufficientVerifiers = matchVerifiers(pkgLite,\n                            receivers, verificationState);\n\n                    // Apps installed for \"all\" users use the device owner to verify the app\n                    UserHandle verifierUser = getUser();\n                    if (verifierUser == UserHandle.ALL) {\n                        verifierUser = UserHandle.OWNER;\n                    }\n\n                    /*\n                     * If any sufficient verifiers were listed in the package\n                     * manifest, attempt to ask them.\n                     */\n                    if (sufficientVerifiers != null) {\n                        final int N = sufficientVerifiers.size();\n                        if (N == 0) {\n                            Slog.i(TAG, \"Additional verifiers required, but none installed.\");\n                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;\n                        } else {\n                            for (int i = 0; i < N; i++) {\n                                final ComponentName verifierComponent = sufficientVerifiers.get(i);\n\n                                final Intent sufficientIntent = new Intent(verification);\n                                sufficientIntent.setComponent(verifierComponent);\n                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);\n                            }\n                        }\n                    }\n\n                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(\n                            mRequiredVerifierPackage, receivers);\n                    if (ret == PackageManager.INSTALL_SUCCEEDED\n                            && mRequiredVerifierPackage != null) {\n                        /*\n                         * Send the intent to the required verification agent,\n                         * but only start the verification timeout after the\n                         * target BroadcastReceivers have run.\n                         */\n                        verification.setComponent(requiredVerifierComponent);\n                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,\n                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,\n                                new BroadcastReceiver() {\n                                    @Override\n                                    public void onReceive(Context context, Intent intent) {\n                                        final Message msg = mHandler\n                                                .obtainMessage(CHECK_PENDING_VERIFICATION);\n                                        msg.arg1 = verificationId;\n                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());\n                                    }\n                                }, null, 0, null, null);\n\n                        /*\n                         * We don't want the copy to proceed until verification\n                         * succeeds, so null out this field.\n                         */\n                        mArgs = null;\n                    }\n                } else {\n                    /*\n                     * No package verification is enabled, so immediately start\n                     * the remote call to initiate copy using temporary file.\n                     */\n                    ret = args.copyApk(mContainerService, true);\n                }\n            }\n\n```\n\n* 如果启动了包验证的话，就会进入验证阶段。 \n\t* 发送有序广播， \n* 否则，直接进行复制操作\n\n验证部分的逻辑很长，大部分代码都是对intent进行设置。\n\n### 7.InstallArgs#copyApk\n\n在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。\n\n```\n    private InstallArgs createInstallArgs(InstallParams params) {\n        if (params.move != null) {\n            return new MoveInstallArgs(params);\n        } else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {\n            return new AsecInstallArgs(params);\n        } else {\n            return new FileInstallArgs(params);\n        }\n    }\n```\n\n以FileInstallArgs为例，我们来看看。\n\n```\n\n       int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {\n            if (origin.staged) {\n                if (DEBUG_INSTALL) Slog.d(TAG, origin.file + \" already staged; skipping copy\");\n                codeFile = origin.file;\n                resourceFile = origin.file;\n                return PackageManager.INSTALL_SUCCEEDED;\n            }\n\n            try {\n                final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);\n                codeFile = tempDir;\n                resourceFile = tempDir;\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to create copy file: \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n\n            final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {\n                @Override\n                public ParcelFileDescriptor open(String name, int mode) throws RemoteException {\n                    if (!FileUtils.isValidExtFilename(name)) {\n                        throw new IllegalArgumentException(\"Invalid filename: \" + name);\n                    }\n                    try {\n                        final File file = new File(codeFile, name);\n                        final FileDescriptor fd = Os.open(file.getAbsolutePath(),\n                                O_RDWR | O_CREAT, 0644);\n                        Os.chmod(file.getAbsolutePath(), 0644);\n                        return new ParcelFileDescriptor(fd);\n                    } catch (ErrnoException e) {\n                        throw new RemoteException(\"Failed to open: \" + e.getMessage());\n                    }\n                }\n            };\n\n            int ret = PackageManager.INSTALL_SUCCEEDED;\n            ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);\n            if (ret != PackageManager.INSTALL_SUCCEEDED) {\n                Slog.e(TAG, \"Failed to copy package\");\n                return ret;\n            }\n\n            final File libraryRoot = new File(codeFile, LIB_DIR_NAME);\n            NativeLibraryHelper.Handle handle = null;\n            try {\n                handle = NativeLibraryHelper.Handle.create(codeFile);\n                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,\n                        abiOverride);\n            } catch (IOException e) {\n                Slog.e(TAG, \"Copying native libraries failed\", e);\n                ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;\n            } finally {\n                IoUtils.closeQuietly(handle);\n            }\n\n            return ret;\n        }\n\n```\n\n* 首先mInstallerService.allocateStageDirLegacy申请足够的存储空间\n* 得到申请的那部分空间的文件描述符，并且修改权限\n* IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，\n* NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)\n\n### 8.DefaultContainerService#copyPackage\n\n```\n        public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) {\n            if (packagePath == null || target == null) {\n                return PackageManager.INSTALL_FAILED_INVALID_URI;\n            }\n\n            PackageLite pkg = null;\n            try {\n                final File packageFile = new File(packagePath);\n                pkg = PackageParser.parsePackageLite(packageFile, 0);\n                return copyPackageInner(pkg, target);\n            } catch (PackageParserException | IOException | RemoteException e) {\n                Slog.w(TAG, \"Failed to copy package at \" + packagePath + \": \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n        }\n```\n\n* 解析apk文件\n* 将文件拷贝到指定目录\n\n### 9.NativeLibraryHelper#copyNativeBinariesWithOverride\n\n在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。\n\n到现在，copy的流程就完了。\n\n在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。\n\n### 10.InstallParams#handleReturnCode\n\n在这个方法中，会调用processPendingInstall去处理。\n\n```\n    private void processPendingInstall(final InstallArgs args, final int currentStatus) {\n        // Queue up an async operation since the package installation may take a little while.\n        mHandler.post(new Runnable() {\n            public void run() {\n                mHandler.removeCallbacks(this);\n                 // Result object to be returned\n                PackageInstalledInfo res = new PackageInstalledInfo();\n                res.returnCode = currentStatus;\n                res.uid = -1;\n                res.pkg = null;\n                res.removedInfo = new PackageRemovedInfo();\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {\n                    args.doPreInstall(res.returnCode);\n                    synchronized (mInstallLock) {\n                        installPackageLI(args, res);\n                    }\n                    args.doPostInstall(res.returnCode, res.uid);\n                }\n\n                // A restore should be performed at this point if (a) the install\n                // succeeded, (b) the operation is not an update, and (c) the new\n                // package has not opted out of backup participation.\n                final boolean update = res.removedInfo.removedPackage != null;\n                final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;\n                boolean doRestore = !update\n                        && ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);\n\n                // Set up the post-install work request bookkeeping.  This will be used\n                // and cleaned up by the post-install event handling regardless of whether\n                // there's a restore pass performed.  Token values are >= 1.\n                int token;\n                if (mNextInstallToken < 0) mNextInstallToken = 1;\n                token = mNextInstallToken++;\n\n                PostInstallData data = new PostInstallData(args, res);\n                mRunningInstalls.put(token, data);\n                if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token);\n\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {\n                    // Pass responsibility to the Backup Manager.  It will perform a\n                    // restore if appropriate, then pass responsibility back to the\n                    // Package Manager to run the post-install observer callbacks\n                    // and broadcasts.\n                    IBackupManager bm = IBackupManager.Stub.asInterface(\n                            ServiceManager.getService(Context.BACKUP_SERVICE));\n                    if (bm != null) {\n                        if (DEBUG_INSTALL) Log.v(TAG, \"token \" + token\n                                + \" to BM for possible restore\");\n                        try {\n                            if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) {\n                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);\n                            } else {\n                                doRestore = false;\n                            }\n                        } catch (RemoteException e) {\n                            // can't happen; the backup manager is local\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"Exception trying to enqueue restore\", e);\n                            doRestore = false;\n                        }\n                    } else {\n                        Slog.e(TAG, \"Backup Manager not found!\");\n                        doRestore = false;\n                    }\n                }\n\n                if (!doRestore) {\n                    // No restore possible, or the Backup Manager was mysteriously not\n                    // available -- just fire the post-install work request directly.\n                    if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token);\n                    Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);\n                    mHandler.sendMessage(msg);\n                }\n            }\n        });\n    }\n```\n\n安装过程\n\n* installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。\n* 恢复部分代码 没看明白。😭\n* 发送POST_INSTALL消息\n\n### 11.installPackageLI\n\n改方法氛围几部分。\n\n首先是解析包过程。\n\n```\n        PackageParser pp = new PackageParser();\n        pp.setSeparateProcesses(mSeparateProcesses);\n        pp.setDisplayMetrics(mMetrics);\n\n        final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(tmpPackageFile, parseFlags);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed parse during installPackageLI\", e);\n            return;\n        }\n```\n\n其次是校验签名的md5的过程\n\n```\n        try {\n            pp.collectCertificates(pkg, parseFlags);\n            pp.collectManifestDigest(pkg);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed collect during installPackageLI\", e);\n            return;\n        }\n\n        /* If the installer passed in a manifest digest, compare it now. */\n        if (args.manifestDigest != null) {\n            if (DEBUG_INSTALL) {\n                final String parsedManifest = pkg.manifestDigest == null ? \"null\"\n                        : pkg.manifestDigest.toString();\n                Slog.d(TAG, \"Comparing manifests: \" + args.manifestDigest.toString() + \" vs. \"\n                        + parsedManifest);\n            }\n\n            if (!args.manifestDigest.equals(pkg.manifestDigest)) {\n                res.setError(INSTALL_FAILED_PACKAGE_CHANGED, \"Manifest digest changed\");\n                return;\n            }\n        } else if (DEBUG_INSTALL) {\n            final String parsedManifest = pkg.manifestDigest == null\n                    ? \"null\" : pkg.manifestDigest.toString();\n            Slog.d(TAG, \"manifestDigest was not present, but parser got: \" + parsedManifest);\n        }\n```\n\n\n调用installNewPackageLI安装。\n\n### 12.installNewPackageLI\n\n在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。\n\n\n### 13.处理POST_INSTALL消息\n\n略。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n","source":"_posts/Android应用程序是如何安装的.md","raw":"---\ntitle: Android应用程序是如何安装的\ndate: 2017-01-04 20:24:27\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，\n\n### 2.安装器\n\n显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。\n\n```\n        if (v == mOk) {\n            if (mOkCanInstall || mScrollView == null) {\n                mInstallFlowAnalytics.setInstallButtonClicked();\n                if (mSessionId != -1) {\n                    mInstaller.setPermissionsResult(mSessionId, true);\n\n                    // We're only confirming permissions, so we don't really know how the\n                    // story ends; assume success.\n                    mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(\n                            PackageManager.INSTALL_SUCCEEDED);\n                    finish();\n                } else {\n                    startInstall();\n                }\n            } else {\n                mScrollView.pageScroll(View.FOCUS_DOWN);\n            }\n        }\n```\n\n虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。\n\n```\n        if (\"package\".equals(mPackageURI.getScheme())) {\n            try {\n                pm.installExistingPackage(mAppInfo.packageName);\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_SUCCEEDED);\n            } catch (PackageManager.NameNotFoundException e) {\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_FAILED_INVALID_APK);\n            }\n        } else {\n            pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,\n                    installerPackageName, verificationParams, null);\n        }\n```\n\n* mPackageURI，安装应用的话，应该是file\n* pm 为ApplicationPackageManager\n\n因此，我们看installPackageWithVerificationAndEncryption方法。\n\n### 3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\n\n\n在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。\n\n```\n    public static IPackageManager getPackageManager() {\n        if (sPackageManager != null) {\n            //Slog.v(\"PackageManager\", \"returning cur default = \" + sPackageManager);\n            return sPackageManager;\n        }\n        IBinder b = ServiceManager.getService(\"package\");\n        //Slog.v(\"PackageManager\", \"default service binder = \" + b);\n        sPackageManager = IPackageManager.Stub.asInterface(b);\n        //Slog.v(\"PackageManager\", \"default service = \" + sPackageManager);\n        return sPackageManager;\n    }\n```\n\n从中可以看出，其binder服务端为PackageManagerService.\n\n### 4.PackageManagerService#installPackage\n\n在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy\n\n```\n        final Message msg = mHandler.obtainMessage(INIT_COPY);\n        msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,\n                null, verificationParams, user, packageAbiOverride, null);\n        mHandler.sendMessage(msg);\n```\n\n这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？\n\n```\n                case INIT_COPY: {\n                    HandlerParams params = (HandlerParams) msg.obj;\n                    int idx = mPendingInstalls.size();\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy idx=\" + idx + \": \" + params);\n                    // If a bind was already initiated we dont really\n                    // need to do anything. The pending install\n                    // will be processed later on.\n                    if (!mBound) {\n                        // If this is the only one pending we might\n                        // have to bind to the service again.\n                        if (!connectToService()) {\n                            Slog.e(TAG, \"Failed to bind to media container service\");\n                            params.serviceError();\n                            return;\n                        } else {\n                            // Once we bind to the service, the first\n                            // pending request will be processed.\n                            mPendingInstalls.add(idx, params);\n                        }\n                    } else {\n                        mPendingInstalls.add(idx, params);\n                        // Already bound to the service. Just make\n                        // sure we trigger off processing the first request.\n                        if (idx == 0) {\n                            mHandler.sendEmptyMessage(MCS_BOUND);\n                        }\n                    }\n                    break;\n                }\n```\n\n如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。\n在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，\n\n```\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_bound\");\n                    if (msg.obj != null) {\n                        mContainerService = (IMediaContainerService) msg.obj;\n                    }\n                    if (mContainerService == null) {\n                        if (!mBound) {\n                            // Something seriously wrong since we are not bound and we are not\n                            // waiting for connection. Bail out.\n                            Slog.e(TAG, \"Cannot bind to media container service\");\n                            for (HandlerParams params : mPendingInstalls) {\n                                // Indicate service bind error\n                                params.serviceError();\n                            }\n                            mPendingInstalls.clear();\n                        } else {\n                            Slog.w(TAG, \"Waiting to connect to media container service\");\n                        }\n                    } else if (mPendingInstalls.size() > 0) {\n                        HandlerParams params = mPendingInstalls.get(0);\n                        if (params != null) {\n                            if (params.startCopy()) {\n                                // We are done...  look for more work or to\n                                // go idle.\n                                if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                        \"Checking for more work or unbind...\");\n                                // Delete pending install\n                                if (mPendingInstalls.size() > 0) {\n                                    mPendingInstalls.remove(0);\n                                }\n                                if (mPendingInstalls.size() == 0) {\n                                    if (mBound) {\n                                        if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                                \"Posting delayed MCS_UNBIND\");\n                                        removeMessages(MCS_UNBIND);\n                                        Message ubmsg = obtainMessage(MCS_UNBIND);\n                                        // Unbind after a little delay, to avoid\n                                        // continual thrashing.\n                                        sendMessageDelayed(ubmsg, 10000);\n                                    }\n                                } else {\n                                    // There are more pending requests in queue.\n                                    // Just post MCS_BOUND message to trigger processing\n                                    // of next pending install.\n                                    if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                            \"Posting MCS_BOUND for next work\");\n                                    mHandler.sendEmptyMessage(MCS_BOUND);\n                                }\n                            }\n                        }\n                    } else {\n                        // Should never happen ideally.\n                        Slog.w(TAG, \"Empty queue\");\n                    }\n                    break;\n```\n\n从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。\n\n### 5.HandlerParams#startCopy\n\n```\n        final boolean startCopy() {\n            boolean res;\n            try {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"startCopy \" + mUser + \": \" + this);\n\n                if (++mRetries > MAX_RETRIES) {\n                    Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\");\n                    mHandler.sendEmptyMessage(MCS_GIVE_UP);\n                    handleServiceError();\n                    return false;\n                } else {\n                    handleStartCopy();\n                    res = true;\n                }\n            } catch (RemoteException e) {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\");\n                mHandler.sendEmptyMessage(MCS_RECONNECT);\n                res = false;\n            }\n            handleReturnCode();\n            return res;\n        }\n```\n\n这里有重试机制。而handleStartCopy的实现在InstallParams中。\n\n### 6.InstallParams#handleStartCopy\n\n这个方法比较长，分段来看。\n\n```\n                    final StorageManager storage = StorageManager.from(mContext);\n                    final long lowThreshold = storage.getStorageLowBytes(\n                            Environment.getDataDirectory());\n\n                    final long sizeBytes = mContainerService.calculateInstalledSize(\n                            origin.resolvedPath, isForwardLocked(), packageAbiOverride);\n\n                    if (mInstaller.freeCache(null, sizeBytes + lowThreshold) >= 0) {\n                        pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,\n                                installFlags, packageAbiOverride);\n                    }\n```\n\n首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。\n\n这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。\n\n中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。\n\n```\nif (ret == PackageManager.INSTALL_SUCCEEDED) {\n                 /*\n                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by\n                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.\n                 */\n                int userIdentifier = getUser().getIdentifier();\n                if (userIdentifier == UserHandle.USER_ALL\n                        && ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0)) {\n                    userIdentifier = UserHandle.USER_OWNER;\n                }\n\n                /*\n                 * Determine if we have any installed package verifiers. If we\n                 * do, then we'll defer to them to verify the packages.\n                 */\n                final int requiredUid = mRequiredVerifierPackage == null ? -1\n                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);\n                if (!origin.existing && requiredUid != -1\n                        && isVerificationEnabled(userIdentifier, installFlags)) {\n                    final Intent verification = new Intent(\n                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);\n                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),\n                            PACKAGE_MIME_TYPE);\n                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n                    final List<ResolveInfo> receivers = queryIntentReceivers(verification,\n                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,\n                            0 /* TODO: Which userId? */);\n\n                    if (DEBUG_VERIFY) {\n                        Slog.d(TAG, \"Found \" + receivers.size() + \" verifiers for intent \"\n                                + verification.toString() + \" with \" + pkgLite.verifiers.length\n                                + \" optional verifiers\");\n                    }\n\n                    final int verificationId = mPendingVerificationToken++;\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,\n                            installerPackageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,\n                            installFlags);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,\n                            pkgLite.packageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,\n                            pkgLite.versionCode);\n\n                    if (verificationParams != null) {\n                        if (verificationParams.getVerificationURI() != null) {\n                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,\n                                 verificationParams.getVerificationURI());\n                        }\n                        if (verificationParams.getOriginatingURI() != null) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,\n                                  verificationParams.getOriginatingURI());\n                        }\n                        if (verificationParams.getReferrer() != null) {\n                            verification.putExtra(Intent.EXTRA_REFERRER,\n                                  verificationParams.getReferrer());\n                        }\n                        if (verificationParams.getOriginatingUid() >= 0) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,\n                                  verificationParams.getOriginatingUid());\n                        }\n                        if (verificationParams.getInstallerUid() >= 0) {\n                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,\n                                  verificationParams.getInstallerUid());\n                        }\n                    }\n\n                    final PackageVerificationState verificationState = new PackageVerificationState(\n                            requiredUid, args);\n\n                    mPendingVerification.append(verificationId, verificationState);\n\n                    final List<ComponentName> sufficientVerifiers = matchVerifiers(pkgLite,\n                            receivers, verificationState);\n\n                    // Apps installed for \"all\" users use the device owner to verify the app\n                    UserHandle verifierUser = getUser();\n                    if (verifierUser == UserHandle.ALL) {\n                        verifierUser = UserHandle.OWNER;\n                    }\n\n                    /*\n                     * If any sufficient verifiers were listed in the package\n                     * manifest, attempt to ask them.\n                     */\n                    if (sufficientVerifiers != null) {\n                        final int N = sufficientVerifiers.size();\n                        if (N == 0) {\n                            Slog.i(TAG, \"Additional verifiers required, but none installed.\");\n                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;\n                        } else {\n                            for (int i = 0; i < N; i++) {\n                                final ComponentName verifierComponent = sufficientVerifiers.get(i);\n\n                                final Intent sufficientIntent = new Intent(verification);\n                                sufficientIntent.setComponent(verifierComponent);\n                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);\n                            }\n                        }\n                    }\n\n                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(\n                            mRequiredVerifierPackage, receivers);\n                    if (ret == PackageManager.INSTALL_SUCCEEDED\n                            && mRequiredVerifierPackage != null) {\n                        /*\n                         * Send the intent to the required verification agent,\n                         * but only start the verification timeout after the\n                         * target BroadcastReceivers have run.\n                         */\n                        verification.setComponent(requiredVerifierComponent);\n                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,\n                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,\n                                new BroadcastReceiver() {\n                                    @Override\n                                    public void onReceive(Context context, Intent intent) {\n                                        final Message msg = mHandler\n                                                .obtainMessage(CHECK_PENDING_VERIFICATION);\n                                        msg.arg1 = verificationId;\n                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());\n                                    }\n                                }, null, 0, null, null);\n\n                        /*\n                         * We don't want the copy to proceed until verification\n                         * succeeds, so null out this field.\n                         */\n                        mArgs = null;\n                    }\n                } else {\n                    /*\n                     * No package verification is enabled, so immediately start\n                     * the remote call to initiate copy using temporary file.\n                     */\n                    ret = args.copyApk(mContainerService, true);\n                }\n            }\n\n```\n\n* 如果启动了包验证的话，就会进入验证阶段。 \n\t* 发送有序广播， \n* 否则，直接进行复制操作\n\n验证部分的逻辑很长，大部分代码都是对intent进行设置。\n\n### 7.InstallArgs#copyApk\n\n在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。\n\n```\n    private InstallArgs createInstallArgs(InstallParams params) {\n        if (params.move != null) {\n            return new MoveInstallArgs(params);\n        } else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {\n            return new AsecInstallArgs(params);\n        } else {\n            return new FileInstallArgs(params);\n        }\n    }\n```\n\n以FileInstallArgs为例，我们来看看。\n\n```\n\n       int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {\n            if (origin.staged) {\n                if (DEBUG_INSTALL) Slog.d(TAG, origin.file + \" already staged; skipping copy\");\n                codeFile = origin.file;\n                resourceFile = origin.file;\n                return PackageManager.INSTALL_SUCCEEDED;\n            }\n\n            try {\n                final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);\n                codeFile = tempDir;\n                resourceFile = tempDir;\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to create copy file: \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n\n            final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {\n                @Override\n                public ParcelFileDescriptor open(String name, int mode) throws RemoteException {\n                    if (!FileUtils.isValidExtFilename(name)) {\n                        throw new IllegalArgumentException(\"Invalid filename: \" + name);\n                    }\n                    try {\n                        final File file = new File(codeFile, name);\n                        final FileDescriptor fd = Os.open(file.getAbsolutePath(),\n                                O_RDWR | O_CREAT, 0644);\n                        Os.chmod(file.getAbsolutePath(), 0644);\n                        return new ParcelFileDescriptor(fd);\n                    } catch (ErrnoException e) {\n                        throw new RemoteException(\"Failed to open: \" + e.getMessage());\n                    }\n                }\n            };\n\n            int ret = PackageManager.INSTALL_SUCCEEDED;\n            ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);\n            if (ret != PackageManager.INSTALL_SUCCEEDED) {\n                Slog.e(TAG, \"Failed to copy package\");\n                return ret;\n            }\n\n            final File libraryRoot = new File(codeFile, LIB_DIR_NAME);\n            NativeLibraryHelper.Handle handle = null;\n            try {\n                handle = NativeLibraryHelper.Handle.create(codeFile);\n                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,\n                        abiOverride);\n            } catch (IOException e) {\n                Slog.e(TAG, \"Copying native libraries failed\", e);\n                ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;\n            } finally {\n                IoUtils.closeQuietly(handle);\n            }\n\n            return ret;\n        }\n\n```\n\n* 首先mInstallerService.allocateStageDirLegacy申请足够的存储空间\n* 得到申请的那部分空间的文件描述符，并且修改权限\n* IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，\n* NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)\n\n### 8.DefaultContainerService#copyPackage\n\n```\n        public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) {\n            if (packagePath == null || target == null) {\n                return PackageManager.INSTALL_FAILED_INVALID_URI;\n            }\n\n            PackageLite pkg = null;\n            try {\n                final File packageFile = new File(packagePath);\n                pkg = PackageParser.parsePackageLite(packageFile, 0);\n                return copyPackageInner(pkg, target);\n            } catch (PackageParserException | IOException | RemoteException e) {\n                Slog.w(TAG, \"Failed to copy package at \" + packagePath + \": \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n        }\n```\n\n* 解析apk文件\n* 将文件拷贝到指定目录\n\n### 9.NativeLibraryHelper#copyNativeBinariesWithOverride\n\n在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。\n\n到现在，copy的流程就完了。\n\n在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。\n\n### 10.InstallParams#handleReturnCode\n\n在这个方法中，会调用processPendingInstall去处理。\n\n```\n    private void processPendingInstall(final InstallArgs args, final int currentStatus) {\n        // Queue up an async operation since the package installation may take a little while.\n        mHandler.post(new Runnable() {\n            public void run() {\n                mHandler.removeCallbacks(this);\n                 // Result object to be returned\n                PackageInstalledInfo res = new PackageInstalledInfo();\n                res.returnCode = currentStatus;\n                res.uid = -1;\n                res.pkg = null;\n                res.removedInfo = new PackageRemovedInfo();\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {\n                    args.doPreInstall(res.returnCode);\n                    synchronized (mInstallLock) {\n                        installPackageLI(args, res);\n                    }\n                    args.doPostInstall(res.returnCode, res.uid);\n                }\n\n                // A restore should be performed at this point if (a) the install\n                // succeeded, (b) the operation is not an update, and (c) the new\n                // package has not opted out of backup participation.\n                final boolean update = res.removedInfo.removedPackage != null;\n                final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;\n                boolean doRestore = !update\n                        && ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);\n\n                // Set up the post-install work request bookkeeping.  This will be used\n                // and cleaned up by the post-install event handling regardless of whether\n                // there's a restore pass performed.  Token values are >= 1.\n                int token;\n                if (mNextInstallToken < 0) mNextInstallToken = 1;\n                token = mNextInstallToken++;\n\n                PostInstallData data = new PostInstallData(args, res);\n                mRunningInstalls.put(token, data);\n                if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token);\n\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {\n                    // Pass responsibility to the Backup Manager.  It will perform a\n                    // restore if appropriate, then pass responsibility back to the\n                    // Package Manager to run the post-install observer callbacks\n                    // and broadcasts.\n                    IBackupManager bm = IBackupManager.Stub.asInterface(\n                            ServiceManager.getService(Context.BACKUP_SERVICE));\n                    if (bm != null) {\n                        if (DEBUG_INSTALL) Log.v(TAG, \"token \" + token\n                                + \" to BM for possible restore\");\n                        try {\n                            if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) {\n                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);\n                            } else {\n                                doRestore = false;\n                            }\n                        } catch (RemoteException e) {\n                            // can't happen; the backup manager is local\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"Exception trying to enqueue restore\", e);\n                            doRestore = false;\n                        }\n                    } else {\n                        Slog.e(TAG, \"Backup Manager not found!\");\n                        doRestore = false;\n                    }\n                }\n\n                if (!doRestore) {\n                    // No restore possible, or the Backup Manager was mysteriously not\n                    // available -- just fire the post-install work request directly.\n                    if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token);\n                    Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);\n                    mHandler.sendMessage(msg);\n                }\n            }\n        });\n    }\n```\n\n安装过程\n\n* installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。\n* 恢复部分代码 没看明白。😭\n* 发送POST_INSTALL消息\n\n### 11.installPackageLI\n\n改方法氛围几部分。\n\n首先是解析包过程。\n\n```\n        PackageParser pp = new PackageParser();\n        pp.setSeparateProcesses(mSeparateProcesses);\n        pp.setDisplayMetrics(mMetrics);\n\n        final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(tmpPackageFile, parseFlags);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed parse during installPackageLI\", e);\n            return;\n        }\n```\n\n其次是校验签名的md5的过程\n\n```\n        try {\n            pp.collectCertificates(pkg, parseFlags);\n            pp.collectManifestDigest(pkg);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed collect during installPackageLI\", e);\n            return;\n        }\n\n        /* If the installer passed in a manifest digest, compare it now. */\n        if (args.manifestDigest != null) {\n            if (DEBUG_INSTALL) {\n                final String parsedManifest = pkg.manifestDigest == null ? \"null\"\n                        : pkg.manifestDigest.toString();\n                Slog.d(TAG, \"Comparing manifests: \" + args.manifestDigest.toString() + \" vs. \"\n                        + parsedManifest);\n            }\n\n            if (!args.manifestDigest.equals(pkg.manifestDigest)) {\n                res.setError(INSTALL_FAILED_PACKAGE_CHANGED, \"Manifest digest changed\");\n                return;\n            }\n        } else if (DEBUG_INSTALL) {\n            final String parsedManifest = pkg.manifestDigest == null\n                    ? \"null\" : pkg.manifestDigest.toString();\n            Slog.d(TAG, \"manifestDigest was not present, but parser got: \" + parsedManifest);\n        }\n```\n\n\n调用installNewPackageLI安装。\n\n### 12.installNewPackageLI\n\n在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。\n\n\n### 13.处理POST_INSTALL消息\n\n略。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n","slug":"Android应用程序是如何安装的","published":1,"updated":"2017-01-06T05:30:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85xp0007uaxa9ywv9x9h","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<p>以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，</p>\n<h3 id=\"2-安装器\"><a href=\"#2-安装器\" class=\"headerlink\" title=\"2.安装器\"></a>2.安装器</h3><p>显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (v == mOk) &#123;</div><div class=\"line\">    if (mOkCanInstall || mScrollView == null) &#123;</div><div class=\"line\">        mInstallFlowAnalytics.setInstallButtonClicked();</div><div class=\"line\">        if (mSessionId != -1) &#123;</div><div class=\"line\">            mInstaller.setPermissionsResult(mSessionId, true);</div><div class=\"line\"></div><div class=\"line\">            // We&apos;re only confirming permissions, so we don&apos;t really know how the</div><div class=\"line\">            // story ends; assume success.</div><div class=\"line\">            mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(</div><div class=\"line\">                    PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">            finish();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            startInstall();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mScrollView.pageScroll(View.FOCUS_DOWN);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        pm.installExistingPackage(mAppInfo.packageName);</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_FAILED_INVALID_APK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,</div><div class=\"line\">            installerPackageName, verificationParams, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>mPackageURI，安装应用的话，应该是file</li>\n<li>pm 为ApplicationPackageManager</li>\n</ul>\n<p>因此，我们看installPackageWithVerificationAndEncryption方法。</p>\n<h3 id=\"3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\"><a href=\"#3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\" class=\"headerlink\" title=\"3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\"></a>3.ApplicationPackageManager#installPackageWithVerificationAndEncryption</h3><p>在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static IPackageManager getPackageManager() &#123;</div><div class=\"line\">    if (sPackageManager != null) &#123;</div><div class=\"line\">        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</div><div class=\"line\">        return sPackageManager;</div><div class=\"line\">    &#125;</div><div class=\"line\">    IBinder b = ServiceManager.getService(&quot;package&quot;);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</div><div class=\"line\">    sPackageManager = IPackageManager.Stub.asInterface(b);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</div><div class=\"line\">    return sPackageManager;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从中可以看出，其binder服务端为PackageManagerService.</p>\n<h3 id=\"4-PackageManagerService-installPackage\"><a href=\"#4-PackageManagerService-installPackage\" class=\"headerlink\" title=\"4.PackageManagerService#installPackage\"></a>4.PackageManagerService#installPackage</h3><p>在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Message msg = mHandler.obtainMessage(INIT_COPY);</div><div class=\"line\">msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,</div><div class=\"line\">        null, verificationParams, user, packageAbiOverride, null);</div><div class=\"line\">mHandler.sendMessage(msg);</div></pre></td></tr></table></figure>\n<p>这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">case INIT_COPY: &#123;</div><div class=\"line\">    HandlerParams params = (HandlerParams) msg.obj;</div><div class=\"line\">    int idx = mPendingInstalls.size();</div><div class=\"line\">    if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params);</div><div class=\"line\">    // If a bind was already initiated we dont really</div><div class=\"line\">    // need to do anything. The pending install</div><div class=\"line\">    // will be processed later on.</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // If this is the only one pending we might</div><div class=\"line\">        // have to bind to the service again.</div><div class=\"line\">        if (!connectToService()) &#123;</div><div class=\"line\">            Slog.e(TAG, &quot;Failed to bind to media container service&quot;);</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Once we bind to the service, the first</div><div class=\"line\">            // pending request will be processed.</div><div class=\"line\">            mPendingInstalls.add(idx, params);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mPendingInstalls.add(idx, params);</div><div class=\"line\">        // Already bound to the service. Just make</div><div class=\"line\">        // sure we trigger off processing the first request.</div><div class=\"line\">        if (idx == 0) &#123;</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。<br>在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;);</div><div class=\"line\">if (msg.obj != null) &#123;</div><div class=\"line\">    mContainerService = (IMediaContainerService) msg.obj;</div><div class=\"line\">&#125;</div><div class=\"line\">if (mContainerService == null) &#123;</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // Something seriously wrong since we are not bound and we are not</div><div class=\"line\">        // waiting for connection. Bail out.</div><div class=\"line\">        Slog.e(TAG, &quot;Cannot bind to media container service&quot;);</div><div class=\"line\">        for (HandlerParams params : mPendingInstalls) &#123;</div><div class=\"line\">            // Indicate service bind error</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mPendingInstalls.clear();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Waiting to connect to media container service&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">    HandlerParams params = mPendingInstalls.get(0);</div><div class=\"line\">    if (params != null) &#123;</div><div class=\"line\">        if (params.startCopy()) &#123;</div><div class=\"line\">            // We are done...  look for more work or to</div><div class=\"line\">            // go idle.</div><div class=\"line\">            if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                    &quot;Checking for more work or unbind...&quot;);</div><div class=\"line\">            // Delete pending install</div><div class=\"line\">            if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">                mPendingInstalls.remove(0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (mPendingInstalls.size() == 0) &#123;</div><div class=\"line\">                if (mBound) &#123;</div><div class=\"line\">                    if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                            &quot;Posting delayed MCS_UNBIND&quot;);</div><div class=\"line\">                    removeMessages(MCS_UNBIND);</div><div class=\"line\">                    Message ubmsg = obtainMessage(MCS_UNBIND);</div><div class=\"line\">                    // Unbind after a little delay, to avoid</div><div class=\"line\">                    // continual thrashing.</div><div class=\"line\">                    sendMessageDelayed(ubmsg, 10000);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are more pending requests in queue.</div><div class=\"line\">                // Just post MCS_BOUND message to trigger processing</div><div class=\"line\">                // of next pending install.</div><div class=\"line\">                if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                        &quot;Posting MCS_BOUND for next work&quot;);</div><div class=\"line\">                mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // Should never happen ideally.</div><div class=\"line\">    Slog.w(TAG, &quot;Empty queue&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div></pre></td></tr></table></figure>\n<p>从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。</p>\n<h3 id=\"5-HandlerParams-startCopy\"><a href=\"#5-HandlerParams-startCopy\" class=\"headerlink\" title=\"5.HandlerParams#startCopy\"></a>5.HandlerParams#startCopy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean startCopy() &#123;</div><div class=\"line\">    boolean res;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);</div><div class=\"line\"></div><div class=\"line\">        if (++mRetries &gt; MAX_RETRIES) &#123;</div><div class=\"line\">            Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_GIVE_UP);</div><div class=\"line\">            handleServiceError();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            handleStartCopy();</div><div class=\"line\">            res = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);</div><div class=\"line\">        mHandler.sendEmptyMessage(MCS_RECONNECT);</div><div class=\"line\">        res = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    handleReturnCode();</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有重试机制。而handleStartCopy的实现在InstallParams中。</p>\n<h3 id=\"6-InstallParams-handleStartCopy\"><a href=\"#6-InstallParams-handleStartCopy\" class=\"headerlink\" title=\"6.InstallParams#handleStartCopy\"></a>6.InstallParams#handleStartCopy</h3><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">final StorageManager storage = StorageManager.from(mContext);</div><div class=\"line\">final long lowThreshold = storage.getStorageLowBytes(</div><div class=\"line\">        Environment.getDataDirectory());</div><div class=\"line\"></div><div class=\"line\">final long sizeBytes = mContainerService.calculateInstalledSize(</div><div class=\"line\">        origin.resolvedPath, isForwardLocked(), packageAbiOverride);</div><div class=\"line\"></div><div class=\"line\">if (mInstaller.freeCache(null, sizeBytes + lowThreshold) &gt;= 0) &#123;</div><div class=\"line\">    pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,</div><div class=\"line\">            installFlags, packageAbiOverride);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。</p>\n<p>这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。</p>\n<p>中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                 /*</div><div class=\"line\">                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by</div><div class=\"line\">                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.</div><div class=\"line\">                 */</div><div class=\"line\">                int userIdentifier = getUser().getIdentifier();</div><div class=\"line\">                if (userIdentifier == UserHandle.USER_ALL</div><div class=\"line\">                        &amp;&amp; ((installFlags &amp; PackageManager.INSTALL_FROM_ADB) != 0)) &#123;</div><div class=\"line\">                    userIdentifier = UserHandle.USER_OWNER;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /*</div><div class=\"line\">                 * Determine if we have any installed package verifiers. If we</div><div class=\"line\">                 * do, then we&apos;ll defer to them to verify the packages.</div><div class=\"line\">                 */</div><div class=\"line\">                final int requiredUid = mRequiredVerifierPackage == null ? -1</div><div class=\"line\">                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);</div><div class=\"line\">                if (!origin.existing &amp;&amp; requiredUid != -1</div><div class=\"line\">                        &amp;&amp; isVerificationEnabled(userIdentifier, installFlags)) &#123;</div><div class=\"line\">                    final Intent verification = new Intent(</div><div class=\"line\">                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</div><div class=\"line\">                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),</div><div class=\"line\">                            PACKAGE_MIME_TYPE);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ResolveInfo&gt; receivers = queryIntentReceivers(verification,</div><div class=\"line\">                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,</div><div class=\"line\">                            0 /* TODO: Which userId? */);</div><div class=\"line\"></div><div class=\"line\">                    if (DEBUG_VERIFY) &#123;</div><div class=\"line\">                        Slog.d(TAG, &quot;Found &quot; + receivers.size() + &quot; verifiers for intent &quot;</div><div class=\"line\">                                + verification.toString() + &quot; with &quot; + pkgLite.verifiers.length</div><div class=\"line\">                                + &quot; optional verifiers&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final int verificationId = mPendingVerificationToken++;</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</div><div class=\"line\">                            installerPackageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,</div><div class=\"line\">                            installFlags);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,</div><div class=\"line\">                            pkgLite.packageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,</div><div class=\"line\">                            pkgLite.versionCode);</div><div class=\"line\"></div><div class=\"line\">                    if (verificationParams != null) &#123;</div><div class=\"line\">                        if (verificationParams.getVerificationURI() != null) &#123;</div><div class=\"line\">                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</div><div class=\"line\">                                 verificationParams.getVerificationURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingURI() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,</div><div class=\"line\">                                  verificationParams.getOriginatingURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getReferrer() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_REFERRER,</div><div class=\"line\">                                  verificationParams.getReferrer());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,</div><div class=\"line\">                                  verificationParams.getOriginatingUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getInstallerUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,</div><div class=\"line\">                                  verificationParams.getInstallerUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final PackageVerificationState verificationState = new PackageVerificationState(</div><div class=\"line\">                            requiredUid, args);</div><div class=\"line\"></div><div class=\"line\">                    mPendingVerification.append(verificationId, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite,</div><div class=\"line\">                            receivers, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    // Apps installed for &quot;all&quot; users use the device owner to verify the app</div><div class=\"line\">                    UserHandle verifierUser = getUser();</div><div class=\"line\">                    if (verifierUser == UserHandle.ALL) &#123;</div><div class=\"line\">                        verifierUser = UserHandle.OWNER;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    /*</div><div class=\"line\">                     * If any sufficient verifiers were listed in the package</div><div class=\"line\">                     * manifest, attempt to ask them.</div><div class=\"line\">                     */</div><div class=\"line\">                    if (sufficientVerifiers != null) &#123;</div><div class=\"line\">                        final int N = sufficientVerifiers.size();</div><div class=\"line\">                        if (N == 0) &#123;</div><div class=\"line\">                            Slog.i(TAG, &quot;Additional verifiers required, but none installed.&quot;);</div><div class=\"line\">                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            for (int i = 0; i &lt; N; i++) &#123;</div><div class=\"line\">                                final ComponentName verifierComponent = sufficientVerifiers.get(i);</div><div class=\"line\"></div><div class=\"line\">                                final Intent sufficientIntent = new Intent(verification);</div><div class=\"line\">                                sufficientIntent.setComponent(verifierComponent);</div><div class=\"line\">                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(</div><div class=\"line\">                            mRequiredVerifierPackage, receivers);</div><div class=\"line\">                    if (ret == PackageManager.INSTALL_SUCCEEDED</div><div class=\"line\">                            &amp;&amp; mRequiredVerifierPackage != null) &#123;</div><div class=\"line\">                        /*</div><div class=\"line\">                         * Send the intent to the required verification agent,</div><div class=\"line\">                         * but only start the verification timeout after the</div><div class=\"line\">                         * target BroadcastReceivers have run.</div><div class=\"line\">                         */</div><div class=\"line\">                        verification.setComponent(requiredVerifierComponent);</div><div class=\"line\">                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,</div><div class=\"line\">                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</div><div class=\"line\">                                new BroadcastReceiver() &#123;</div><div class=\"line\">                                    @Override</div><div class=\"line\">                                    public void onReceive(Context context, Intent intent) &#123;</div><div class=\"line\">                                        final Message msg = mHandler</div><div class=\"line\">                                                .obtainMessage(CHECK_PENDING_VERIFICATION);</div><div class=\"line\">                                        msg.arg1 = verificationId;</div><div class=\"line\">                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125;, null, 0, null, null);</div><div class=\"line\"></div><div class=\"line\">                        /*</div><div class=\"line\">                         * We don&apos;t want the copy to proceed until verification</div><div class=\"line\">                         * succeeds, so null out this field.</div><div class=\"line\">                         */</div><div class=\"line\">                        mArgs = null;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    /*</div><div class=\"line\">                     * No package verification is enabled, so immediately start</div><div class=\"line\">                     * the remote call to initiate copy using temporary file.</div><div class=\"line\">                     */</div><div class=\"line\">                    ret = args.copyApk(mContainerService, true);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果启动了包验证的话，就会进入验证阶段。 <ul>\n<li>发送有序广播， </li>\n</ul>\n</li>\n<li>否则，直接进行复制操作</li>\n</ul>\n<p>验证部分的逻辑很长，大部分代码都是对intent进行设置。</p>\n<h3 id=\"7-InstallArgs-copyApk\"><a href=\"#7-InstallArgs-copyApk\" class=\"headerlink\" title=\"7.InstallArgs#copyApk\"></a>7.InstallArgs#copyApk</h3><p>在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private InstallArgs createInstallArgs(InstallParams params) &#123;</div><div class=\"line\">    if (params.move != null) &#123;</div><div class=\"line\">        return new MoveInstallArgs(params);</div><div class=\"line\">    &#125; else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) &#123;</div><div class=\"line\">        return new AsecInstallArgs(params);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return new FileInstallArgs(params);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以FileInstallArgs为例，我们来看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException &#123;</div><div class=\"line\">     if (origin.staged) &#123;</div><div class=\"line\">         if (DEBUG_INSTALL) Slog.d(TAG, origin.file + &quot; already staged; skipping copy&quot;);</div><div class=\"line\">         codeFile = origin.file;</div><div class=\"line\">         resourceFile = origin.file;</div><div class=\"line\">         return PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);</div><div class=\"line\">         codeFile = tempDir;</div><div class=\"line\">         resourceFile = tempDir;</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.w(TAG, &quot;Failed to create copy file: &quot; + e);</div><div class=\"line\">         return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() &#123;</div><div class=\"line\">         @Override</div><div class=\"line\">         public ParcelFileDescriptor open(String name, int mode) throws RemoteException &#123;</div><div class=\"line\">             if (!FileUtils.isValidExtFilename(name)) &#123;</div><div class=\"line\">                 throw new IllegalArgumentException(&quot;Invalid filename: &quot; + name);</div><div class=\"line\">             &#125;</div><div class=\"line\">             try &#123;</div><div class=\"line\">                 final File file = new File(codeFile, name);</div><div class=\"line\">                 final FileDescriptor fd = Os.open(file.getAbsolutePath(),</div><div class=\"line\">                         O_RDWR | O_CREAT, 0644);</div><div class=\"line\">                 Os.chmod(file.getAbsolutePath(), 0644);</div><div class=\"line\">                 return new ParcelFileDescriptor(fd);</div><div class=\"line\">             &#125; catch (ErrnoException e) &#123;</div><div class=\"line\">                 throw new RemoteException(&quot;Failed to open: &quot; + e.getMessage());</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\"></div><div class=\"line\">     int ret = PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);</div><div class=\"line\">     if (ret != PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Failed to copy package&quot;);</div><div class=\"line\">         return ret;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final File libraryRoot = new File(codeFile, LIB_DIR_NAME);</div><div class=\"line\">     NativeLibraryHelper.Handle handle = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         handle = NativeLibraryHelper.Handle.create(codeFile);</div><div class=\"line\">         ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,</div><div class=\"line\">                 abiOverride);</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Copying native libraries failed&quot;, e);</div><div class=\"line\">         ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(handle);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     return ret;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先mInstallerService.allocateStageDirLegacy申请足够的存储空间</li>\n<li>得到申请的那部分空间的文件描述符，并且修改权限</li>\n<li>IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，</li>\n<li>NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)</li>\n</ul>\n<h3 id=\"8-DefaultContainerService-copyPackage\"><a href=\"#8-DefaultContainerService-copyPackage\" class=\"headerlink\" title=\"8.DefaultContainerService#copyPackage\"></a>8.DefaultContainerService#copyPackage</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) &#123;</div><div class=\"line\">    if (packagePath == null || target == null) &#123;</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INVALID_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    PackageLite pkg = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        final File packageFile = new File(packagePath);</div><div class=\"line\">        pkg = PackageParser.parsePackageLite(packageFile, 0);</div><div class=\"line\">        return copyPackageInner(pkg, target);</div><div class=\"line\">    &#125; catch (PackageParserException | IOException | RemoteException e) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Failed to copy package at &quot; + packagePath + &quot;: &quot; + e);</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>解析apk文件</li>\n<li>将文件拷贝到指定目录</li>\n</ul>\n<h3 id=\"9-NativeLibraryHelper-copyNativeBinariesWithOverride\"><a href=\"#9-NativeLibraryHelper-copyNativeBinariesWithOverride\" class=\"headerlink\" title=\"9.NativeLibraryHelper#copyNativeBinariesWithOverride\"></a>9.NativeLibraryHelper#copyNativeBinariesWithOverride</h3><p>在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。</p>\n<p>到现在，copy的流程就完了。</p>\n<p>在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。</p>\n<h3 id=\"10-InstallParams-handleReturnCode\"><a href=\"#10-InstallParams-handleReturnCode\" class=\"headerlink\" title=\"10.InstallParams#handleReturnCode\"></a>10.InstallParams#handleReturnCode</h3><p>在这个方法中，会调用processPendingInstall去处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123;</div><div class=\"line\">    // Queue up an async operation since the package installation may take a little while.</div><div class=\"line\">    mHandler.post(new Runnable() &#123;</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            mHandler.removeCallbacks(this);</div><div class=\"line\">             // Result object to be returned</div><div class=\"line\">            PackageInstalledInfo res = new PackageInstalledInfo();</div><div class=\"line\">            res.returnCode = currentStatus;</div><div class=\"line\">            res.uid = -1;</div><div class=\"line\">            res.pkg = null;</div><div class=\"line\">            res.removedInfo = new PackageRemovedInfo();</div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                args.doPreInstall(res.returnCode);</div><div class=\"line\">                synchronized (mInstallLock) &#123;</div><div class=\"line\">                    installPackageLI(args, res);</div><div class=\"line\">                &#125;</div><div class=\"line\">                args.doPostInstall(res.returnCode, res.uid);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // A restore should be performed at this point if (a) the install</div><div class=\"line\">            // succeeded, (b) the operation is not an update, and (c) the new</div><div class=\"line\">            // package has not opted out of backup participation.</div><div class=\"line\">            final boolean update = res.removedInfo.removedPackage != null;</div><div class=\"line\">            final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;</div><div class=\"line\">            boolean doRestore = !update</div><div class=\"line\">                    &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);</div><div class=\"line\"></div><div class=\"line\">            // Set up the post-install work request bookkeeping.  This will be used</div><div class=\"line\">            // and cleaned up by the post-install event handling regardless of whether</div><div class=\"line\">            // there&apos;s a restore pass performed.  Token values are &gt;= 1.</div><div class=\"line\">            int token;</div><div class=\"line\">            if (mNextInstallToken &lt; 0) mNextInstallToken = 1;</div><div class=\"line\">            token = mNextInstallToken++;</div><div class=\"line\"></div><div class=\"line\">            PostInstallData data = new PostInstallData(args, res);</div><div class=\"line\">            mRunningInstalls.put(token, data);</div><div class=\"line\">            if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token);</div><div class=\"line\"></div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123;</div><div class=\"line\">                // Pass responsibility to the Backup Manager.  It will perform a</div><div class=\"line\">                // restore if appropriate, then pass responsibility back to the</div><div class=\"line\">                // Package Manager to run the post-install observer callbacks</div><div class=\"line\">                // and broadcasts.</div><div class=\"line\">                IBackupManager bm = IBackupManager.Stub.asInterface(</div><div class=\"line\">                        ServiceManager.getService(Context.BACKUP_SERVICE));</div><div class=\"line\">                if (bm != null) &#123;</div><div class=\"line\">                    if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token</div><div class=\"line\">                            + &quot; to BM for possible restore&quot;);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) &#123;</div><div class=\"line\">                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            doRestore = false;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">                        // can&apos;t happen; the backup manager is local</div><div class=\"line\">                    &#125; catch (Exception e) &#123;</div><div class=\"line\">                        Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e);</div><div class=\"line\">                        doRestore = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    Slog.e(TAG, &quot;Backup Manager not found!&quot;);</div><div class=\"line\">                    doRestore = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!doRestore) &#123;</div><div class=\"line\">                // No restore possible, or the Backup Manager was mysteriously not</div><div class=\"line\">                // available -- just fire the post-install work request directly.</div><div class=\"line\">                if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);</div><div class=\"line\">                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</div><div class=\"line\">                mHandler.sendMessage(msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装过程</p>\n<ul>\n<li>installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。</li>\n<li>恢复部分代码 没看明白。😭</li>\n<li>发送POST_INSTALL消息</li>\n</ul>\n<h3 id=\"11-installPackageLI\"><a href=\"#11-installPackageLI\" class=\"headerlink\" title=\"11.installPackageLI\"></a>11.installPackageLI</h3><p>改方法氛围几部分。</p>\n<p>首先是解析包过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">PackageParser pp = new PackageParser();</div><div class=\"line\">pp.setSeparateProcesses(mSeparateProcesses);</div><div class=\"line\">pp.setDisplayMetrics(mMetrics);</div><div class=\"line\"></div><div class=\"line\">final PackageParser.Package pkg;</div><div class=\"line\">try &#123;</div><div class=\"line\">    pkg = pp.parsePackage(tmpPackageFile, parseFlags);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed parse during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其次是校验签名的md5的过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    pp.collectCertificates(pkg, parseFlags);</div><div class=\"line\">    pp.collectManifestDigest(pkg);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed collect during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* If the installer passed in a manifest digest, compare it now. */</div><div class=\"line\">if (args.manifestDigest != null) &#123;</div><div class=\"line\">    if (DEBUG_INSTALL) &#123;</div><div class=\"line\">        final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot;</div><div class=\"line\">                : pkg.manifestDigest.toString();</div><div class=\"line\">        Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot;</div><div class=\"line\">                + parsedManifest);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!args.manifestDigest.equals(pkg.manifestDigest)) &#123;</div><div class=\"line\">        res.setError(INSTALL_FAILED_PACKAGE_CHANGED, &quot;Manifest digest changed&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (DEBUG_INSTALL) &#123;</div><div class=\"line\">    final String parsedManifest = pkg.manifestDigest == null</div><div class=\"line\">            ? &quot;null&quot; : pkg.manifestDigest.toString();</div><div class=\"line\">    Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用installNewPackageLI安装。</p>\n<h3 id=\"12-installNewPackageLI\"><a href=\"#12-installNewPackageLI\" class=\"headerlink\" title=\"12.installNewPackageLI\"></a>12.installNewPackageLI</h3><p>在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。</p>\n<h3 id=\"13-处理POST-INSTALL消息\"><a href=\"#13-处理POST-INSTALL消息\" class=\"headerlink\" title=\"13.处理POST_INSTALL消息\"></a>13.处理POST_INSTALL消息</h3><p>略。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<p>以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，</p>\n<h3 id=\"2-安装器\"><a href=\"#2-安装器\" class=\"headerlink\" title=\"2.安装器\"></a>2.安装器</h3><p>显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (v == mOk) &#123;</div><div class=\"line\">    if (mOkCanInstall || mScrollView == null) &#123;</div><div class=\"line\">        mInstallFlowAnalytics.setInstallButtonClicked();</div><div class=\"line\">        if (mSessionId != -1) &#123;</div><div class=\"line\">            mInstaller.setPermissionsResult(mSessionId, true);</div><div class=\"line\"></div><div class=\"line\">            // We&apos;re only confirming permissions, so we don&apos;t really know how the</div><div class=\"line\">            // story ends; assume success.</div><div class=\"line\">            mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(</div><div class=\"line\">                    PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">            finish();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            startInstall();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mScrollView.pageScroll(View.FOCUS_DOWN);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        pm.installExistingPackage(mAppInfo.packageName);</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_FAILED_INVALID_APK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,</div><div class=\"line\">            installerPackageName, verificationParams, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>mPackageURI，安装应用的话，应该是file</li>\n<li>pm 为ApplicationPackageManager</li>\n</ul>\n<p>因此，我们看installPackageWithVerificationAndEncryption方法。</p>\n<h3 id=\"3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\"><a href=\"#3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\" class=\"headerlink\" title=\"3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\"></a>3.ApplicationPackageManager#installPackageWithVerificationAndEncryption</h3><p>在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static IPackageManager getPackageManager() &#123;</div><div class=\"line\">    if (sPackageManager != null) &#123;</div><div class=\"line\">        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</div><div class=\"line\">        return sPackageManager;</div><div class=\"line\">    &#125;</div><div class=\"line\">    IBinder b = ServiceManager.getService(&quot;package&quot;);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</div><div class=\"line\">    sPackageManager = IPackageManager.Stub.asInterface(b);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</div><div class=\"line\">    return sPackageManager;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从中可以看出，其binder服务端为PackageManagerService.</p>\n<h3 id=\"4-PackageManagerService-installPackage\"><a href=\"#4-PackageManagerService-installPackage\" class=\"headerlink\" title=\"4.PackageManagerService#installPackage\"></a>4.PackageManagerService#installPackage</h3><p>在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Message msg = mHandler.obtainMessage(INIT_COPY);</div><div class=\"line\">msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,</div><div class=\"line\">        null, verificationParams, user, packageAbiOverride, null);</div><div class=\"line\">mHandler.sendMessage(msg);</div></pre></td></tr></table></figure>\n<p>这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">case INIT_COPY: &#123;</div><div class=\"line\">    HandlerParams params = (HandlerParams) msg.obj;</div><div class=\"line\">    int idx = mPendingInstalls.size();</div><div class=\"line\">    if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params);</div><div class=\"line\">    // If a bind was already initiated we dont really</div><div class=\"line\">    // need to do anything. The pending install</div><div class=\"line\">    // will be processed later on.</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // If this is the only one pending we might</div><div class=\"line\">        // have to bind to the service again.</div><div class=\"line\">        if (!connectToService()) &#123;</div><div class=\"line\">            Slog.e(TAG, &quot;Failed to bind to media container service&quot;);</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Once we bind to the service, the first</div><div class=\"line\">            // pending request will be processed.</div><div class=\"line\">            mPendingInstalls.add(idx, params);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mPendingInstalls.add(idx, params);</div><div class=\"line\">        // Already bound to the service. Just make</div><div class=\"line\">        // sure we trigger off processing the first request.</div><div class=\"line\">        if (idx == 0) &#123;</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。<br>在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;);</div><div class=\"line\">if (msg.obj != null) &#123;</div><div class=\"line\">    mContainerService = (IMediaContainerService) msg.obj;</div><div class=\"line\">&#125;</div><div class=\"line\">if (mContainerService == null) &#123;</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // Something seriously wrong since we are not bound and we are not</div><div class=\"line\">        // waiting for connection. Bail out.</div><div class=\"line\">        Slog.e(TAG, &quot;Cannot bind to media container service&quot;);</div><div class=\"line\">        for (HandlerParams params : mPendingInstalls) &#123;</div><div class=\"line\">            // Indicate service bind error</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mPendingInstalls.clear();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Waiting to connect to media container service&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">    HandlerParams params = mPendingInstalls.get(0);</div><div class=\"line\">    if (params != null) &#123;</div><div class=\"line\">        if (params.startCopy()) &#123;</div><div class=\"line\">            // We are done...  look for more work or to</div><div class=\"line\">            // go idle.</div><div class=\"line\">            if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                    &quot;Checking for more work or unbind...&quot;);</div><div class=\"line\">            // Delete pending install</div><div class=\"line\">            if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">                mPendingInstalls.remove(0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (mPendingInstalls.size() == 0) &#123;</div><div class=\"line\">                if (mBound) &#123;</div><div class=\"line\">                    if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                            &quot;Posting delayed MCS_UNBIND&quot;);</div><div class=\"line\">                    removeMessages(MCS_UNBIND);</div><div class=\"line\">                    Message ubmsg = obtainMessage(MCS_UNBIND);</div><div class=\"line\">                    // Unbind after a little delay, to avoid</div><div class=\"line\">                    // continual thrashing.</div><div class=\"line\">                    sendMessageDelayed(ubmsg, 10000);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are more pending requests in queue.</div><div class=\"line\">                // Just post MCS_BOUND message to trigger processing</div><div class=\"line\">                // of next pending install.</div><div class=\"line\">                if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                        &quot;Posting MCS_BOUND for next work&quot;);</div><div class=\"line\">                mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // Should never happen ideally.</div><div class=\"line\">    Slog.w(TAG, &quot;Empty queue&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div></pre></td></tr></table></figure>\n<p>从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。</p>\n<h3 id=\"5-HandlerParams-startCopy\"><a href=\"#5-HandlerParams-startCopy\" class=\"headerlink\" title=\"5.HandlerParams#startCopy\"></a>5.HandlerParams#startCopy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean startCopy() &#123;</div><div class=\"line\">    boolean res;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);</div><div class=\"line\"></div><div class=\"line\">        if (++mRetries &gt; MAX_RETRIES) &#123;</div><div class=\"line\">            Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_GIVE_UP);</div><div class=\"line\">            handleServiceError();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            handleStartCopy();</div><div class=\"line\">            res = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);</div><div class=\"line\">        mHandler.sendEmptyMessage(MCS_RECONNECT);</div><div class=\"line\">        res = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    handleReturnCode();</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有重试机制。而handleStartCopy的实现在InstallParams中。</p>\n<h3 id=\"6-InstallParams-handleStartCopy\"><a href=\"#6-InstallParams-handleStartCopy\" class=\"headerlink\" title=\"6.InstallParams#handleStartCopy\"></a>6.InstallParams#handleStartCopy</h3><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">final StorageManager storage = StorageManager.from(mContext);</div><div class=\"line\">final long lowThreshold = storage.getStorageLowBytes(</div><div class=\"line\">        Environment.getDataDirectory());</div><div class=\"line\"></div><div class=\"line\">final long sizeBytes = mContainerService.calculateInstalledSize(</div><div class=\"line\">        origin.resolvedPath, isForwardLocked(), packageAbiOverride);</div><div class=\"line\"></div><div class=\"line\">if (mInstaller.freeCache(null, sizeBytes + lowThreshold) &gt;= 0) &#123;</div><div class=\"line\">    pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,</div><div class=\"line\">            installFlags, packageAbiOverride);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。</p>\n<p>这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。</p>\n<p>中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                 /*</div><div class=\"line\">                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by</div><div class=\"line\">                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.</div><div class=\"line\">                 */</div><div class=\"line\">                int userIdentifier = getUser().getIdentifier();</div><div class=\"line\">                if (userIdentifier == UserHandle.USER_ALL</div><div class=\"line\">                        &amp;&amp; ((installFlags &amp; PackageManager.INSTALL_FROM_ADB) != 0)) &#123;</div><div class=\"line\">                    userIdentifier = UserHandle.USER_OWNER;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /*</div><div class=\"line\">                 * Determine if we have any installed package verifiers. If we</div><div class=\"line\">                 * do, then we&apos;ll defer to them to verify the packages.</div><div class=\"line\">                 */</div><div class=\"line\">                final int requiredUid = mRequiredVerifierPackage == null ? -1</div><div class=\"line\">                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);</div><div class=\"line\">                if (!origin.existing &amp;&amp; requiredUid != -1</div><div class=\"line\">                        &amp;&amp; isVerificationEnabled(userIdentifier, installFlags)) &#123;</div><div class=\"line\">                    final Intent verification = new Intent(</div><div class=\"line\">                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</div><div class=\"line\">                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),</div><div class=\"line\">                            PACKAGE_MIME_TYPE);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ResolveInfo&gt; receivers = queryIntentReceivers(verification,</div><div class=\"line\">                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,</div><div class=\"line\">                            0 /* TODO: Which userId? */);</div><div class=\"line\"></div><div class=\"line\">                    if (DEBUG_VERIFY) &#123;</div><div class=\"line\">                        Slog.d(TAG, &quot;Found &quot; + receivers.size() + &quot; verifiers for intent &quot;</div><div class=\"line\">                                + verification.toString() + &quot; with &quot; + pkgLite.verifiers.length</div><div class=\"line\">                                + &quot; optional verifiers&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final int verificationId = mPendingVerificationToken++;</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</div><div class=\"line\">                            installerPackageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,</div><div class=\"line\">                            installFlags);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,</div><div class=\"line\">                            pkgLite.packageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,</div><div class=\"line\">                            pkgLite.versionCode);</div><div class=\"line\"></div><div class=\"line\">                    if (verificationParams != null) &#123;</div><div class=\"line\">                        if (verificationParams.getVerificationURI() != null) &#123;</div><div class=\"line\">                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</div><div class=\"line\">                                 verificationParams.getVerificationURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingURI() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,</div><div class=\"line\">                                  verificationParams.getOriginatingURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getReferrer() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_REFERRER,</div><div class=\"line\">                                  verificationParams.getReferrer());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,</div><div class=\"line\">                                  verificationParams.getOriginatingUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getInstallerUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,</div><div class=\"line\">                                  verificationParams.getInstallerUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final PackageVerificationState verificationState = new PackageVerificationState(</div><div class=\"line\">                            requiredUid, args);</div><div class=\"line\"></div><div class=\"line\">                    mPendingVerification.append(verificationId, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite,</div><div class=\"line\">                            receivers, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    // Apps installed for &quot;all&quot; users use the device owner to verify the app</div><div class=\"line\">                    UserHandle verifierUser = getUser();</div><div class=\"line\">                    if (verifierUser == UserHandle.ALL) &#123;</div><div class=\"line\">                        verifierUser = UserHandle.OWNER;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    /*</div><div class=\"line\">                     * If any sufficient verifiers were listed in the package</div><div class=\"line\">                     * manifest, attempt to ask them.</div><div class=\"line\">                     */</div><div class=\"line\">                    if (sufficientVerifiers != null) &#123;</div><div class=\"line\">                        final int N = sufficientVerifiers.size();</div><div class=\"line\">                        if (N == 0) &#123;</div><div class=\"line\">                            Slog.i(TAG, &quot;Additional verifiers required, but none installed.&quot;);</div><div class=\"line\">                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            for (int i = 0; i &lt; N; i++) &#123;</div><div class=\"line\">                                final ComponentName verifierComponent = sufficientVerifiers.get(i);</div><div class=\"line\"></div><div class=\"line\">                                final Intent sufficientIntent = new Intent(verification);</div><div class=\"line\">                                sufficientIntent.setComponent(verifierComponent);</div><div class=\"line\">                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(</div><div class=\"line\">                            mRequiredVerifierPackage, receivers);</div><div class=\"line\">                    if (ret == PackageManager.INSTALL_SUCCEEDED</div><div class=\"line\">                            &amp;&amp; mRequiredVerifierPackage != null) &#123;</div><div class=\"line\">                        /*</div><div class=\"line\">                         * Send the intent to the required verification agent,</div><div class=\"line\">                         * but only start the verification timeout after the</div><div class=\"line\">                         * target BroadcastReceivers have run.</div><div class=\"line\">                         */</div><div class=\"line\">                        verification.setComponent(requiredVerifierComponent);</div><div class=\"line\">                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,</div><div class=\"line\">                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</div><div class=\"line\">                                new BroadcastReceiver() &#123;</div><div class=\"line\">                                    @Override</div><div class=\"line\">                                    public void onReceive(Context context, Intent intent) &#123;</div><div class=\"line\">                                        final Message msg = mHandler</div><div class=\"line\">                                                .obtainMessage(CHECK_PENDING_VERIFICATION);</div><div class=\"line\">                                        msg.arg1 = verificationId;</div><div class=\"line\">                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125;, null, 0, null, null);</div><div class=\"line\"></div><div class=\"line\">                        /*</div><div class=\"line\">                         * We don&apos;t want the copy to proceed until verification</div><div class=\"line\">                         * succeeds, so null out this field.</div><div class=\"line\">                         */</div><div class=\"line\">                        mArgs = null;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    /*</div><div class=\"line\">                     * No package verification is enabled, so immediately start</div><div class=\"line\">                     * the remote call to initiate copy using temporary file.</div><div class=\"line\">                     */</div><div class=\"line\">                    ret = args.copyApk(mContainerService, true);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果启动了包验证的话，就会进入验证阶段。 <ul>\n<li>发送有序广播， </li>\n</ul>\n</li>\n<li>否则，直接进行复制操作</li>\n</ul>\n<p>验证部分的逻辑很长，大部分代码都是对intent进行设置。</p>\n<h3 id=\"7-InstallArgs-copyApk\"><a href=\"#7-InstallArgs-copyApk\" class=\"headerlink\" title=\"7.InstallArgs#copyApk\"></a>7.InstallArgs#copyApk</h3><p>在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private InstallArgs createInstallArgs(InstallParams params) &#123;</div><div class=\"line\">    if (params.move != null) &#123;</div><div class=\"line\">        return new MoveInstallArgs(params);</div><div class=\"line\">    &#125; else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) &#123;</div><div class=\"line\">        return new AsecInstallArgs(params);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return new FileInstallArgs(params);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以FileInstallArgs为例，我们来看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException &#123;</div><div class=\"line\">     if (origin.staged) &#123;</div><div class=\"line\">         if (DEBUG_INSTALL) Slog.d(TAG, origin.file + &quot; already staged; skipping copy&quot;);</div><div class=\"line\">         codeFile = origin.file;</div><div class=\"line\">         resourceFile = origin.file;</div><div class=\"line\">         return PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);</div><div class=\"line\">         codeFile = tempDir;</div><div class=\"line\">         resourceFile = tempDir;</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.w(TAG, &quot;Failed to create copy file: &quot; + e);</div><div class=\"line\">         return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() &#123;</div><div class=\"line\">         @Override</div><div class=\"line\">         public ParcelFileDescriptor open(String name, int mode) throws RemoteException &#123;</div><div class=\"line\">             if (!FileUtils.isValidExtFilename(name)) &#123;</div><div class=\"line\">                 throw new IllegalArgumentException(&quot;Invalid filename: &quot; + name);</div><div class=\"line\">             &#125;</div><div class=\"line\">             try &#123;</div><div class=\"line\">                 final File file = new File(codeFile, name);</div><div class=\"line\">                 final FileDescriptor fd = Os.open(file.getAbsolutePath(),</div><div class=\"line\">                         O_RDWR | O_CREAT, 0644);</div><div class=\"line\">                 Os.chmod(file.getAbsolutePath(), 0644);</div><div class=\"line\">                 return new ParcelFileDescriptor(fd);</div><div class=\"line\">             &#125; catch (ErrnoException e) &#123;</div><div class=\"line\">                 throw new RemoteException(&quot;Failed to open: &quot; + e.getMessage());</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\"></div><div class=\"line\">     int ret = PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);</div><div class=\"line\">     if (ret != PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Failed to copy package&quot;);</div><div class=\"line\">         return ret;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final File libraryRoot = new File(codeFile, LIB_DIR_NAME);</div><div class=\"line\">     NativeLibraryHelper.Handle handle = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         handle = NativeLibraryHelper.Handle.create(codeFile);</div><div class=\"line\">         ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,</div><div class=\"line\">                 abiOverride);</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Copying native libraries failed&quot;, e);</div><div class=\"line\">         ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(handle);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     return ret;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先mInstallerService.allocateStageDirLegacy申请足够的存储空间</li>\n<li>得到申请的那部分空间的文件描述符，并且修改权限</li>\n<li>IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，</li>\n<li>NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)</li>\n</ul>\n<h3 id=\"8-DefaultContainerService-copyPackage\"><a href=\"#8-DefaultContainerService-copyPackage\" class=\"headerlink\" title=\"8.DefaultContainerService#copyPackage\"></a>8.DefaultContainerService#copyPackage</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) &#123;</div><div class=\"line\">    if (packagePath == null || target == null) &#123;</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INVALID_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    PackageLite pkg = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        final File packageFile = new File(packagePath);</div><div class=\"line\">        pkg = PackageParser.parsePackageLite(packageFile, 0);</div><div class=\"line\">        return copyPackageInner(pkg, target);</div><div class=\"line\">    &#125; catch (PackageParserException | IOException | RemoteException e) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Failed to copy package at &quot; + packagePath + &quot;: &quot; + e);</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>解析apk文件</li>\n<li>将文件拷贝到指定目录</li>\n</ul>\n<h3 id=\"9-NativeLibraryHelper-copyNativeBinariesWithOverride\"><a href=\"#9-NativeLibraryHelper-copyNativeBinariesWithOverride\" class=\"headerlink\" title=\"9.NativeLibraryHelper#copyNativeBinariesWithOverride\"></a>9.NativeLibraryHelper#copyNativeBinariesWithOverride</h3><p>在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。</p>\n<p>到现在，copy的流程就完了。</p>\n<p>在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。</p>\n<h3 id=\"10-InstallParams-handleReturnCode\"><a href=\"#10-InstallParams-handleReturnCode\" class=\"headerlink\" title=\"10.InstallParams#handleReturnCode\"></a>10.InstallParams#handleReturnCode</h3><p>在这个方法中，会调用processPendingInstall去处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123;</div><div class=\"line\">    // Queue up an async operation since the package installation may take a little while.</div><div class=\"line\">    mHandler.post(new Runnable() &#123;</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            mHandler.removeCallbacks(this);</div><div class=\"line\">             // Result object to be returned</div><div class=\"line\">            PackageInstalledInfo res = new PackageInstalledInfo();</div><div class=\"line\">            res.returnCode = currentStatus;</div><div class=\"line\">            res.uid = -1;</div><div class=\"line\">            res.pkg = null;</div><div class=\"line\">            res.removedInfo = new PackageRemovedInfo();</div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                args.doPreInstall(res.returnCode);</div><div class=\"line\">                synchronized (mInstallLock) &#123;</div><div class=\"line\">                    installPackageLI(args, res);</div><div class=\"line\">                &#125;</div><div class=\"line\">                args.doPostInstall(res.returnCode, res.uid);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // A restore should be performed at this point if (a) the install</div><div class=\"line\">            // succeeded, (b) the operation is not an update, and (c) the new</div><div class=\"line\">            // package has not opted out of backup participation.</div><div class=\"line\">            final boolean update = res.removedInfo.removedPackage != null;</div><div class=\"line\">            final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;</div><div class=\"line\">            boolean doRestore = !update</div><div class=\"line\">                    &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);</div><div class=\"line\"></div><div class=\"line\">            // Set up the post-install work request bookkeeping.  This will be used</div><div class=\"line\">            // and cleaned up by the post-install event handling regardless of whether</div><div class=\"line\">            // there&apos;s a restore pass performed.  Token values are &gt;= 1.</div><div class=\"line\">            int token;</div><div class=\"line\">            if (mNextInstallToken &lt; 0) mNextInstallToken = 1;</div><div class=\"line\">            token = mNextInstallToken++;</div><div class=\"line\"></div><div class=\"line\">            PostInstallData data = new PostInstallData(args, res);</div><div class=\"line\">            mRunningInstalls.put(token, data);</div><div class=\"line\">            if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token);</div><div class=\"line\"></div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123;</div><div class=\"line\">                // Pass responsibility to the Backup Manager.  It will perform a</div><div class=\"line\">                // restore if appropriate, then pass responsibility back to the</div><div class=\"line\">                // Package Manager to run the post-install observer callbacks</div><div class=\"line\">                // and broadcasts.</div><div class=\"line\">                IBackupManager bm = IBackupManager.Stub.asInterface(</div><div class=\"line\">                        ServiceManager.getService(Context.BACKUP_SERVICE));</div><div class=\"line\">                if (bm != null) &#123;</div><div class=\"line\">                    if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token</div><div class=\"line\">                            + &quot; to BM for possible restore&quot;);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) &#123;</div><div class=\"line\">                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            doRestore = false;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">                        // can&apos;t happen; the backup manager is local</div><div class=\"line\">                    &#125; catch (Exception e) &#123;</div><div class=\"line\">                        Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e);</div><div class=\"line\">                        doRestore = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    Slog.e(TAG, &quot;Backup Manager not found!&quot;);</div><div class=\"line\">                    doRestore = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!doRestore) &#123;</div><div class=\"line\">                // No restore possible, or the Backup Manager was mysteriously not</div><div class=\"line\">                // available -- just fire the post-install work request directly.</div><div class=\"line\">                if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);</div><div class=\"line\">                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</div><div class=\"line\">                mHandler.sendMessage(msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装过程</p>\n<ul>\n<li>installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。</li>\n<li>恢复部分代码 没看明白。😭</li>\n<li>发送POST_INSTALL消息</li>\n</ul>\n<h3 id=\"11-installPackageLI\"><a href=\"#11-installPackageLI\" class=\"headerlink\" title=\"11.installPackageLI\"></a>11.installPackageLI</h3><p>改方法氛围几部分。</p>\n<p>首先是解析包过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">PackageParser pp = new PackageParser();</div><div class=\"line\">pp.setSeparateProcesses(mSeparateProcesses);</div><div class=\"line\">pp.setDisplayMetrics(mMetrics);</div><div class=\"line\"></div><div class=\"line\">final PackageParser.Package pkg;</div><div class=\"line\">try &#123;</div><div class=\"line\">    pkg = pp.parsePackage(tmpPackageFile, parseFlags);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed parse during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其次是校验签名的md5的过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    pp.collectCertificates(pkg, parseFlags);</div><div class=\"line\">    pp.collectManifestDigest(pkg);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed collect during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* If the installer passed in a manifest digest, compare it now. */</div><div class=\"line\">if (args.manifestDigest != null) &#123;</div><div class=\"line\">    if (DEBUG_INSTALL) &#123;</div><div class=\"line\">        final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot;</div><div class=\"line\">                : pkg.manifestDigest.toString();</div><div class=\"line\">        Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot;</div><div class=\"line\">                + parsedManifest);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!args.manifestDigest.equals(pkg.manifestDigest)) &#123;</div><div class=\"line\">        res.setError(INSTALL_FAILED_PACKAGE_CHANGED, &quot;Manifest digest changed&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (DEBUG_INSTALL) &#123;</div><div class=\"line\">    final String parsedManifest = pkg.manifestDigest == null</div><div class=\"line\">            ? &quot;null&quot; : pkg.manifestDigest.toString();</div><div class=\"line\">    Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用installNewPackageLI安装。</p>\n<h3 id=\"12-installNewPackageLI\"><a href=\"#12-installNewPackageLI\" class=\"headerlink\" title=\"12.installNewPackageLI\"></a>12.installNewPackageLI</h3><p>在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。</p>\n<h3 id=\"13-处理POST-INSTALL消息\"><a href=\"#13-处理POST-INSTALL消息\" class=\"headerlink\" title=\"13.处理POST_INSTALL消息\"></a>13.处理POST_INSTALL消息</h3><p>略。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"ContentProvider凑数文","date":"2016-12-29T10:33:56.000Z","_content":"<Excerpt in index | 首页摘要>\n这一篇，没营养，凑数用的。\n\n### 1. ActivityThread的main方法\n\n* 我们知道android应用程序的入口是ActivityThread的main方法。\n* ContentProvid是何时、何流程，调用的onCreate方法呢？\n\nActivityThread的main方法说起。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n```\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n```\n\n在main方法中，我们能发现如上代码，attach什么？我们跟进去看。\n\n```\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n            final IActivityManager mgr = ActivityManagerNative.getDefault();\n            try {\n                mgr.attachApplication(mAppThread);\n            } catch (RemoteException ex) {\n                // Ignore\n            }\n```\n\n我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现\n\n```\nList<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;\n```\n\n* app ProcessRecord, 进程相关信息\n* ProviderInfo contentprovider信息\n\n再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：\n\n```\n            if (!data.restrictedBackupMode) {\n                List<ProviderInfo> providers = data.providers;\n                if (providers != null) {\n                    installContentProviders(app, providers);\n                    // For process that contains content providers, we want to\n                    // ensure that the JIT is enabled \"at some point\".\n                    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);\n                }\n            }\n```\n\n找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。\n\n```\n    private void installContentProviders(\n            Context context, List<ProviderInfo> providers) {\n        final ArrayList<IActivityManager.ContentProviderHolder> results =\n            new ArrayList<IActivityManager.ContentProviderHolder>();\n\n        for (ProviderInfo cpi : providers) {\n            if (DEBUG_PROVIDER) {\n                StringBuilder buf = new StringBuilder(128);\n                buf.append(\"Pub \");\n                buf.append(cpi.authority);\n                buf.append(\": \");\n                buf.append(cpi.name);\n                Log.i(TAG, buf.toString());\n            }\n            IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,\n                    false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);\n            if (cph != null) {\n                cph.noReleaseNeeded = true;\n                results.add(cph);\n            }\n        }\n\n        try {\n            ActivityManagerNative.getDefault().publishContentProviders(\n                getApplicationThread(), results);\n        } catch (RemoteException ex) {\n        }\n    }\n```\n\n总体分为两步，\n\n* installProvider 生成ContentProviderHolder对象\n* publishContentProviders 发布出去\n\n### 2.installProvider\n\n\n```\n                final java.lang.ClassLoader cl = c.getClassLoader();\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n                if (provider == null) {\n                    Slog.e(TAG, \"Failed to instantiate class \" +\n                          info.name + \" from sourceDir \" +\n                          info.applicationInfo.sourceDir);\n                    return null;\n                }\n                if (DEBUG_PROVIDER) Slog.v(\n                    TAG, \"Instantiating local provider \" + info.name);\n                // XXX Need to create the correct context for this provider.\n                localProvider.attachInfo(c, info);\n```\n\n在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现\n\n```\nContentProvider.this.onCreate();\n```\n\n### 3.query操作\n\nContext的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。\n\nquery方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个[理解ContentProvider原理](http://gityuan.com/2016/07/30/content-provider/) \n\n* 获取IContentProvider对象\n* IContentProvider的query方法\n\n\nIContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。\n\n```\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n```\ncp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/ContentProvider水文(凑四大组件).md","raw":"---\ntitle: ContentProvider凑数文\ndate: 2016-12-29 18:33:56\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n这一篇，没营养，凑数用的。\n\n### 1. ActivityThread的main方法\n\n* 我们知道android应用程序的入口是ActivityThread的main方法。\n* ContentProvid是何时、何流程，调用的onCreate方法呢？\n\nActivityThread的main方法说起。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n```\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n```\n\n在main方法中，我们能发现如上代码，attach什么？我们跟进去看。\n\n```\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n            final IActivityManager mgr = ActivityManagerNative.getDefault();\n            try {\n                mgr.attachApplication(mAppThread);\n            } catch (RemoteException ex) {\n                // Ignore\n            }\n```\n\n我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现\n\n```\nList<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;\n```\n\n* app ProcessRecord, 进程相关信息\n* ProviderInfo contentprovider信息\n\n再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：\n\n```\n            if (!data.restrictedBackupMode) {\n                List<ProviderInfo> providers = data.providers;\n                if (providers != null) {\n                    installContentProviders(app, providers);\n                    // For process that contains content providers, we want to\n                    // ensure that the JIT is enabled \"at some point\".\n                    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);\n                }\n            }\n```\n\n找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。\n\n```\n    private void installContentProviders(\n            Context context, List<ProviderInfo> providers) {\n        final ArrayList<IActivityManager.ContentProviderHolder> results =\n            new ArrayList<IActivityManager.ContentProviderHolder>();\n\n        for (ProviderInfo cpi : providers) {\n            if (DEBUG_PROVIDER) {\n                StringBuilder buf = new StringBuilder(128);\n                buf.append(\"Pub \");\n                buf.append(cpi.authority);\n                buf.append(\": \");\n                buf.append(cpi.name);\n                Log.i(TAG, buf.toString());\n            }\n            IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,\n                    false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);\n            if (cph != null) {\n                cph.noReleaseNeeded = true;\n                results.add(cph);\n            }\n        }\n\n        try {\n            ActivityManagerNative.getDefault().publishContentProviders(\n                getApplicationThread(), results);\n        } catch (RemoteException ex) {\n        }\n    }\n```\n\n总体分为两步，\n\n* installProvider 生成ContentProviderHolder对象\n* publishContentProviders 发布出去\n\n### 2.installProvider\n\n\n```\n                final java.lang.ClassLoader cl = c.getClassLoader();\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n                if (provider == null) {\n                    Slog.e(TAG, \"Failed to instantiate class \" +\n                          info.name + \" from sourceDir \" +\n                          info.applicationInfo.sourceDir);\n                    return null;\n                }\n                if (DEBUG_PROVIDER) Slog.v(\n                    TAG, \"Instantiating local provider \" + info.name);\n                // XXX Need to create the correct context for this provider.\n                localProvider.attachInfo(c, info);\n```\n\n在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现\n\n```\nContentProvider.this.onCreate();\n```\n\n### 3.query操作\n\nContext的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。\n\nquery方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个[理解ContentProvider原理](http://gityuan.com/2016/07/30/content-provider/) \n\n* 获取IContentProvider对象\n* IContentProvider的query方法\n\n\nIContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。\n\n```\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n```\ncp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"ContentProvider水文(凑四大组件)","published":1,"updated":"2017-01-06T05:30:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85xu000buaxa88v30ilx","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br>这一篇，没营养，凑数用的。</excerpt></p>\n<h3 id=\"1-ActivityThread的main方法\"><a href=\"#1-ActivityThread的main方法\" class=\"headerlink\" title=\"1. ActivityThread的main方法\"></a>1. ActivityThread的main方法</h3><ul>\n<li>我们知道android应用程序的入口是ActivityThread的main方法。</li>\n<li>ContentProvid是何时、何流程，调用的onCreate方法呢？</li>\n</ul>\n<p>ActivityThread的main方法说起。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityThread thread = new ActivityThread();</div><div class=\"line\">thread.attach(false);</div></pre></td></tr></table></figure>\n<p>在main方法中，我们能发现如上代码，attach什么？我们跟进去看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class=\"line\">final IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class=\"line\">try &#123;</div><div class=\"line\">    mgr.attachApplication(mAppThread);</div><div class=\"line\">&#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    // Ignore</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null;</div></pre></td></tr></table></figure>\n<ul>\n<li>app ProcessRecord, 进程相关信息</li>\n<li>ProviderInfo contentprovider信息</li>\n</ul>\n<p>再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!data.restrictedBackupMode) &#123;</div><div class=\"line\">    List&lt;ProviderInfo&gt; providers = data.providers;</div><div class=\"line\">    if (providers != null) &#123;</div><div class=\"line\">        installContentProviders(app, providers);</div><div class=\"line\">        // For process that contains content providers, we want to</div><div class=\"line\">        // ensure that the JIT is enabled &quot;at some point&quot;.</div><div class=\"line\">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void installContentProviders(</div><div class=\"line\">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class=\"line\">    final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</div><div class=\"line\">        new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</div><div class=\"line\"></div><div class=\"line\">    for (ProviderInfo cpi : providers) &#123;</div><div class=\"line\">        if (DEBUG_PROVIDER) &#123;</div><div class=\"line\">            StringBuilder buf = new StringBuilder(128);</div><div class=\"line\">            buf.append(&quot;Pub &quot;);</div><div class=\"line\">            buf.append(cpi.authority);</div><div class=\"line\">            buf.append(&quot;: &quot;);</div><div class=\"line\">            buf.append(cpi.name);</div><div class=\"line\">            Log.i(TAG, buf.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">        IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class=\"line\">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class=\"line\">        if (cph != null) &#123;</div><div class=\"line\">            cph.noReleaseNeeded = true;</div><div class=\"line\">            results.add(cph);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        ActivityManagerNative.getDefault().publishContentProviders(</div><div class=\"line\">            getApplicationThread(), results);</div><div class=\"line\">    &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总体分为两步，</p>\n<ul>\n<li>installProvider 生成ContentProviderHolder对象</li>\n<li>publishContentProviders 发布出去</li>\n</ul>\n<h3 id=\"2-installProvider\"><a href=\"#2-installProvider\" class=\"headerlink\" title=\"2.installProvider\"></a>2.installProvider</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">final java.lang.ClassLoader cl = c.getClassLoader();</div><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div><div class=\"line\">if (provider == null) &#123;</div><div class=\"line\">    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</div><div class=\"line\">          info.name + &quot; from sourceDir &quot; +</div><div class=\"line\">          info.applicationInfo.sourceDir);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div><div class=\"line\">if (DEBUG_PROVIDER) Slog.v(</div><div class=\"line\">    TAG, &quot;Instantiating local provider &quot; + info.name);</div><div class=\"line\">// XXX Need to create the correct context for this provider.</div><div class=\"line\">localProvider.attachInfo(c, info);</div></pre></td></tr></table></figure>\n<p>在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentProvider.this.onCreate();</div></pre></td></tr></table></figure>\n<h3 id=\"3-query操作\"><a href=\"#3-query操作\" class=\"headerlink\" title=\"3.query操作\"></a>3.query操作</h3><p>Context的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。</p>\n<p>query方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个<a href=\"http://gityuan.com/2016/07/30/content-provider/\" target=\"_blank\" rel=\"external\">理解ContentProvider原理</a> </p>\n<ul>\n<li>获取IContentProvider对象</li>\n<li>IContentProvider的query方法</li>\n</ul>\n<p>IContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div></pre></td></tr></table></figure>\n<p>cp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","excerpt":"<p><Excerpt in index | 首页摘要><br>这一篇，没营养，凑数用的。</p>\n<h3 id=\"1-ActivityThread的main方法\"><a href=\"#1-ActivityThread的main方法\" class=\"headerlink\" title=\"1. ActivityThread的main方法\"></a>1. ActivityThread的main方法</h3><ul>\n<li>我们知道android应用程序的入口是ActivityThread的main方法。</li>\n<li>ContentProvid是何时、何流程，调用的onCreate方法呢？</li>\n</ul>\n<p>ActivityThread的main方法说起。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityThread thread = new ActivityThread();</div><div class=\"line\">thread.attach(false);</div></pre></td></tr></table></figure>\n<p>在main方法中，我们能发现如上代码，attach什么？我们跟进去看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class=\"line\">final IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class=\"line\">try &#123;</div><div class=\"line\">    mgr.attachApplication(mAppThread);</div><div class=\"line\">&#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    // Ignore</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null;</div></pre></td></tr></table></figure>\n<ul>\n<li>app ProcessRecord, 进程相关信息</li>\n<li>ProviderInfo contentprovider信息</li>\n</ul>\n<p>再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!data.restrictedBackupMode) &#123;</div><div class=\"line\">    List&lt;ProviderInfo&gt; providers = data.providers;</div><div class=\"line\">    if (providers != null) &#123;</div><div class=\"line\">        installContentProviders(app, providers);</div><div class=\"line\">        // For process that contains content providers, we want to</div><div class=\"line\">        // ensure that the JIT is enabled &quot;at some point&quot;.</div><div class=\"line\">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void installContentProviders(</div><div class=\"line\">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class=\"line\">    final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</div><div class=\"line\">        new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</div><div class=\"line\"></div><div class=\"line\">    for (ProviderInfo cpi : providers) &#123;</div><div class=\"line\">        if (DEBUG_PROVIDER) &#123;</div><div class=\"line\">            StringBuilder buf = new StringBuilder(128);</div><div class=\"line\">            buf.append(&quot;Pub &quot;);</div><div class=\"line\">            buf.append(cpi.authority);</div><div class=\"line\">            buf.append(&quot;: &quot;);</div><div class=\"line\">            buf.append(cpi.name);</div><div class=\"line\">            Log.i(TAG, buf.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">        IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class=\"line\">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class=\"line\">        if (cph != null) &#123;</div><div class=\"line\">            cph.noReleaseNeeded = true;</div><div class=\"line\">            results.add(cph);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        ActivityManagerNative.getDefault().publishContentProviders(</div><div class=\"line\">            getApplicationThread(), results);</div><div class=\"line\">    &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总体分为两步，</p>\n<ul>\n<li>installProvider 生成ContentProviderHolder对象</li>\n<li>publishContentProviders 发布出去</li>\n</ul>\n<h3 id=\"2-installProvider\"><a href=\"#2-installProvider\" class=\"headerlink\" title=\"2.installProvider\"></a>2.installProvider</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">final java.lang.ClassLoader cl = c.getClassLoader();</div><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div><div class=\"line\">if (provider == null) &#123;</div><div class=\"line\">    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</div><div class=\"line\">          info.name + &quot; from sourceDir &quot; +</div><div class=\"line\">          info.applicationInfo.sourceDir);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div><div class=\"line\">if (DEBUG_PROVIDER) Slog.v(</div><div class=\"line\">    TAG, &quot;Instantiating local provider &quot; + info.name);</div><div class=\"line\">// XXX Need to create the correct context for this provider.</div><div class=\"line\">localProvider.attachInfo(c, info);</div></pre></td></tr></table></figure>\n<p>在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentProvider.this.onCreate();</div></pre></td></tr></table></figure>\n<h3 id=\"3-query操作\"><a href=\"#3-query操作\" class=\"headerlink\" title=\"3.query操作\"></a>3.query操作</h3><p>Context的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。</p>\n<p>query方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个<a href=\"http://gityuan.com/2016/07/30/content-provider/\">理解ContentProvider原理</a> </p>\n<ul>\n<li>获取IContentProvider对象</li>\n<li>IContentProvider的query方法</li>\n</ul>\n<p>IContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div></pre></td></tr></table></figure>\n<p>cp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"JNI学习笔记（三）－编译文件makefile以及cmake","date":"2016-11-29T10:38:27.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. Android.mk\n\nAndroid.mk在jni目录下，用于描述构建系统的源文件以及\nshared libraries 。文件格式如下：\n\n* 以LOCAL_PATH变量开始 \n\n\n\n\t```\nLOCAL_PATH := $(call my-dir)\n```\n* 紧接着是CLEAR_VARS变量 \n\n\t```\n\tinclude $(CLEAR_VARS) \n\t```\n* 接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。\n* 接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如\n\n\t```\n\tLOCAL_SRC_FILES := hello-jni.c \n\t```\n* 最后一行是帮助构建系统联系在一起的。\n\n\t```\ninclude $(BUILD_SHARED_LIBRARY) \n```\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := hello-jni\n\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。\n\n构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：\n\n* 以LOCAL_开始，如LOCAL_MODULE\n* 以PRIVATE_, NDK_, or APP \n* 小写字母，如 my-di\n\n如果要自定义的话，建议MY_开头。\n\n#### 2.1 NDK 默认的变量\n\n* CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 \n\n\t```\ninclude $(CLEAR_VARS) \n```\n* BUILD_SHARED_LIBRARY,告诉构建系统去收集声明的LOCAL_变量的值，然后输出成so \n\n\t```\ninclude $(BUILD_SHARED_LIBRARY)\n```\n* BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a \n\n\t```\ninclude $(BUILD_STATIC_LIBRARY) \n```\n* PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 \n\n\t```\n\tinclude $(PREBUILT_SHARED_LIBRARY) \n\t```\n* PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似\n* TARGET_ARCH 略，重点看TARGET_ARCH_ABI\n* TARGET_PLATFORM 指定当前编译的android api版本 \n\n\t```\nTARGET_PLATFORM := android-22\n```\n* TARGET_ARCH_ABI 指定cpu架构，\n\n\t```\nTARGET_ARCH_ABI := arm64-v8a\n```\n* TARGET_ABI，指定android api版本鱼abi架构\n* \n\t```\n\tTARGET_ABI := android-22-arm64-v8a\n\t```\n\n#### 2.2 Module-Description Variables 描述model的变量\n\n*  LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 \n\n\n\t\n\t```\n\tLOCAL_PATH := $(call my-dir)\n\t\n\t```\n\t注意CLEAR_VARS，并不会清除这个的值\n* LOCAL_MODULE \n* LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字\n* LOCAL_SRC_FILES 指定这个model对应的原文件\n* LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他\n* LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),\n\n\t```\n\tLOCAL_CPP_FEATURES := rtti\n\t```\n* LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径\n* LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项\n* LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries\n* LOCAL_WHOLE_STATIC_LIBRARIES  整个。\n* LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so \n\n\t```\n\tLOCAL_LDLIBS := -lz \n\t```\n* LOCAL_LDFLAGS 略，没看明白\n* LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。\n* 剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。\n\n### 3. Application.mk\n\n用于描述app需要的native model。\n\n#### 3.1 变量\n\n* APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。\n* APP_OPTIM 配置release和debug\n* APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件\n* APP_CPPFLAGS 和 APP_CFLAGS类似\n* APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效\n* APP_BUILD_SCRIPT 指定Android.mk文件\n* APP_ABI 指定abi\n* APP_PLATFORM 指定android api版本\n* APP_STL 链接其他的c＋＋支持\n* NDK_TOOLCHAIN_VERSION  gcc编译版本\n* APP_PIE \n* APP_THIN_ARCHIVE\n\n\n### 4.在Android Studio中使用 \n\n要求 Android Studio 2.2 以上。\n\n在gradle中，\n\n```\nandroid {\n  defaultConfig {  \n    externalNativeBuild {\n      cmake {\n        // 设置cmake参数 \"-DVAR_NAME=VALUE\"\n        arguments \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_TOOLCHAIN=clang\"\n      }\n    }\n    // 设置 abi\n    ndk {\n            abiFilters \"armeabi\",\"x86\",\"armeabi-v7a\"\n        }\n  }\n  buildTypes {...}\n  \n  externalNativeBuild {\n    cmake {\n    \t// CMakeLists.txt 文件路径\n    \tpath 'src/main/jni/CMakeLists.txt' \n    }\n  }\n}\n```\n\n我们需要编写的就是上面三处有注释的地方。\n\n* cmake参数 格式为 -D + Variable name ＝ Arguments 的形势\n\t* ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种\n\t* ANDROID_PLATFORM target Android platform\n\t* ANDROID_STL  cmake编译时用哪个stl，有以下种类[Helper Runtimes](https://developer.android.com/ndk/guides/cpp-support.html#hr)\n\t* ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。\n\t* ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions\n\t* ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。\n\t* ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb\n\t* NDROID_ARM_NEON build native lib 是否NONE支持\n\t* ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过\n\t* ANDROID_DISABLE_RELRO 是否只读\n\t* ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。\n* ndk abifilters\n* cmake path\n\n关于cmake 参数，[官方文档](https://developer.android.com/ndk/guides/cmake.html)\n\n### 5. CMakeLists.txt 编写\n\n\n* cmake 最小版本 ```\n\tcmake_minimum_required(VERSION 3.4.1)\t\n\t``` \n\t\t\n* \n\t```\nadd_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)\n```\n* 指定头文件路径 \n\n\t```\ninclude_directories(src/main/cpp/include/)\n``` \n\n#### 5.1 添加native api\n\n```\nfind_library( # Defines the name of the path variable that stores the\n              # location of the NDK library.\n              log-lib\n\n              # Specifies the name of the NDK library that\n              # CMake needs to locate.\n              log )\n```\n\n按照我个人的理解，\n\n* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。\n* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name\n\n然后使用target_link_libraries(native-lib,${log-lib}) 去链接咱们的本地库和ndk中带的本地库，\n\n_ _ _\n\n也可以将源代码添加进来，\n\n```\nadd_library( app-glue\n             STATIC\n             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )\n```\n* lib name\n* 类型\n* 文件路径\n\n\n#### 5.2 添加其他预先构建的libraries\n\n因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project\n\n```\nadd_library( imported-lib\n             SHARED\n             IMPORTED )\n```\n\n然后需要用set_target_properties去指定路径。\n\n```\nset_target_properties( # Specifies the target library.\n                       imported-lib\n\n                       # Specifies the parameter you want to define.\n                       PROPERTIES IMPORTED_LOCATION\n\n                       # Provides the path to the library you want to import.\n                       imported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n```\n\n* lib name\n* 指定参数\n* 指定so的路径\n\n这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。\n\n\n### 6. 总结\n有理解的不对的，大家指出，共同学习共同进步。\n\n\n\n\n\n\n\n\n\n\n\n\n_ _ _\n\n参考资料：\n\n* [Android.mk、文档](https://developer.android.com/ndk/guides/android_mk.html)\n* [Application.mk 文档](https://developer.android.com/ndk/guides/application_mk.html)\n* [Android 文档cmake 文档](https://developer.android.com/ndk/guides/cmake.html)\n* [Android studio 中介绍](https://developer.android.com/studio/projects/add-native-code.html#existing-project)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/JNI学习笔记（三）－编译文件makefile以及cmake.md","raw":"---\ntitle: JNI学习笔记（三）－编译文件makefile以及cmake\ndate: 2016-11-29 18:38:27\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. Android.mk\n\nAndroid.mk在jni目录下，用于描述构建系统的源文件以及\nshared libraries 。文件格式如下：\n\n* 以LOCAL_PATH变量开始 \n\n\n\n\t```\nLOCAL_PATH := $(call my-dir)\n```\n* 紧接着是CLEAR_VARS变量 \n\n\t```\n\tinclude $(CLEAR_VARS) \n\t```\n* 接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。\n* 接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如\n\n\t```\n\tLOCAL_SRC_FILES := hello-jni.c \n\t```\n* 最后一行是帮助构建系统联系在一起的。\n\n\t```\ninclude $(BUILD_SHARED_LIBRARY) \n```\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := hello-jni\n\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。\n\n构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：\n\n* 以LOCAL_开始，如LOCAL_MODULE\n* 以PRIVATE_, NDK_, or APP \n* 小写字母，如 my-di\n\n如果要自定义的话，建议MY_开头。\n\n#### 2.1 NDK 默认的变量\n\n* CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 \n\n\t```\ninclude $(CLEAR_VARS) \n```\n* BUILD_SHARED_LIBRARY,告诉构建系统去收集声明的LOCAL_变量的值，然后输出成so \n\n\t```\ninclude $(BUILD_SHARED_LIBRARY)\n```\n* BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a \n\n\t```\ninclude $(BUILD_STATIC_LIBRARY) \n```\n* PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 \n\n\t```\n\tinclude $(PREBUILT_SHARED_LIBRARY) \n\t```\n* PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似\n* TARGET_ARCH 略，重点看TARGET_ARCH_ABI\n* TARGET_PLATFORM 指定当前编译的android api版本 \n\n\t```\nTARGET_PLATFORM := android-22\n```\n* TARGET_ARCH_ABI 指定cpu架构，\n\n\t```\nTARGET_ARCH_ABI := arm64-v8a\n```\n* TARGET_ABI，指定android api版本鱼abi架构\n* \n\t```\n\tTARGET_ABI := android-22-arm64-v8a\n\t```\n\n#### 2.2 Module-Description Variables 描述model的变量\n\n*  LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 \n\n\n\t\n\t```\n\tLOCAL_PATH := $(call my-dir)\n\t\n\t```\n\t注意CLEAR_VARS，并不会清除这个的值\n* LOCAL_MODULE \n* LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字\n* LOCAL_SRC_FILES 指定这个model对应的原文件\n* LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他\n* LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),\n\n\t```\n\tLOCAL_CPP_FEATURES := rtti\n\t```\n* LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径\n* LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项\n* LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries\n* LOCAL_WHOLE_STATIC_LIBRARIES  整个。\n* LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so \n\n\t```\n\tLOCAL_LDLIBS := -lz \n\t```\n* LOCAL_LDFLAGS 略，没看明白\n* LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。\n* 剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。\n\n### 3. Application.mk\n\n用于描述app需要的native model。\n\n#### 3.1 变量\n\n* APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。\n* APP_OPTIM 配置release和debug\n* APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件\n* APP_CPPFLAGS 和 APP_CFLAGS类似\n* APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效\n* APP_BUILD_SCRIPT 指定Android.mk文件\n* APP_ABI 指定abi\n* APP_PLATFORM 指定android api版本\n* APP_STL 链接其他的c＋＋支持\n* NDK_TOOLCHAIN_VERSION  gcc编译版本\n* APP_PIE \n* APP_THIN_ARCHIVE\n\n\n### 4.在Android Studio中使用 \n\n要求 Android Studio 2.2 以上。\n\n在gradle中，\n\n```\nandroid {\n  defaultConfig {  \n    externalNativeBuild {\n      cmake {\n        // 设置cmake参数 \"-DVAR_NAME=VALUE\"\n        arguments \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_TOOLCHAIN=clang\"\n      }\n    }\n    // 设置 abi\n    ndk {\n            abiFilters \"armeabi\",\"x86\",\"armeabi-v7a\"\n        }\n  }\n  buildTypes {...}\n  \n  externalNativeBuild {\n    cmake {\n    \t// CMakeLists.txt 文件路径\n    \tpath 'src/main/jni/CMakeLists.txt' \n    }\n  }\n}\n```\n\n我们需要编写的就是上面三处有注释的地方。\n\n* cmake参数 格式为 -D + Variable name ＝ Arguments 的形势\n\t* ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种\n\t* ANDROID_PLATFORM target Android platform\n\t* ANDROID_STL  cmake编译时用哪个stl，有以下种类[Helper Runtimes](https://developer.android.com/ndk/guides/cpp-support.html#hr)\n\t* ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。\n\t* ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions\n\t* ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。\n\t* ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb\n\t* NDROID_ARM_NEON build native lib 是否NONE支持\n\t* ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过\n\t* ANDROID_DISABLE_RELRO 是否只读\n\t* ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。\n* ndk abifilters\n* cmake path\n\n关于cmake 参数，[官方文档](https://developer.android.com/ndk/guides/cmake.html)\n\n### 5. CMakeLists.txt 编写\n\n\n* cmake 最小版本 ```\n\tcmake_minimum_required(VERSION 3.4.1)\t\n\t``` \n\t\t\n* \n\t```\nadd_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)\n```\n* 指定头文件路径 \n\n\t```\ninclude_directories(src/main/cpp/include/)\n``` \n\n#### 5.1 添加native api\n\n```\nfind_library( # Defines the name of the path variable that stores the\n              # location of the NDK library.\n              log-lib\n\n              # Specifies the name of the NDK library that\n              # CMake needs to locate.\n              log )\n```\n\n按照我个人的理解，\n\n* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。\n* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name\n\n然后使用target_link_libraries(native-lib,${log-lib}) 去链接咱们的本地库和ndk中带的本地库，\n\n_ _ _\n\n也可以将源代码添加进来，\n\n```\nadd_library( app-glue\n             STATIC\n             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )\n```\n* lib name\n* 类型\n* 文件路径\n\n\n#### 5.2 添加其他预先构建的libraries\n\n因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project\n\n```\nadd_library( imported-lib\n             SHARED\n             IMPORTED )\n```\n\n然后需要用set_target_properties去指定路径。\n\n```\nset_target_properties( # Specifies the target library.\n                       imported-lib\n\n                       # Specifies the parameter you want to define.\n                       PROPERTIES IMPORTED_LOCATION\n\n                       # Provides the path to the library you want to import.\n                       imported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n```\n\n* lib name\n* 指定参数\n* 指定so的路径\n\n这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。\n\n\n### 6. 总结\n有理解的不对的，大家指出，共同学习共同进步。\n\n\n\n\n\n\n\n\n\n\n\n\n_ _ _\n\n参考资料：\n\n* [Android.mk、文档](https://developer.android.com/ndk/guides/android_mk.html)\n* [Application.mk 文档](https://developer.android.com/ndk/guides/application_mk.html)\n* [Android 文档cmake 文档](https://developer.android.com/ndk/guides/cmake.html)\n* [Android studio 中介绍](https://developer.android.com/studio/projects/add-native-code.html#existing-project)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"JNI学习笔记（三）－编译文件makefile以及cmake","published":1,"updated":"2017-01-06T05:32:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85xz000euaxazckuyv9l","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n</the></li>\n</ul>\n<h3 id=\"2-Android-mk\"><a href=\"#2-Android-mk\" class=\"headerlink\" title=\"2. Android.mk\"></a>2. Android.mk</h3><p>Android.mk在jni目录下，用于描述构建系统的源文件以及<br>shared libraries 。文件格式如下：</p>\n<ul>\n<li>以LOCAL_PATH变量开始 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><p>紧接着是CLEAR_VARS变量 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。</p>\n</li>\n<li><p>接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div></pre></td></tr></table></figure>\n</li>\n<li><p>最后一行是帮助构建系统联系在一起的。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。</p>\n<p>构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：</p>\n<ul>\n<li>以LOCAL_开始，如LOCAL_MODULE</li>\n<li>以PRIVATE<em>, NDK</em>, or APP </li>\n<li>小写字母，如 my-di</li>\n</ul>\n<p>如果要自定义的话，建议MY_开头。</p>\n<h4 id=\"2-1-NDK-默认的变量\"><a href=\"#2-1-NDK-默认的变量\" class=\"headerlink\" title=\"2.1 NDK 默认的变量\"></a>2.1 NDK 默认的变量</h4><ul>\n<li><p>CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_SHARED<em>LIBRARY,告诉构建系统去收集声明的LOCAL</em>变量的值，然后输出成so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_STATIC_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(PREBUILT_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似</p>\n</li>\n<li>TARGET_ARCH 略，重点看TARGET_ARCH_ABI</li>\n<li><p>TARGET_PLATFORM 指定当前编译的android api版本 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_PLATFORM := android-22</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ARCH_ABI 指定cpu架构，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ARCH_ABI := arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ABI，指定android api版本鱼abi架构</p>\n</li>\n<li>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ABI := android-22-arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-2-Module-Description-Variables-描述model的变量\"><a href=\"#2-2-Module-Description-Variables-描述model的变量\" class=\"headerlink\" title=\"2.2 Module-Description Variables 描述model的变量\"></a>2.2 Module-Description Variables 描述model的变量</h4><ul>\n<li>LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n\n注意CLEAR_VARS，并不会清除这个的值\n</code></pre><ul>\n<li>LOCAL_MODULE </li>\n<li>LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字</li>\n<li>LOCAL_SRC_FILES 指定这个model对应的原文件</li>\n<li>LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他</li>\n<li><p>LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_CPP_FEATURES := rtti</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径</p>\n</li>\n<li>LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项</li>\n<li>LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries</li>\n<li>LOCAL_WHOLE_STATIC_LIBRARIES  整个。</li>\n<li><p>LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_LDLIBS := -lz</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_LDFLAGS 略，没看明白</p>\n</li>\n<li>LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。</li>\n<li>剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。</li>\n</ul>\n<h3 id=\"3-Application-mk\"><a href=\"#3-Application-mk\" class=\"headerlink\" title=\"3. Application.mk\"></a>3. Application.mk</h3><p>用于描述app需要的native model。</p>\n<h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><ul>\n<li>APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。</li>\n<li>APP_OPTIM 配置release和debug</li>\n<li>APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件</li>\n<li>APP_CPPFLAGS 和 APP_CFLAGS类似</li>\n<li>APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效</li>\n<li>APP_BUILD_SCRIPT 指定Android.mk文件</li>\n<li>APP_ABI 指定abi</li>\n<li>APP_PLATFORM 指定android api版本</li>\n<li>APP_STL 链接其他的c＋＋支持</li>\n<li>NDK_TOOLCHAIN_VERSION  gcc编译版本</li>\n<li>APP_PIE </li>\n<li>APP_THIN_ARCHIVE</li>\n</ul>\n<h3 id=\"4-在Android-Studio中使用\"><a href=\"#4-在Android-Studio中使用\" class=\"headerlink\" title=\"4.在Android Studio中使用\"></a>4.在Android Studio中使用</h3><p>要求 Android Studio 2.2 以上。</p>\n<p>在gradle中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">  defaultConfig &#123;  </div><div class=\"line\">    externalNativeBuild &#123;</div><div class=\"line\">      cmake &#123;</div><div class=\"line\">        // 设置cmake参数 &quot;-DVAR_NAME=VALUE&quot;</div><div class=\"line\">        arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DANDROID_TOOLCHAIN=clang&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 设置 abi</div><div class=\"line\">    ndk &#123;</div><div class=\"line\">            abiFilters &quot;armeabi&quot;,&quot;x86&quot;,&quot;armeabi-v7a&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  buildTypes &#123;...&#125;</div><div class=\"line\">  </div><div class=\"line\">  externalNativeBuild &#123;</div><div class=\"line\">    cmake &#123;</div><div class=\"line\">    \t// CMakeLists.txt 文件路径</div><div class=\"line\">    \tpath &apos;src/main/jni/CMakeLists.txt&apos; </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要编写的就是上面三处有注释的地方。</p>\n<ul>\n<li>cmake参数 格式为 -D + Variable name ＝ Arguments 的形势<ul>\n<li>ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种</li>\n<li>ANDROID_PLATFORM target Android platform</li>\n<li>ANDROID_STL  cmake编译时用哪个stl，有以下种类<a href=\"https://developer.android.com/ndk/guides/cpp-support.html#hr\" target=\"_blank\" rel=\"external\">Helper Runtimes</a></li>\n<li>ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。</li>\n<li>ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions</li>\n<li>ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。</li>\n<li>ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb</li>\n<li>NDROID_ARM_NEON build native lib 是否NONE支持</li>\n<li>ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过</li>\n<li>ANDROID_DISABLE_RELRO 是否只读</li>\n<li>ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。</li>\n</ul>\n</li>\n<li>ndk abifilters</li>\n<li>cmake path</li>\n</ul>\n<p>关于cmake 参数，<a href=\"https://developer.android.com/ndk/guides/cmake.html\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<h3 id=\"5-CMakeLists-txt-编写\"><a href=\"#5-CMakeLists-txt-编写\" class=\"headerlink\" title=\"5. CMakeLists.txt 编写\"></a>5. CMakeLists.txt 编写</h3><ul>\n<li>cmake 最小版本 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tcmake_minimum_required(VERSION 3.4.1)\t</div><div class=\"line\">\t``` </div><div class=\"line\">\t\t</div><div class=\"line\">*</div></pre></td></tr></table></figure></li>\n</ul>\n<p>add_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* 指定头文件路径</div></pre></td></tr></table></figure></p>\n<p>include_directories(src/main/cpp/include/)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 5.1 添加native api</div></pre></td></tr></table></figure></p>\n<p>find_library( # Defines the name of the path variable that stores the</p>\n<pre><code># location of the NDK library.\nlog-lib\n\n# Specifies the name of the NDK library that\n# CMake needs to locate.\nlog )\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">按照我个人的理解，</div><div class=\"line\"></div><div class=\"line\">* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。</div><div class=\"line\">* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name</div><div class=\"line\"></div><div class=\"line\">然后使用target_link_libraries(native-lib,$&#123;log-lib&#125;) 去链接咱们的本地库和ndk中带的本地库，</div><div class=\"line\"></div><div class=\"line\">_ _ _</div><div class=\"line\"></div><div class=\"line\">也可以将源代码添加进来，</div></pre></td></tr></table></figure>\n<p>add_library( app-glue<br>             STATIC<br>             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">* lib name</div><div class=\"line\">* 类型</div><div class=\"line\">* 文件路径</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 5.2 添加其他预先构建的libraries</div><div class=\"line\"></div><div class=\"line\">因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project</div></pre></td></tr></table></figure></p>\n<p>add_library( imported-lib<br>             SHARED<br>             IMPORTED )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后需要用set_target_properties去指定路径。</div></pre></td></tr></table></figure></p>\n<p>set_target_properties( # Specifies the target library.<br>                       imported-lib</p>\n<pre><code># Specifies the parameter you want to define.\nPROPERTIES IMPORTED_LOCATION\n\n# Provides the path to the library you want to import.\nimported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n</code></pre><p>```</p>\n<ul>\n<li>lib name</li>\n<li>指定参数</li>\n<li>指定so的路径</li>\n</ul>\n<p>这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>有理解的不对的，大家指出，共同学习共同进步。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/ndk/guides/android_mk.html\" target=\"_blank\" rel=\"external\">Android.mk、文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/application_mk.html\" target=\"_blank\" rel=\"external\">Application.mk 文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/cmake.html\" target=\"_blank\" rel=\"external\">Android 文档cmake 文档</a></li>\n<li><a href=\"https://developer.android.com/studio/projects/add-native-code.html#existing-project\" target=\"_blank\" rel=\"external\">Android studio 中介绍</a></li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n</li>\n</ul>\n<h3 id=\"2-Android-mk\"><a href=\"#2-Android-mk\" class=\"headerlink\" title=\"2. Android.mk\"></a>2. Android.mk</h3><p>Android.mk在jni目录下，用于描述构建系统的源文件以及<br>shared libraries 。文件格式如下：</p>\n<ul>\n<li>以LOCAL_PATH变量开始 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><p>紧接着是CLEAR_VARS变量 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。</p>\n</li>\n<li><p>接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div></pre></td></tr></table></figure>\n</li>\n<li><p>最后一行是帮助构建系统联系在一起的。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。</p>\n<p>构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：</p>\n<ul>\n<li>以LOCAL_开始，如LOCAL_MODULE</li>\n<li>以PRIVATE<em>, NDK</em>, or APP </li>\n<li>小写字母，如 my-di</li>\n</ul>\n<p>如果要自定义的话，建议MY_开头。</p>\n<h4 id=\"2-1-NDK-默认的变量\"><a href=\"#2-1-NDK-默认的变量\" class=\"headerlink\" title=\"2.1 NDK 默认的变量\"></a>2.1 NDK 默认的变量</h4><ul>\n<li><p>CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_SHARED<em>LIBRARY,告诉构建系统去收集声明的LOCAL</em>变量的值，然后输出成so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_STATIC_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(PREBUILT_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似</p>\n</li>\n<li>TARGET_ARCH 略，重点看TARGET_ARCH_ABI</li>\n<li><p>TARGET_PLATFORM 指定当前编译的android api版本 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_PLATFORM := android-22</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ARCH_ABI 指定cpu架构，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ARCH_ABI := arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ABI，指定android api版本鱼abi架构</p>\n</li>\n<li>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ABI := android-22-arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-2-Module-Description-Variables-描述model的变量\"><a href=\"#2-2-Module-Description-Variables-描述model的变量\" class=\"headerlink\" title=\"2.2 Module-Description Variables 描述model的变量\"></a>2.2 Module-Description Variables 描述model的变量</h4><ul>\n<li>LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n\n注意CLEAR_VARS，并不会清除这个的值\n</code></pre><ul>\n<li>LOCAL_MODULE </li>\n<li>LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字</li>\n<li>LOCAL_SRC_FILES 指定这个model对应的原文件</li>\n<li>LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他</li>\n<li><p>LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_CPP_FEATURES := rtti</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径</p>\n</li>\n<li>LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项</li>\n<li>LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries</li>\n<li>LOCAL_WHOLE_STATIC_LIBRARIES  整个。</li>\n<li><p>LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_LDLIBS := -lz</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_LDFLAGS 略，没看明白</p>\n</li>\n<li>LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。</li>\n<li>剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。</li>\n</ul>\n<h3 id=\"3-Application-mk\"><a href=\"#3-Application-mk\" class=\"headerlink\" title=\"3. Application.mk\"></a>3. Application.mk</h3><p>用于描述app需要的native model。</p>\n<h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><ul>\n<li>APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。</li>\n<li>APP_OPTIM 配置release和debug</li>\n<li>APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件</li>\n<li>APP_CPPFLAGS 和 APP_CFLAGS类似</li>\n<li>APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效</li>\n<li>APP_BUILD_SCRIPT 指定Android.mk文件</li>\n<li>APP_ABI 指定abi</li>\n<li>APP_PLATFORM 指定android api版本</li>\n<li>APP_STL 链接其他的c＋＋支持</li>\n<li>NDK_TOOLCHAIN_VERSION  gcc编译版本</li>\n<li>APP_PIE </li>\n<li>APP_THIN_ARCHIVE</li>\n</ul>\n<h3 id=\"4-在Android-Studio中使用\"><a href=\"#4-在Android-Studio中使用\" class=\"headerlink\" title=\"4.在Android Studio中使用\"></a>4.在Android Studio中使用</h3><p>要求 Android Studio 2.2 以上。</p>\n<p>在gradle中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">  defaultConfig &#123;  </div><div class=\"line\">    externalNativeBuild &#123;</div><div class=\"line\">      cmake &#123;</div><div class=\"line\">        // 设置cmake参数 &quot;-DVAR_NAME=VALUE&quot;</div><div class=\"line\">        arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DANDROID_TOOLCHAIN=clang&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 设置 abi</div><div class=\"line\">    ndk &#123;</div><div class=\"line\">            abiFilters &quot;armeabi&quot;,&quot;x86&quot;,&quot;armeabi-v7a&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  buildTypes &#123;...&#125;</div><div class=\"line\">  </div><div class=\"line\">  externalNativeBuild &#123;</div><div class=\"line\">    cmake &#123;</div><div class=\"line\">    \t// CMakeLists.txt 文件路径</div><div class=\"line\">    \tpath &apos;src/main/jni/CMakeLists.txt&apos; </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要编写的就是上面三处有注释的地方。</p>\n<ul>\n<li>cmake参数 格式为 -D + Variable name ＝ Arguments 的形势<ul>\n<li>ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种</li>\n<li>ANDROID_PLATFORM target Android platform</li>\n<li>ANDROID_STL  cmake编译时用哪个stl，有以下种类<a href=\"https://developer.android.com/ndk/guides/cpp-support.html#hr\">Helper Runtimes</a></li>\n<li>ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。</li>\n<li>ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions</li>\n<li>ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。</li>\n<li>ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb</li>\n<li>NDROID_ARM_NEON build native lib 是否NONE支持</li>\n<li>ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过</li>\n<li>ANDROID_DISABLE_RELRO 是否只读</li>\n<li>ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。</li>\n</ul>\n</li>\n<li>ndk abifilters</li>\n<li>cmake path</li>\n</ul>\n<p>关于cmake 参数，<a href=\"https://developer.android.com/ndk/guides/cmake.html\">官方文档</a></p>\n<h3 id=\"5-CMakeLists-txt-编写\"><a href=\"#5-CMakeLists-txt-编写\" class=\"headerlink\" title=\"5. CMakeLists.txt 编写\"></a>5. CMakeLists.txt 编写</h3><ul>\n<li>cmake 最小版本 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tcmake_minimum_required(VERSION 3.4.1)\t</div><div class=\"line\">\t``` </div><div class=\"line\">\t\t</div><div class=\"line\">*</div></pre></td></tr></table></figure></li>\n</ul>\n<p>add_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* 指定头文件路径</div></pre></td></tr></table></figure></p>\n<p>include_directories(src/main/cpp/include/)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 5.1 添加native api</div></pre></td></tr></table></figure></p>\n<p>find_library( # Defines the name of the path variable that stores the</p>\n<pre><code># location of the NDK library.\nlog-lib\n\n# Specifies the name of the NDK library that\n# CMake needs to locate.\nlog )\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">按照我个人的理解，</div><div class=\"line\"></div><div class=\"line\">* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。</div><div class=\"line\">* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name</div><div class=\"line\"></div><div class=\"line\">然后使用target_link_libraries(native-lib,$&#123;log-lib&#125;) 去链接咱们的本地库和ndk中带的本地库，</div><div class=\"line\"></div><div class=\"line\">_ _ _</div><div class=\"line\"></div><div class=\"line\">也可以将源代码添加进来，</div></pre></td></tr></table></figure>\n<p>add_library( app-glue<br>             STATIC<br>             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">* lib name</div><div class=\"line\">* 类型</div><div class=\"line\">* 文件路径</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 5.2 添加其他预先构建的libraries</div><div class=\"line\"></div><div class=\"line\">因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project</div></pre></td></tr></table></figure></p>\n<p>add_library( imported-lib<br>             SHARED<br>             IMPORTED )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后需要用set_target_properties去指定路径。</div></pre></td></tr></table></figure></p>\n<p>set_target_properties( # Specifies the target library.<br>                       imported-lib</p>\n<pre><code># Specifies the parameter you want to define.\nPROPERTIES IMPORTED_LOCATION\n\n# Provides the path to the library you want to import.\nimported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n</code></pre><p>```</p>\n<ul>\n<li>lib name</li>\n<li>指定参数</li>\n<li>指定so的路径</li>\n</ul>\n<p>这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>有理解的不对的，大家指出，共同学习共同进步。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/ndk/guides/android_mk.html\">Android.mk、文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/application_mk.html\">Application.mk 文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/cmake.html\">Android 文档cmake 文档</a></li>\n<li><a href=\"https://developer.android.com/studio/projects/add-native-code.html#existing-project\">Android studio 中介绍</a></li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"layout":"android","title":"JNI学习笔记（二）－动态注册native函数","date":"2016-11-29T08:33:30.000Z","_content":"<Excerpt in index | 首页摘要> \n\n### 1.前言\n\n在很久之前的一篇[Android 开发艺术探索的笔记](http://blog.csdn.net/qq_21430549/article/details/49535483)当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. 首先声明native函数\n\n现在，我在activity里声明了一个native函数。\n\n```\npublic native String getStringFromC();\n```\n\n然后我们build一下，为啥要build呢，这个马上就说的。\n\n### 3. 创建并编写 .h头文件\n\n创建jni目录，并且右键->new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。\n\n```\n#ifndef NDK_CORE_H\n#define NDK_CORE_H\n\n#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))\n\n#include <jni.h>\n#include <stdlib.h>\n\n__BEGIN_DECLS\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);\nJNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);\n\n\n__END_DECLS\n\n#endif //TEXT_HELLO_H\n\n```\n\n代码说明如下：\n\n*  我们定义了一个宏NELEM，后面会用到\n*  我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，\n\n### 4. 编写cpp文件\n\n代码如下：\n\n```\njstring returnString(JNIEnv *env,jobject jobj){\n  char* str = \"I come from C＋＋\";\n  return env->NewStringUTF(str);\n}\n\nstatic JNINativeMethod gMethods[] = {\n    {\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n};\n\nJNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) {\n  JNIEnv *env;\n  if (vm->GetEnv((void **) &env,JNI_VERSION_1_6) != JNI_OK){\n    return JNI_ERR;\n  }\n\n  jclass javaClass = env->FindClass(\"com/example/hello_jni/MainActivity\");\n  if (javaClass == NULL){\n    return JNI_ERR;\n  }\n  if (env->RegisterNatives(javaClass,gMethods,NELEM(gMethods)) < 0) {\n    return JNI_ERR;\n  }\n\n  return JNI_VERSION_1_6;\n}\n```\n先看JNI_OnLoad方法，这是注册native函数的地方。\n\n*  首先判断jni版本是不是JNI_VERSION_1_6\n*  FindClass方法找到我们对应生命native函数的类，返回一个jclass\n*  RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，\n\n就这样，我们就注册了native函数了。接下来我们看下gMethods。\n\n### 5. JNINativeMethod数组\n\n这个数组里存放着这样的元素。\n\n```\n{\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n```\n\n* 第一个参数对应的native方法名\n* 第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。\n![这里写图片描述](http://img.blog.csdn.net/20161126110049266)\n* 第三个参数对应的是我嗯c++代码里对应的实现\n\n最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。\n\nandroid.mk\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := hello-jni\n\nLOCAL_C_INCLUDES += $(LOCAL_PATH)\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\napplication.mk\n\n```\nAPP_ABI := armeabi x86\nAPP_PLATFORM := android-14\nAPP_STL := stlport_static\nAPP_OPTIM := debug\n```\n\ngradle 配置\n\n![这里写图片描述](http://img.blog.csdn.net/20161126110601745)\n\n最后就会生出so文件了。(会自动打包进apk里)\n![这里写图片描述](http://img.blog.csdn.net/20161126110719106)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/JNI学习笔记（二）－动态注册native函数.md","raw":"layout: android\ntitle: JNI学习笔记（二）－动态注册native函数\ndate: 2016-11-29 16:33:30\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要> \n\n### 1.前言\n\n在很久之前的一篇[Android 开发艺术探索的笔记](http://blog.csdn.net/qq_21430549/article/details/49535483)当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. 首先声明native函数\n\n现在，我在activity里声明了一个native函数。\n\n```\npublic native String getStringFromC();\n```\n\n然后我们build一下，为啥要build呢，这个马上就说的。\n\n### 3. 创建并编写 .h头文件\n\n创建jni目录，并且右键->new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。\n\n```\n#ifndef NDK_CORE_H\n#define NDK_CORE_H\n\n#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))\n\n#include <jni.h>\n#include <stdlib.h>\n\n__BEGIN_DECLS\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);\nJNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);\n\n\n__END_DECLS\n\n#endif //TEXT_HELLO_H\n\n```\n\n代码说明如下：\n\n*  我们定义了一个宏NELEM，后面会用到\n*  我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，\n\n### 4. 编写cpp文件\n\n代码如下：\n\n```\njstring returnString(JNIEnv *env,jobject jobj){\n  char* str = \"I come from C＋＋\";\n  return env->NewStringUTF(str);\n}\n\nstatic JNINativeMethod gMethods[] = {\n    {\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n};\n\nJNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) {\n  JNIEnv *env;\n  if (vm->GetEnv((void **) &env,JNI_VERSION_1_6) != JNI_OK){\n    return JNI_ERR;\n  }\n\n  jclass javaClass = env->FindClass(\"com/example/hello_jni/MainActivity\");\n  if (javaClass == NULL){\n    return JNI_ERR;\n  }\n  if (env->RegisterNatives(javaClass,gMethods,NELEM(gMethods)) < 0) {\n    return JNI_ERR;\n  }\n\n  return JNI_VERSION_1_6;\n}\n```\n先看JNI_OnLoad方法，这是注册native函数的地方。\n\n*  首先判断jni版本是不是JNI_VERSION_1_6\n*  FindClass方法找到我们对应生命native函数的类，返回一个jclass\n*  RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，\n\n就这样，我们就注册了native函数了。接下来我们看下gMethods。\n\n### 5. JNINativeMethod数组\n\n这个数组里存放着这样的元素。\n\n```\n{\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n```\n\n* 第一个参数对应的native方法名\n* 第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。\n![这里写图片描述](http://img.blog.csdn.net/20161126110049266)\n* 第三个参数对应的是我嗯c++代码里对应的实现\n\n最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。\n\nandroid.mk\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := hello-jni\n\nLOCAL_C_INCLUDES += $(LOCAL_PATH)\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\napplication.mk\n\n```\nAPP_ABI := armeabi x86\nAPP_PLATFORM := android-14\nAPP_STL := stlport_static\nAPP_OPTIM := debug\n```\n\ngradle 配置\n\n![这里写图片描述](http://img.blog.csdn.net/20161126110601745)\n\n最后就会生出so文件了。(会自动打包进apk里)\n![这里写图片描述](http://img.blog.csdn.net/20161126110719106)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"JNI学习笔记（二）－动态注册native函数","published":1,"updated":"2017-01-06T05:31:58.000Z","comments":1,"photos":[],"link":"","_id":"cixld85y2000juaxatrvk3ry9","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"> \n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在很久之前的一篇<a href=\"http://blog.csdn.net/qq_21430549/article/details/49535483\" target=\"_blank\" rel=\"external\">Android 开发艺术探索的笔记</a>当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n</the></li>\n</ul>\n<h3 id=\"2-首先声明native函数\"><a href=\"#2-首先声明native函数\" class=\"headerlink\" title=\"2. 首先声明native函数\"></a>2. 首先声明native函数</h3><p>现在，我在activity里声明了一个native函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public native String getStringFromC();</div></pre></td></tr></table></figure>\n<p>然后我们build一下，为啥要build呢，这个马上就说的。</p>\n<h3 id=\"3-创建并编写-h头文件\"><a href=\"#3-创建并编写-h头文件\" class=\"headerlink\" title=\"3. 创建并编写 .h头文件\"></a>3. 创建并编写 .h头文件</h3><p>创建jni目录，并且右键-&gt;new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef NDK_CORE_H</div><div class=\"line\">#define NDK_CORE_H</div><div class=\"line\"></div><div class=\"line\">#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))</div><div class=\"line\"></div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\"></div><div class=\"line\">__BEGIN_DECLS</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);</div><div class=\"line\">JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">__END_DECLS</div><div class=\"line\"></div><div class=\"line\">#endif //TEXT_HELLO_H</div></pre></td></tr></table></figure>\n<p>代码说明如下：</p>\n<ul>\n<li>我们定义了一个宏NELEM，后面会用到</li>\n<li>我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，</li>\n</ul>\n<h3 id=\"4-编写cpp文件\"><a href=\"#4-编写cpp文件\" class=\"headerlink\" title=\"4. 编写cpp文件\"></a>4. 编写cpp文件</h3><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">jstring returnString(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;I come from C＋＋&quot;;</div><div class=\"line\">  return env-&gt;NewStringUTF(str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">    &#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) &#123;</div><div class=\"line\">  JNIEnv *env;</div><div class=\"line\">  if (vm-&gt;GetEnv((void **) &amp;env,JNI_VERSION_1_6) != JNI_OK)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jclass javaClass = env-&gt;FindClass(&quot;com/example/hello_jni/MainActivity&quot;);</div><div class=\"line\">  if (javaClass == NULL)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (env-&gt;RegisterNatives(javaClass,gMethods,NELEM(gMethods)) &lt; 0) &#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return JNI_VERSION_1_6;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先看JNI_OnLoad方法，这是注册native函数的地方。</p>\n<ul>\n<li>首先判断jni版本是不是JNI_VERSION_1_6</li>\n<li>FindClass方法找到我们对应生命native函数的类，返回一个jclass</li>\n<li>RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，</li>\n</ul>\n<p>就这样，我们就注册了native函数了。接下来我们看下gMethods。</p>\n<h3 id=\"5-JNINativeMethod数组\"><a href=\"#5-JNINativeMethod数组\" class=\"headerlink\" title=\"5. JNINativeMethod数组\"></a>5. JNINativeMethod数组</h3><p>这个数组里存放着这样的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数对应的native方法名</li>\n<li>第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。<br><img src=\"http://img.blog.csdn.net/20161126110049266\" alt=\"这里写图片描述\"></li>\n<li>第三个参数对应的是我嗯c++代码里对应的实现</li>\n</ul>\n<p>最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。</p>\n<p>android.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_C_INCLUDES += $(LOCAL_PATH)</div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>application.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP_ABI := armeabi x86</div><div class=\"line\">APP_PLATFORM := android-14</div><div class=\"line\">APP_STL := stlport_static</div><div class=\"line\">APP_OPTIM := debug</div></pre></td></tr></table></figure>\n<p>gradle 配置</p>\n<p><img src=\"http://img.blog.csdn.net/20161126110601745\" alt=\"这里写图片描述\"></p>\n<p>最后就会生出so文件了。(会自动打包进apk里)<br><img src=\"http://img.blog.csdn.net/20161126110719106\" alt=\"这里写图片描述\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n</excerpt>","excerpt":"<Excerpt in index | 首页摘要> \n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在很久之前的一篇<a href=\"http://blog.csdn.net/qq_21430549/article/details/49535483\">Android 开发艺术探索的笔记</a>当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n</li>\n</ul>\n<h3 id=\"2-首先声明native函数\"><a href=\"#2-首先声明native函数\" class=\"headerlink\" title=\"2. 首先声明native函数\"></a>2. 首先声明native函数</h3><p>现在，我在activity里声明了一个native函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public native String getStringFromC();</div></pre></td></tr></table></figure>\n<p>然后我们build一下，为啥要build呢，这个马上就说的。</p>\n<h3 id=\"3-创建并编写-h头文件\"><a href=\"#3-创建并编写-h头文件\" class=\"headerlink\" title=\"3. 创建并编写 .h头文件\"></a>3. 创建并编写 .h头文件</h3><p>创建jni目录，并且右键-&gt;new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef NDK_CORE_H</div><div class=\"line\">#define NDK_CORE_H</div><div class=\"line\"></div><div class=\"line\">#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))</div><div class=\"line\"></div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\"></div><div class=\"line\">__BEGIN_DECLS</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);</div><div class=\"line\">JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">__END_DECLS</div><div class=\"line\"></div><div class=\"line\">#endif //TEXT_HELLO_H</div></pre></td></tr></table></figure>\n<p>代码说明如下：</p>\n<ul>\n<li>我们定义了一个宏NELEM，后面会用到</li>\n<li>我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，</li>\n</ul>\n<h3 id=\"4-编写cpp文件\"><a href=\"#4-编写cpp文件\" class=\"headerlink\" title=\"4. 编写cpp文件\"></a>4. 编写cpp文件</h3><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">jstring returnString(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;I come from C＋＋&quot;;</div><div class=\"line\">  return env-&gt;NewStringUTF(str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">    &#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) &#123;</div><div class=\"line\">  JNIEnv *env;</div><div class=\"line\">  if (vm-&gt;GetEnv((void **) &amp;env,JNI_VERSION_1_6) != JNI_OK)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jclass javaClass = env-&gt;FindClass(&quot;com/example/hello_jni/MainActivity&quot;);</div><div class=\"line\">  if (javaClass == NULL)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (env-&gt;RegisterNatives(javaClass,gMethods,NELEM(gMethods)) &lt; 0) &#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return JNI_VERSION_1_6;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先看JNI_OnLoad方法，这是注册native函数的地方。</p>\n<ul>\n<li>首先判断jni版本是不是JNI_VERSION_1_6</li>\n<li>FindClass方法找到我们对应生命native函数的类，返回一个jclass</li>\n<li>RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，</li>\n</ul>\n<p>就这样，我们就注册了native函数了。接下来我们看下gMethods。</p>\n<h3 id=\"5-JNINativeMethod数组\"><a href=\"#5-JNINativeMethod数组\" class=\"headerlink\" title=\"5. JNINativeMethod数组\"></a>5. JNINativeMethod数组</h3><p>这个数组里存放着这样的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数对应的native方法名</li>\n<li>第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。<br><img src=\"http://img.blog.csdn.net/20161126110049266\" alt=\"这里写图片描述\"></li>\n<li>第三个参数对应的是我嗯c++代码里对应的实现</li>\n</ul>\n<p>最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。</p>\n<p>android.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_C_INCLUDES += $(LOCAL_PATH)</div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>application.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP_ABI := armeabi x86</div><div class=\"line\">APP_PLATFORM := android-14</div><div class=\"line\">APP_STL := stlport_static</div><div class=\"line\">APP_OPTIM := debug</div></pre></td></tr></table></figure>\n<p>gradle 配置</p>\n<p><img src=\"http://img.blog.csdn.net/20161126110601745\" alt=\"这里写图片描述\"></p>\n<p>最后就会生出so文件了。(会自动打包进apk里)<br><img src=\"http://img.blog.csdn.net/20161126110719106\" alt=\"这里写图片描述\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android消息机制－native层","date":"2016-12-24T08:25:04.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2.初始化\n\n在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。\n\n首先，我们先看下方法表：\n\n```\nstatic JNINativeMethod gMessageQueueMethods[] = {\n    /* name, signature, funcPtr */\n    { \"nativeInit\", \"()J\", (void*)android_os_MessageQueue_nativeInit },\n    { \"nativeDestroy\", \"(J)V\", (void*)android_os_MessageQueue_nativeDestroy },\n    { \"nativePollOnce\", \"(JI)V\", (void*)android_os_MessageQueue_nativePollOnce },\n    { \"nativeWake\", \"(J)V\", (void*)android_os_MessageQueue_nativeWake },\n    { \"nativeIsPolling\", \"(J)Z\", (void*)android_os_MessageQueue_nativeIsPolling },\n    { \"nativeSetFileDescriptorEvents\", \"(JII)V\",\n            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },\n};\n```\n\n\n因为前面有介绍jni的相关知识，这里就不多说了。\n\n从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.\n\n```\nstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n    if (!nativeMessageQueue) {\n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");\n        return 0;\n    }\n\n    nativeMessageQueue->incStrong(env);\n    return reinterpret_cast<jlong>(nativeMessageQueue);\n}\n```\n\n\n* 初始化NativeMessageQueue\n* 并且返回给java层，也就是java层的mPtr\n\n那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。\n\n```\nNativeMessageQueue::NativeMessageQueue() :\n        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n        mLooper = new Looper(false);\n        Looper::setForThread(mLooper);\n    }\n}\n```\n\n* 构造native层的looper，注意，这个和java层的没有任何关系\n* 保存在类似ThreadLocal一样的结构里。\n\nLooper的构造函数在Looper.cpp中。\n\n```\nLooper::Looper(bool allowNonCallbacks) :\n        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),\n        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),\n        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {\n    mWakeEventFd = eventfd(0, EFD_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(mWakeEventFd < 0, \"Could not make wake event fd.  errno=%d\", errno);\n\n    AutoMutex _l(mLock);\n    rebuildEpollLocked();\n}\n```\n\n* eventfd构造欢迎时间的fd\n* rebuildEpollLocked 重建epoll\n\nepoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：\n\n* 监视的描述符数量不受限制\n* IO效率不会随着监视fd的数量增长而下降\n\n关于epoll的更多内容，这里就不介绍了。\n\n那么，在我们native的looper里面，是如何重建的呢？\n\n```\nvoid Looper::rebuildEpollLocked() {\n    // Close old epoll instance if we have one.\n    if (mEpollFd >= 0) {\n#if DEBUG_CALLBACKS\n        ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);\n#endif\n        close(mEpollFd);\n    }\n\n    // Allocate the new epoll instance and register the wake pipe.\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance.  errno=%d\", errno);\n\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;\n    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance.  errno=%d\",\n            errno);\n\n    for (size_t i = 0; i < mRequests.size(); i++) {\n        const Request& request = mRequests.valueAt(i);\n        struct epoll_event eventItem;\n        request.initEventItem(&eventItem);\n\n        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, & eventItem);\n        if (epollResult < 0) {\n            ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d\",\n                    request.fd, errno);\n        }\n    }\n}\n```\n\n* epoll_create，创建epoll句柄\n* memset 将数据区域至0\n* eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。\n* epoll_ctl添加唤醒事件\n* 循环将mRequests中的事件都添加进去。\n\n### 3. nativePollOnce\n\n在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。\n\nandroid_os_MessageQueue_nativePollOnce->pollOnce->Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)\n\n\n\n```\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != NULL) *outFd = fd;\n                if (outEvents != NULL) *outEvents = events;\n                if (outData != NULL) *outData = data;\n                return ident;\n            }\n        }\n\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != NULL) *outFd = 0;\n            if (outEvents != NULL) *outEvents = 0;\n            if (outData != NULL) *outData = NULL;\n            return result;\n        }\n\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n这个方法的参数含义：\n\n* timeoutMillis 超时等待时间，-1无限等待，0立即返回\n* outFd 发生事件的文件描述符\n* outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,\n* outData 存储上下文数据\n\n返回值的含义如下：\n\n* ALOOPER_POLL_WAKE 表示由wake触发\n* ALOOPER_POLL_TIMEOUT 等待超时\n* ALOOPER_POLL_ERROR 等待过程中发生错误\n* ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发\n\n这个方法的处理逻辑如下：\n\n* 先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)\n* pollInner 处理内部轮询\n\n\npollInner方法很长，\n\n* toMillisecondTimeoutDelay 重新计算超时时间\n* epoll_wait 等待\n* 如果需要，重建epoll\n* epoll_wait函数返回，三种情况\n\t* eventCount<0 发生错误，goto Done\n\t* eventCount=0 连接超时 goto Done\n\t* 监听到有事件发生，\n* 如果有事件发生，则循环处理\n\t* 如果是mWakeEventFd，则进行awoken唤醒\n\t* pushResponse，根据request构建response，并添加到response数组中\n* Done 标志，事件处理\n\t* handleMessage 先处理native的message\n\t* handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。 \t\n\t\n\n### 4.nativeWake\n\n同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。\n\n在native层通过层层调用，会调用到looper的wake方法中。\n\n```\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(\"Could not write wake signal, errno=%d\", errno);\n        }\n    }\n}\n``` \n\n* 向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。\n\n### 补充\n\n\n当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/Android消息机制－native层.md","raw":"---\ntitle: Android消息机制－native层\ndate: 2016-12-24 16:25:04\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2.初始化\n\n在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。\n\n首先，我们先看下方法表：\n\n```\nstatic JNINativeMethod gMessageQueueMethods[] = {\n    /* name, signature, funcPtr */\n    { \"nativeInit\", \"()J\", (void*)android_os_MessageQueue_nativeInit },\n    { \"nativeDestroy\", \"(J)V\", (void*)android_os_MessageQueue_nativeDestroy },\n    { \"nativePollOnce\", \"(JI)V\", (void*)android_os_MessageQueue_nativePollOnce },\n    { \"nativeWake\", \"(J)V\", (void*)android_os_MessageQueue_nativeWake },\n    { \"nativeIsPolling\", \"(J)Z\", (void*)android_os_MessageQueue_nativeIsPolling },\n    { \"nativeSetFileDescriptorEvents\", \"(JII)V\",\n            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },\n};\n```\n\n\n因为前面有介绍jni的相关知识，这里就不多说了。\n\n从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.\n\n```\nstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n    if (!nativeMessageQueue) {\n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");\n        return 0;\n    }\n\n    nativeMessageQueue->incStrong(env);\n    return reinterpret_cast<jlong>(nativeMessageQueue);\n}\n```\n\n\n* 初始化NativeMessageQueue\n* 并且返回给java层，也就是java层的mPtr\n\n那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。\n\n```\nNativeMessageQueue::NativeMessageQueue() :\n        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n        mLooper = new Looper(false);\n        Looper::setForThread(mLooper);\n    }\n}\n```\n\n* 构造native层的looper，注意，这个和java层的没有任何关系\n* 保存在类似ThreadLocal一样的结构里。\n\nLooper的构造函数在Looper.cpp中。\n\n```\nLooper::Looper(bool allowNonCallbacks) :\n        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),\n        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),\n        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {\n    mWakeEventFd = eventfd(0, EFD_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(mWakeEventFd < 0, \"Could not make wake event fd.  errno=%d\", errno);\n\n    AutoMutex _l(mLock);\n    rebuildEpollLocked();\n}\n```\n\n* eventfd构造欢迎时间的fd\n* rebuildEpollLocked 重建epoll\n\nepoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：\n\n* 监视的描述符数量不受限制\n* IO效率不会随着监视fd的数量增长而下降\n\n关于epoll的更多内容，这里就不介绍了。\n\n那么，在我们native的looper里面，是如何重建的呢？\n\n```\nvoid Looper::rebuildEpollLocked() {\n    // Close old epoll instance if we have one.\n    if (mEpollFd >= 0) {\n#if DEBUG_CALLBACKS\n        ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);\n#endif\n        close(mEpollFd);\n    }\n\n    // Allocate the new epoll instance and register the wake pipe.\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance.  errno=%d\", errno);\n\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;\n    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance.  errno=%d\",\n            errno);\n\n    for (size_t i = 0; i < mRequests.size(); i++) {\n        const Request& request = mRequests.valueAt(i);\n        struct epoll_event eventItem;\n        request.initEventItem(&eventItem);\n\n        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, & eventItem);\n        if (epollResult < 0) {\n            ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d\",\n                    request.fd, errno);\n        }\n    }\n}\n```\n\n* epoll_create，创建epoll句柄\n* memset 将数据区域至0\n* eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。\n* epoll_ctl添加唤醒事件\n* 循环将mRequests中的事件都添加进去。\n\n### 3. nativePollOnce\n\n在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。\n\nandroid_os_MessageQueue_nativePollOnce->pollOnce->Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)\n\n\n\n```\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != NULL) *outFd = fd;\n                if (outEvents != NULL) *outEvents = events;\n                if (outData != NULL) *outData = data;\n                return ident;\n            }\n        }\n\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != NULL) *outFd = 0;\n            if (outEvents != NULL) *outEvents = 0;\n            if (outData != NULL) *outData = NULL;\n            return result;\n        }\n\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n这个方法的参数含义：\n\n* timeoutMillis 超时等待时间，-1无限等待，0立即返回\n* outFd 发生事件的文件描述符\n* outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,\n* outData 存储上下文数据\n\n返回值的含义如下：\n\n* ALOOPER_POLL_WAKE 表示由wake触发\n* ALOOPER_POLL_TIMEOUT 等待超时\n* ALOOPER_POLL_ERROR 等待过程中发生错误\n* ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发\n\n这个方法的处理逻辑如下：\n\n* 先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)\n* pollInner 处理内部轮询\n\n\npollInner方法很长，\n\n* toMillisecondTimeoutDelay 重新计算超时时间\n* epoll_wait 等待\n* 如果需要，重建epoll\n* epoll_wait函数返回，三种情况\n\t* eventCount<0 发生错误，goto Done\n\t* eventCount=0 连接超时 goto Done\n\t* 监听到有事件发生，\n* 如果有事件发生，则循环处理\n\t* 如果是mWakeEventFd，则进行awoken唤醒\n\t* pushResponse，根据request构建response，并添加到response数组中\n* Done 标志，事件处理\n\t* handleMessage 先处理native的message\n\t* handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。 \t\n\t\n\n### 4.nativeWake\n\n同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。\n\n在native层通过层层调用，会调用到looper的wake方法中。\n\n```\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(\"Could not write wake signal, errno=%d\", errno);\n        }\n    }\n}\n``` \n\n* 向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。\n\n### 补充\n\n\n当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"Android消息机制－native层","published":1,"updated":"2017-01-06T05:29:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85y4000muaxasbjb2906","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n</the></li>\n</ul>\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><p>在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。</p>\n<p>首先，我们先看下方法表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class=\"line\">    /* name, signature, funcPtr */</div><div class=\"line\">    &#123; &quot;nativeInit&quot;, &quot;()J&quot;, (void*)android_os_MessageQueue_nativeInit &#125;,</div><div class=\"line\">    &#123; &quot;nativeDestroy&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class=\"line\">    &#123; &quot;nativePollOnce&quot;, &quot;(JI)V&quot;, (void*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class=\"line\">    &#123; &quot;nativeWake&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeWake &#125;,</div><div class=\"line\">    &#123; &quot;nativeIsPolling&quot;, &quot;(J)Z&quot;, (void*)android_os_MessageQueue_nativeIsPolling &#125;,</div><div class=\"line\">    &#123; &quot;nativeSetFileDescriptorEvents&quot;, &quot;(JII)V&quot;,</div><div class=\"line\">            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>因为前面有介绍jni的相关知识，这里就不多说了。</p>\n<p>从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</div><div class=\"line\">    if (!nativeMessageQueue) &#123;</div><div class=\"line\">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    nativeMessageQueue-&gt;incStrong(env);</div><div class=\"line\">    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化NativeMessageQueue</li>\n<li>并且返回给java层，也就是java层的mPtr</li>\n</ul>\n<p>那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMessageQueue::NativeMessageQueue() :</div><div class=\"line\">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</div><div class=\"line\">    mLooper = Looper::getForThread();</div><div class=\"line\">    if (mLooper == NULL) &#123;</div><div class=\"line\">        mLooper = new Looper(false);</div><div class=\"line\">        Looper::setForThread(mLooper);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造native层的looper，注意，这个和java层的没有任何关系</li>\n<li>保存在类似ThreadLocal一样的结构里。</li>\n</ul>\n<p>Looper的构造函数在Looper.cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper::Looper(bool allowNonCallbacks) :</div><div class=\"line\">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</div><div class=\"line\">        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),</div><div class=\"line\">        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</div><div class=\"line\">    mWakeEventFd = eventfd(0, EFD_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, &quot;Could not make wake event fd.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\">    rebuildEpollLocked();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>eventfd构造欢迎时间的fd</li>\n<li>rebuildEpollLocked 重建epoll</li>\n</ul>\n<p>epoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：</p>\n<ul>\n<li>监视的描述符数量不受限制</li>\n<li>IO效率不会随着监视fd的数量增长而下降</li>\n</ul>\n<p>关于epoll的更多内容，这里就不介绍了。</p>\n<p>那么，在我们native的looper里面，是如何重建的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Looper::rebuildEpollLocked() &#123;</div><div class=\"line\">    // Close old epoll instance if we have one.</div><div class=\"line\">    if (mEpollFd &gt;= 0) &#123;</div><div class=\"line\">#if DEBUG_CALLBACKS</div><div class=\"line\">        ALOGD(&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;, this);</div><div class=\"line\">#endif</div><div class=\"line\">        close(mEpollFd);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Allocate the new epoll instance and register the wake pipe.</div><div class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    struct epoll_event eventItem;</div><div class=\"line\">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</div><div class=\"line\">    eventItem.events = EPOLLIN;</div><div class=\"line\">    eventItem.data.fd = mWakeEventFd;</div><div class=\"line\">    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; mRequests.size(); i++) &#123;</div><div class=\"line\">        const Request&amp; request = mRequests.valueAt(i);</div><div class=\"line\">        struct epoll_event eventItem;</div><div class=\"line\">        request.initEventItem(&amp;eventItem);</div><div class=\"line\"></div><div class=\"line\">        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</div><div class=\"line\">        if (epollResult &lt; 0) &#123;</div><div class=\"line\">            ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set, errno=%d&quot;,</div><div class=\"line\">                    request.fd, errno);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>epoll_create，创建epoll句柄</li>\n<li>memset 将数据区域至0</li>\n<li>eventItem.events = EPOLLIN;<br>  eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。</li>\n<li>epoll_ctl添加唤醒事件</li>\n<li>循环将mRequests中的事件都添加进去。</li>\n</ul>\n<h3 id=\"3-nativePollOnce\"><a href=\"#3-nativePollOnce\" class=\"headerlink\" title=\"3. nativePollOnce\"></a>3. nativePollOnce</h3><p>在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。</p>\n<p>android_os_MessageQueue_nativePollOnce-&gt;pollOnce-&gt;Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class=\"line\">    int result = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class=\"line\">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class=\"line\">            int ident = response.request.ident;</div><div class=\"line\">            if (ident &gt;= 0) &#123;</div><div class=\"line\">                int fd = response.request.fd;</div><div class=\"line\">                int events = response.events;</div><div class=\"line\">                void* data = response.request.data;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class=\"line\">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class=\"line\">                        this, ident, fd, events, data);</div><div class=\"line\">#endif</div><div class=\"line\">                if (outFd != NULL) *outFd = fd;</div><div class=\"line\">                if (outEvents != NULL) *outEvents = events;</div><div class=\"line\">                if (outData != NULL) *outData = data;</div><div class=\"line\">                return ident;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (result != 0) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class=\"line\">#endif</div><div class=\"line\">            if (outFd != NULL) *outFd = 0;</div><div class=\"line\">            if (outEvents != NULL) *outEvents = 0;</div><div class=\"line\">            if (outData != NULL) *outData = NULL;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        result = pollInner(timeoutMillis);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的参数含义：</p>\n<ul>\n<li>timeoutMillis 超时等待时间，-1无限等待，0立即返回</li>\n<li>outFd 发生事件的文件描述符</li>\n<li>outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,</li>\n<li>outData 存储上下文数据</li>\n</ul>\n<p>返回值的含义如下：</p>\n<ul>\n<li>ALOOPER_POLL_WAKE 表示由wake触发</li>\n<li>ALOOPER_POLL_TIMEOUT 等待超时</li>\n<li>ALOOPER_POLL_ERROR 等待过程中发生错误</li>\n<li>ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发</li>\n</ul>\n<p>这个方法的处理逻辑如下：</p>\n<ul>\n<li>先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)</li>\n<li>pollInner 处理内部轮询</li>\n</ul>\n<p>pollInner方法很长，</p>\n<ul>\n<li>toMillisecondTimeoutDelay 重新计算超时时间</li>\n<li>epoll_wait 等待</li>\n<li>如果需要，重建epoll</li>\n<li>epoll_wait函数返回，三种情况<ul>\n<li>eventCount&lt;0 发生错误，goto Done</li>\n<li>eventCount=0 连接超时 goto Done</li>\n<li>监听到有事件发生，</li>\n</ul>\n</li>\n<li>如果有事件发生，则循环处理<ul>\n<li>如果是mWakeEventFd，则进行awoken唤醒</li>\n<li>pushResponse，根据request构建response，并添加到response数组中</li>\n</ul>\n</li>\n<li>Done 标志，事件处理<ul>\n<li>handleMessage 先处理native的message</li>\n<li>handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-nativeWake\"><a href=\"#4-nativeWake\" class=\"headerlink\" title=\"4.nativeWake\"></a>4.nativeWake</h3><p>同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。</p>\n<p>在native层通过层层调用，会调用到looper的wake方法中。</p>\n<pre><code>void Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(&quot;%p ~ wake&quot;, this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);\n        }\n    }\n}\n</code></pre><ul>\n<li>向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。</li>\n</ul>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n\n</li>\n</ul>\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><p>在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。</p>\n<p>首先，我们先看下方法表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class=\"line\">    /* name, signature, funcPtr */</div><div class=\"line\">    &#123; &quot;nativeInit&quot;, &quot;()J&quot;, (void*)android_os_MessageQueue_nativeInit &#125;,</div><div class=\"line\">    &#123; &quot;nativeDestroy&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class=\"line\">    &#123; &quot;nativePollOnce&quot;, &quot;(JI)V&quot;, (void*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class=\"line\">    &#123; &quot;nativeWake&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeWake &#125;,</div><div class=\"line\">    &#123; &quot;nativeIsPolling&quot;, &quot;(J)Z&quot;, (void*)android_os_MessageQueue_nativeIsPolling &#125;,</div><div class=\"line\">    &#123; &quot;nativeSetFileDescriptorEvents&quot;, &quot;(JII)V&quot;,</div><div class=\"line\">            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>因为前面有介绍jni的相关知识，这里就不多说了。</p>\n<p>从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</div><div class=\"line\">    if (!nativeMessageQueue) &#123;</div><div class=\"line\">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    nativeMessageQueue-&gt;incStrong(env);</div><div class=\"line\">    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化NativeMessageQueue</li>\n<li>并且返回给java层，也就是java层的mPtr</li>\n</ul>\n<p>那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMessageQueue::NativeMessageQueue() :</div><div class=\"line\">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</div><div class=\"line\">    mLooper = Looper::getForThread();</div><div class=\"line\">    if (mLooper == NULL) &#123;</div><div class=\"line\">        mLooper = new Looper(false);</div><div class=\"line\">        Looper::setForThread(mLooper);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造native层的looper，注意，这个和java层的没有任何关系</li>\n<li>保存在类似ThreadLocal一样的结构里。</li>\n</ul>\n<p>Looper的构造函数在Looper.cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper::Looper(bool allowNonCallbacks) :</div><div class=\"line\">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</div><div class=\"line\">        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),</div><div class=\"line\">        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</div><div class=\"line\">    mWakeEventFd = eventfd(0, EFD_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, &quot;Could not make wake event fd.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\">    rebuildEpollLocked();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>eventfd构造欢迎时间的fd</li>\n<li>rebuildEpollLocked 重建epoll</li>\n</ul>\n<p>epoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：</p>\n<ul>\n<li>监视的描述符数量不受限制</li>\n<li>IO效率不会随着监视fd的数量增长而下降</li>\n</ul>\n<p>关于epoll的更多内容，这里就不介绍了。</p>\n<p>那么，在我们native的looper里面，是如何重建的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Looper::rebuildEpollLocked() &#123;</div><div class=\"line\">    // Close old epoll instance if we have one.</div><div class=\"line\">    if (mEpollFd &gt;= 0) &#123;</div><div class=\"line\">#if DEBUG_CALLBACKS</div><div class=\"line\">        ALOGD(&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;, this);</div><div class=\"line\">#endif</div><div class=\"line\">        close(mEpollFd);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Allocate the new epoll instance and register the wake pipe.</div><div class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    struct epoll_event eventItem;</div><div class=\"line\">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</div><div class=\"line\">    eventItem.events = EPOLLIN;</div><div class=\"line\">    eventItem.data.fd = mWakeEventFd;</div><div class=\"line\">    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; mRequests.size(); i++) &#123;</div><div class=\"line\">        const Request&amp; request = mRequests.valueAt(i);</div><div class=\"line\">        struct epoll_event eventItem;</div><div class=\"line\">        request.initEventItem(&amp;eventItem);</div><div class=\"line\"></div><div class=\"line\">        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</div><div class=\"line\">        if (epollResult &lt; 0) &#123;</div><div class=\"line\">            ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set, errno=%d&quot;,</div><div class=\"line\">                    request.fd, errno);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>epoll_create，创建epoll句柄</li>\n<li>memset 将数据区域至0</li>\n<li>eventItem.events = EPOLLIN;<br>  eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。</li>\n<li>epoll_ctl添加唤醒事件</li>\n<li>循环将mRequests中的事件都添加进去。</li>\n</ul>\n<h3 id=\"3-nativePollOnce\"><a href=\"#3-nativePollOnce\" class=\"headerlink\" title=\"3. nativePollOnce\"></a>3. nativePollOnce</h3><p>在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。</p>\n<p>android_os_MessageQueue_nativePollOnce-&gt;pollOnce-&gt;Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class=\"line\">    int result = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class=\"line\">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class=\"line\">            int ident = response.request.ident;</div><div class=\"line\">            if (ident &gt;= 0) &#123;</div><div class=\"line\">                int fd = response.request.fd;</div><div class=\"line\">                int events = response.events;</div><div class=\"line\">                void* data = response.request.data;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class=\"line\">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class=\"line\">                        this, ident, fd, events, data);</div><div class=\"line\">#endif</div><div class=\"line\">                if (outFd != NULL) *outFd = fd;</div><div class=\"line\">                if (outEvents != NULL) *outEvents = events;</div><div class=\"line\">                if (outData != NULL) *outData = data;</div><div class=\"line\">                return ident;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (result != 0) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class=\"line\">#endif</div><div class=\"line\">            if (outFd != NULL) *outFd = 0;</div><div class=\"line\">            if (outEvents != NULL) *outEvents = 0;</div><div class=\"line\">            if (outData != NULL) *outData = NULL;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        result = pollInner(timeoutMillis);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的参数含义：</p>\n<ul>\n<li>timeoutMillis 超时等待时间，-1无限等待，0立即返回</li>\n<li>outFd 发生事件的文件描述符</li>\n<li>outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,</li>\n<li>outData 存储上下文数据</li>\n</ul>\n<p>返回值的含义如下：</p>\n<ul>\n<li>ALOOPER_POLL_WAKE 表示由wake触发</li>\n<li>ALOOPER_POLL_TIMEOUT 等待超时</li>\n<li>ALOOPER_POLL_ERROR 等待过程中发生错误</li>\n<li>ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发</li>\n</ul>\n<p>这个方法的处理逻辑如下：</p>\n<ul>\n<li>先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)</li>\n<li>pollInner 处理内部轮询</li>\n</ul>\n<p>pollInner方法很长，</p>\n<ul>\n<li>toMillisecondTimeoutDelay 重新计算超时时间</li>\n<li>epoll_wait 等待</li>\n<li>如果需要，重建epoll</li>\n<li>epoll_wait函数返回，三种情况<ul>\n<li>eventCount&lt;0 发生错误，goto Done</li>\n<li>eventCount=0 连接超时 goto Done</li>\n<li>监听到有事件发生，</li>\n</ul>\n</li>\n<li>如果有事件发生，则循环处理<ul>\n<li>如果是mWakeEventFd，则进行awoken唤醒</li>\n<li>pushResponse，根据request构建response，并添加到response数组中</li>\n</ul>\n</li>\n<li>Done 标志，事件处理<ul>\n<li>handleMessage 先处理native的message</li>\n<li>handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-nativeWake\"><a href=\"#4-nativeWake\" class=\"headerlink\" title=\"4.nativeWake\"></a>4.nativeWake</h3><p>同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。</p>\n<p>在native层通过层层调用，会调用到looper的wake方法中。</p>\n<pre><code>void Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(&quot;%p ~ wake&quot;, this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);\n        }\n    }\n}\n</code></pre><ul>\n<li>向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。</li>\n</ul>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"PMS初始化做了什么","date":"2017-01-05T09:21:21.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n```java\n    public static PackageManagerService main(Context context, Installer installer,\n            boolean factoryTest, boolean onlyCore) {\n        PackageManagerService m = new PackageManagerService(context, installer,\n                factoryTest, onlyCore);\n        ServiceManager.addService(\"package\", m);\n        return m;\n    }\n```\n\n### 2.从pms构造函数说起\n\npms的构造函数相当长，根据[gityuan大神](http://gityuan.com/2016/11/06/packagemanager/)的提示，按照log的打印进行分布查看却是清晰了很多。\n\n#### 2.1 BOOT_PROGRESS_PMS_START\n\n```java\n        mContext = context;\n        mFactoryTest = factoryTest;\n        mOnlyCore = onlyCore;\n        mLazyDexOpt = \"eng\".equals(SystemProperties.get(\"ro.build.type\"));\n        mMetrics = new DisplayMetrics();\n        mSettings = new Settings(mPackages);\n        mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n\n        // TODO: add a property to control this?\n        long dexOptLRUThresholdInMinutes;\n        if (mLazyDexOpt) {\n            dexOptLRUThresholdInMinutes = 30; // only last 30 minutes of apps for eng builds.\n        } else {\n            dexOptLRUThresholdInMinutes = 7 * 24 * 60; // apps used in the 7 days for users.\n        }\n        mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * 60 * 1000;\n\n        String separateProcesses = SystemProperties.get(\"debug.separate_processes\");\n        if (separateProcesses != null && separateProcesses.length() > 0) {\n            if (\"*\".equals(separateProcesses)) {\n                mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;\n                mSeparateProcesses = null;\n                Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\");\n            } else {\n                mDefParseFlags = 0;\n                mSeparateProcesses = separateProcesses.split(\",\");\n                Slog.w(TAG, \"Running with debug.separate_processes: \"\n                        + separateProcesses);\n            }\n        } else {\n            mDefParseFlags = 0;\n            mSeparateProcesses = null;\n        }\n\n        mInstaller = installer;\n        mPackageDexOptimizer = new PackageDexOptimizer(this);\n        mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());\n\n        mOnPermissionChangeListeners = new OnPermissionChangeListeners(\n                FgThread.get().getLooper());\n\n        getDefaultDisplayMetrics(context, mMetrics);\n\n        SystemConfig systemConfig = SystemConfig.getInstance();\n        mGlobalGids = systemConfig.getGlobalGids();\n        mSystemPermissions = systemConfig.getSystemPermissions();\n        mAvailableFeatures = systemConfig.getAvailableFeatures();\n\n        synchronized (mInstallLock) {\n        // writer\n        synchronized (mPackages) {\n            mHandlerThread = new ServiceThread(TAG,\n                    Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);\n            mHandlerThread.start();\n            mHandler = new PackageHandler(mHandlerThread.getLooper());\n            Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);\n\n            File dataDir = Environment.getDataDirectory();\n            mAppDataDir = new File(dataDir, \"data\");\n            mAppInstallDir = new File(dataDir, \"app\");\n            mAppLib32InstallDir = new File(dataDir, \"app-lib\");\n            mAsecInternalPath = new File(dataDir, \"app-asec\").getPath();\n            mUserAppDataDir = new File(dataDir, \"user\");\n            mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\");\n\n            sUserManager = new UserManagerService(context, this,\n                    mInstallLock, mPackages);\n\n            // Propagate permission configuration in to package manager.\n            ArrayMap<String, SystemConfig.PermissionEntry> permConfig\n                    = systemConfig.getPermissions();\n            for (int i=0; i<permConfig.size(); i++) {\n                SystemConfig.PermissionEntry perm = permConfig.valueAt(i);\n                BasePermission bp = mSettings.mPermissions.get(perm.name);\n                if (bp == null) {\n                    bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN);\n                    mSettings.mPermissions.put(perm.name, bp);\n                }\n                if (perm.gids != null) {\n                    bp.setGids(perm.gids, perm.perUser);\n                }\n            }\n\n            ArrayMap<String, String> libConfig = systemConfig.getSharedLibraries();\n            for (int i=0; i<libConfig.size(); i++) {\n                mSharedLibraries.put(libConfig.keyAt(i),\n                        new SharedLibraryEntry(libConfig.valueAt(i), null));\n            }\n\n            mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();\n\n            mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false),\n                    mSdkVersion, mOnlyCore);\n\n            String customResolverActivity = Resources.getSystem().getString(\n                    R.string.config_customResolverActivity);\n            if (TextUtils.isEmpty(customResolverActivity)) {\n                customResolverActivity = null;\n            } else {\n                mCustomResolverComponentName = ComponentName.unflattenFromString(\n                        customResolverActivity);\n            }\n\n            long startTime = SystemClock.uptimeMillis();\n```\n\n* 构造Settings对象，添加shareUserId\n* 构造SystemConfig，获取mSystemPermissions灯属性\n* 创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象\n* 从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，\n\n#### 2.2 PMS_SYSTEM_SCAN_START\n\n```java\n            final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;\n\n            final ArraySet<String> alreadyDexOpted = new ArraySet<String>();\n\n            /**\n             * Add everything in the in the boot class path to the\n             * list of process files because dexopt will have been run\n             * if necessary during zygote startup.\n             */\n            final String bootClassPath = System.getenv(\"BOOTCLASSPATH\");\n            final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\");\n\n            if (bootClassPath != null) {\n                String[] bootClassPathElements = splitString(bootClassPath, ':');\n                for (String element : bootClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No BOOTCLASSPATH found!\");\n            }\n\n            if (systemServerClassPath != null) {\n                String[] systemServerClassPathElements = splitString(systemServerClassPath, ':');\n                for (String element : systemServerClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No SYSTEMSERVERCLASSPATH found!\");\n            }\n\n            final List<String> allInstructionSets = InstructionSets.getAllInstructionSets();\n            final String[] dexCodeInstructionSets =\n                    getDexCodeInstructionSets(\n                            allInstructionSets.toArray(new String[allInstructionSets.size()]));\n\n            /**\n             * Ensure all external libraries have had dexopt run on them.\n             */\n            if (mSharedLibraries.size() > 0) {\n                // NOTE: For now, we're compiling these system \"shared libraries\"\n                // (and framework jars) into all available architectures. It's possible\n                // to compile them only when we come across an app that uses them (there's\n                // already logic for that in scanPackageLI) but that adds some complexity.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (SharedLibraryEntry libEntry : mSharedLibraries.values()) {\n                        final String lib = libEntry.path;\n                        if (lib == null) {\n                            continue;\n                        }\n\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                alreadyDexOpted.add(lib);\n                                mInstaller.dexopt(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Library not found: \" + lib);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n\n            File frameworkDir = new File(Environment.getRootDirectory(), \"framework\");\n\n            // Gross hack for now: we know this file doesn't contain any\n            // code, so don't dexopt it to avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/framework-res.apk\");\n\n            // Gross hack for now: we know this file is only part of\n            // the boot class path for art, so don't dexopt it to\n            // avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/core-libart.jar\");\n\n            /**\n             * There are a number of commands implemented in Java, which\n             * we currently need to do the dexopt on so that they can be\n             * run from a non-root shell.\n             */\n            String[] frameworkFiles = frameworkDir.list();\n            if (frameworkFiles != null) {\n                // TODO: We could compile these only for the most preferred ABI. We should\n                // first double check that the dex files for these commands are not referenced\n                // by other system apps.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (int i=0; i<frameworkFiles.length; i++) {\n                        File libPath = new File(frameworkDir, frameworkFiles[i]);\n                        String path = libPath.getPath();\n                        // Skip the file if we already did it.\n                        if (alreadyDexOpted.contains(path)) {\n                            continue;\n                        }\n                        // Skip the file if it is not a type we want to dexopt.\n                        if (!path.endsWith(\".apk\") && !path.endsWith(\".jar\")) {\n                            continue;\n                        }\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                mInstaller.dexopt(path, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Jar not found: \" + path);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Exception reading jar: \" + path, e);\n                        }\n                    }\n                }\n            }\n\n            final VersionInfo ver = mSettings.getInternalVersion();\n            mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);\n            // when upgrading from pre-M, promote system app permissions from install to runtime\n            mPromoteSystemApps =\n                    mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;\n\n            // save off the names of pre-existing system packages prior to scanning; we don't\n            // want to automatically grant runtime permissions for new system apps\n            if (mPromoteSystemApps) {\n                Iterator<PackageSetting> pkgSettingIter = mSettings.mPackages.values().iterator();\n                while (pkgSettingIter.hasNext()) {\n                    PackageSetting ps = pkgSettingIter.next();\n                    if (isSystemApp(ps)) {\n                        mExistingSystemPackages.add(ps.name);\n                    }\n                }\n            }\n\n            // Collect vendor overlay packages.\n            // (Do this before scanning any apps.)\n            // For security and version matching reason, only consider\n            // overlay packages if they reside in VENDOR_OVERLAY_DIR.\n            File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);\n            scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);\n\n            // Find base frameworks (resource packages without code).\n            scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED,\n                    scanFlags | SCAN_NO_DEX, 0);\n\n            // Collected privileged system packages.\n            final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");\n            scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);\n\n            // Collect ordinary system packages.\n            final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");\n            scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all vendor packages.\n            File vendorAppDir = new File(\"/vendor/app\");\n            try {\n                vendorAppDir = vendorAppDir.getCanonicalFile();\n            } catch (IOException e) {\n                // failed to look up canonical path, continue with original one\n            }\n            scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all OEM packages.\n            final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");\n            scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            if (DEBUG_UPGRADE) Log.v(TAG, \"Running installd update commands\");\n            mInstaller.moveFiles();\n\n            // Prune any system packages that no longer exist.\n            final List<String> possiblyDeletedUpdatedSystemApps = new ArrayList<String>();\n            if (!mOnlyCore) {\n                Iterator<PackageSetting> psit = mSettings.mPackages.values().iterator();\n                while (psit.hasNext()) {\n                    PackageSetting ps = psit.next();\n\n                    /*\n                     * If this is not a system app, it can't be a\n                     * disable system app.\n                     */\n                    if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {\n                        continue;\n                    }\n\n                    /*\n                     * If the package is scanned, it's not erased.\n                     */\n                    final PackageParser.Package scannedPkg = mPackages.get(ps.name);\n                    if (scannedPkg != null) {\n                        /*\n                         * If the system app is both scanned and in the\n                         * disabled packages list, then it must have been\n                         * added via OTA. Remove it from the currently\n                         * scanned package so the previously user-installed\n                         * application can be scanned.\n                         */\n                        if (mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                            logCriticalInfo(Log.WARN, \"Expecting better updated system app for \"\n                                    + ps.name + \"; removing system app.  Last known codePath=\"\n                                    + ps.codePathString + \", installStatus=\" + ps.installStatus\n                                    + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\"\n                                    + scannedPkg.mVersionCode);\n                            removePackageLI(ps, true);\n                            mExpectingBetter.put(ps.name, ps.codePath);\n                        }\n\n                        continue;\n                    }\n\n                    if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                        psit.remove();\n                        logCriticalInfo(Log.WARN, \"System package \" + ps.name\n                                + \" no longer exists; wiping its data\");\n                        removeDataDirsLI(null, ps.name);\n                    } else {\n                        final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);\n                        if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {\n                            possiblyDeletedUpdatedSystemApps.add(ps.name);\n                        }\n                    }\n                }\n            }\n\n            //look for any incomplete package installations\n            ArrayList<PackageSetting> deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();\n            //clean up list\n            for(int i = 0; i < deletePkgsList.size(); i++) {\n                //clean up here\n                cleanupInstallFailedPackage(deletePkgsList.get(i));\n            }\n            //delete tmp files\n            deleteTempPackageFiles();\n\n            // Remove any shared userIDs that have no associated packages\n            mSettings.pruneSharedUsersLPw();\n\n            if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。\n\n* 首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,\n\n\t```\n/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found\n```\nSYSTEMSERVERCLASSPATH内容为下\n\n\t```\n/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found\n```\n\n* 获取构建时指定的cpu指令\n* 根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中\n* 将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表\n* 将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表\n* 收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息\n* 删除系统不存在的包removePackageLI\n* 清理安装失败的包 cleanupInstallFailedPackage\n* 删除临时文件\n* 移除不想干的包中的shared userIDs\n\n#### 2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\n\n```java\n          if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n* mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，\n\n\n#### 2.4 PMS_SCAN_END\n\n```java\n          int updateFlags = UPDATE_PERMISSIONS_ALL;\n            if (ver.sdkVersion != mSdkVersion) {\n                Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \"\n                        + mSdkVersion + \"; regranting permissions for internal storage\");\n                updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;\n            }\n            updatePermissionsLPw(null, null, updateFlags);\n            ver.sdkVersion = mSdkVersion;\n\n            // If this is the first boot or an update from pre-M, and it is a normal\n            // boot, then we need to initialize the default preferred apps across\n            // all defined users.\n            if (!onlyCore && (mPromoteSystemApps || !mRestoredSettings)) {\n                for (UserInfo user : sUserManager.getUsers(true)) {\n                    mSettings.applyDefaultPreferredAppsLPw(this, user.id);\n                    applyFactoryDefaultBrowserLPw(user.id);\n                    primeDomainVerificationsLPw(user.id);\n                }\n            }\n\n            // If this is first boot after an OTA, and a normal boot, then\n            // we need to clear code cache directories.\n            if (mIsUpgrade && !onlyCore) {\n                Slog.i(TAG, \"Build fingerprint changed; clearing code caches\");\n                for (int i = 0; i < mSettings.mPackages.size(); i++) {\n                    final PackageSetting ps = mSettings.mPackages.valueAt(i);\n                    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) {\n                        deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);\n                    }\n                }\n                ver.fingerprint = Build.FINGERPRINT;\n            }\n\n            checkDefaultBrowser();\n\n            // clear only after permissions and other defaults have been updated\n            mExistingSystemPackages.clear();\n            mPromoteSystemApps = false;\n\n            // All the changes are done during package scanning.\n            ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;\n\n            // can downgrade to reader\n            mSettings.writeLPr();\n```\n\n* 当sdk版本不一致时，需要更新权限\n* 当这是ota后的首次启动，正常启动则需要清除目录的缓存代码\n* 当权限和其他默认项都完成更新，则清理相关信息\n* 信息写回packages.xml文件\n\n这部分不是很懂。\n\n#### 2.5 BOOT_PROGRESS_PMS_READY\n\n```java\n          mRequiredVerifierPackage = getRequiredVerifierLPr();\n            mRequiredInstallerPackage = getRequiredInstallerLPr();\n\n            mInstallerService = new PackageInstallerService(context, this);\n\n            mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();\n            mIntentFilterVerifier = new IntentVerifierProxy(mContext,\n                    mIntentFilterVerifierComponent);\n\n        } // synchronized (mPackages)\n        } // synchronized (mInstallLock)\n\n        // Now after opening every single application zip, make sure they\n        // are all flushed.  Not really needed, but keeps things nice and\n        // tidy.\n        Runtime.getRuntime().gc();\n\n        // Expose private service for system components to use.\n        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());\n```\n\n* 初始化PackageInstallerService\n* gc，回收下内存\n\n\n### 3.Settings\n\n这个类负责读取data/system下的几个xml文件。收集其中的一些信息。\n\n* packages.xml\t记录所有安装app的信息\n* packages-backup.xml\t备份文件\n* packages-stopped.xml\t记录系统被强制停止的文件\n* packages-stopped-backup.xml\t备份文件\n* packages.list\t记录应用的数据信息\n\n### 4.scanDirLI\n\n这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。\n\n```java\n       final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(scanFile, parseFlags);\n        } catch (PackageParserException e) {\n            throw PackageManagerException.from(e);\n        }\n```\n\n重点看解析部分的代码。\n\n```java\n   public Package parsePackage(File packageFile, int flags) throws PackageParserException {\n        if (packageFile.isDirectory()) {\n            return parseClusterPackage(packageFile, flags);\n        } else {\n            return parseMonolithicPackage(packageFile, flags);\n        }\n    }\n```\n\n三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，\n\n```java\n            res = new Resources(assets, mMetrics, null);\n            assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                    Build.VERSION.RESOURCES_SDK_INT);\n            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\n\n            final String[] outError = new String[1];\n            final Package pkg = parseBaseApk(res, parser, flags, outError);\n```\n\n在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。\n\n```java\nif (tagName.equals(\"application\")) {\n                if (foundApp) {\n                    if (RIGID_PARSER) {\n                        outError[0] = \"<manifest> has more than one <application>\";\n                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                        return null;\n                    } else {\n                        Slog.w(TAG, \"<manifest> has more than one <application>\");\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                }\n\n                foundApp = true;\n                if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) {\n                    return null;\n                }\n            }\n```\n\n用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。\n\n```java\nif (tagName.equals(\"activity\")) {\n                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false,\n                        owner.baseHardwareAccelerated);\n                if (a == null) {\n                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                    return false;\n                }\n\n                owner.activities.add(a);\n\n            }\n```\n\n这里就不多说了。\n\n### 4. dex优化\n\n在Installer中，\n\n```java\n    public int dexopt(String apkPath, int uid, boolean isPublic, String pkgName,\n            String instructionSet, int dexoptNeeded, boolean vmSafeMode,\n            boolean debuggable, String outputPath) {\n        StringBuilder builder = new StringBuilder(\"dexopt\");\n        builder.append(' ');\n        builder.append(apkPath);\n        builder.append(' ');\n        builder.append(uid);\n        builder.append(isPublic ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(pkgName);\n        builder.append(' ');\n        builder.append(instructionSet);\n        builder.append(' ');\n        builder.append(dexoptNeeded);\n        builder.append(vmSafeMode ? \" 1\" : \" 0\");\n        builder.append(debuggable ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(outputPath != null ? outputPath : \"!\");\n        return execute(builder.toString());\n    }\n```\n\n进行参数封装，\n\n```java\n    public int execute(String cmd) {\n        String res = transact(cmd);\n        try {\n            return Integer.parseInt(res);\n        } catch (NumberFormatException ex) {\n            return -1;\n        }\n    }\n```\n\n在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。\n\n\n参考资料\n\n* [gityuan](http://gityuan.com/2016/11/06/packagemanager/)\n* Android 5.0 源代码\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/PMS初始化做了什么.md","raw":"---\ntitle: PMS初始化做了什么\ndate: 2017-01-05 17:21:21\ncategories: Android\ntags: \n- framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n```java\n    public static PackageManagerService main(Context context, Installer installer,\n            boolean factoryTest, boolean onlyCore) {\n        PackageManagerService m = new PackageManagerService(context, installer,\n                factoryTest, onlyCore);\n        ServiceManager.addService(\"package\", m);\n        return m;\n    }\n```\n\n### 2.从pms构造函数说起\n\npms的构造函数相当长，根据[gityuan大神](http://gityuan.com/2016/11/06/packagemanager/)的提示，按照log的打印进行分布查看却是清晰了很多。\n\n#### 2.1 BOOT_PROGRESS_PMS_START\n\n```java\n        mContext = context;\n        mFactoryTest = factoryTest;\n        mOnlyCore = onlyCore;\n        mLazyDexOpt = \"eng\".equals(SystemProperties.get(\"ro.build.type\"));\n        mMetrics = new DisplayMetrics();\n        mSettings = new Settings(mPackages);\n        mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n\n        // TODO: add a property to control this?\n        long dexOptLRUThresholdInMinutes;\n        if (mLazyDexOpt) {\n            dexOptLRUThresholdInMinutes = 30; // only last 30 minutes of apps for eng builds.\n        } else {\n            dexOptLRUThresholdInMinutes = 7 * 24 * 60; // apps used in the 7 days for users.\n        }\n        mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * 60 * 1000;\n\n        String separateProcesses = SystemProperties.get(\"debug.separate_processes\");\n        if (separateProcesses != null && separateProcesses.length() > 0) {\n            if (\"*\".equals(separateProcesses)) {\n                mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;\n                mSeparateProcesses = null;\n                Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\");\n            } else {\n                mDefParseFlags = 0;\n                mSeparateProcesses = separateProcesses.split(\",\");\n                Slog.w(TAG, \"Running with debug.separate_processes: \"\n                        + separateProcesses);\n            }\n        } else {\n            mDefParseFlags = 0;\n            mSeparateProcesses = null;\n        }\n\n        mInstaller = installer;\n        mPackageDexOptimizer = new PackageDexOptimizer(this);\n        mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());\n\n        mOnPermissionChangeListeners = new OnPermissionChangeListeners(\n                FgThread.get().getLooper());\n\n        getDefaultDisplayMetrics(context, mMetrics);\n\n        SystemConfig systemConfig = SystemConfig.getInstance();\n        mGlobalGids = systemConfig.getGlobalGids();\n        mSystemPermissions = systemConfig.getSystemPermissions();\n        mAvailableFeatures = systemConfig.getAvailableFeatures();\n\n        synchronized (mInstallLock) {\n        // writer\n        synchronized (mPackages) {\n            mHandlerThread = new ServiceThread(TAG,\n                    Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);\n            mHandlerThread.start();\n            mHandler = new PackageHandler(mHandlerThread.getLooper());\n            Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);\n\n            File dataDir = Environment.getDataDirectory();\n            mAppDataDir = new File(dataDir, \"data\");\n            mAppInstallDir = new File(dataDir, \"app\");\n            mAppLib32InstallDir = new File(dataDir, \"app-lib\");\n            mAsecInternalPath = new File(dataDir, \"app-asec\").getPath();\n            mUserAppDataDir = new File(dataDir, \"user\");\n            mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\");\n\n            sUserManager = new UserManagerService(context, this,\n                    mInstallLock, mPackages);\n\n            // Propagate permission configuration in to package manager.\n            ArrayMap<String, SystemConfig.PermissionEntry> permConfig\n                    = systemConfig.getPermissions();\n            for (int i=0; i<permConfig.size(); i++) {\n                SystemConfig.PermissionEntry perm = permConfig.valueAt(i);\n                BasePermission bp = mSettings.mPermissions.get(perm.name);\n                if (bp == null) {\n                    bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN);\n                    mSettings.mPermissions.put(perm.name, bp);\n                }\n                if (perm.gids != null) {\n                    bp.setGids(perm.gids, perm.perUser);\n                }\n            }\n\n            ArrayMap<String, String> libConfig = systemConfig.getSharedLibraries();\n            for (int i=0; i<libConfig.size(); i++) {\n                mSharedLibraries.put(libConfig.keyAt(i),\n                        new SharedLibraryEntry(libConfig.valueAt(i), null));\n            }\n\n            mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();\n\n            mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false),\n                    mSdkVersion, mOnlyCore);\n\n            String customResolverActivity = Resources.getSystem().getString(\n                    R.string.config_customResolverActivity);\n            if (TextUtils.isEmpty(customResolverActivity)) {\n                customResolverActivity = null;\n            } else {\n                mCustomResolverComponentName = ComponentName.unflattenFromString(\n                        customResolverActivity);\n            }\n\n            long startTime = SystemClock.uptimeMillis();\n```\n\n* 构造Settings对象，添加shareUserId\n* 构造SystemConfig，获取mSystemPermissions灯属性\n* 创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象\n* 从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，\n\n#### 2.2 PMS_SYSTEM_SCAN_START\n\n```java\n            final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;\n\n            final ArraySet<String> alreadyDexOpted = new ArraySet<String>();\n\n            /**\n             * Add everything in the in the boot class path to the\n             * list of process files because dexopt will have been run\n             * if necessary during zygote startup.\n             */\n            final String bootClassPath = System.getenv(\"BOOTCLASSPATH\");\n            final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\");\n\n            if (bootClassPath != null) {\n                String[] bootClassPathElements = splitString(bootClassPath, ':');\n                for (String element : bootClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No BOOTCLASSPATH found!\");\n            }\n\n            if (systemServerClassPath != null) {\n                String[] systemServerClassPathElements = splitString(systemServerClassPath, ':');\n                for (String element : systemServerClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No SYSTEMSERVERCLASSPATH found!\");\n            }\n\n            final List<String> allInstructionSets = InstructionSets.getAllInstructionSets();\n            final String[] dexCodeInstructionSets =\n                    getDexCodeInstructionSets(\n                            allInstructionSets.toArray(new String[allInstructionSets.size()]));\n\n            /**\n             * Ensure all external libraries have had dexopt run on them.\n             */\n            if (mSharedLibraries.size() > 0) {\n                // NOTE: For now, we're compiling these system \"shared libraries\"\n                // (and framework jars) into all available architectures. It's possible\n                // to compile them only when we come across an app that uses them (there's\n                // already logic for that in scanPackageLI) but that adds some complexity.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (SharedLibraryEntry libEntry : mSharedLibraries.values()) {\n                        final String lib = libEntry.path;\n                        if (lib == null) {\n                            continue;\n                        }\n\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                alreadyDexOpted.add(lib);\n                                mInstaller.dexopt(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Library not found: \" + lib);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n\n            File frameworkDir = new File(Environment.getRootDirectory(), \"framework\");\n\n            // Gross hack for now: we know this file doesn't contain any\n            // code, so don't dexopt it to avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/framework-res.apk\");\n\n            // Gross hack for now: we know this file is only part of\n            // the boot class path for art, so don't dexopt it to\n            // avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/core-libart.jar\");\n\n            /**\n             * There are a number of commands implemented in Java, which\n             * we currently need to do the dexopt on so that they can be\n             * run from a non-root shell.\n             */\n            String[] frameworkFiles = frameworkDir.list();\n            if (frameworkFiles != null) {\n                // TODO: We could compile these only for the most preferred ABI. We should\n                // first double check that the dex files for these commands are not referenced\n                // by other system apps.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (int i=0; i<frameworkFiles.length; i++) {\n                        File libPath = new File(frameworkDir, frameworkFiles[i]);\n                        String path = libPath.getPath();\n                        // Skip the file if we already did it.\n                        if (alreadyDexOpted.contains(path)) {\n                            continue;\n                        }\n                        // Skip the file if it is not a type we want to dexopt.\n                        if (!path.endsWith(\".apk\") && !path.endsWith(\".jar\")) {\n                            continue;\n                        }\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                mInstaller.dexopt(path, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Jar not found: \" + path);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Exception reading jar: \" + path, e);\n                        }\n                    }\n                }\n            }\n\n            final VersionInfo ver = mSettings.getInternalVersion();\n            mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);\n            // when upgrading from pre-M, promote system app permissions from install to runtime\n            mPromoteSystemApps =\n                    mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;\n\n            // save off the names of pre-existing system packages prior to scanning; we don't\n            // want to automatically grant runtime permissions for new system apps\n            if (mPromoteSystemApps) {\n                Iterator<PackageSetting> pkgSettingIter = mSettings.mPackages.values().iterator();\n                while (pkgSettingIter.hasNext()) {\n                    PackageSetting ps = pkgSettingIter.next();\n                    if (isSystemApp(ps)) {\n                        mExistingSystemPackages.add(ps.name);\n                    }\n                }\n            }\n\n            // Collect vendor overlay packages.\n            // (Do this before scanning any apps.)\n            // For security and version matching reason, only consider\n            // overlay packages if they reside in VENDOR_OVERLAY_DIR.\n            File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);\n            scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);\n\n            // Find base frameworks (resource packages without code).\n            scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED,\n                    scanFlags | SCAN_NO_DEX, 0);\n\n            // Collected privileged system packages.\n            final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");\n            scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);\n\n            // Collect ordinary system packages.\n            final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");\n            scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all vendor packages.\n            File vendorAppDir = new File(\"/vendor/app\");\n            try {\n                vendorAppDir = vendorAppDir.getCanonicalFile();\n            } catch (IOException e) {\n                // failed to look up canonical path, continue with original one\n            }\n            scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all OEM packages.\n            final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");\n            scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            if (DEBUG_UPGRADE) Log.v(TAG, \"Running installd update commands\");\n            mInstaller.moveFiles();\n\n            // Prune any system packages that no longer exist.\n            final List<String> possiblyDeletedUpdatedSystemApps = new ArrayList<String>();\n            if (!mOnlyCore) {\n                Iterator<PackageSetting> psit = mSettings.mPackages.values().iterator();\n                while (psit.hasNext()) {\n                    PackageSetting ps = psit.next();\n\n                    /*\n                     * If this is not a system app, it can't be a\n                     * disable system app.\n                     */\n                    if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {\n                        continue;\n                    }\n\n                    /*\n                     * If the package is scanned, it's not erased.\n                     */\n                    final PackageParser.Package scannedPkg = mPackages.get(ps.name);\n                    if (scannedPkg != null) {\n                        /*\n                         * If the system app is both scanned and in the\n                         * disabled packages list, then it must have been\n                         * added via OTA. Remove it from the currently\n                         * scanned package so the previously user-installed\n                         * application can be scanned.\n                         */\n                        if (mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                            logCriticalInfo(Log.WARN, \"Expecting better updated system app for \"\n                                    + ps.name + \"; removing system app.  Last known codePath=\"\n                                    + ps.codePathString + \", installStatus=\" + ps.installStatus\n                                    + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\"\n                                    + scannedPkg.mVersionCode);\n                            removePackageLI(ps, true);\n                            mExpectingBetter.put(ps.name, ps.codePath);\n                        }\n\n                        continue;\n                    }\n\n                    if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                        psit.remove();\n                        logCriticalInfo(Log.WARN, \"System package \" + ps.name\n                                + \" no longer exists; wiping its data\");\n                        removeDataDirsLI(null, ps.name);\n                    } else {\n                        final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);\n                        if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {\n                            possiblyDeletedUpdatedSystemApps.add(ps.name);\n                        }\n                    }\n                }\n            }\n\n            //look for any incomplete package installations\n            ArrayList<PackageSetting> deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();\n            //clean up list\n            for(int i = 0; i < deletePkgsList.size(); i++) {\n                //clean up here\n                cleanupInstallFailedPackage(deletePkgsList.get(i));\n            }\n            //delete tmp files\n            deleteTempPackageFiles();\n\n            // Remove any shared userIDs that have no associated packages\n            mSettings.pruneSharedUsersLPw();\n\n            if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。\n\n* 首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,\n\n\t```\n/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found\n```\nSYSTEMSERVERCLASSPATH内容为下\n\n\t```\n/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found\n```\n\n* 获取构建时指定的cpu指令\n* 根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中\n* 将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表\n* 将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表\n* 收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息\n* 删除系统不存在的包removePackageLI\n* 清理安装失败的包 cleanupInstallFailedPackage\n* 删除临时文件\n* 移除不想干的包中的shared userIDs\n\n#### 2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\n\n```java\n          if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n* mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，\n\n\n#### 2.4 PMS_SCAN_END\n\n```java\n          int updateFlags = UPDATE_PERMISSIONS_ALL;\n            if (ver.sdkVersion != mSdkVersion) {\n                Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \"\n                        + mSdkVersion + \"; regranting permissions for internal storage\");\n                updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;\n            }\n            updatePermissionsLPw(null, null, updateFlags);\n            ver.sdkVersion = mSdkVersion;\n\n            // If this is the first boot or an update from pre-M, and it is a normal\n            // boot, then we need to initialize the default preferred apps across\n            // all defined users.\n            if (!onlyCore && (mPromoteSystemApps || !mRestoredSettings)) {\n                for (UserInfo user : sUserManager.getUsers(true)) {\n                    mSettings.applyDefaultPreferredAppsLPw(this, user.id);\n                    applyFactoryDefaultBrowserLPw(user.id);\n                    primeDomainVerificationsLPw(user.id);\n                }\n            }\n\n            // If this is first boot after an OTA, and a normal boot, then\n            // we need to clear code cache directories.\n            if (mIsUpgrade && !onlyCore) {\n                Slog.i(TAG, \"Build fingerprint changed; clearing code caches\");\n                for (int i = 0; i < mSettings.mPackages.size(); i++) {\n                    final PackageSetting ps = mSettings.mPackages.valueAt(i);\n                    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) {\n                        deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);\n                    }\n                }\n                ver.fingerprint = Build.FINGERPRINT;\n            }\n\n            checkDefaultBrowser();\n\n            // clear only after permissions and other defaults have been updated\n            mExistingSystemPackages.clear();\n            mPromoteSystemApps = false;\n\n            // All the changes are done during package scanning.\n            ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;\n\n            // can downgrade to reader\n            mSettings.writeLPr();\n```\n\n* 当sdk版本不一致时，需要更新权限\n* 当这是ota后的首次启动，正常启动则需要清除目录的缓存代码\n* 当权限和其他默认项都完成更新，则清理相关信息\n* 信息写回packages.xml文件\n\n这部分不是很懂。\n\n#### 2.5 BOOT_PROGRESS_PMS_READY\n\n```java\n          mRequiredVerifierPackage = getRequiredVerifierLPr();\n            mRequiredInstallerPackage = getRequiredInstallerLPr();\n\n            mInstallerService = new PackageInstallerService(context, this);\n\n            mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();\n            mIntentFilterVerifier = new IntentVerifierProxy(mContext,\n                    mIntentFilterVerifierComponent);\n\n        } // synchronized (mPackages)\n        } // synchronized (mInstallLock)\n\n        // Now after opening every single application zip, make sure they\n        // are all flushed.  Not really needed, but keeps things nice and\n        // tidy.\n        Runtime.getRuntime().gc();\n\n        // Expose private service for system components to use.\n        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());\n```\n\n* 初始化PackageInstallerService\n* gc，回收下内存\n\n\n### 3.Settings\n\n这个类负责读取data/system下的几个xml文件。收集其中的一些信息。\n\n* packages.xml\t记录所有安装app的信息\n* packages-backup.xml\t备份文件\n* packages-stopped.xml\t记录系统被强制停止的文件\n* packages-stopped-backup.xml\t备份文件\n* packages.list\t记录应用的数据信息\n\n### 4.scanDirLI\n\n这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。\n\n```java\n       final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(scanFile, parseFlags);\n        } catch (PackageParserException e) {\n            throw PackageManagerException.from(e);\n        }\n```\n\n重点看解析部分的代码。\n\n```java\n   public Package parsePackage(File packageFile, int flags) throws PackageParserException {\n        if (packageFile.isDirectory()) {\n            return parseClusterPackage(packageFile, flags);\n        } else {\n            return parseMonolithicPackage(packageFile, flags);\n        }\n    }\n```\n\n三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，\n\n```java\n            res = new Resources(assets, mMetrics, null);\n            assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                    Build.VERSION.RESOURCES_SDK_INT);\n            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\n\n            final String[] outError = new String[1];\n            final Package pkg = parseBaseApk(res, parser, flags, outError);\n```\n\n在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。\n\n```java\nif (tagName.equals(\"application\")) {\n                if (foundApp) {\n                    if (RIGID_PARSER) {\n                        outError[0] = \"<manifest> has more than one <application>\";\n                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                        return null;\n                    } else {\n                        Slog.w(TAG, \"<manifest> has more than one <application>\");\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                }\n\n                foundApp = true;\n                if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) {\n                    return null;\n                }\n            }\n```\n\n用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。\n\n```java\nif (tagName.equals(\"activity\")) {\n                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false,\n                        owner.baseHardwareAccelerated);\n                if (a == null) {\n                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                    return false;\n                }\n\n                owner.activities.add(a);\n\n            }\n```\n\n这里就不多说了。\n\n### 4. dex优化\n\n在Installer中，\n\n```java\n    public int dexopt(String apkPath, int uid, boolean isPublic, String pkgName,\n            String instructionSet, int dexoptNeeded, boolean vmSafeMode,\n            boolean debuggable, String outputPath) {\n        StringBuilder builder = new StringBuilder(\"dexopt\");\n        builder.append(' ');\n        builder.append(apkPath);\n        builder.append(' ');\n        builder.append(uid);\n        builder.append(isPublic ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(pkgName);\n        builder.append(' ');\n        builder.append(instructionSet);\n        builder.append(' ');\n        builder.append(dexoptNeeded);\n        builder.append(vmSafeMode ? \" 1\" : \" 0\");\n        builder.append(debuggable ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(outputPath != null ? outputPath : \"!\");\n        return execute(builder.toString());\n    }\n```\n\n进行参数封装，\n\n```java\n    public int execute(String cmd) {\n        String res = transact(cmd);\n        try {\n            return Integer.parseInt(res);\n        } catch (NumberFormatException ex) {\n            return -1;\n        }\n    }\n```\n\n在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。\n\n\n参考资料\n\n* [gityuan](http://gityuan.com/2016/11/06/packagemanager/)\n* Android 5.0 源代码\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"PMS初始化做了什么","published":1,"updated":"2017-01-06T05:19:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85y6000puaxap1ut39p1","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n</the></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PackageManagerService <span class=\"title\">main</span><span class=\"params\">(Context context, Installer installer,</span></span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> factoryTest, <span class=\"keyword\">boolean</span> onlyCore) &#123;</div><div class=\"line\">    PackageManagerService m = <span class=\"keyword\">new</span> PackageManagerService(context, installer,</div><div class=\"line\">            factoryTest, onlyCore);</div><div class=\"line\">    ServiceManager.addService(<span class=\"string\">\"package\"</span>, m);</div><div class=\"line\">    <span class=\"keyword\">return</span> m;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-从pms构造函数说起\"><a href=\"#2-从pms构造函数说起\" class=\"headerlink\" title=\"2.从pms构造函数说起\"></a>2.从pms构造函数说起</h3><p>pms的构造函数相当长，根据<a href=\"http://gityuan.com/2016/11/06/packagemanager/\" target=\"_blank\" rel=\"external\">gityuan大神</a>的提示，按照log的打印进行分布查看却是清晰了很多。</p>\n<h4 id=\"2-1-BOOT-PROGRESS-PMS-START\"><a href=\"#2-1-BOOT-PROGRESS-PMS-START\" class=\"headerlink\" title=\"2.1 BOOT_PROGRESS_PMS_START\"></a>2.1 BOOT_PROGRESS_PMS_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">mContext = context;</div><div class=\"line\">mFactoryTest = factoryTest;</div><div class=\"line\">mOnlyCore = onlyCore;</div><div class=\"line\">mLazyDexOpt = <span class=\"string\">\"eng\"</span>.equals(SystemProperties.get(<span class=\"string\">\"ro.build.type\"</span>));</div><div class=\"line\">mMetrics = <span class=\"keyword\">new</span> DisplayMetrics();</div><div class=\"line\">mSettings = <span class=\"keyword\">new</span> Settings(mPackages);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.system\"</span>, Process.SYSTEM_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.phone\"</span>, RADIO_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.log\"</span>, LOG_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.nfc\"</span>, NFC_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.bluetooth\"</span>, BLUETOOTH_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.shell\"</span>, SHELL_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> add a property to control this?</span></div><div class=\"line\"><span class=\"keyword\">long</span> dexOptLRUThresholdInMinutes;</div><div class=\"line\"><span class=\"keyword\">if</span> (mLazyDexOpt) &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">30</span>; <span class=\"comment\">// only last 30 minutes of apps for eng builds.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">7</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span>; <span class=\"comment\">// apps used in the 7 days for users.</span></div><div class=\"line\">&#125;</div><div class=\"line\">mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\">String separateProcesses = SystemProperties.get(<span class=\"string\">\"debug.separate_processes\"</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (separateProcesses != <span class=\"keyword\">null</span> &amp;&amp; separateProcesses.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"*\"</span>.equals(separateProcesses)) &#123;</div><div class=\"line\">        mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</div><div class=\"line\">        mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: * (ALL)\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">        mSeparateProcesses = separateProcesses.split(<span class=\"string\">\",\"</span>);</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: \"</span></div><div class=\"line\">                + separateProcesses);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">    mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mInstaller = installer;</div><div class=\"line\">mPackageDexOptimizer = <span class=\"keyword\">new</span> PackageDexOptimizer(<span class=\"keyword\">this</span>);</div><div class=\"line\">mMoveCallbacks = <span class=\"keyword\">new</span> MoveCallbacks(FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">mOnPermissionChangeListeners = <span class=\"keyword\">new</span> OnPermissionChangeListeners(</div><div class=\"line\">        FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">getDefaultDisplayMetrics(context, mMetrics);</div><div class=\"line\"></div><div class=\"line\">SystemConfig systemConfig = SystemConfig.getInstance();</div><div class=\"line\">mGlobalGids = systemConfig.getGlobalGids();</div><div class=\"line\">mSystemPermissions = systemConfig.getSystemPermissions();</div><div class=\"line\">mAvailableFeatures = systemConfig.getAvailableFeatures();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mInstallLock) &#123;</div><div class=\"line\"><span class=\"comment\">// writer</span></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mPackages) &#123;</div><div class=\"line\">    mHandlerThread = <span class=\"keyword\">new</span> ServiceThread(TAG,</div><div class=\"line\">            Process.THREAD_PRIORITY_BACKGROUND, <span class=\"keyword\">true</span> <span class=\"comment\">/*allowIo*/</span>);</div><div class=\"line\">    mHandlerThread.start();</div><div class=\"line\">    mHandler = <span class=\"keyword\">new</span> PackageHandler(mHandlerThread.getLooper());</div><div class=\"line\">    Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</div><div class=\"line\"></div><div class=\"line\">    File dataDir = Environment.getDataDirectory();</div><div class=\"line\">    mAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"data\"</span>);</div><div class=\"line\">    mAppInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app\"</span>);</div><div class=\"line\">    mAppLib32InstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-lib\"</span>);</div><div class=\"line\">    mAsecInternalPath = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-asec\"</span>).getPath();</div><div class=\"line\">    mUserAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"user\"</span>);</div><div class=\"line\">    mDrmAppPrivateInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-private\"</span>);</div><div class=\"line\"></div><div class=\"line\">    sUserManager = <span class=\"keyword\">new</span> UserManagerService(context, <span class=\"keyword\">this</span>,</div><div class=\"line\">            mInstallLock, mPackages);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Propagate permission configuration in to package manager.</span></div><div class=\"line\">    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</div><div class=\"line\">            = systemConfig.getPermissions();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;permConfig.size(); i++) &#123;</div><div class=\"line\">        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</div><div class=\"line\">        BasePermission bp = mSettings.mPermissions.get(perm.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (bp == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp = <span class=\"keyword\">new</span> BasePermission(perm.name, <span class=\"string\">\"android\"</span>, BasePermission.TYPE_BUILTIN);</div><div class=\"line\">            mSettings.mPermissions.put(perm.name, bp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm.gids != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp.setGids(perm.gids, perm.perUser);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;libConfig.size(); i++) &#123;</div><div class=\"line\">        mSharedLibraries.put(libConfig.keyAt(i),</div><div class=\"line\">                <span class=\"keyword\">new</span> SharedLibraryEntry(libConfig.valueAt(i), <span class=\"keyword\">null</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</div><div class=\"line\"></div><div class=\"line\">    mRestoredSettings = mSettings.readLPw(<span class=\"keyword\">this</span>, sUserManager.getUsers(<span class=\"keyword\">false</span>),</div><div class=\"line\">            mSdkVersion, mOnlyCore);</div><div class=\"line\"></div><div class=\"line\">    String customResolverActivity = Resources.getSystem().getString(</div><div class=\"line\">            R.string.config_customResolverActivity);</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(customResolverActivity)) &#123;</div><div class=\"line\">        customResolverActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mCustomResolverComponentName = ComponentName.unflattenFromString(</div><div class=\"line\">                customResolverActivity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">long</span> startTime = SystemClock.uptimeMillis();</div></pre></td></tr></table></figure>\n<ul>\n<li>构造Settings对象，添加shareUserId</li>\n<li>构造SystemConfig，获取mSystemPermissions灯属性</li>\n<li>创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象</li>\n<li>从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，</li>\n</ul>\n<h4 id=\"2-2-PMS-SYSTEM-SCAN-START\"><a href=\"#2-2-PMS-SYSTEM-SCAN-START\" class=\"headerlink\" title=\"2.2 PMS_SYSTEM_SCAN_START\"></a>2.2 PMS_SYSTEM_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> ArraySet&lt;String&gt; alreadyDexOpted = <span class=\"keyword\">new</span> ArraySet&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Add everything in the in the boot class path to the</div><div class=\"line\"> * list of process files because dexopt will have been run</div><div class=\"line\"> * if necessary during zygote startup.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">final</span> String bootClassPath = System.getenv(<span class=\"string\">\"BOOTCLASSPATH\"</span>);</div><div class=\"line\"><span class=\"keyword\">final</span> String systemServerClassPath = System.getenv(<span class=\"string\">\"SYSTEMSERVERCLASSPATH\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (bootClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] bootClassPathElements = splitString(bootClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : bootClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No BOOTCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (systemServerClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : systemServerClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No SYSTEMSERVERCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</div><div class=\"line\"><span class=\"keyword\">final</span> String[] dexCodeInstructionSets =</div><div class=\"line\">        getDexCodeInstructionSets(</div><div class=\"line\">                allInstructionSets.toArray(<span class=\"keyword\">new</span> String[allInstructionSets.size()]));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Ensure all external libraries have had dexopt run on them.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">if</span> (mSharedLibraries.size() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> For now, we're compiling these system \"shared libraries\"</span></div><div class=\"line\">    <span class=\"comment\">// (and framework jars) into all available architectures. It's possible</span></div><div class=\"line\">    <span class=\"comment\">// to compile them only when we come across an app that uses them (there's</span></div><div class=\"line\">    <span class=\"comment\">// already logic for that in scanPackageLI) but that adds some complexity.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> String lib = libEntry.path;</div><div class=\"line\">            <span class=\"keyword\">if</span> (lib == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(lib, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    alreadyDexOpted.add(lib);</div><div class=\"line\">                    mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Library not found: \"</span> + lib);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Cannot dexopt \"</span> + lib + <span class=\"string\">\"; is it an APK or JAR? \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">File frameworkDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"framework\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file doesn't contain any</span></div><div class=\"line\"><span class=\"comment\">// code, so don't dexopt it to avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/framework-res.apk\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file is only part of</span></div><div class=\"line\"><span class=\"comment\">// the boot class path for art, so don't dexopt it to</span></div><div class=\"line\"><span class=\"comment\">// avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/core-libart.jar\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * There are a number of commands implemented in Java, which</div><div class=\"line\"> * we currently need to do the dexopt on so that they can be</div><div class=\"line\"> * run from a non-root shell.</div><div class=\"line\"> */</div><div class=\"line\">String[] frameworkFiles = frameworkDir.list();</div><div class=\"line\"><span class=\"keyword\">if</span> (frameworkFiles != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We could compile these only for the most preferred ABI. We should</span></div><div class=\"line\">    <span class=\"comment\">// first double check that the dex files for these commands are not referenced</span></div><div class=\"line\">    <span class=\"comment\">// by other system apps.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;frameworkFiles.length; i++) &#123;</div><div class=\"line\">            File libPath = <span class=\"keyword\">new</span> File(frameworkDir, frameworkFiles[i]);</div><div class=\"line\">            String path = libPath.getPath();</div><div class=\"line\">            <span class=\"comment\">// Skip the file if we already did it.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (alreadyDexOpted.contains(path)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// Skip the file if it is not a type we want to dexopt.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!path.endsWith(<span class=\"string\">\".apk\"</span>) &amp;&amp; !path.endsWith(<span class=\"string\">\".jar\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(path, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    mInstaller.dexopt(path, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Jar not found: \"</span> + path);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Exception reading jar: \"</span> + path, e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> VersionInfo ver = mSettings.getInternalVersion();</div><div class=\"line\">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</div><div class=\"line\"><span class=\"comment\">// when upgrading from pre-M, promote system app permissions from install to runtime</span></div><div class=\"line\">mPromoteSystemApps =</div><div class=\"line\">        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// save off the names of pre-existing system packages prior to scanning; we don't</span></div><div class=\"line\"><span class=\"comment\">// want to automatically grant runtime permissions for new system apps</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mPromoteSystemApps) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (pkgSettingIter.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = pkgSettingIter.next();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isSystemApp(ps)) &#123;</div><div class=\"line\">            mExistingSystemPackages.add(ps.name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect vendor overlay packages.</span></div><div class=\"line\"><span class=\"comment\">// (Do this before scanning any apps.)</span></div><div class=\"line\"><span class=\"comment\">// For security and version matching reason, only consider</span></div><div class=\"line\"><span class=\"comment\">// overlay packages if they reside in VENDOR_OVERLAY_DIR.</span></div><div class=\"line\">File vendorOverlayDir = <span class=\"keyword\">new</span> File(VENDOR_OVERLAY_DIR);</div><div class=\"line\">scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Find base frameworks (resource packages without code).</span></div><div class=\"line\">scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED,</div><div class=\"line\">        scanFlags | SCAN_NO_DEX, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collected privileged system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File privilegedAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"priv-app\"</span>);</div><div class=\"line\">scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect ordinary system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File systemAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all vendor packages.</span></div><div class=\"line\">File vendorAppDir = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/vendor/app\"</span>);</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    vendorAppDir = vendorAppDir.getCanonicalFile();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">    <span class=\"comment\">// failed to look up canonical path, continue with original one</span></div><div class=\"line\">&#125;</div><div class=\"line\">scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all OEM packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File oemAppDir = <span class=\"keyword\">new</span> File(Environment.getOemDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (DEBUG_UPGRADE) Log.v(TAG, <span class=\"string\">\"Running installd update commands\"</span>);</div><div class=\"line\">mInstaller.moveFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prune any system packages that no longer exist.</span></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; possiblyDeletedUpdatedSystemApps = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (psit.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = psit.next();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * If this is not a system app, it can't be a</div><div class=\"line\">         * disable system app.</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * If the package is scanned, it's not erased.</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">final</span> PackageParser.Package scannedPkg = mPackages.get(ps.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (scannedPkg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</span></div><div class=\"line\">             * If the system app is both scanned and in the</div><div class=\"line\">             * disabled packages list, then it must have been</div><div class=\"line\">             * added via OTA. Remove it from the currently</div><div class=\"line\">             * scanned package so the previously user-installed</div><div class=\"line\">             * application can be scanned.</div><div class=\"line\">             */</div><div class=\"line\">            <span class=\"keyword\">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">                logCriticalInfo(Log.WARN, <span class=\"string\">\"Expecting better updated system app for \"</span></div><div class=\"line\">                        + ps.name + <span class=\"string\">\"; removing system app.  Last known codePath=\"</span></div><div class=\"line\">                        + ps.codePathString + <span class=\"string\">\", installStatus=\"</span> + ps.installStatus</div><div class=\"line\">                        + <span class=\"string\">\", versionCode=\"</span> + ps.versionCode + <span class=\"string\">\"; scanned versionCode=\"</span></div><div class=\"line\">                        + scannedPkg.mVersionCode);</div><div class=\"line\">                removePackageLI(ps, <span class=\"keyword\">true</span>);</div><div class=\"line\">                mExpectingBetter.put(ps.name, ps.codePath);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">            psit.remove();</div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"System package \"</span> + ps.name</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>);</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, ps.name);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</div><div class=\"line\">            <span class=\"keyword\">if</span> (disabledPs.codePath == <span class=\"keyword\">null</span> || !disabledPs.codePath.exists()) &#123;</div><div class=\"line\">                possiblyDeletedUpdatedSystemApps.add(ps.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//look for any incomplete package installations</span></div><div class=\"line\">ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</div><div class=\"line\"><span class=\"comment\">//clean up list</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deletePkgsList.size(); i++) &#123;</div><div class=\"line\">    <span class=\"comment\">//clean up here</span></div><div class=\"line\">    cleanupInstallFailedPackage(deletePkgsList.get(i));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//delete tmp files</span></div><div class=\"line\">deleteTempPackageFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Remove any shared userIDs that have no associated packages</span></div><div class=\"line\">mSettings.pruneSharedUsersLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">    scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">            scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Remove disable package settings for any updated system</div><div class=\"line\">     * apps that were removed via an OTA. If they're not a</div><div class=\"line\">     * previously-updated app, remove them completely.</div><div class=\"line\">     * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">        PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">        mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">        String msg;</div><div class=\"line\">        <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                    + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">            deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">            PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">            deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">        &#125;</div><div class=\"line\">        logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Make sure all system apps that we expected to appear on</div><div class=\"line\">     * the userdata partition actually showed up. If they never</div><div class=\"line\">     * appeared, crawl back and revive the system version.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                    + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">            <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                        | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\"><span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">    <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">    <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">    adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">            <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\"><span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<p>扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。</p>\n<ul>\n<li><p>首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>SYSTEMSERVERCLASSPATH内容为下</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>获取构建时指定的cpu指令</li>\n<li>根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中</li>\n<li>将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表</li>\n<li>将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表</li>\n<li>收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息</li>\n<li>删除系统不存在的包removePackageLI</li>\n<li>清理安装失败的包 cleanupInstallFailedPackage</li>\n<li>删除临时文件</li>\n<li>移除不想干的包中的shared userIDs</li>\n</ul>\n<h4 id=\"2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\"><a href=\"#2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\" class=\"headerlink\" title=\"2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\"></a>2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">              SystemClock.uptimeMillis());</div><div class=\"line\">      scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">              scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</span></div><div class=\"line\">       * Remove disable package settings for any updated system</div><div class=\"line\">       * apps that were removed via an OTA. If they're not a</div><div class=\"line\">       * previously-updated app, remove them completely.</div><div class=\"line\">       * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">       */</div><div class=\"line\">      <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">          PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">          mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">          String msg;</div><div class=\"line\">          <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">              removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                      + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">              deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">              PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">              deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">          &#125;</div><div class=\"line\">          logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</span></div><div class=\"line\">       * Make sure all system apps that we expected to appear on</div><div class=\"line\">       * the userdata partition actually showed up. If they never</div><div class=\"line\">       * appeared, crawl back and revive the system version.</div><div class=\"line\">       */</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">              <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">              logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                      + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">              <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                          | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                  <span class=\"keyword\">continue</span>;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">              mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                  scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">              &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                          + e.getMessage());</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\">  <span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">  updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">      <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">      <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">      adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">              <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\">  <span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">  mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<ul>\n<li>mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，</li>\n</ul>\n<h4 id=\"2-4-PMS-SCAN-END\"><a href=\"#2-4-PMS-SCAN-END\" class=\"headerlink\" title=\"2.4 PMS_SCAN_END\"></a>2.4 PMS_SCAN_END</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> updateFlags = UPDATE_PERMISSIONS_ALL;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ver.sdkVersion != mSdkVersion) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Platform changed from \"</span> + ver.sdkVersion + <span class=\"string\">\" to \"</span></div><div class=\"line\">              + mSdkVersion + <span class=\"string\">\"; regranting permissions for internal storage\"</span>);</div><div class=\"line\">      updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</div><div class=\"line\">  &#125;</div><div class=\"line\">  updatePermissionsLPw(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, updateFlags);</div><div class=\"line\">  ver.sdkVersion = mSdkVersion;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is the first boot or an update from pre-M, and it is a normal</span></div><div class=\"line\">  <span class=\"comment\">// boot, then we need to initialize the default preferred apps across</span></div><div class=\"line\">  <span class=\"comment\">// all defined users.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (UserInfo user : sUserManager.getUsers(<span class=\"keyword\">true</span>)) &#123;</div><div class=\"line\">          mSettings.applyDefaultPreferredAppsLPw(<span class=\"keyword\">this</span>, user.id);</div><div class=\"line\">          applyFactoryDefaultBrowserLPw(user.id);</div><div class=\"line\">          primeDomainVerificationsLPw(user.id);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is first boot after an OTA, and a normal boot, then</span></div><div class=\"line\">  <span class=\"comment\">// we need to clear code cache directories.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Build fingerprint changed; clearing code caches\"</span>);</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mSettings.mPackages.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</div><div class=\"line\">              deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      ver.fingerprint = Build.FINGERPRINT;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  checkDefaultBrowser();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// clear only after permissions and other defaults have been updated</span></div><div class=\"line\">  mExistingSystemPackages.clear();</div><div class=\"line\">  mPromoteSystemApps = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// All the changes are done during package scanning.</span></div><div class=\"line\">  ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// can downgrade to reader</span></div><div class=\"line\">  mSettings.writeLPr();</div></pre></td></tr></table></figure>\n<ul>\n<li>当sdk版本不一致时，需要更新权限</li>\n<li>当这是ota后的首次启动，正常启动则需要清除目录的缓存代码</li>\n<li>当权限和其他默认项都完成更新，则清理相关信息</li>\n<li>信息写回packages.xml文件</li>\n</ul>\n<p>这部分不是很懂。</p>\n<h4 id=\"2-5-BOOT-PROGRESS-PMS-READY\"><a href=\"#2-5-BOOT-PROGRESS-PMS-READY\" class=\"headerlink\" title=\"2.5 BOOT_PROGRESS_PMS_READY\"></a>2.5 BOOT_PROGRESS_PMS_READY</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">  mRequiredVerifierPackage = getRequiredVerifierLPr();</div><div class=\"line\">    mRequiredInstallerPackage = getRequiredInstallerLPr();</div><div class=\"line\"></div><div class=\"line\">    mInstallerService = <span class=\"keyword\">new</span> PackageInstallerService(context, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</div><div class=\"line\">    mIntentFilterVerifier = <span class=\"keyword\">new</span> IntentVerifierProxy(mContext,</div><div class=\"line\">            mIntentFilterVerifierComponent);</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mPackages)</span></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mInstallLock)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now after opening every single application zip, make sure they</span></div><div class=\"line\"><span class=\"comment\">// are all flushed.  Not really needed, but keeps things nice and</span></div><div class=\"line\"><span class=\"comment\">// tidy.</span></div><div class=\"line\">Runtime.getRuntime().gc();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Expose private service for system components to use.</span></div><div class=\"line\">LocalServices.addService(PackageManagerInternal.class, <span class=\"keyword\">new</span> PackageManagerInternalImpl());</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化PackageInstallerService</li>\n<li>gc，回收下内存</li>\n</ul>\n<h3 id=\"3-Settings\"><a href=\"#3-Settings\" class=\"headerlink\" title=\"3.Settings\"></a>3.Settings</h3><p>这个类负责读取data/system下的几个xml文件。收集其中的一些信息。</p>\n<ul>\n<li>packages.xml    记录所有安装app的信息</li>\n<li>packages-backup.xml    备份文件</li>\n<li>packages-stopped.xml    记录系统被强制停止的文件</li>\n<li>packages-stopped-backup.xml    备份文件</li>\n<li>packages.list    记录应用的数据信息</li>\n</ul>\n<h3 id=\"4-scanDirLI\"><a href=\"#4-scanDirLI\" class=\"headerlink\" title=\"4.scanDirLI\"></a>4.scanDirLI</h3><p>这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> PackageParser.Package pkg;</div><div class=\"line\"> <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     pkg = pp.parsePackage(scanFile, parseFlags);</div><div class=\"line\"> &#125; <span class=\"keyword\">catch</span> (PackageParserException e) &#123;</div><div class=\"line\">     <span class=\"keyword\">throw</span> PackageManagerException.from(e);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>重点看解析部分的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Package <span class=\"title\">parsePackage</span><span class=\"params\">(File packageFile, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> PackageParserException </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (packageFile.isDirectory()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseClusterPackage(packageFile, flags);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseMonolithicPackage(packageFile, flags);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = <span class=\"keyword\">new</span> Resources(assets, mMetrics, <span class=\"keyword\">null</span>);</div><div class=\"line\">assets.setConfiguration(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        Build.VERSION.RESOURCES_SDK_INT);</div><div class=\"line\">parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> String[] outError = <span class=\"keyword\">new</span> String[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">final</span> Package pkg = parseBaseApk(res, parser, flags, outError);</div></pre></td></tr></table></figure>\n<p>在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"application\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (foundApp) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (RIGID_PARSER) &#123;</div><div class=\"line\">                        outError[<span class=\"number\">0</span>] = <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>;</div><div class=\"line\">                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        Slog.w(TAG, <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>);</div><div class=\"line\">                        XmlUtils.skipCurrentTag(parser);</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                foundApp = <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"activity\"</span>)) &#123;</div><div class=\"line\">                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, <span class=\"keyword\">false</span>,</div><div class=\"line\">                        owner.baseHardwareAccelerated);</div><div class=\"line\">                <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                owner.activities.add(a);</div><div class=\"line\"></div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>这里就不多说了。</p>\n<h3 id=\"4-dex优化\"><a href=\"#4-dex优化\" class=\"headerlink\" title=\"4. dex优化\"></a>4. dex优化</h3><p>在Installer中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dexopt</span><span class=\"params\">(String apkPath, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">boolean</span> isPublic, String pkgName,</span></span></div><div class=\"line\">        String instructionSet, <span class=\"keyword\">int</span> dexoptNeeded, <span class=\"keyword\">boolean</span> vmSafeMode,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> debuggable, String outputPath) &#123;</div><div class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"dexopt\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(apkPath);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(uid);</div><div class=\"line\">    builder.append(isPublic ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(pkgName);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(instructionSet);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(dexoptNeeded);</div><div class=\"line\">    builder.append(vmSafeMode ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(debuggable ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(outputPath != <span class=\"keyword\">null</span> ? outputPath : <span class=\"string\">\"!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> execute(builder.toString());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进行参数封装，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">execute</span><span class=\"params\">(String cmd)</span> </span>&#123;</div><div class=\"line\">    String res = transact(cmd);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Integer.parseInt(res);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException ex) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。</p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://gityuan.com/2016/11/06/packagemanager/\" target=\"_blank\" rel=\"external\">gityuan</a></li>\n<li>Android 5.0 源代码</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PackageManagerService <span class=\"title\">main</span><span class=\"params\">(Context context, Installer installer,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> factoryTest, <span class=\"keyword\">boolean</span> onlyCore)</span> </span>&#123;</div><div class=\"line\">    PackageManagerService m = <span class=\"keyword\">new</span> PackageManagerService(context, installer,</div><div class=\"line\">            factoryTest, onlyCore);</div><div class=\"line\">    ServiceManager.addService(<span class=\"string\">\"package\"</span>, m);</div><div class=\"line\">    <span class=\"keyword\">return</span> m;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-从pms构造函数说起\"><a href=\"#2-从pms构造函数说起\" class=\"headerlink\" title=\"2.从pms构造函数说起\"></a>2.从pms构造函数说起</h3><p>pms的构造函数相当长，根据<a href=\"http://gityuan.com/2016/11/06/packagemanager/\">gityuan大神</a>的提示，按照log的打印进行分布查看却是清晰了很多。</p>\n<h4 id=\"2-1-BOOT-PROGRESS-PMS-START\"><a href=\"#2-1-BOOT-PROGRESS-PMS-START\" class=\"headerlink\" title=\"2.1 BOOT_PROGRESS_PMS_START\"></a>2.1 BOOT_PROGRESS_PMS_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">mContext = context;</div><div class=\"line\">mFactoryTest = factoryTest;</div><div class=\"line\">mOnlyCore = onlyCore;</div><div class=\"line\">mLazyDexOpt = <span class=\"string\">\"eng\"</span>.equals(SystemProperties.get(<span class=\"string\">\"ro.build.type\"</span>));</div><div class=\"line\">mMetrics = <span class=\"keyword\">new</span> DisplayMetrics();</div><div class=\"line\">mSettings = <span class=\"keyword\">new</span> Settings(mPackages);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.system\"</span>, Process.SYSTEM_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.phone\"</span>, RADIO_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.log\"</span>, LOG_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.nfc\"</span>, NFC_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.bluetooth\"</span>, BLUETOOTH_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.shell\"</span>, SHELL_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> add a property to control this?</span></div><div class=\"line\"><span class=\"keyword\">long</span> dexOptLRUThresholdInMinutes;</div><div class=\"line\"><span class=\"keyword\">if</span> (mLazyDexOpt) &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">30</span>; <span class=\"comment\">// only last 30 minutes of apps for eng builds.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">7</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span>; <span class=\"comment\">// apps used in the 7 days for users.</span></div><div class=\"line\">&#125;</div><div class=\"line\">mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\">String separateProcesses = SystemProperties.get(<span class=\"string\">\"debug.separate_processes\"</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (separateProcesses != <span class=\"keyword\">null</span> &amp;&amp; separateProcesses.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"*\"</span>.equals(separateProcesses)) &#123;</div><div class=\"line\">        mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</div><div class=\"line\">        mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: * (ALL)\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">        mSeparateProcesses = separateProcesses.split(<span class=\"string\">\",\"</span>);</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: \"</span></div><div class=\"line\">                + separateProcesses);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">    mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mInstaller = installer;</div><div class=\"line\">mPackageDexOptimizer = <span class=\"keyword\">new</span> PackageDexOptimizer(<span class=\"keyword\">this</span>);</div><div class=\"line\">mMoveCallbacks = <span class=\"keyword\">new</span> MoveCallbacks(FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">mOnPermissionChangeListeners = <span class=\"keyword\">new</span> OnPermissionChangeListeners(</div><div class=\"line\">        FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">getDefaultDisplayMetrics(context, mMetrics);</div><div class=\"line\"></div><div class=\"line\">SystemConfig systemConfig = SystemConfig.getInstance();</div><div class=\"line\">mGlobalGids = systemConfig.getGlobalGids();</div><div class=\"line\">mSystemPermissions = systemConfig.getSystemPermissions();</div><div class=\"line\">mAvailableFeatures = systemConfig.getAvailableFeatures();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mInstallLock) &#123;</div><div class=\"line\"><span class=\"comment\">// writer</span></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mPackages) &#123;</div><div class=\"line\">    mHandlerThread = <span class=\"keyword\">new</span> ServiceThread(TAG,</div><div class=\"line\">            Process.THREAD_PRIORITY_BACKGROUND, <span class=\"keyword\">true</span> <span class=\"comment\">/*allowIo*/</span>);</div><div class=\"line\">    mHandlerThread.start();</div><div class=\"line\">    mHandler = <span class=\"keyword\">new</span> PackageHandler(mHandlerThread.getLooper());</div><div class=\"line\">    Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</div><div class=\"line\"></div><div class=\"line\">    File dataDir = Environment.getDataDirectory();</div><div class=\"line\">    mAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"data\"</span>);</div><div class=\"line\">    mAppInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app\"</span>);</div><div class=\"line\">    mAppLib32InstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-lib\"</span>);</div><div class=\"line\">    mAsecInternalPath = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-asec\"</span>).getPath();</div><div class=\"line\">    mUserAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"user\"</span>);</div><div class=\"line\">    mDrmAppPrivateInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-private\"</span>);</div><div class=\"line\"></div><div class=\"line\">    sUserManager = <span class=\"keyword\">new</span> UserManagerService(context, <span class=\"keyword\">this</span>,</div><div class=\"line\">            mInstallLock, mPackages);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Propagate permission configuration in to package manager.</span></div><div class=\"line\">    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</div><div class=\"line\">            = systemConfig.getPermissions();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;permConfig.size(); i++) &#123;</div><div class=\"line\">        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</div><div class=\"line\">        BasePermission bp = mSettings.mPermissions.get(perm.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (bp == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp = <span class=\"keyword\">new</span> BasePermission(perm.name, <span class=\"string\">\"android\"</span>, BasePermission.TYPE_BUILTIN);</div><div class=\"line\">            mSettings.mPermissions.put(perm.name, bp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm.gids != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp.setGids(perm.gids, perm.perUser);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;libConfig.size(); i++) &#123;</div><div class=\"line\">        mSharedLibraries.put(libConfig.keyAt(i),</div><div class=\"line\">                <span class=\"keyword\">new</span> SharedLibraryEntry(libConfig.valueAt(i), <span class=\"keyword\">null</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</div><div class=\"line\"></div><div class=\"line\">    mRestoredSettings = mSettings.readLPw(<span class=\"keyword\">this</span>, sUserManager.getUsers(<span class=\"keyword\">false</span>),</div><div class=\"line\">            mSdkVersion, mOnlyCore);</div><div class=\"line\"></div><div class=\"line\">    String customResolverActivity = Resources.getSystem().getString(</div><div class=\"line\">            R.string.config_customResolverActivity);</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(customResolverActivity)) &#123;</div><div class=\"line\">        customResolverActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mCustomResolverComponentName = ComponentName.unflattenFromString(</div><div class=\"line\">                customResolverActivity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">long</span> startTime = SystemClock.uptimeMillis();</div></pre></td></tr></table></figure>\n<ul>\n<li>构造Settings对象，添加shareUserId</li>\n<li>构造SystemConfig，获取mSystemPermissions灯属性</li>\n<li>创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象</li>\n<li>从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，</li>\n</ul>\n<h4 id=\"2-2-PMS-SYSTEM-SCAN-START\"><a href=\"#2-2-PMS-SYSTEM-SCAN-START\" class=\"headerlink\" title=\"2.2 PMS_SYSTEM_SCAN_START\"></a>2.2 PMS_SYSTEM_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> ArraySet&lt;String&gt; alreadyDexOpted = <span class=\"keyword\">new</span> ArraySet&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Add everything in the in the boot class path to the</div><div class=\"line\"> * list of process files because dexopt will have been run</div><div class=\"line\"> * if necessary during zygote startup.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">final</span> String bootClassPath = System.getenv(<span class=\"string\">\"BOOTCLASSPATH\"</span>);</div><div class=\"line\"><span class=\"keyword\">final</span> String systemServerClassPath = System.getenv(<span class=\"string\">\"SYSTEMSERVERCLASSPATH\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (bootClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] bootClassPathElements = splitString(bootClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : bootClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No BOOTCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (systemServerClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : systemServerClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No SYSTEMSERVERCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</div><div class=\"line\"><span class=\"keyword\">final</span> String[] dexCodeInstructionSets =</div><div class=\"line\">        getDexCodeInstructionSets(</div><div class=\"line\">                allInstructionSets.toArray(<span class=\"keyword\">new</span> String[allInstructionSets.size()]));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Ensure all external libraries have had dexopt run on them.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mSharedLibraries.size() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> For now, we're compiling these system \"shared libraries\"</span></div><div class=\"line\">    <span class=\"comment\">// (and framework jars) into all available architectures. It's possible</span></div><div class=\"line\">    <span class=\"comment\">// to compile them only when we come across an app that uses them (there's</span></div><div class=\"line\">    <span class=\"comment\">// already logic for that in scanPackageLI) but that adds some complexity.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> String lib = libEntry.path;</div><div class=\"line\">            <span class=\"keyword\">if</span> (lib == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(lib, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    alreadyDexOpted.add(lib);</div><div class=\"line\">                    mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Library not found: \"</span> + lib);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Cannot dexopt \"</span> + lib + <span class=\"string\">\"; is it an APK or JAR? \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">File frameworkDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"framework\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file doesn't contain any</span></div><div class=\"line\"><span class=\"comment\">// code, so don't dexopt it to avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/framework-res.apk\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file is only part of</span></div><div class=\"line\"><span class=\"comment\">// the boot class path for art, so don't dexopt it to</span></div><div class=\"line\"><span class=\"comment\">// avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/core-libart.jar\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * There are a number of commands implemented in Java, which</div><div class=\"line\"> * we currently need to do the dexopt on so that they can be</div><div class=\"line\"> * run from a non-root shell.</div><div class=\"line\"> */</span></div><div class=\"line\">String[] frameworkFiles = frameworkDir.list();</div><div class=\"line\"><span class=\"keyword\">if</span> (frameworkFiles != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We could compile these only for the most preferred ABI. We should</span></div><div class=\"line\">    <span class=\"comment\">// first double check that the dex files for these commands are not referenced</span></div><div class=\"line\">    <span class=\"comment\">// by other system apps.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;frameworkFiles.length; i++) &#123;</div><div class=\"line\">            File libPath = <span class=\"keyword\">new</span> File(frameworkDir, frameworkFiles[i]);</div><div class=\"line\">            String path = libPath.getPath();</div><div class=\"line\">            <span class=\"comment\">// Skip the file if we already did it.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (alreadyDexOpted.contains(path)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// Skip the file if it is not a type we want to dexopt.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!path.endsWith(<span class=\"string\">\".apk\"</span>) &amp;&amp; !path.endsWith(<span class=\"string\">\".jar\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(path, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    mInstaller.dexopt(path, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Jar not found: \"</span> + path);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Exception reading jar: \"</span> + path, e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> VersionInfo ver = mSettings.getInternalVersion();</div><div class=\"line\">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</div><div class=\"line\"><span class=\"comment\">// when upgrading from pre-M, promote system app permissions from install to runtime</span></div><div class=\"line\">mPromoteSystemApps =</div><div class=\"line\">        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// save off the names of pre-existing system packages prior to scanning; we don't</span></div><div class=\"line\"><span class=\"comment\">// want to automatically grant runtime permissions for new system apps</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mPromoteSystemApps) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (pkgSettingIter.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = pkgSettingIter.next();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isSystemApp(ps)) &#123;</div><div class=\"line\">            mExistingSystemPackages.add(ps.name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect vendor overlay packages.</span></div><div class=\"line\"><span class=\"comment\">// (Do this before scanning any apps.)</span></div><div class=\"line\"><span class=\"comment\">// For security and version matching reason, only consider</span></div><div class=\"line\"><span class=\"comment\">// overlay packages if they reside in VENDOR_OVERLAY_DIR.</span></div><div class=\"line\">File vendorOverlayDir = <span class=\"keyword\">new</span> File(VENDOR_OVERLAY_DIR);</div><div class=\"line\">scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Find base frameworks (resource packages without code).</span></div><div class=\"line\">scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED,</div><div class=\"line\">        scanFlags | SCAN_NO_DEX, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collected privileged system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File privilegedAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"priv-app\"</span>);</div><div class=\"line\">scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect ordinary system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File systemAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all vendor packages.</span></div><div class=\"line\">File vendorAppDir = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/vendor/app\"</span>);</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    vendorAppDir = vendorAppDir.getCanonicalFile();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">    <span class=\"comment\">// failed to look up canonical path, continue with original one</span></div><div class=\"line\">&#125;</div><div class=\"line\">scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all OEM packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File oemAppDir = <span class=\"keyword\">new</span> File(Environment.getOemDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (DEBUG_UPGRADE) Log.v(TAG, <span class=\"string\">\"Running installd update commands\"</span>);</div><div class=\"line\">mInstaller.moveFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prune any system packages that no longer exist.</span></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; possiblyDeletedUpdatedSystemApps = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (psit.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = psit.next();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * If this is not a system app, it can't be a</div><div class=\"line\">         * disable system app.</div><div class=\"line\">         */</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * If the package is scanned, it's not erased.</div><div class=\"line\">         */</span></div><div class=\"line\">        <span class=\"keyword\">final</span> PackageParser.Package scannedPkg = mPackages.get(ps.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (scannedPkg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</div><div class=\"line\">             * If the system app is both scanned and in the</div><div class=\"line\">             * disabled packages list, then it must have been</div><div class=\"line\">             * added via OTA. Remove it from the currently</div><div class=\"line\">             * scanned package so the previously user-installed</div><div class=\"line\">             * application can be scanned.</div><div class=\"line\">             */</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">                logCriticalInfo(Log.WARN, <span class=\"string\">\"Expecting better updated system app for \"</span></div><div class=\"line\">                        + ps.name + <span class=\"string\">\"; removing system app.  Last known codePath=\"</span></div><div class=\"line\">                        + ps.codePathString + <span class=\"string\">\", installStatus=\"</span> + ps.installStatus</div><div class=\"line\">                        + <span class=\"string\">\", versionCode=\"</span> + ps.versionCode + <span class=\"string\">\"; scanned versionCode=\"</span></div><div class=\"line\">                        + scannedPkg.mVersionCode);</div><div class=\"line\">                removePackageLI(ps, <span class=\"keyword\">true</span>);</div><div class=\"line\">                mExpectingBetter.put(ps.name, ps.codePath);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">            psit.remove();</div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"System package \"</span> + ps.name</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>);</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, ps.name);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</div><div class=\"line\">            <span class=\"keyword\">if</span> (disabledPs.codePath == <span class=\"keyword\">null</span> || !disabledPs.codePath.exists()) &#123;</div><div class=\"line\">                possiblyDeletedUpdatedSystemApps.add(ps.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//look for any incomplete package installations</span></div><div class=\"line\">ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</div><div class=\"line\"><span class=\"comment\">//clean up list</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deletePkgsList.size(); i++) &#123;</div><div class=\"line\">    <span class=\"comment\">//clean up here</span></div><div class=\"line\">    cleanupInstallFailedPackage(deletePkgsList.get(i));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//delete tmp files</span></div><div class=\"line\">deleteTempPackageFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Remove any shared userIDs that have no associated packages</span></div><div class=\"line\">mSettings.pruneSharedUsersLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">    scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">            scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Remove disable package settings for any updated system</div><div class=\"line\">     * apps that were removed via an OTA. If they're not a</div><div class=\"line\">     * previously-updated app, remove them completely.</div><div class=\"line\">     * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">        PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">        mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">        String msg;</div><div class=\"line\">        <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                    + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">            deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">            PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">            deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">        &#125;</div><div class=\"line\">        logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Make sure all system apps that we expected to appear on</div><div class=\"line\">     * the userdata partition actually showed up. If they never</div><div class=\"line\">     * appeared, crawl back and revive the system version.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                    + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">            <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                        | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\"><span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">    <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">    <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">    adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">            <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\"><span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<p>扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。</p>\n<ul>\n<li><p>首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>SYSTEMSERVERCLASSPATH内容为下</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>获取构建时指定的cpu指令</li>\n<li>根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中</li>\n<li>将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表</li>\n<li>将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表</li>\n<li>收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息</li>\n<li>删除系统不存在的包removePackageLI</li>\n<li>清理安装失败的包 cleanupInstallFailedPackage</li>\n<li>删除临时文件</li>\n<li>移除不想干的包中的shared userIDs</li>\n</ul>\n<h4 id=\"2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\"><a href=\"#2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\" class=\"headerlink\" title=\"2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\"></a>2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">              SystemClock.uptimeMillis());</div><div class=\"line\">      scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">              scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</div><div class=\"line\">       * Remove disable package settings for any updated system</div><div class=\"line\">       * apps that were removed via an OTA. If they're not a</div><div class=\"line\">       * previously-updated app, remove them completely.</div><div class=\"line\">       * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">       */</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">          PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">          mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">          String msg;</div><div class=\"line\">          <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">              removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                      + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">              deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">              PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">              deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">          &#125;</div><div class=\"line\">          logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</div><div class=\"line\">       * Make sure all system apps that we expected to appear on</div><div class=\"line\">       * the userdata partition actually showed up. If they never</div><div class=\"line\">       * appeared, crawl back and revive the system version.</div><div class=\"line\">       */</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">              <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">              logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                      + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">              <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                          | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                  <span class=\"keyword\">continue</span>;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">              mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                  scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">              &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                          + e.getMessage());</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\">  <span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">  updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">      <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">      <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">      adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">              <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\">  <span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">  mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<ul>\n<li>mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，</li>\n</ul>\n<h4 id=\"2-4-PMS-SCAN-END\"><a href=\"#2-4-PMS-SCAN-END\" class=\"headerlink\" title=\"2.4 PMS_SCAN_END\"></a>2.4 PMS_SCAN_END</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> updateFlags = UPDATE_PERMISSIONS_ALL;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ver.sdkVersion != mSdkVersion) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Platform changed from \"</span> + ver.sdkVersion + <span class=\"string\">\" to \"</span></div><div class=\"line\">              + mSdkVersion + <span class=\"string\">\"; regranting permissions for internal storage\"</span>);</div><div class=\"line\">      updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</div><div class=\"line\">  &#125;</div><div class=\"line\">  updatePermissionsLPw(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, updateFlags);</div><div class=\"line\">  ver.sdkVersion = mSdkVersion;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is the first boot or an update from pre-M, and it is a normal</span></div><div class=\"line\">  <span class=\"comment\">// boot, then we need to initialize the default preferred apps across</span></div><div class=\"line\">  <span class=\"comment\">// all defined users.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (UserInfo user : sUserManager.getUsers(<span class=\"keyword\">true</span>)) &#123;</div><div class=\"line\">          mSettings.applyDefaultPreferredAppsLPw(<span class=\"keyword\">this</span>, user.id);</div><div class=\"line\">          applyFactoryDefaultBrowserLPw(user.id);</div><div class=\"line\">          primeDomainVerificationsLPw(user.id);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is first boot after an OTA, and a normal boot, then</span></div><div class=\"line\">  <span class=\"comment\">// we need to clear code cache directories.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Build fingerprint changed; clearing code caches\"</span>);</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mSettings.mPackages.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</div><div class=\"line\">              deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      ver.fingerprint = Build.FINGERPRINT;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  checkDefaultBrowser();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// clear only after permissions and other defaults have been updated</span></div><div class=\"line\">  mExistingSystemPackages.clear();</div><div class=\"line\">  mPromoteSystemApps = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// All the changes are done during package scanning.</span></div><div class=\"line\">  ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// can downgrade to reader</span></div><div class=\"line\">  mSettings.writeLPr();</div></pre></td></tr></table></figure>\n<ul>\n<li>当sdk版本不一致时，需要更新权限</li>\n<li>当这是ota后的首次启动，正常启动则需要清除目录的缓存代码</li>\n<li>当权限和其他默认项都完成更新，则清理相关信息</li>\n<li>信息写回packages.xml文件</li>\n</ul>\n<p>这部分不是很懂。</p>\n<h4 id=\"2-5-BOOT-PROGRESS-PMS-READY\"><a href=\"#2-5-BOOT-PROGRESS-PMS-READY\" class=\"headerlink\" title=\"2.5 BOOT_PROGRESS_PMS_READY\"></a>2.5 BOOT_PROGRESS_PMS_READY</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">  mRequiredVerifierPackage = getRequiredVerifierLPr();</div><div class=\"line\">    mRequiredInstallerPackage = getRequiredInstallerLPr();</div><div class=\"line\"></div><div class=\"line\">    mInstallerService = <span class=\"keyword\">new</span> PackageInstallerService(context, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</div><div class=\"line\">    mIntentFilterVerifier = <span class=\"keyword\">new</span> IntentVerifierProxy(mContext,</div><div class=\"line\">            mIntentFilterVerifierComponent);</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mPackages)</span></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mInstallLock)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now after opening every single application zip, make sure they</span></div><div class=\"line\"><span class=\"comment\">// are all flushed.  Not really needed, but keeps things nice and</span></div><div class=\"line\"><span class=\"comment\">// tidy.</span></div><div class=\"line\">Runtime.getRuntime().gc();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Expose private service for system components to use.</span></div><div class=\"line\">LocalServices.addService(PackageManagerInternal.class, <span class=\"keyword\">new</span> PackageManagerInternalImpl());</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化PackageInstallerService</li>\n<li>gc，回收下内存</li>\n</ul>\n<h3 id=\"3-Settings\"><a href=\"#3-Settings\" class=\"headerlink\" title=\"3.Settings\"></a>3.Settings</h3><p>这个类负责读取data/system下的几个xml文件。收集其中的一些信息。</p>\n<ul>\n<li>packages.xml    记录所有安装app的信息</li>\n<li>packages-backup.xml    备份文件</li>\n<li>packages-stopped.xml    记录系统被强制停止的文件</li>\n<li>packages-stopped-backup.xml    备份文件</li>\n<li>packages.list    记录应用的数据信息</li>\n</ul>\n<h3 id=\"4-scanDirLI\"><a href=\"#4-scanDirLI\" class=\"headerlink\" title=\"4.scanDirLI\"></a>4.scanDirLI</h3><p>这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> PackageParser.Package pkg;</div><div class=\"line\"> <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     pkg = pp.parsePackage(scanFile, parseFlags);</div><div class=\"line\"> &#125; <span class=\"keyword\">catch</span> (PackageParserException e) &#123;</div><div class=\"line\">     <span class=\"keyword\">throw</span> PackageManagerException.from(e);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>重点看解析部分的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Package <span class=\"title\">parsePackage</span><span class=\"params\">(File packageFile, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> PackageParserException </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (packageFile.isDirectory()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseClusterPackage(packageFile, flags);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseMonolithicPackage(packageFile, flags);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = <span class=\"keyword\">new</span> Resources(assets, mMetrics, <span class=\"keyword\">null</span>);</div><div class=\"line\">assets.setConfiguration(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        Build.VERSION.RESOURCES_SDK_INT);</div><div class=\"line\">parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> String[] outError = <span class=\"keyword\">new</span> String[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">final</span> Package pkg = parseBaseApk(res, parser, flags, outError);</div></pre></td></tr></table></figure>\n<p>在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"application\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (foundApp) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (RIGID_PARSER) &#123;</div><div class=\"line\">                        outError[<span class=\"number\">0</span>] = <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>;</div><div class=\"line\">                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        Slog.w(TAG, <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>);</div><div class=\"line\">                        XmlUtils.skipCurrentTag(parser);</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                foundApp = <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"activity\"</span>)) &#123;</div><div class=\"line\">                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, <span class=\"keyword\">false</span>,</div><div class=\"line\">                        owner.baseHardwareAccelerated);</div><div class=\"line\">                <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                owner.activities.add(a);</div><div class=\"line\"></div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>这里就不多说了。</p>\n<h3 id=\"4-dex优化\"><a href=\"#4-dex优化\" class=\"headerlink\" title=\"4. dex优化\"></a>4. dex优化</h3><p>在Installer中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dexopt</span><span class=\"params\">(String apkPath, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">boolean</span> isPublic, String pkgName,</div><div class=\"line\">        String instructionSet, <span class=\"keyword\">int</span> dexoptNeeded, <span class=\"keyword\">boolean</span> vmSafeMode,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> debuggable, String outputPath)</span> </span>&#123;</div><div class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"dexopt\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(apkPath);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(uid);</div><div class=\"line\">    builder.append(isPublic ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(pkgName);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(instructionSet);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(dexoptNeeded);</div><div class=\"line\">    builder.append(vmSafeMode ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(debuggable ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(outputPath != <span class=\"keyword\">null</span> ? outputPath : <span class=\"string\">\"!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> execute(builder.toString());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进行参数封装，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">execute</span><span class=\"params\">(String cmd)</span> </span>&#123;</div><div class=\"line\">    String res = transact(cmd);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Integer.parseInt(res);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException ex) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。</p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://gityuan.com/2016/11/06/packagemanager/\">gityuan</a></li>\n<li>Android 5.0 源代码</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Service启动流程","date":"2016-12-26T07:19:04.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n我们启动service分为两种情况\n\n* startService\n* bindService\n\n我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。\n\n### 2.startService的方式\n\n#### 2.1 ContextImpl#startServiceCommon\n\n在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：\n\n```\n            ComponentName cn = ActivityManagerNative.getDefault().startService(\n                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(\n                            getContentResolver()), getOpPackageName(), user.getIdentifier());\n```\nActivityManagerNative.getDefault()，为binder客户端，上篇说到过。\n\n在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。\n\n因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。\n\n#### 2.2 ActivityManagerService#startService\n\n在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，\n\n```\n            final int callingPid = Binder.getCallingPid();\n            final int callingUid = Binder.getCallingUid();\n            final long origId = Binder.clearCallingIdentity();\n            ComponentName res = mServices.startServiceLocked(caller, service,\n                    resolvedType, callingPid, callingUid, callingPackage, userId);\n            Binder.restoreCallingIdentity(origId);\n            return res;\n```\n\n#### 2.3 ActivityService#startServiceLocked\n\n在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法\n\n#### 2.4 ActivityService#startServiceInnerLocked\n\n\n\n```\nString error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);\n```\n在这个方法中,后续操作交由bringUpServiceLocked处理。\n\n\n#### 2.5 ActivityService#bringUpServiceLocked\n\n在这个方法中，有两种情况：\n\n* 需要的进程存在\n* 需要的进程不存在\n\n当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。\n\n如果需要的进程不存在，则需要fork进程，这个后面的文章在说。\n\n解析来我们直接看realStartServiceLocked操作吧。\n\n#### 2.6 ActivityService#realStartServiceLocked\n\n改方法核心代码；\n\n```\n            app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),\n                    app.repProcState);\n```\n\n这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。\n\n#### 2.7 ActivityThread#handleCreateService\n\n```\n   private void handleCreateService(CreateServiceData data) {\n        // If we are getting ready to gc after going to the background, well\n        // we are back active so skip it.\n        unscheduleGcIdler();\n\n        LoadedApk packageInfo = getPackageInfoNoCheck(\n                data.info.applicationInfo, data.compatInfo);\n        Service service = null;\n        try {\n            java.lang.ClassLoader cl = packageInfo.getClassLoader();\n            service = (Service) cl.loadClass(data.info.name).newInstance();\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to instantiate service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n\n        try {\n            if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name);\n\n            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n            context.setOuterContext(service);\n\n            Application app = packageInfo.makeApplication(false, mInstrumentation);\n            service.attach(context, this, data.info.name, data.token, app,\n                    ActivityManagerNative.getDefault());\n            service.onCreate();\n            mServices.put(data.token, service);\n            try {\n                ActivityManagerNative.getDefault().serviceDoneExecuting(\n                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);\n            } catch (RemoteException e) {\n                // nothing to do.\n            }\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to create service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n    }\n```\n\n* 构造service\n* 关联application\n* 调用onCreate 执行\n\n就这样，一个全新的service就启动了。\n\n\n\n\n\n\n### 3.bindService的方式\n\n这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；\n\n```\n                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,\n                        r.app.repProcState);\n\n```\n\n随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。\n\n### 4.上图\n这里只是简单的介绍了流程，很多细节的东西并没有看。\n\n![](/images/framework/service/startservice.png)\n\n\n![](/images/framework/service/bindservice.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Service启动流程.md","raw":"---\ntitle: Service启动流程\ndate: 2016-12-26 15:19:04\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n我们启动service分为两种情况\n\n* startService\n* bindService\n\n我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。\n\n### 2.startService的方式\n\n#### 2.1 ContextImpl#startServiceCommon\n\n在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：\n\n```\n            ComponentName cn = ActivityManagerNative.getDefault().startService(\n                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(\n                            getContentResolver()), getOpPackageName(), user.getIdentifier());\n```\nActivityManagerNative.getDefault()，为binder客户端，上篇说到过。\n\n在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。\n\n因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。\n\n#### 2.2 ActivityManagerService#startService\n\n在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，\n\n```\n            final int callingPid = Binder.getCallingPid();\n            final int callingUid = Binder.getCallingUid();\n            final long origId = Binder.clearCallingIdentity();\n            ComponentName res = mServices.startServiceLocked(caller, service,\n                    resolvedType, callingPid, callingUid, callingPackage, userId);\n            Binder.restoreCallingIdentity(origId);\n            return res;\n```\n\n#### 2.3 ActivityService#startServiceLocked\n\n在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法\n\n#### 2.4 ActivityService#startServiceInnerLocked\n\n\n\n```\nString error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);\n```\n在这个方法中,后续操作交由bringUpServiceLocked处理。\n\n\n#### 2.5 ActivityService#bringUpServiceLocked\n\n在这个方法中，有两种情况：\n\n* 需要的进程存在\n* 需要的进程不存在\n\n当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。\n\n如果需要的进程不存在，则需要fork进程，这个后面的文章在说。\n\n解析来我们直接看realStartServiceLocked操作吧。\n\n#### 2.6 ActivityService#realStartServiceLocked\n\n改方法核心代码；\n\n```\n            app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),\n                    app.repProcState);\n```\n\n这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。\n\n#### 2.7 ActivityThread#handleCreateService\n\n```\n   private void handleCreateService(CreateServiceData data) {\n        // If we are getting ready to gc after going to the background, well\n        // we are back active so skip it.\n        unscheduleGcIdler();\n\n        LoadedApk packageInfo = getPackageInfoNoCheck(\n                data.info.applicationInfo, data.compatInfo);\n        Service service = null;\n        try {\n            java.lang.ClassLoader cl = packageInfo.getClassLoader();\n            service = (Service) cl.loadClass(data.info.name).newInstance();\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to instantiate service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n\n        try {\n            if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name);\n\n            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n            context.setOuterContext(service);\n\n            Application app = packageInfo.makeApplication(false, mInstrumentation);\n            service.attach(context, this, data.info.name, data.token, app,\n                    ActivityManagerNative.getDefault());\n            service.onCreate();\n            mServices.put(data.token, service);\n            try {\n                ActivityManagerNative.getDefault().serviceDoneExecuting(\n                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);\n            } catch (RemoteException e) {\n                // nothing to do.\n            }\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to create service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n    }\n```\n\n* 构造service\n* 关联application\n* 调用onCreate 执行\n\n就这样，一个全新的service就启动了。\n\n\n\n\n\n\n### 3.bindService的方式\n\n这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；\n\n```\n                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,\n                        r.app.repProcState);\n\n```\n\n随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。\n\n### 4.上图\n这里只是简单的介绍了流程，很多细节的东西并没有看。\n\n![](/images/framework/service/startservice.png)\n\n\n![](/images/framework/service/bindservice.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Service启动流程","published":1,"updated":"2017-01-06T05:32:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85y8000suaxawlqvfyug","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<p>我们启动service分为两种情况</p>\n<ul>\n<li>startService</li>\n<li>bindService</li>\n</ul>\n<p>我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。</p>\n<h3 id=\"2-startService的方式\"><a href=\"#2-startService的方式\" class=\"headerlink\" title=\"2.startService的方式\"></a>2.startService的方式</h3><h4 id=\"2-1-ContextImpl-startServiceCommon\"><a href=\"#2-1-ContextImpl-startServiceCommon\" class=\"headerlink\" title=\"2.1 ContextImpl#startServiceCommon\"></a>2.1 ContextImpl#startServiceCommon</h4><p>在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ComponentName cn = ActivityManagerNative.getDefault().startService(</div><div class=\"line\">    mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</div><div class=\"line\">                getContentResolver()), getOpPackageName(), user.getIdentifier());</div></pre></td></tr></table></figure>\n<p>ActivityManagerNative.getDefault()，为binder客户端，上篇说到过。</p>\n<p>在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。</p>\n<p>因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。</p>\n<h4 id=\"2-2-ActivityManagerService-startService\"><a href=\"#2-2-ActivityManagerService-startService\" class=\"headerlink\" title=\"2.2 ActivityManagerService#startService\"></a>2.2 ActivityManagerService#startService</h4><p>在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int callingPid = Binder.getCallingPid();</div><div class=\"line\">final int callingUid = Binder.getCallingUid();</div><div class=\"line\">final long origId = Binder.clearCallingIdentity();</div><div class=\"line\">ComponentName res = mServices.startServiceLocked(caller, service,</div><div class=\"line\">        resolvedType, callingPid, callingUid, callingPackage, userId);</div><div class=\"line\">Binder.restoreCallingIdentity(origId);</div><div class=\"line\">return res;</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-ActivityService-startServiceLocked\"><a href=\"#2-3-ActivityService-startServiceLocked\" class=\"headerlink\" title=\"2.3 ActivityService#startServiceLocked\"></a>2.3 ActivityService#startServiceLocked</h4><p>在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法</p>\n<h4 id=\"2-4-ActivityService-startServiceInnerLocked\"><a href=\"#2-4-ActivityService-startServiceInnerLocked\" class=\"headerlink\" title=\"2.4 ActivityService#startServiceInnerLocked\"></a>2.4 ActivityService#startServiceInnerLocked</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);</div></pre></td></tr></table></figure>\n<p>在这个方法中,后续操作交由bringUpServiceLocked处理。</p>\n<h4 id=\"2-5-ActivityService-bringUpServiceLocked\"><a href=\"#2-5-ActivityService-bringUpServiceLocked\" class=\"headerlink\" title=\"2.5 ActivityService#bringUpServiceLocked\"></a>2.5 ActivityService#bringUpServiceLocked</h4><p>在这个方法中，有两种情况：</p>\n<ul>\n<li>需要的进程存在</li>\n<li>需要的进程不存在</li>\n</ul>\n<p>当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。</p>\n<p>如果需要的进程不存在，则需要fork进程，这个后面的文章在说。</p>\n<p>解析来我们直接看realStartServiceLocked操作吧。</p>\n<h4 id=\"2-6-ActivityService-realStartServiceLocked\"><a href=\"#2-6-ActivityService-realStartServiceLocked\" class=\"headerlink\" title=\"2.6 ActivityService#realStartServiceLocked\"></a>2.6 ActivityService#realStartServiceLocked</h4><p>改方法核心代码；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleCreateService(r, r.serviceInfo,</div><div class=\"line\">        mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</div><div class=\"line\">        app.repProcState);</div></pre></td></tr></table></figure>\n<p>这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。</p>\n<h4 id=\"2-7-ActivityThread-handleCreateService\"><a href=\"#2-7-ActivityThread-handleCreateService\" class=\"headerlink\" title=\"2.7 ActivityThread#handleCreateService\"></a>2.7 ActivityThread#handleCreateService</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void handleCreateService(CreateServiceData data) &#123;</div><div class=\"line\">     // If we are getting ready to gc after going to the background, well</div><div class=\"line\">     // we are back active so skip it.</div><div class=\"line\">     unscheduleGcIdler();</div><div class=\"line\"></div><div class=\"line\">     LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class=\"line\">             data.info.applicationInfo, data.compatInfo);</div><div class=\"line\">     Service service = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class=\"line\">         service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to instantiate service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</div><div class=\"line\"></div><div class=\"line\">         ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</div><div class=\"line\">         context.setOuterContext(service);</div><div class=\"line\"></div><div class=\"line\">         Application app = packageInfo.makeApplication(false, mInstrumentation);</div><div class=\"line\">         service.attach(context, this, data.info.name, data.token, app,</div><div class=\"line\">                 ActivityManagerNative.getDefault());</div><div class=\"line\">         service.onCreate();</div><div class=\"line\">         mServices.put(data.token, service);</div><div class=\"line\">         try &#123;</div><div class=\"line\">             ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class=\"line\">                     data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</div><div class=\"line\">         &#125; catch (RemoteException e) &#123;</div><div class=\"line\">             // nothing to do.</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to create service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造service</li>\n<li>关联application</li>\n<li>调用onCreate 执行</li>\n</ul>\n<p>就这样，一个全新的service就启动了。</p>\n<h3 id=\"3-bindService的方式\"><a href=\"#3-bindService的方式\" class=\"headerlink\" title=\"3.bindService的方式\"></a>3.bindService的方式</h3><p>这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</div><div class=\"line\">        r.app.repProcState);</div></pre></td></tr></table></figure>\n<p>随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。</p>\n<h3 id=\"4-上图\"><a href=\"#4-上图\" class=\"headerlink\" title=\"4.上图\"></a>4.上图</h3><p>这里只是简单的介绍了流程，很多细节的东西并没有看。</p>\n<p><img src=\"/images/framework/service/startservice.png\" alt=\"\"></p>\n<p><img src=\"/images/framework/service/bindservice.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<p>我们启动service分为两种情况</p>\n<ul>\n<li>startService</li>\n<li>bindService</li>\n</ul>\n<p>我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。</p>\n<h3 id=\"2-startService的方式\"><a href=\"#2-startService的方式\" class=\"headerlink\" title=\"2.startService的方式\"></a>2.startService的方式</h3><h4 id=\"2-1-ContextImpl-startServiceCommon\"><a href=\"#2-1-ContextImpl-startServiceCommon\" class=\"headerlink\" title=\"2.1 ContextImpl#startServiceCommon\"></a>2.1 ContextImpl#startServiceCommon</h4><p>在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ComponentName cn = ActivityManagerNative.getDefault().startService(</div><div class=\"line\">    mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</div><div class=\"line\">                getContentResolver()), getOpPackageName(), user.getIdentifier());</div></pre></td></tr></table></figure>\n<p>ActivityManagerNative.getDefault()，为binder客户端，上篇说到过。</p>\n<p>在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。</p>\n<p>因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。</p>\n<h4 id=\"2-2-ActivityManagerService-startService\"><a href=\"#2-2-ActivityManagerService-startService\" class=\"headerlink\" title=\"2.2 ActivityManagerService#startService\"></a>2.2 ActivityManagerService#startService</h4><p>在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int callingPid = Binder.getCallingPid();</div><div class=\"line\">final int callingUid = Binder.getCallingUid();</div><div class=\"line\">final long origId = Binder.clearCallingIdentity();</div><div class=\"line\">ComponentName res = mServices.startServiceLocked(caller, service,</div><div class=\"line\">        resolvedType, callingPid, callingUid, callingPackage, userId);</div><div class=\"line\">Binder.restoreCallingIdentity(origId);</div><div class=\"line\">return res;</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-ActivityService-startServiceLocked\"><a href=\"#2-3-ActivityService-startServiceLocked\" class=\"headerlink\" title=\"2.3 ActivityService#startServiceLocked\"></a>2.3 ActivityService#startServiceLocked</h4><p>在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法</p>\n<h4 id=\"2-4-ActivityService-startServiceInnerLocked\"><a href=\"#2-4-ActivityService-startServiceInnerLocked\" class=\"headerlink\" title=\"2.4 ActivityService#startServiceInnerLocked\"></a>2.4 ActivityService#startServiceInnerLocked</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);</div></pre></td></tr></table></figure>\n<p>在这个方法中,后续操作交由bringUpServiceLocked处理。</p>\n<h4 id=\"2-5-ActivityService-bringUpServiceLocked\"><a href=\"#2-5-ActivityService-bringUpServiceLocked\" class=\"headerlink\" title=\"2.5 ActivityService#bringUpServiceLocked\"></a>2.5 ActivityService#bringUpServiceLocked</h4><p>在这个方法中，有两种情况：</p>\n<ul>\n<li>需要的进程存在</li>\n<li>需要的进程不存在</li>\n</ul>\n<p>当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。</p>\n<p>如果需要的进程不存在，则需要fork进程，这个后面的文章在说。</p>\n<p>解析来我们直接看realStartServiceLocked操作吧。</p>\n<h4 id=\"2-6-ActivityService-realStartServiceLocked\"><a href=\"#2-6-ActivityService-realStartServiceLocked\" class=\"headerlink\" title=\"2.6 ActivityService#realStartServiceLocked\"></a>2.6 ActivityService#realStartServiceLocked</h4><p>改方法核心代码；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleCreateService(r, r.serviceInfo,</div><div class=\"line\">        mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</div><div class=\"line\">        app.repProcState);</div></pre></td></tr></table></figure>\n<p>这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。</p>\n<h4 id=\"2-7-ActivityThread-handleCreateService\"><a href=\"#2-7-ActivityThread-handleCreateService\" class=\"headerlink\" title=\"2.7 ActivityThread#handleCreateService\"></a>2.7 ActivityThread#handleCreateService</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void handleCreateService(CreateServiceData data) &#123;</div><div class=\"line\">     // If we are getting ready to gc after going to the background, well</div><div class=\"line\">     // we are back active so skip it.</div><div class=\"line\">     unscheduleGcIdler();</div><div class=\"line\"></div><div class=\"line\">     LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class=\"line\">             data.info.applicationInfo, data.compatInfo);</div><div class=\"line\">     Service service = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class=\"line\">         service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to instantiate service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</div><div class=\"line\"></div><div class=\"line\">         ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</div><div class=\"line\">         context.setOuterContext(service);</div><div class=\"line\"></div><div class=\"line\">         Application app = packageInfo.makeApplication(false, mInstrumentation);</div><div class=\"line\">         service.attach(context, this, data.info.name, data.token, app,</div><div class=\"line\">                 ActivityManagerNative.getDefault());</div><div class=\"line\">         service.onCreate();</div><div class=\"line\">         mServices.put(data.token, service);</div><div class=\"line\">         try &#123;</div><div class=\"line\">             ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class=\"line\">                     data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</div><div class=\"line\">         &#125; catch (RemoteException e) &#123;</div><div class=\"line\">             // nothing to do.</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to create service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造service</li>\n<li>关联application</li>\n<li>调用onCreate 执行</li>\n</ul>\n<p>就这样，一个全新的service就启动了。</p>\n<h3 id=\"3-bindService的方式\"><a href=\"#3-bindService的方式\" class=\"headerlink\" title=\"3.bindService的方式\"></a>3.bindService的方式</h3><p>这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</div><div class=\"line\">        r.app.repProcState);</div></pre></td></tr></table></figure>\n<p>随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。</p>\n<h3 id=\"4-上图\"><a href=\"#4-上图\" class=\"headerlink\" title=\"4.上图\"></a>4.上图</h3><p>这里只是简单的介绍了流程，很多细节的东西并没有看。</p>\n<p><img src=\"/images/framework/service/startservice.png\" alt=\"\"></p>\n<p><img src=\"/images/framework/service/bindservice.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"broadcast流程浅析","date":"2016-12-27T07:45:50.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n个人看法。\n\n前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 静态广播\n* 动态广播\n* 发送广播\n* 动态注册广播接收者对广播的处理\n\n\n### 2. 静态广播的注册过程\n\n系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。\n\n在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。\n\n```\n        for (File file : files) {\n            final boolean isPackage = (isApkFile(file) || file.isDirectory())\n                    && !PackageInstallerService.isStageName(file.getName());\n            if (!isPackage) {\n                // Ignore entries which are not packages\n                continue;\n            }\n            try {\n                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,\n                        scanFlags, currentTime, null);\n            } catch (PackageManagerException e) {\n                                \n            }\n        }\n```\n\n如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用\n\n```\nprivate Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,\n            String[] outError) \n```\n\n方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到\n\n```\nowner.receivers.add(a);\n```\n\nPackage对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用\n\n```\nprivate PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  \n        int scanFlags, long currentTime, UserHandle user)\n```\n\n这个方法将其保存在ams里。这里就不多说了。\n\n### 3. 动态广播注册\n\n我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，\n\n```\n    private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,\n            IntentFilter filter, String broadcastPermission,\n            Handler scheduler, Context context) {\n        IIntentReceiver rd = null;\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n        try {\n            return ActivityManagerNative.getDefault().registerReceiver(\n                    mMainThread.getApplicationThread(), mBasePackageName,\n                    rd, filter, broadcastPermission, userId);\n        } catch (RemoteException e) {\n            return null;\n        }\n    }\n```\n\n* 注意这里的rd，\n* 看到，注册的过程和其他一样，也是交给了ams来完成。\n\n我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。\n\n* 收集粘性广播\n* 将我们这个广播接收者加入到mRegisteredReceivers中，\n* 插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。\n\n### 4. 发送广播\n\n不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,\n在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。\n\n```\nintent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);\n```\n\n这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。\n解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过\n\n```\nreceivers = collectReceiverComponents(intent, resolvedType, callingUid, users);\n```\n找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。\n\n```\n        if (!ordered && NR > 0) {\n            // If we are not serializing this broadcast, then send the\n            // registered receivers separately so they don't wait for the\n            // components to be launched.\n            final BroadcastQueue queue = broadcastQueueForIntent(intent);\n            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n                    callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,\n                    appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,\n                    resultExtras, ordered, sticky, false, userId);\n            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing parallel broadcast \" + r);\n            final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n            if (!replaced) {\n                queue.enqueueParallelBroadcastLocked(r);\n                queue.scheduleBroadcastsLocked();\n            }\n            registeredReceivers = null;\n            NR = 0;\n        }\n```\n\n解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。\n\n这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。\n\n```\n    public void scheduleBroadcastsLocked() {\n        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\"\n                + mQueueName + \"]: current=\"\n                + mBroadcastsScheduled);\n\n        if (mBroadcastsScheduled) {\n            return;\n        }\n        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n        mBroadcastsScheduled = true;\n    }\n```\n\n这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。\n\n在这个方法中，首先会处理普通广播代码如下。\n\n```\n            while (mParallelBroadcasts.size() > 0) {\n                r = mParallelBroadcasts.remove(0);\n                r.dispatchTime = SystemClock.uptimeMillis();\n                r.dispatchClockTime = System.currentTimeMillis();\n                final int N = r.receivers.size();\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n                for (int i=0; i<N; i++) {\n                    Object target = r.receivers.get(i);\n                    if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,\n                            \"Delivering non-ordered on [\" + mQueueName + \"] to registered \"\n                            + target + \": \" + r);\n                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n                }\n                addBroadcastToHistoryLocked(r);\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Done with parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n            }\n```\n\n可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。\n\n### 5. 动态注册广播接收者对广播的处理\n\ndeliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked\n\n```\n    private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n            Intent intent, int resultCode, String data, Bundle extras,\n            boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n        // Send the intent to the receiver asynchronously using one-way binder calls.\n        if (app != null) {\n            if (app.thread != null) {\n                // If we have an app thread, do the call through that so it is\n                // correctly ordered with other one-way calls.\n                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n            } else {\n                // Application has died. Receiver doesn't exist.\n                throw new RemoteException(\"app.thread must not be null\");\n            }\n        } else {\n            receiver.performReceive(intent, resultCode, data, extras, ordered,\n                    sticky, sendingUser);\n        }\n    }\n```\n\n* 如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，\n* 否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。\n\n```\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n```\n\n其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。\n\n而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。\n\n```\n        public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,\n                int resultCode, String dataStr, Bundle extras, boolean ordered,\n                boolean sticky, int sendingUser, int processState) throws RemoteException {\n            updateProcessState(processState, false);\n            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,\n                    sticky, sendingUser);\n        }\n\n```\nreceiver的performReceive方法中，调用ReceiverDispatcher的performReceive。\n\n```\n                if (rd != null) {\n                    rd.performReceive(intent, resultCode, data, extras,\n                            ordered, sticky, sendingUser);\n                }\n```\n\nReceiverDispatcher的performReceive中，通过handler，post一个runable消息。\n\n```\n\nmActivityThread.post(args)\n\n```\n在这个方法中，有如下代码\n\n```\nClassLoader cl =  mReceiver.getClass().getClassLoader();\nintent.setExtrasClassLoader(cl);\nsetExtrasClassLoader(cl);\nreceiver.setPendingResult(this);\nreceiver.onReceive(mContext, intent);\n```\n\n这样，BroadcastReceiver就创建并调用了onReceive方法。\n\n\n### 6. 上图\n\n![](/images/framework/broadcast/broadcast流程.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","source":"_posts/broadcast流程浅析.md","raw":"---\ntitle: broadcast流程浅析\ndate: 2016-12-27 15:45:50\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n个人看法。\n\n前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 静态广播\n* 动态广播\n* 发送广播\n* 动态注册广播接收者对广播的处理\n\n\n### 2. 静态广播的注册过程\n\n系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。\n\n在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。\n\n```\n        for (File file : files) {\n            final boolean isPackage = (isApkFile(file) || file.isDirectory())\n                    && !PackageInstallerService.isStageName(file.getName());\n            if (!isPackage) {\n                // Ignore entries which are not packages\n                continue;\n            }\n            try {\n                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,\n                        scanFlags, currentTime, null);\n            } catch (PackageManagerException e) {\n                                \n            }\n        }\n```\n\n如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用\n\n```\nprivate Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,\n            String[] outError) \n```\n\n方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到\n\n```\nowner.receivers.add(a);\n```\n\nPackage对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用\n\n```\nprivate PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  \n        int scanFlags, long currentTime, UserHandle user)\n```\n\n这个方法将其保存在ams里。这里就不多说了。\n\n### 3. 动态广播注册\n\n我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，\n\n```\n    private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,\n            IntentFilter filter, String broadcastPermission,\n            Handler scheduler, Context context) {\n        IIntentReceiver rd = null;\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n        try {\n            return ActivityManagerNative.getDefault().registerReceiver(\n                    mMainThread.getApplicationThread(), mBasePackageName,\n                    rd, filter, broadcastPermission, userId);\n        } catch (RemoteException e) {\n            return null;\n        }\n    }\n```\n\n* 注意这里的rd，\n* 看到，注册的过程和其他一样，也是交给了ams来完成。\n\n我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。\n\n* 收集粘性广播\n* 将我们这个广播接收者加入到mRegisteredReceivers中，\n* 插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。\n\n### 4. 发送广播\n\n不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,\n在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。\n\n```\nintent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);\n```\n\n这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。\n解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过\n\n```\nreceivers = collectReceiverComponents(intent, resolvedType, callingUid, users);\n```\n找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。\n\n```\n        if (!ordered && NR > 0) {\n            // If we are not serializing this broadcast, then send the\n            // registered receivers separately so they don't wait for the\n            // components to be launched.\n            final BroadcastQueue queue = broadcastQueueForIntent(intent);\n            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n                    callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,\n                    appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,\n                    resultExtras, ordered, sticky, false, userId);\n            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing parallel broadcast \" + r);\n            final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n            if (!replaced) {\n                queue.enqueueParallelBroadcastLocked(r);\n                queue.scheduleBroadcastsLocked();\n            }\n            registeredReceivers = null;\n            NR = 0;\n        }\n```\n\n解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。\n\n这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。\n\n```\n    public void scheduleBroadcastsLocked() {\n        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\"\n                + mQueueName + \"]: current=\"\n                + mBroadcastsScheduled);\n\n        if (mBroadcastsScheduled) {\n            return;\n        }\n        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n        mBroadcastsScheduled = true;\n    }\n```\n\n这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。\n\n在这个方法中，首先会处理普通广播代码如下。\n\n```\n            while (mParallelBroadcasts.size() > 0) {\n                r = mParallelBroadcasts.remove(0);\n                r.dispatchTime = SystemClock.uptimeMillis();\n                r.dispatchClockTime = System.currentTimeMillis();\n                final int N = r.receivers.size();\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n                for (int i=0; i<N; i++) {\n                    Object target = r.receivers.get(i);\n                    if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,\n                            \"Delivering non-ordered on [\" + mQueueName + \"] to registered \"\n                            + target + \": \" + r);\n                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n                }\n                addBroadcastToHistoryLocked(r);\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Done with parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n            }\n```\n\n可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。\n\n### 5. 动态注册广播接收者对广播的处理\n\ndeliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked\n\n```\n    private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n            Intent intent, int resultCode, String data, Bundle extras,\n            boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n        // Send the intent to the receiver asynchronously using one-way binder calls.\n        if (app != null) {\n            if (app.thread != null) {\n                // If we have an app thread, do the call through that so it is\n                // correctly ordered with other one-way calls.\n                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n            } else {\n                // Application has died. Receiver doesn't exist.\n                throw new RemoteException(\"app.thread must not be null\");\n            }\n        } else {\n            receiver.performReceive(intent, resultCode, data, extras, ordered,\n                    sticky, sendingUser);\n        }\n    }\n```\n\n* 如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，\n* 否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。\n\n```\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n```\n\n其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。\n\n而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。\n\n```\n        public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,\n                int resultCode, String dataStr, Bundle extras, boolean ordered,\n                boolean sticky, int sendingUser, int processState) throws RemoteException {\n            updateProcessState(processState, false);\n            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,\n                    sticky, sendingUser);\n        }\n\n```\nreceiver的performReceive方法中，调用ReceiverDispatcher的performReceive。\n\n```\n                if (rd != null) {\n                    rd.performReceive(intent, resultCode, data, extras,\n                            ordered, sticky, sendingUser);\n                }\n```\n\nReceiverDispatcher的performReceive中，通过handler，post一个runable消息。\n\n```\n\nmActivityThread.post(args)\n\n```\n在这个方法中，有如下代码\n\n```\nClassLoader cl =  mReceiver.getClass().getClassLoader();\nintent.setExtrasClassLoader(cl);\nsetExtrasClassLoader(cl);\nreceiver.setPendingResult(this);\nreceiver.onReceive(mContext, intent);\n```\n\n这样，BroadcastReceiver就创建并调用了onReceive方法。\n\n\n### 6. 上图\n\n![](/images/framework/broadcast/broadcast流程.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","slug":"broadcast流程浅析","published":1,"updated":"2017-01-06T05:30:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85y9000vuaxana6nyiao","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>个人看法。</p>\n<p>前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n</the></li>\n</ul>\n<ul>\n<li>静态广播</li>\n<li>动态广播</li>\n<li>发送广播</li>\n<li>动态注册广播接收者对广播的处理</li>\n</ul>\n<h3 id=\"2-静态广播的注册过程\"><a href=\"#2-静态广播的注册过程\" class=\"headerlink\" title=\"2. 静态广播的注册过程\"></a>2. 静态广播的注册过程</h3><p>系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。</p>\n<p>在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (File file : files) &#123;</div><div class=\"line\">    final boolean isPackage = (isApkFile(file) || file.isDirectory())</div><div class=\"line\">            &amp;&amp; !PackageInstallerService.isStageName(file.getName());</div><div class=\"line\">    if (!isPackage) &#123;</div><div class=\"line\">        // Ignore entries which are not packages</div><div class=\"line\">        continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</div><div class=\"line\">                scanFlags, currentTime, null);</div><div class=\"line\">    &#125; catch (PackageManagerException e) &#123;</div><div class=\"line\">                        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,</div><div class=\"line\">            String[] outError)</div></pre></td></tr></table></figure>\n<p>方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">owner.receivers.add(a);</div></pre></td></tr></table></figure>\n<p>Package对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  </div><div class=\"line\">        int scanFlags, long currentTime, UserHandle user)</div></pre></td></tr></table></figure>\n<p>这个方法将其保存在ams里。这里就不多说了。</p>\n<h3 id=\"3-动态广播注册\"><a href=\"#3-动态广播注册\" class=\"headerlink\" title=\"3. 动态广播注册\"></a>3. 动态广播注册</h3><p>我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</div><div class=\"line\">        IntentFilter filter, String broadcastPermission,</div><div class=\"line\">        Handler scheduler, Context context) &#123;</div><div class=\"line\">    IIntentReceiver rd = null;</div><div class=\"line\">    if (receiver != null) &#123;</div><div class=\"line\">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler,</div><div class=\"line\">                mMainThread.getInstrumentation(), true);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                    receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        return ActivityManagerNative.getDefault().registerReceiver(</div><div class=\"line\">                mMainThread.getApplicationThread(), mBasePackageName,</div><div class=\"line\">                rd, filter, broadcastPermission, userId);</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意这里的rd，</li>\n<li>看到，注册的过程和其他一样，也是交给了ams来完成。</li>\n</ul>\n<p>我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。</p>\n<ul>\n<li>收集粘性广播</li>\n<li>将我们这个广播接收者加入到mRegisteredReceivers中，</li>\n<li>插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。</li>\n</ul>\n<h3 id=\"4-发送广播\"><a href=\"#4-发送广播\" class=\"headerlink\" title=\"4. 发送广播\"></a>4. 发送广播</h3><p>不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,<br>在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div></pre></td></tr></table></figure>\n<p>这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。<br>解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</div></pre></td></tr></table></figure>\n<p>找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!ordered &amp;&amp; NR &gt; 0) &#123;</div><div class=\"line\">    // If we are not serializing this broadcast, then send the</div><div class=\"line\">    // registered receivers separately so they don&apos;t wait for the</div><div class=\"line\">    // components to be launched.</div><div class=\"line\">    final BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class=\"line\">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</div><div class=\"line\">            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</div><div class=\"line\">            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</div><div class=\"line\">            resultExtras, ordered, sticky, false, userId);</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</div><div class=\"line\">    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</div><div class=\"line\">    if (!replaced) &#123;</div><div class=\"line\">        queue.enqueueParallelBroadcastLocked(r);</div><div class=\"line\">        queue.scheduleBroadcastsLocked();</div><div class=\"line\">    &#125;</div><div class=\"line\">    registeredReceivers = null;</div><div class=\"line\">    NR = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。</p>\n<p>这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleBroadcastsLocked() &#123;</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</div><div class=\"line\">            + mQueueName + &quot;]: current=&quot;</div><div class=\"line\">            + mBroadcastsScheduled);</div><div class=\"line\"></div><div class=\"line\">    if (mBroadcastsScheduled) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</div><div class=\"line\">    mBroadcastsScheduled = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。</p>\n<p>在这个方法中，首先会处理普通广播代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (mParallelBroadcasts.size() &gt; 0) &#123;</div><div class=\"line\">    r = mParallelBroadcasts.remove(0);</div><div class=\"line\">    r.dispatchTime = SystemClock.uptimeMillis();</div><div class=\"line\">    r.dispatchClockTime = System.currentTimeMillis();</div><div class=\"line\">    final int N = r.receivers.size();</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        Object target = r.receivers.get(i);</div><div class=\"line\">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</div><div class=\"line\">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</div><div class=\"line\">                + target + &quot;: &quot; + r);</div><div class=\"line\">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">    addBroadcastToHistoryLocked(r);</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。</p>\n<h3 id=\"5-动态注册广播接收者对广播的处理\"><a href=\"#5-动态注册广播接收者对广播的处理\" class=\"headerlink\" title=\"5. 动态注册广播接收者对广播的处理\"></a>5. 动态注册广播接收者对广播的处理</h3><p>deliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</div><div class=\"line\">        Intent intent, int resultCode, String data, Bundle extras,</div><div class=\"line\">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</div><div class=\"line\">    // Send the intent to the receiver asynchronously using one-way binder calls.</div><div class=\"line\">    if (app != null) &#123;</div><div class=\"line\">        if (app.thread != null) &#123;</div><div class=\"line\">            // If we have an app thread, do the call through that so it is</div><div class=\"line\">            // correctly ordered with other one-way calls.</div><div class=\"line\">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class=\"line\">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Application has died. Receiver doesn&apos;t exist.</div><div class=\"line\">            throw new RemoteException(&quot;app.thread must not be null&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class=\"line\">                sticky, sendingUser);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，</li>\n<li>否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (receiver != null) &#123;</div><div class=\"line\">    if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">            receiver, context, scheduler,</div><div class=\"line\">            mMainThread.getInstrumentation(), true);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。</p>\n<p>而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</div><div class=\"line\">        int resultCode, String dataStr, Bundle extras, boolean ordered,</div><div class=\"line\">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</div><div class=\"line\">    updateProcessState(processState, false);</div><div class=\"line\">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</div><div class=\"line\">            sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>receiver的performReceive方法中，调用ReceiverDispatcher的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (rd != null) &#123;</div><div class=\"line\">    rd.performReceive(intent, resultCode, data, extras,</div><div class=\"line\">            ordered, sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ReceiverDispatcher的performReceive中，通过handler，post一个runable消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">mActivityThread.post(args)</div></pre></td></tr></table></figure>\n<p>在这个方法中，有如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class=\"line\">intent.setExtrasClassLoader(cl);</div><div class=\"line\">setExtrasClassLoader(cl);</div><div class=\"line\">receiver.setPendingResult(this);</div><div class=\"line\">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>\n<p>这样，BroadcastReceiver就创建并调用了onReceive方法。</p>\n<h3 id=\"6-上图\"><a href=\"#6-上图\" class=\"headerlink\" title=\"6. 上图\"></a>6. 上图</h3><p><img src=\"/images/framework/broadcast/broadcast流程.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>个人看法。</p>\n<p>前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n</li>\n</ul>\n<ul>\n<li>静态广播</li>\n<li>动态广播</li>\n<li>发送广播</li>\n<li>动态注册广播接收者对广播的处理</li>\n</ul>\n<h3 id=\"2-静态广播的注册过程\"><a href=\"#2-静态广播的注册过程\" class=\"headerlink\" title=\"2. 静态广播的注册过程\"></a>2. 静态广播的注册过程</h3><p>系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。</p>\n<p>在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (File file : files) &#123;</div><div class=\"line\">    final boolean isPackage = (isApkFile(file) || file.isDirectory())</div><div class=\"line\">            &amp;&amp; !PackageInstallerService.isStageName(file.getName());</div><div class=\"line\">    if (!isPackage) &#123;</div><div class=\"line\">        // Ignore entries which are not packages</div><div class=\"line\">        continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</div><div class=\"line\">                scanFlags, currentTime, null);</div><div class=\"line\">    &#125; catch (PackageManagerException e) &#123;</div><div class=\"line\">                        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,</div><div class=\"line\">            String[] outError)</div></pre></td></tr></table></figure>\n<p>方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">owner.receivers.add(a);</div></pre></td></tr></table></figure>\n<p>Package对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  </div><div class=\"line\">        int scanFlags, long currentTime, UserHandle user)</div></pre></td></tr></table></figure>\n<p>这个方法将其保存在ams里。这里就不多说了。</p>\n<h3 id=\"3-动态广播注册\"><a href=\"#3-动态广播注册\" class=\"headerlink\" title=\"3. 动态广播注册\"></a>3. 动态广播注册</h3><p>我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</div><div class=\"line\">        IntentFilter filter, String broadcastPermission,</div><div class=\"line\">        Handler scheduler, Context context) &#123;</div><div class=\"line\">    IIntentReceiver rd = null;</div><div class=\"line\">    if (receiver != null) &#123;</div><div class=\"line\">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler,</div><div class=\"line\">                mMainThread.getInstrumentation(), true);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                    receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        return ActivityManagerNative.getDefault().registerReceiver(</div><div class=\"line\">                mMainThread.getApplicationThread(), mBasePackageName,</div><div class=\"line\">                rd, filter, broadcastPermission, userId);</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意这里的rd，</li>\n<li>看到，注册的过程和其他一样，也是交给了ams来完成。</li>\n</ul>\n<p>我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。</p>\n<ul>\n<li>收集粘性广播</li>\n<li>将我们这个广播接收者加入到mRegisteredReceivers中，</li>\n<li>插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。</li>\n</ul>\n<h3 id=\"4-发送广播\"><a href=\"#4-发送广播\" class=\"headerlink\" title=\"4. 发送广播\"></a>4. 发送广播</h3><p>不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,<br>在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div></pre></td></tr></table></figure>\n<p>这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。<br>解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</div></pre></td></tr></table></figure>\n<p>找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!ordered &amp;&amp; NR &gt; 0) &#123;</div><div class=\"line\">    // If we are not serializing this broadcast, then send the</div><div class=\"line\">    // registered receivers separately so they don&apos;t wait for the</div><div class=\"line\">    // components to be launched.</div><div class=\"line\">    final BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class=\"line\">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</div><div class=\"line\">            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</div><div class=\"line\">            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</div><div class=\"line\">            resultExtras, ordered, sticky, false, userId);</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</div><div class=\"line\">    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</div><div class=\"line\">    if (!replaced) &#123;</div><div class=\"line\">        queue.enqueueParallelBroadcastLocked(r);</div><div class=\"line\">        queue.scheduleBroadcastsLocked();</div><div class=\"line\">    &#125;</div><div class=\"line\">    registeredReceivers = null;</div><div class=\"line\">    NR = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。</p>\n<p>这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleBroadcastsLocked() &#123;</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</div><div class=\"line\">            + mQueueName + &quot;]: current=&quot;</div><div class=\"line\">            + mBroadcastsScheduled);</div><div class=\"line\"></div><div class=\"line\">    if (mBroadcastsScheduled) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</div><div class=\"line\">    mBroadcastsScheduled = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。</p>\n<p>在这个方法中，首先会处理普通广播代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (mParallelBroadcasts.size() &gt; 0) &#123;</div><div class=\"line\">    r = mParallelBroadcasts.remove(0);</div><div class=\"line\">    r.dispatchTime = SystemClock.uptimeMillis();</div><div class=\"line\">    r.dispatchClockTime = System.currentTimeMillis();</div><div class=\"line\">    final int N = r.receivers.size();</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        Object target = r.receivers.get(i);</div><div class=\"line\">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</div><div class=\"line\">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</div><div class=\"line\">                + target + &quot;: &quot; + r);</div><div class=\"line\">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">    addBroadcastToHistoryLocked(r);</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。</p>\n<h3 id=\"5-动态注册广播接收者对广播的处理\"><a href=\"#5-动态注册广播接收者对广播的处理\" class=\"headerlink\" title=\"5. 动态注册广播接收者对广播的处理\"></a>5. 动态注册广播接收者对广播的处理</h3><p>deliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</div><div class=\"line\">        Intent intent, int resultCode, String data, Bundle extras,</div><div class=\"line\">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</div><div class=\"line\">    // Send the intent to the receiver asynchronously using one-way binder calls.</div><div class=\"line\">    if (app != null) &#123;</div><div class=\"line\">        if (app.thread != null) &#123;</div><div class=\"line\">            // If we have an app thread, do the call through that so it is</div><div class=\"line\">            // correctly ordered with other one-way calls.</div><div class=\"line\">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class=\"line\">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Application has died. Receiver doesn&apos;t exist.</div><div class=\"line\">            throw new RemoteException(&quot;app.thread must not be null&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class=\"line\">                sticky, sendingUser);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，</li>\n<li>否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (receiver != null) &#123;</div><div class=\"line\">    if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">            receiver, context, scheduler,</div><div class=\"line\">            mMainThread.getInstrumentation(), true);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。</p>\n<p>而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</div><div class=\"line\">        int resultCode, String dataStr, Bundle extras, boolean ordered,</div><div class=\"line\">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</div><div class=\"line\">    updateProcessState(processState, false);</div><div class=\"line\">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</div><div class=\"line\">            sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>receiver的performReceive方法中，调用ReceiverDispatcher的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (rd != null) &#123;</div><div class=\"line\">    rd.performReceive(intent, resultCode, data, extras,</div><div class=\"line\">            ordered, sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ReceiverDispatcher的performReceive中，通过handler，post一个runable消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">mActivityThread.post(args)</div></pre></td></tr></table></figure>\n<p>在这个方法中，有如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class=\"line\">intent.setExtrasClassLoader(cl);</div><div class=\"line\">setExtrasClassLoader(cl);</div><div class=\"line\">receiver.setPendingResult(this);</div><div class=\"line\">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>\n<p>这样，BroadcastReceiver就创建并调用了onReceive方法。</p>\n<h3 id=\"6-上图\"><a href=\"#6-上图\" class=\"headerlink\" title=\"6. 上图\"></a>6. 上图</h3><p><img src=\"/images/framework/broadcast/broadcast流程.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"android应用进程是如何启动的","date":"2017-01-01T16:55:08.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n            if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                    app.processName);\n            checkTime(startTime, \"startProcess: asking zygote to start proc\");\n            Process.ProcessStartResult startResult = Process.start(entryPoint,\n                    app.processName, uid, uid, gids, debugFlags, mountExternal,\n                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                    app.info.dataDir, entryPointArgs);\n```\n\n* 其中entryPoint是进程的运行入口\n\n\n### 2.Process#start\n\n在start方法中，会调用startViaZygote方法。\n\n```\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                  final String niceName,\n                                  final int uid, final int gid,\n                                  final int[] gids,\n                                  int debugFlags, int mountExternal,\n                                  int targetSdkVersion,\n                                  String seInfo,\n                                  String abi,\n                                  String instructionSet,\n                                  String appDataDir,\n                                  String[] extraArgs)\n                                  throws ZygoteStartFailedEx {\n        synchronized(Process.class) {\n            ArrayList<String> argsForZygote = new ArrayList<String>();\n\n            // --runtime-args, --setuid=, --setgid=,\n            // and --setgroups= must go first\n            argsForZygote.add(\"--runtime-args\");\n            argsForZygote.add(\"--setuid=\" + uid);\n            argsForZygote.add(\"--setgid=\" + gid);\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {\n                argsForZygote.add(\"--enable-jni-logging\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {\n                argsForZygote.add(\"--enable-safemode\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {\n                argsForZygote.add(\"--enable-debugger\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {\n                argsForZygote.add(\"--enable-checkjni\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JIT) != 0) {\n                argsForZygote.add(\"--enable-jit\");\n            }\n            if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {\n                argsForZygote.add(\"--generate-debug-info\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {\n                argsForZygote.add(\"--enable-assert\");\n            }\n            if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {\n                argsForZygote.add(\"--mount-external-default\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {\n                argsForZygote.add(\"--mount-external-read\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {\n                argsForZygote.add(\"--mount-external-write\");\n            }\n            argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion);\n\n            //TODO optionally enable debuger\n            //argsForZygote.add(\"--enable-debugger\");\n\n            // --setgroups is a comma-separated list\n            if (gids != null && gids.length > 0) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(\"--setgroups=\");\n\n                int sz = gids.length;\n                for (int i = 0; i < sz; i++) {\n                    if (i != 0) {\n                        sb.append(',');\n                    }\n                    sb.append(gids[i]);\n                }\n\n                argsForZygote.add(sb.toString());\n            }\n\n            if (niceName != null) {\n                argsForZygote.add(\"--nice-name=\" + niceName);\n            }\n\n            if (seInfo != null) {\n                argsForZygote.add(\"--seinfo=\" + seInfo);\n            }\n\n            if (instructionSet != null) {\n                argsForZygote.add(\"--instruction-set=\" + instructionSet);\n            }\n\n            if (appDataDir != null) {\n                argsForZygote.add(\"--app-data-dir=\" + appDataDir);\n            }\n\n            argsForZygote.add(processClass);\n\n            if (extraArgs != null) {\n                for (String arg : extraArgs) {\n                    argsForZygote.add(arg);\n                }\n            }\n\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n        }\n    }\n```\n在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？\n\n### 3.Process#openZygoteSocketIfNeeded\n\n ```\n     private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n            try {\n                primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n            }\n        }\n\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        // The primary zygote didn't match. Try the secondary.\n        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n            try {\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n            }\n        }\n\n        if (secondaryZygoteState.matches(abi)) {\n            return secondaryZygoteState;\n        }\n\n        throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n    }\n ```\n \n 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。\n \n### 4. Process#zygoteSendArgsAndGetResult\n\n```\n            final BufferedWriter writer = zygoteState.writer;\n            final DataInputStream inputStream = zygoteState.inputStream;\n\n            writer.write(Integer.toString(args.size()));\n            writer.newLine();\n\n            int sz = args.size();\n            for (int i = 0; i < sz; i++) {\n                String arg = args.get(i);\n                if (arg.indexOf('\\n') >= 0) {\n                    throw new ZygoteStartFailedEx(\n                            \"embedded newlines not allowed\");\n                }\n                writer.write(arg);\n                writer.newLine();\n            }\n\n            writer.flush();\n\n            // Should there be a timeout on this?\n            ProcessStartResult result = new ProcessStartResult();\n            result.pid = inputStream.readInt();\n            if (result.pid < 0) {\n                throw new ZygoteStartFailedEx(\"fork() failed\");\n            }\n            result.usingWrapper = inputStream.readBoolean();\n            return result;\n```\n\n在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。\n\n那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。\n\n### 5. ZygoteInit#runSelectLoop\n\n```\n    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(sServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    boolean done = peers.get(i).runOnce();\n                    if (done) {\n                        peers.remove(i);\n                        fds.remove(i);\n                    }\n                }\n            }\n        }\n    }\n```\n\n首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。\n\n### 6.ZygoteConnection#runOnce\n\n```\n   boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n\n        String args[];\n        Arguments parsedArgs = null;\n        FileDescriptor[] descriptors;\n\n        try {\n            args = readArgumentList();\n            descriptors = mSocket.getAncillaryFileDescriptors();\n        } catch (IOException ex) {\n            Log.w(TAG, \"IOException on command socket \" + ex.getMessage());\n            closeSocket();\n            return true;\n        }\n\n        if (args == null) {\n            // EOF reached.\n            closeSocket();\n            return true;\n        }\n\n        /** the stderr of the most recent request, if avail */\n        PrintStream newStderr = null;\n\n        if (descriptors != null && descriptors.length >= 3) {\n            newStderr = new PrintStream(\n                    new FileOutputStream(descriptors[2]));\n        }\n\n        int pid = -1;\n        FileDescriptor childPipeFd = null;\n        FileDescriptor serverPipeFd = null;\n\n        try {\n            parsedArgs = new Arguments(args);\n\n            if (parsedArgs.abiListQuery) {\n                return handleAbiListQuery();\n            }\n\n            if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {\n                throw new ZygoteSecurityException(\"Client may not specify capabilities: \" +\n                        \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) +\n                        \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities));\n            }\n\n            applyUidSecurityPolicy(parsedArgs, peer);\n            applyInvokeWithSecurityPolicy(parsedArgs, peer);\n\n            applyDebuggerSystemProperty(parsedArgs);\n            applyInvokeWithSystemProperty(parsedArgs);\n\n            int[][] rlimits = null;\n\n            if (parsedArgs.rlimits != null) {\n                rlimits = parsedArgs.rlimits.toArray(intArray2d);\n            }\n\n            if (parsedArgs.invokeWith != null) {\n                FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);\n                childPipeFd = pipeFds[1];\n                serverPipeFd = pipeFds[0];\n                Os.fcntlInt(childPipeFd, F_SETFD, 0);\n            }\n\n            /**\n             * In order to avoid leaking descriptors to the Zygote child,\n             * the native code must close the two Zygote socket descriptors\n             * in the child process before it switches from Zygote-root to\n             * the UID and privileges of the application being launched.\n             *\n             * In order to avoid \"bad file descriptor\" errors when the\n             * two LocalSocket objects are closed, the Posix file\n             * descriptors are released via a dup2() call which closes\n             * the socket and substitutes an open descriptor to /dev/null.\n             */\n\n            int [] fdsToClose = { -1, -1 };\n\n            FileDescriptor fd = mSocket.getFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[0] = fd.getInt$();\n            }\n\n            fd = ZygoteInit.getServerSocketFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[1] = fd.getInt$();\n            }\n\n            fd = null;\n\n            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                    parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                    parsedArgs.appDataDir);\n        } catch (ErrnoException ex) {\n            logAndPrintError(newStderr, \"Exception creating pipe\", ex);\n        } catch (IllegalArgumentException ex) {\n            logAndPrintError(newStderr, \"Invalid zygote arguments\", ex);\n        } catch (ZygoteSecurityException ex) {\n            logAndPrintError(newStderr,\n                    \"Zygote security policy prevents request: \", ex);\n        }\n\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n```\n\n* readArgumentList读区启动参数\n* 构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数\n* 随后进行参数检查和配置\n* 调用Zygote.forkAndSpecialize进行fork进程，返回进程id\n\n\n### 7.Zygote#forkAndSpecialize\n\n```\n    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n```\n\n* VM_HOOKS是ZygoteHooks\n* 在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下\n\n\t```\nstatic JNINativeMethod gMethods[] = {\n  NATIVE_METHOD(ZygoteHooks, nativePreFork, \"()J\"),\n  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, \"(JILjava/lang/String;)V\"),\n};\n\t```\n* 然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。\n* 调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。\n\n\n### 8. nativePreFork\n\n```\nstatic jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {\n  Runtime* runtime = Runtime::Current();\n  CHECK(runtime->IsZygote()) << \"runtime instance not started with -Xzygote\";\n\n  runtime->PreZygoteFork();\n\n  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) {\n    // Tracing active, pause it.\n    Trace::Pause();\n  }\n\n  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.\n  return reinterpret_cast<jlong>(ThreadForEnv(env));\n}\n```\n这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略\n\n### 9. nativeForkAndSpecialize\n\n在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。\n\n```\nstatic pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,\n                                     jint debug_flags, jobjectArray javaRlimits,\n                                     jlong permittedCapabilities, jlong effectiveCapabilities,\n                                     jint mount_external,\n                                     jstring java_se_info, jstring java_se_name,\n                                     bool is_system_server, jintArray fdsToClose,\n                                     jstring instructionSet, jstring dataDir) {\n  SetSigChldHandler();\n\n  pid_t pid = fork();\n\n  if (pid == 0) {\n    // The child process.\n    gMallocLeakZygoteChild = 1;\n\n    // Clean up any descriptors which must be closed immediately\n    DetachDescriptors(env, fdsToClose);\n\n    // Keep capabilities across UID change, unless we're staying root.\n    if (uid != 0) {\n      EnableKeepCapabilities(env);\n    }\n\n    DropCapabilitiesBoundingSet(env);\n\n    bool use_native_bridge = !is_system_server && (instructionSet != NULL)\n        && android::NativeBridgeAvailable();\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());\n    }\n    if (use_native_bridge && dataDir == NULL) {\n      // dataDir should never be null if we need to use a native bridge.\n      // In general, dataDir will never be null for normal applications. It can only happen in\n      // special cases (for isolated processes which are not associated with any app). These are\n      // launched by the framework and should not be emulated anyway.\n      use_native_bridge = false;\n      ALOGW(\"Native bridge will not be used because dataDir == NULL.\");\n    }\n\n    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) {\n      ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno));\n      if (errno == ENOTCONN || errno == EROFS) {\n        // When device is actively encrypting, we get ENOTCONN here\n        // since FUSE was mounted before the framework restarted.\n        // When encrypted device is booting, we get EROFS since\n        // FUSE hasn't been created yet by init.\n        // In either case, continue without external storage.\n      } else {\n        ALOGE(\"Cannot continue without emulated storage\");\n        RuntimeAbort(env);\n      }\n    }\n\n    if (!is_system_server) {\n        int rc = createProcessGroup(uid, getpid());\n        if (rc != 0) {\n            if (rc == -EROFS) {\n                ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\");\n            } else {\n                ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc));\n            }\n        }\n    }\n\n    SetGids(env, javaGids);\n\n    SetRLimits(env, javaRlimits);\n\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      ScopedUtfChars data_dir(env, dataDir);\n      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());\n    }\n\n    int rc = setresgid(gid, gid, gid);\n    if (rc == -1) {\n      ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    rc = setresuid(uid, uid, uid);\n    if (rc == -1) {\n      ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    if (NeedsNoRandomizeWorkaround()) {\n        // Work around ARM kernel ASLR lossage (http://b/5817320).\n        int old_personality = personality(0xffffffff);\n        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);\n        if (new_personality == -1) {\n            ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno));\n        }\n    }\n\n    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);\n\n    SetSchedulerPolicy(env);\n\n    const char* se_info_c_str = NULL;\n    ScopedUtfChars* se_info = NULL;\n    if (java_se_info != NULL) {\n        se_info = new ScopedUtfChars(env, java_se_info);\n        se_info_c_str = se_info->c_str();\n        if (se_info_c_str == NULL) {\n          ALOGE(\"se_info_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    const char* se_name_c_str = NULL;\n    ScopedUtfChars* se_name = NULL;\n    if (java_se_name != NULL) {\n        se_name = new ScopedUtfChars(env, java_se_name);\n        se_name_c_str = se_name->c_str();\n        if (se_name_c_str == NULL) {\n          ALOGE(\"se_name_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);\n    if (rc == -1) {\n      ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid,\n            is_system_server, se_info_c_str, se_name_c_str);\n      RuntimeAbort(env);\n    }\n\n    // Make it easier to debug audit logs by setting the main thread's name to the\n    // nice name rather than \"app_process\".\n    if (se_info_c_str == NULL && is_system_server) {\n      se_name_c_str = \"system_server\";\n    }\n    if (se_info_c_str != NULL) {\n      SetThreadName(se_name_c_str);\n    }\n\n    delete se_info;\n    delete se_name;\n\n    UnsetSigChldHandler();\n\n    env->CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,\n                              is_system_server ? NULL : instructionSet);\n    if (env->ExceptionCheck()) {\n      ALOGE(\"Error calling post fork hooks.\");\n      RuntimeAbort(env);\n    }\n  } else if (pid > 0) {\n    // the parent process\n  }\n  return pid;\n}\n```\n\n* 设置子进程的signal信号处理函数 SetSigChldHandler函数\n* fork进程，fork函数\n* pid为0，进入子进程\n\t* DetachDescriptors 关闭清理文件描述符\n\t* SetGids 设置group\n\t* SetRLimits 设置资源限制\n\t* 进行其他的初始化设置\n\t* CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。\n\t* ...\n* 父进程分支，啥也不做\n* 返回pid\t \n当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作\n\n```\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n\n```\n\n我们重点看handleChildProc。\n\n### 10.ZygoteConnection#handleChildProc\n\n在这个方法中，有如下代码。\n\n```\n        if (parsedArgs.invokeWith != null) {\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(),\n                    pipeFd, parsedArgs.remainingArgs);\n        } else {\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                    parsedArgs.remainingArgs, null /* classLoader */);\n        }\n```\n\n大部分情况下，invokeWith为null，所以我们看下面的分支。\n\n\n### 11.RuntimeInit.zygoteInit\n\n```\n    public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n        redirectLogStreams();\n\n        commonInit();\n        nativeZygoteInit();\n        applicationInit(targetSdkVersion, argv, classLoader);\n    }\n```\n\n* 重定向log输出\n* commonInit,进行通用的一些设置如时区。\n* zygote初始化\n* 应用初始化\n\n### 12.nativeZygoteInit\n\n该函数的实现在AndroidRuntime.cpp中，\n\n```\nstatic void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)\n{\n    gCurRuntime->onZygoteInit();\n}\n```\n\n这里onZygoteInit在app_main.cpp中，这里就不多说了。\n\n### 13.RuntimeInit.applicationInit\n\n```\n    private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        // If the application calls System.exit(), terminate the process\n        // immediately without running any shutdown hooks.  It is not possible to\n        // shutdown an Android application gracefully.  Among other things, the\n        // Android runtime shutdown hooks close the Binder driver, which can cause\n        // leftover running threads to crash before the process actually exits.\n        nativeSetExitWithoutCleanup(true);\n\n        // We want to be fairly aggressive about heap utilization, to avoid\n        // holding on to a lot of memory that isn't needed.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);\n        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);\n\n        final Arguments args;\n        try {\n            args = new Arguments(argv);\n        } catch (IllegalArgumentException ex) {\n            Slog.e(TAG, ex.getMessage());\n            // let the process exit\n            return;\n        }\n\n        // The end of of the RuntimeInit event (see #zygoteInit).\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n        // Remaining arguments are passed to the start class's static main\n        invokeStaticMain(args.startClass, args.startArgs, classLoader);\n    }\n```\n\n这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。\n\n```\n    private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        Class<?> cl;\n\n        try {\n            cl = Class.forName(className, true, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(\n                    \"Missing class when invoking static main \" + className,\n                    ex);\n        }\n\n        Method m;\n        try {\n            m = cl.getMethod(\"main\", new Class[] { String[].class });\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(\n                    \"Missing static main on \" + className, ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(\n                    \"Problem getting static main on \" + className, ex);\n        }\n\n        int modifiers = m.getModifiers();\n        if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n            throw new RuntimeException(\n                    \"Main method is not public and static on \" + className);\n        }\n\n        /*\n         * This throw gets caught in ZygoteInit.main(), which responds\n         * by invoking the exception's run() method. This arrangement\n         * clears up all the stack frames that were required in setting\n         * up the process.\n         */\n        throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n    }\n```\n\n注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。\n\n```\n        public void run() {\n            try {\n                mMethod.invoke(null, new Object[] { mArgs });\n            } catch (IllegalAccessException ex) {\n                throw new RuntimeException(ex);\n            } catch (InvocationTargetException ex) {\n                Throwable cause = ex.getCause();\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                } else if (cause instanceof Error) {\n                    throw (Error) cause;\n                }\n                throw new RuntimeException(ex);\n            }\n        }\n```\n\n就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：\n\n在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/android应用进程是如何启动的.md","raw":"---\ntitle: android应用进程是如何启动的\ndate: 2017-01-02 00:55:08\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n            if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                    app.processName);\n            checkTime(startTime, \"startProcess: asking zygote to start proc\");\n            Process.ProcessStartResult startResult = Process.start(entryPoint,\n                    app.processName, uid, uid, gids, debugFlags, mountExternal,\n                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                    app.info.dataDir, entryPointArgs);\n```\n\n* 其中entryPoint是进程的运行入口\n\n\n### 2.Process#start\n\n在start方法中，会调用startViaZygote方法。\n\n```\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                  final String niceName,\n                                  final int uid, final int gid,\n                                  final int[] gids,\n                                  int debugFlags, int mountExternal,\n                                  int targetSdkVersion,\n                                  String seInfo,\n                                  String abi,\n                                  String instructionSet,\n                                  String appDataDir,\n                                  String[] extraArgs)\n                                  throws ZygoteStartFailedEx {\n        synchronized(Process.class) {\n            ArrayList<String> argsForZygote = new ArrayList<String>();\n\n            // --runtime-args, --setuid=, --setgid=,\n            // and --setgroups= must go first\n            argsForZygote.add(\"--runtime-args\");\n            argsForZygote.add(\"--setuid=\" + uid);\n            argsForZygote.add(\"--setgid=\" + gid);\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {\n                argsForZygote.add(\"--enable-jni-logging\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {\n                argsForZygote.add(\"--enable-safemode\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {\n                argsForZygote.add(\"--enable-debugger\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {\n                argsForZygote.add(\"--enable-checkjni\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JIT) != 0) {\n                argsForZygote.add(\"--enable-jit\");\n            }\n            if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {\n                argsForZygote.add(\"--generate-debug-info\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {\n                argsForZygote.add(\"--enable-assert\");\n            }\n            if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {\n                argsForZygote.add(\"--mount-external-default\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {\n                argsForZygote.add(\"--mount-external-read\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {\n                argsForZygote.add(\"--mount-external-write\");\n            }\n            argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion);\n\n            //TODO optionally enable debuger\n            //argsForZygote.add(\"--enable-debugger\");\n\n            // --setgroups is a comma-separated list\n            if (gids != null && gids.length > 0) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(\"--setgroups=\");\n\n                int sz = gids.length;\n                for (int i = 0; i < sz; i++) {\n                    if (i != 0) {\n                        sb.append(',');\n                    }\n                    sb.append(gids[i]);\n                }\n\n                argsForZygote.add(sb.toString());\n            }\n\n            if (niceName != null) {\n                argsForZygote.add(\"--nice-name=\" + niceName);\n            }\n\n            if (seInfo != null) {\n                argsForZygote.add(\"--seinfo=\" + seInfo);\n            }\n\n            if (instructionSet != null) {\n                argsForZygote.add(\"--instruction-set=\" + instructionSet);\n            }\n\n            if (appDataDir != null) {\n                argsForZygote.add(\"--app-data-dir=\" + appDataDir);\n            }\n\n            argsForZygote.add(processClass);\n\n            if (extraArgs != null) {\n                for (String arg : extraArgs) {\n                    argsForZygote.add(arg);\n                }\n            }\n\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n        }\n    }\n```\n在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？\n\n### 3.Process#openZygoteSocketIfNeeded\n\n ```\n     private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n            try {\n                primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n            }\n        }\n\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        // The primary zygote didn't match. Try the secondary.\n        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n            try {\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n            }\n        }\n\n        if (secondaryZygoteState.matches(abi)) {\n            return secondaryZygoteState;\n        }\n\n        throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n    }\n ```\n \n 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。\n \n### 4. Process#zygoteSendArgsAndGetResult\n\n```\n            final BufferedWriter writer = zygoteState.writer;\n            final DataInputStream inputStream = zygoteState.inputStream;\n\n            writer.write(Integer.toString(args.size()));\n            writer.newLine();\n\n            int sz = args.size();\n            for (int i = 0; i < sz; i++) {\n                String arg = args.get(i);\n                if (arg.indexOf('\\n') >= 0) {\n                    throw new ZygoteStartFailedEx(\n                            \"embedded newlines not allowed\");\n                }\n                writer.write(arg);\n                writer.newLine();\n            }\n\n            writer.flush();\n\n            // Should there be a timeout on this?\n            ProcessStartResult result = new ProcessStartResult();\n            result.pid = inputStream.readInt();\n            if (result.pid < 0) {\n                throw new ZygoteStartFailedEx(\"fork() failed\");\n            }\n            result.usingWrapper = inputStream.readBoolean();\n            return result;\n```\n\n在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。\n\n那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。\n\n### 5. ZygoteInit#runSelectLoop\n\n```\n    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(sServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    boolean done = peers.get(i).runOnce();\n                    if (done) {\n                        peers.remove(i);\n                        fds.remove(i);\n                    }\n                }\n            }\n        }\n    }\n```\n\n首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。\n\n### 6.ZygoteConnection#runOnce\n\n```\n   boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n\n        String args[];\n        Arguments parsedArgs = null;\n        FileDescriptor[] descriptors;\n\n        try {\n            args = readArgumentList();\n            descriptors = mSocket.getAncillaryFileDescriptors();\n        } catch (IOException ex) {\n            Log.w(TAG, \"IOException on command socket \" + ex.getMessage());\n            closeSocket();\n            return true;\n        }\n\n        if (args == null) {\n            // EOF reached.\n            closeSocket();\n            return true;\n        }\n\n        /** the stderr of the most recent request, if avail */\n        PrintStream newStderr = null;\n\n        if (descriptors != null && descriptors.length >= 3) {\n            newStderr = new PrintStream(\n                    new FileOutputStream(descriptors[2]));\n        }\n\n        int pid = -1;\n        FileDescriptor childPipeFd = null;\n        FileDescriptor serverPipeFd = null;\n\n        try {\n            parsedArgs = new Arguments(args);\n\n            if (parsedArgs.abiListQuery) {\n                return handleAbiListQuery();\n            }\n\n            if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {\n                throw new ZygoteSecurityException(\"Client may not specify capabilities: \" +\n                        \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) +\n                        \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities));\n            }\n\n            applyUidSecurityPolicy(parsedArgs, peer);\n            applyInvokeWithSecurityPolicy(parsedArgs, peer);\n\n            applyDebuggerSystemProperty(parsedArgs);\n            applyInvokeWithSystemProperty(parsedArgs);\n\n            int[][] rlimits = null;\n\n            if (parsedArgs.rlimits != null) {\n                rlimits = parsedArgs.rlimits.toArray(intArray2d);\n            }\n\n            if (parsedArgs.invokeWith != null) {\n                FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);\n                childPipeFd = pipeFds[1];\n                serverPipeFd = pipeFds[0];\n                Os.fcntlInt(childPipeFd, F_SETFD, 0);\n            }\n\n            /**\n             * In order to avoid leaking descriptors to the Zygote child,\n             * the native code must close the two Zygote socket descriptors\n             * in the child process before it switches from Zygote-root to\n             * the UID and privileges of the application being launched.\n             *\n             * In order to avoid \"bad file descriptor\" errors when the\n             * two LocalSocket objects are closed, the Posix file\n             * descriptors are released via a dup2() call which closes\n             * the socket and substitutes an open descriptor to /dev/null.\n             */\n\n            int [] fdsToClose = { -1, -1 };\n\n            FileDescriptor fd = mSocket.getFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[0] = fd.getInt$();\n            }\n\n            fd = ZygoteInit.getServerSocketFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[1] = fd.getInt$();\n            }\n\n            fd = null;\n\n            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                    parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                    parsedArgs.appDataDir);\n        } catch (ErrnoException ex) {\n            logAndPrintError(newStderr, \"Exception creating pipe\", ex);\n        } catch (IllegalArgumentException ex) {\n            logAndPrintError(newStderr, \"Invalid zygote arguments\", ex);\n        } catch (ZygoteSecurityException ex) {\n            logAndPrintError(newStderr,\n                    \"Zygote security policy prevents request: \", ex);\n        }\n\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n```\n\n* readArgumentList读区启动参数\n* 构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数\n* 随后进行参数检查和配置\n* 调用Zygote.forkAndSpecialize进行fork进程，返回进程id\n\n\n### 7.Zygote#forkAndSpecialize\n\n```\n    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n```\n\n* VM_HOOKS是ZygoteHooks\n* 在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下\n\n\t```\nstatic JNINativeMethod gMethods[] = {\n  NATIVE_METHOD(ZygoteHooks, nativePreFork, \"()J\"),\n  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, \"(JILjava/lang/String;)V\"),\n};\n\t```\n* 然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。\n* 调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。\n\n\n### 8. nativePreFork\n\n```\nstatic jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {\n  Runtime* runtime = Runtime::Current();\n  CHECK(runtime->IsZygote()) << \"runtime instance not started with -Xzygote\";\n\n  runtime->PreZygoteFork();\n\n  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) {\n    // Tracing active, pause it.\n    Trace::Pause();\n  }\n\n  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.\n  return reinterpret_cast<jlong>(ThreadForEnv(env));\n}\n```\n这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略\n\n### 9. nativeForkAndSpecialize\n\n在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。\n\n```\nstatic pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,\n                                     jint debug_flags, jobjectArray javaRlimits,\n                                     jlong permittedCapabilities, jlong effectiveCapabilities,\n                                     jint mount_external,\n                                     jstring java_se_info, jstring java_se_name,\n                                     bool is_system_server, jintArray fdsToClose,\n                                     jstring instructionSet, jstring dataDir) {\n  SetSigChldHandler();\n\n  pid_t pid = fork();\n\n  if (pid == 0) {\n    // The child process.\n    gMallocLeakZygoteChild = 1;\n\n    // Clean up any descriptors which must be closed immediately\n    DetachDescriptors(env, fdsToClose);\n\n    // Keep capabilities across UID change, unless we're staying root.\n    if (uid != 0) {\n      EnableKeepCapabilities(env);\n    }\n\n    DropCapabilitiesBoundingSet(env);\n\n    bool use_native_bridge = !is_system_server && (instructionSet != NULL)\n        && android::NativeBridgeAvailable();\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());\n    }\n    if (use_native_bridge && dataDir == NULL) {\n      // dataDir should never be null if we need to use a native bridge.\n      // In general, dataDir will never be null for normal applications. It can only happen in\n      // special cases (for isolated processes which are not associated with any app). These are\n      // launched by the framework and should not be emulated anyway.\n      use_native_bridge = false;\n      ALOGW(\"Native bridge will not be used because dataDir == NULL.\");\n    }\n\n    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) {\n      ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno));\n      if (errno == ENOTCONN || errno == EROFS) {\n        // When device is actively encrypting, we get ENOTCONN here\n        // since FUSE was mounted before the framework restarted.\n        // When encrypted device is booting, we get EROFS since\n        // FUSE hasn't been created yet by init.\n        // In either case, continue without external storage.\n      } else {\n        ALOGE(\"Cannot continue without emulated storage\");\n        RuntimeAbort(env);\n      }\n    }\n\n    if (!is_system_server) {\n        int rc = createProcessGroup(uid, getpid());\n        if (rc != 0) {\n            if (rc == -EROFS) {\n                ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\");\n            } else {\n                ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc));\n            }\n        }\n    }\n\n    SetGids(env, javaGids);\n\n    SetRLimits(env, javaRlimits);\n\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      ScopedUtfChars data_dir(env, dataDir);\n      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());\n    }\n\n    int rc = setresgid(gid, gid, gid);\n    if (rc == -1) {\n      ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    rc = setresuid(uid, uid, uid);\n    if (rc == -1) {\n      ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    if (NeedsNoRandomizeWorkaround()) {\n        // Work around ARM kernel ASLR lossage (http://b/5817320).\n        int old_personality = personality(0xffffffff);\n        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);\n        if (new_personality == -1) {\n            ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno));\n        }\n    }\n\n    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);\n\n    SetSchedulerPolicy(env);\n\n    const char* se_info_c_str = NULL;\n    ScopedUtfChars* se_info = NULL;\n    if (java_se_info != NULL) {\n        se_info = new ScopedUtfChars(env, java_se_info);\n        se_info_c_str = se_info->c_str();\n        if (se_info_c_str == NULL) {\n          ALOGE(\"se_info_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    const char* se_name_c_str = NULL;\n    ScopedUtfChars* se_name = NULL;\n    if (java_se_name != NULL) {\n        se_name = new ScopedUtfChars(env, java_se_name);\n        se_name_c_str = se_name->c_str();\n        if (se_name_c_str == NULL) {\n          ALOGE(\"se_name_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);\n    if (rc == -1) {\n      ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid,\n            is_system_server, se_info_c_str, se_name_c_str);\n      RuntimeAbort(env);\n    }\n\n    // Make it easier to debug audit logs by setting the main thread's name to the\n    // nice name rather than \"app_process\".\n    if (se_info_c_str == NULL && is_system_server) {\n      se_name_c_str = \"system_server\";\n    }\n    if (se_info_c_str != NULL) {\n      SetThreadName(se_name_c_str);\n    }\n\n    delete se_info;\n    delete se_name;\n\n    UnsetSigChldHandler();\n\n    env->CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,\n                              is_system_server ? NULL : instructionSet);\n    if (env->ExceptionCheck()) {\n      ALOGE(\"Error calling post fork hooks.\");\n      RuntimeAbort(env);\n    }\n  } else if (pid > 0) {\n    // the parent process\n  }\n  return pid;\n}\n```\n\n* 设置子进程的signal信号处理函数 SetSigChldHandler函数\n* fork进程，fork函数\n* pid为0，进入子进程\n\t* DetachDescriptors 关闭清理文件描述符\n\t* SetGids 设置group\n\t* SetRLimits 设置资源限制\n\t* 进行其他的初始化设置\n\t* CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。\n\t* ...\n* 父进程分支，啥也不做\n* 返回pid\t \n当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作\n\n```\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n\n```\n\n我们重点看handleChildProc。\n\n### 10.ZygoteConnection#handleChildProc\n\n在这个方法中，有如下代码。\n\n```\n        if (parsedArgs.invokeWith != null) {\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(),\n                    pipeFd, parsedArgs.remainingArgs);\n        } else {\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                    parsedArgs.remainingArgs, null /* classLoader */);\n        }\n```\n\n大部分情况下，invokeWith为null，所以我们看下面的分支。\n\n\n### 11.RuntimeInit.zygoteInit\n\n```\n    public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n        redirectLogStreams();\n\n        commonInit();\n        nativeZygoteInit();\n        applicationInit(targetSdkVersion, argv, classLoader);\n    }\n```\n\n* 重定向log输出\n* commonInit,进行通用的一些设置如时区。\n* zygote初始化\n* 应用初始化\n\n### 12.nativeZygoteInit\n\n该函数的实现在AndroidRuntime.cpp中，\n\n```\nstatic void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)\n{\n    gCurRuntime->onZygoteInit();\n}\n```\n\n这里onZygoteInit在app_main.cpp中，这里就不多说了。\n\n### 13.RuntimeInit.applicationInit\n\n```\n    private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        // If the application calls System.exit(), terminate the process\n        // immediately without running any shutdown hooks.  It is not possible to\n        // shutdown an Android application gracefully.  Among other things, the\n        // Android runtime shutdown hooks close the Binder driver, which can cause\n        // leftover running threads to crash before the process actually exits.\n        nativeSetExitWithoutCleanup(true);\n\n        // We want to be fairly aggressive about heap utilization, to avoid\n        // holding on to a lot of memory that isn't needed.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);\n        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);\n\n        final Arguments args;\n        try {\n            args = new Arguments(argv);\n        } catch (IllegalArgumentException ex) {\n            Slog.e(TAG, ex.getMessage());\n            // let the process exit\n            return;\n        }\n\n        // The end of of the RuntimeInit event (see #zygoteInit).\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n        // Remaining arguments are passed to the start class's static main\n        invokeStaticMain(args.startClass, args.startArgs, classLoader);\n    }\n```\n\n这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。\n\n```\n    private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        Class<?> cl;\n\n        try {\n            cl = Class.forName(className, true, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(\n                    \"Missing class when invoking static main \" + className,\n                    ex);\n        }\n\n        Method m;\n        try {\n            m = cl.getMethod(\"main\", new Class[] { String[].class });\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(\n                    \"Missing static main on \" + className, ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(\n                    \"Problem getting static main on \" + className, ex);\n        }\n\n        int modifiers = m.getModifiers();\n        if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n            throw new RuntimeException(\n                    \"Main method is not public and static on \" + className);\n        }\n\n        /*\n         * This throw gets caught in ZygoteInit.main(), which responds\n         * by invoking the exception's run() method. This arrangement\n         * clears up all the stack frames that were required in setting\n         * up the process.\n         */\n        throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n    }\n```\n\n注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。\n\n```\n        public void run() {\n            try {\n                mMethod.invoke(null, new Object[] { mArgs });\n            } catch (IllegalAccessException ex) {\n                throw new RuntimeException(ex);\n            } catch (InvocationTargetException ex) {\n                Throwable cause = ex.getCause();\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                } else if (cause instanceof Error) {\n                    throw (Error) cause;\n                }\n                throw new RuntimeException(ex);\n            }\n        }\n```\n\n就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：\n\n在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"android应用进程是如何启动的","published":1,"updated":"2017-01-06T05:30:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yc000yuaxa32km4vzf","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n</the></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</div><div class=\"line\">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</div><div class=\"line\">        app.processName);</div><div class=\"line\">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</div><div class=\"line\">Process.ProcessStartResult startResult = Process.start(entryPoint,</div><div class=\"line\">        app.processName, uid, uid, gids, debugFlags, mountExternal,</div><div class=\"line\">        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</div><div class=\"line\">        app.info.dataDir, entryPointArgs);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中entryPoint是进程的运行入口</li>\n</ul>\n<h3 id=\"2-Process-start\"><a href=\"#2-Process-start\" class=\"headerlink\" title=\"2.Process#start\"></a>2.Process#start</h3><p>在start方法中，会调用startViaZygote方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static ProcessStartResult startViaZygote(final String processClass,</div><div class=\"line\">                              final String niceName,</div><div class=\"line\">                              final int uid, final int gid,</div><div class=\"line\">                              final int[] gids,</div><div class=\"line\">                              int debugFlags, int mountExternal,</div><div class=\"line\">                              int targetSdkVersion,</div><div class=\"line\">                              String seInfo,</div><div class=\"line\">                              String abi,</div><div class=\"line\">                              String instructionSet,</div><div class=\"line\">                              String appDataDir,</div><div class=\"line\">                              String[] extraArgs)</div><div class=\"line\">                              throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    synchronized(Process.class) &#123;</div><div class=\"line\">        ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\">        // --runtime-args, --setuid=, --setgid=,</div><div class=\"line\">        // and --setgroups= must go first</div><div class=\"line\">        argsForZygote.add(&quot;--runtime-args&quot;);</div><div class=\"line\">        argsForZygote.add(&quot;--setuid=&quot; + uid);</div><div class=\"line\">        argsForZygote.add(&quot;--setgid=&quot; + gid);</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jni-logging&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-safemode&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-checkjni&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jit&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--generate-debug-info&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-assert&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-default&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-read&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-write&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">        //TODO optionally enable debuger</div><div class=\"line\">        //argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\"></div><div class=\"line\">        // --setgroups is a comma-separated list</div><div class=\"line\">        if (gids != null &amp;&amp; gids.length &gt; 0) &#123;</div><div class=\"line\">            StringBuilder sb = new StringBuilder();</div><div class=\"line\">            sb.append(&quot;--setgroups=&quot;);</div><div class=\"line\"></div><div class=\"line\">            int sz = gids.length;</div><div class=\"line\">            for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">                if (i != 0) &#123;</div><div class=\"line\">                    sb.append(&apos;,&apos;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                sb.append(gids[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            argsForZygote.add(sb.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (niceName != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--nice-name=&quot; + niceName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (seInfo != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--seinfo=&quot; + seInfo);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (instructionSet != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--instruction-set=&quot; + instructionSet);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (appDataDir != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        argsForZygote.add(processClass);</div><div class=\"line\"></div><div class=\"line\">        if (extraArgs != null) &#123;</div><div class=\"line\">            for (String arg : extraArgs) &#123;</div><div class=\"line\">                argsForZygote.add(arg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？</p>\n<h3 id=\"3-Process-openZygoteSocketIfNeeded\"><a href=\"#3-Process-openZygoteSocketIfNeeded\" class=\"headerlink\" title=\"3.Process#openZygoteSocketIfNeeded\"></a>3.Process#openZygoteSocketIfNeeded</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (primaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return primaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The primary zygote didn&apos;t match. Try the secondary.</div><div class=\"line\">    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (secondaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return secondaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。</p>\n<h3 id=\"4-Process-zygoteSendArgsAndGetResult\"><a href=\"#4-Process-zygoteSendArgsAndGetResult\" class=\"headerlink\" title=\"4. Process#zygoteSendArgsAndGetResult\"></a>4. Process#zygoteSendArgsAndGetResult</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">final BufferedWriter writer = zygoteState.writer;</div><div class=\"line\">final DataInputStream inputStream = zygoteState.inputStream;</div><div class=\"line\"></div><div class=\"line\">writer.write(Integer.toString(args.size()));</div><div class=\"line\">writer.newLine();</div><div class=\"line\"></div><div class=\"line\">int sz = args.size();</div><div class=\"line\">for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">    String arg = args.get(i);</div><div class=\"line\">    if (arg.indexOf(&apos;\\n&apos;) &gt;= 0) &#123;</div><div class=\"line\">        throw new ZygoteStartFailedEx(</div><div class=\"line\">                &quot;embedded newlines not allowed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    writer.write(arg);</div><div class=\"line\">    writer.newLine();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">writer.flush();</div><div class=\"line\"></div><div class=\"line\">// Should there be a timeout on this?</div><div class=\"line\">ProcessStartResult result = new ProcessStartResult();</div><div class=\"line\">result.pid = inputStream.readInt();</div><div class=\"line\">if (result.pid &lt; 0) &#123;</div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">result.usingWrapper = inputStream.readBoolean();</div><div class=\"line\">return result;</div></pre></td></tr></table></figure>\n<p>在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。</p>\n<p>那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。</p>\n<h3 id=\"5-ZygoteInit-runSelectLoop\"><a href=\"#5-ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"5. ZygoteInit#runSelectLoop\"></a>5. ZygoteInit#runSelectLoop</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</div><div class=\"line\">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</div><div class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</div><div class=\"line\"></div><div class=\"line\">    fds.add(sServerSocket.getFileDescriptor());</div><div class=\"line\">    peers.add(null);</div><div class=\"line\"></div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</div><div class=\"line\">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</div><div class=\"line\">            pollFds[i] = new StructPollfd();</div><div class=\"line\">            pollFds[i].fd = fds.get(i);</div><div class=\"line\">            pollFds[i].events = (short) POLLIN;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.poll(pollFds, -1);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;poll failed&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class=\"line\">                peers.add(newPeer);</div><div class=\"line\">                fds.add(newPeer.getFileDesciptor());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                boolean done = peers.get(i).runOnce();</div><div class=\"line\">                if (done) &#123;</div><div class=\"line\">                    peers.remove(i);</div><div class=\"line\">                    fds.remove(i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。</p>\n<h3 id=\"6-ZygoteConnection-runOnce\"><a href=\"#6-ZygoteConnection-runOnce\" class=\"headerlink\" title=\"6.ZygoteConnection#runOnce\"></a>6.ZygoteConnection#runOnce</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">     String args[];</div><div class=\"line\">     Arguments parsedArgs = null;</div><div class=\"line\">     FileDescriptor[] descriptors;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         args = readArgumentList();</div><div class=\"line\">         descriptors = mSocket.getAncillaryFileDescriptors();</div><div class=\"line\">     &#125; catch (IOException ex) &#123;</div><div class=\"line\">         Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage());</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     if (args == null) &#123;</div><div class=\"line\">         // EOF reached.</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     /** the stderr of the most recent request, if avail */</div><div class=\"line\">     PrintStream newStderr = null;</div><div class=\"line\"></div><div class=\"line\">     if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123;</div><div class=\"line\">         newStderr = new PrintStream(</div><div class=\"line\">                 new FileOutputStream(descriptors[2]));</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     int pid = -1;</div><div class=\"line\">     FileDescriptor childPipeFd = null;</div><div class=\"line\">     FileDescriptor serverPipeFd = null;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         parsedArgs = new Arguments(args);</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.abiListQuery) &#123;</div><div class=\"line\">             return handleAbiListQuery();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123;</div><div class=\"line\">             throw new ZygoteSecurityException(&quot;Client may not specify capabilities: &quot; +</div><div class=\"line\">                     &quot;permitted=0x&quot; + Long.toHexString(parsedArgs.permittedCapabilities) +</div><div class=\"line\">                     &quot;, effective=0x&quot; + Long.toHexString(parsedArgs.effectiveCapabilities));</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         applyUidSecurityPolicy(parsedArgs, peer);</div><div class=\"line\">         applyInvokeWithSecurityPolicy(parsedArgs, peer);</div><div class=\"line\"></div><div class=\"line\">         applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">         applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">         int[][] rlimits = null;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.rlimits != null) &#123;</div><div class=\"line\">             rlimits = parsedArgs.rlimits.toArray(intArray2d);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">             FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</div><div class=\"line\">             childPipeFd = pipeFds[1];</div><div class=\"line\">             serverPipeFd = pipeFds[0];</div><div class=\"line\">             Os.fcntlInt(childPipeFd, F_SETFD, 0);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         /**</div><div class=\"line\">          * In order to avoid leaking descriptors to the Zygote child,</div><div class=\"line\">          * the native code must close the two Zygote socket descriptors</div><div class=\"line\">          * in the child process before it switches from Zygote-root to</div><div class=\"line\">          * the UID and privileges of the application being launched.</div><div class=\"line\">          *</div><div class=\"line\">          * In order to avoid &quot;bad file descriptor&quot; errors when the</div><div class=\"line\">          * two LocalSocket objects are closed, the Posix file</div><div class=\"line\">          * descriptors are released via a dup2() call which closes</div><div class=\"line\">          * the socket and substitutes an open descriptor to /dev/null.</div><div class=\"line\">          */</div><div class=\"line\"></div><div class=\"line\">         int [] fdsToClose = &#123; -1, -1 &#125;;</div><div class=\"line\"></div><div class=\"line\">         FileDescriptor fd = mSocket.getFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[0] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = ZygoteInit.getServerSocketFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[1] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = null;</div><div class=\"line\"></div><div class=\"line\">         pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class=\"line\">                 parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class=\"line\">                 parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class=\"line\">                 parsedArgs.appDataDir);</div><div class=\"line\">     &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex);</div><div class=\"line\">     &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex);</div><div class=\"line\">     &#125; catch (ZygoteSecurityException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr,</div><div class=\"line\">                 &quot;Zygote security policy prevents request: &quot;, ex);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (pid == 0) &#123;</div><div class=\"line\">             // in child</div><div class=\"line\">             IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">             serverPipeFd = null;</div><div class=\"line\">             handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">             // should never get here, the child is expected to either</div><div class=\"line\">             // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">             return true;</div><div class=\"line\">         &#125; else &#123;</div><div class=\"line\">             // in parent...pid of &lt; 0 means failure</div><div class=\"line\">             IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">             childPipeFd = null;</div><div class=\"line\">             return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">         IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>readArgumentList读区启动参数</li>\n<li>构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数</li>\n<li>随后进行参数检查和配置</li>\n<li>调用Zygote.forkAndSpecialize进行fork进程，返回进程id</li>\n</ul>\n<h3 id=\"7-Zygote-forkAndSpecialize\"><a href=\"#7-Zygote-forkAndSpecialize\" class=\"headerlink\" title=\"7.Zygote#forkAndSpecialize\"></a>7.Zygote#forkAndSpecialize</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();</div><div class=\"line\">    int pid = nativeForkAndSpecialize(</div><div class=\"line\">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class=\"line\">              instructionSet, appDataDir);</div><div class=\"line\">    // Enable tracing as soon as possible for the child process.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\"></div><div class=\"line\">        // Note that this event ends at the end of handleChildProc,</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon();</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>VM_HOOKS是ZygoteHooks</li>\n<li><p>在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePreFork, &quot;()J&quot;),</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, &quot;(JILjava/lang/String;)V&quot;),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。</p>\n</li>\n<li>调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。</li>\n</ul>\n<h3 id=\"8-nativePreFork\"><a href=\"#8-nativePreFork\" class=\"headerlink\" title=\"8. nativePreFork\"></a>8. nativePreFork</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</div><div class=\"line\">  Runtime* runtime = Runtime::Current();</div><div class=\"line\">  CHECK(runtime-&gt;IsZygote()) &lt;&lt; &quot;runtime instance not started with -Xzygote&quot;;</div><div class=\"line\"></div><div class=\"line\">  runtime-&gt;PreZygoteFork();</div><div class=\"line\"></div><div class=\"line\">  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</div><div class=\"line\">    // Tracing active, pause it.</div><div class=\"line\">    Trace::Pause();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.</div><div class=\"line\">  return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略</p>\n<h3 id=\"9-nativeForkAndSpecialize\"><a href=\"#9-nativeForkAndSpecialize\" class=\"headerlink\" title=\"9. nativeForkAndSpecialize\"></a>9. nativeForkAndSpecialize</h3><p>在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div></pre></td><td class=\"code\"><pre><div class=\"line\">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</div><div class=\"line\">                                     jint debug_flags, jobjectArray javaRlimits,</div><div class=\"line\">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</div><div class=\"line\">                                     jint mount_external,</div><div class=\"line\">                                     jstring java_se_info, jstring java_se_name,</div><div class=\"line\">                                     bool is_system_server, jintArray fdsToClose,</div><div class=\"line\">                                     jstring instructionSet, jstring dataDir) &#123;</div><div class=\"line\">  SetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">  pid_t pid = fork();</div><div class=\"line\"></div><div class=\"line\">  if (pid == 0) &#123;</div><div class=\"line\">    // The child process.</div><div class=\"line\">    gMallocLeakZygoteChild = 1;</div><div class=\"line\"></div><div class=\"line\">    // Clean up any descriptors which must be closed immediately</div><div class=\"line\">    DetachDescriptors(env, fdsToClose);</div><div class=\"line\"></div><div class=\"line\">    // Keep capabilities across UID change, unless we&apos;re staying root.</div><div class=\"line\">    if (uid != 0) &#123;</div><div class=\"line\">      EnableKeepCapabilities(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    DropCapabilitiesBoundingSet(env);</div><div class=\"line\"></div><div class=\"line\">    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)</div><div class=\"line\">        &amp;&amp; android::NativeBridgeAvailable();</div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (use_native_bridge &amp;&amp; dataDir == NULL) &#123;</div><div class=\"line\">      // dataDir should never be null if we need to use a native bridge.</div><div class=\"line\">      // In general, dataDir will never be null for normal applications. It can only happen in</div><div class=\"line\">      // special cases (for isolated processes which are not associated with any app). These are</div><div class=\"line\">      // launched by the framework and should not be emulated anyway.</div><div class=\"line\">      use_native_bridge = false;</div><div class=\"line\">      ALOGW(&quot;Native bridge will not be used because dataDir == NULL.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</div><div class=\"line\">      ALOGW(&quot;Failed to mount emulated storage: %s&quot;, strerror(errno));</div><div class=\"line\">      if (errno == ENOTCONN || errno == EROFS) &#123;</div><div class=\"line\">        // When device is actively encrypting, we get ENOTCONN here</div><div class=\"line\">        // since FUSE was mounted before the framework restarted.</div><div class=\"line\">        // When encrypted device is booting, we get EROFS since</div><div class=\"line\">        // FUSE hasn&apos;t been created yet by init.</div><div class=\"line\">        // In either case, continue without external storage.</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        ALOGE(&quot;Cannot continue without emulated storage&quot;);</div><div class=\"line\">        RuntimeAbort(env);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!is_system_server) &#123;</div><div class=\"line\">        int rc = createProcessGroup(uid, getpid());</div><div class=\"line\">        if (rc != 0) &#123;</div><div class=\"line\">            if (rc == -EROFS) &#123;</div><div class=\"line\">                ALOGW(&quot;createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                ALOGE(&quot;createProcessGroup(%d, %d) failed: %s&quot;, uid, pid, strerror(-rc));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetGids(env, javaGids);</div><div class=\"line\"></div><div class=\"line\">    SetRLimits(env, javaRlimits);</div><div class=\"line\"></div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      ScopedUtfChars data_dir(env, dataDir);</div><div class=\"line\">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int rc = setresgid(gid, gid, gid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresgid(%d) failed: %s&quot;, gid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    rc = setresuid(uid, uid, uid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresuid(%d) failed: %s&quot;, uid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (NeedsNoRandomizeWorkaround()) &#123;</div><div class=\"line\">        // Work around ARM kernel ASLR lossage (http://b/5817320).</div><div class=\"line\">        int old_personality = personality(0xffffffff);</div><div class=\"line\">        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</div><div class=\"line\">        if (new_personality == -1) &#123;</div><div class=\"line\">            ALOGW(&quot;personality(%d) failed: %s&quot;, new_personality, strerror(errno));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</div><div class=\"line\"></div><div class=\"line\">    SetSchedulerPolicy(env);</div><div class=\"line\"></div><div class=\"line\">    const char* se_info_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_info = NULL;</div><div class=\"line\">    if (java_se_info != NULL) &#123;</div><div class=\"line\">        se_info = new ScopedUtfChars(env, java_se_info);</div><div class=\"line\">        se_info_c_str = se_info-&gt;c_str();</div><div class=\"line\">        if (se_info_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_info_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const char* se_name_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_name = NULL;</div><div class=\"line\">    if (java_se_name != NULL) &#123;</div><div class=\"line\">        se_name = new ScopedUtfChars(env, java_se_name);</div><div class=\"line\">        se_name_c_str = se_name-&gt;c_str();</div><div class=\"line\">        if (se_name_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_name_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;selinux_android_setcontext(%d, %d, \\&quot;%s\\&quot;, \\&quot;%s\\&quot;) failed&quot;, uid,</div><div class=\"line\">            is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Make it easier to debug audit logs by setting the main thread&apos;s name to the</div><div class=\"line\">    // nice name rather than &quot;app_process&quot;.</div><div class=\"line\">    if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</div><div class=\"line\">      se_name_c_str = &quot;system_server&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (se_info_c_str != NULL) &#123;</div><div class=\"line\">      SetThreadName(se_name_c_str);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    delete se_info;</div><div class=\"line\">    delete se_name;</div><div class=\"line\"></div><div class=\"line\">    UnsetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</div><div class=\"line\">                              is_system_server ? NULL : instructionSet);</div><div class=\"line\">    if (env-&gt;ExceptionCheck()) &#123;</div><div class=\"line\">      ALOGE(&quot;Error calling post fork hooks.&quot;);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else if (pid &gt; 0) &#123;</div><div class=\"line\">    // the parent process</div><div class=\"line\">  &#125;</div><div class=\"line\">  return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>设置子进程的signal信号处理函数 SetSigChldHandler函数</li>\n<li>fork进程，fork函数</li>\n<li>pid为0，进入子进程<ul>\n<li>DetachDescriptors 关闭清理文件描述符</li>\n<li>SetGids 设置group</li>\n<li>SetRLimits 设置资源限制</li>\n<li>进行其他的初始化设置</li>\n<li>CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。</li>\n<li>…</li>\n</ul>\n</li>\n<li>父进程分支，啥也不做</li>\n<li>返回pid<br>当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        // in child</div><div class=\"line\">        IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">        serverPipeFd = null;</div><div class=\"line\">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">        // should never get here, the child is expected to either</div><div class=\"line\">        // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // in parent...pid of &lt; 0 means failure</div><div class=\"line\">        IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">        childPipeFd = null;</div><div class=\"line\">        return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">    IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们重点看handleChildProc。</p>\n<h3 id=\"10-ZygoteConnection-handleChildProc\"><a href=\"#10-ZygoteConnection-handleChildProc\" class=\"headerlink\" title=\"10.ZygoteConnection#handleChildProc\"></a>10.ZygoteConnection#handleChildProc</h3><p>在这个方法中，有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">    WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">            parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">            VMRuntime.getCurrentInstructionSet(),</div><div class=\"line\">            pipeFd, parsedArgs.remainingArgs);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</div><div class=\"line\">            parsedArgs.remainingArgs, null /* classLoader */);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大部分情况下，invokeWith为null，所以我们看下面的分支。</p>\n<h3 id=\"11-RuntimeInit-zygoteInit\"><a href=\"#11-RuntimeInit-zygoteInit\" class=\"headerlink\" title=\"11.RuntimeInit.zygoteInit\"></a>11.RuntimeInit.zygoteInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</div><div class=\"line\"></div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</div><div class=\"line\">    redirectLogStreams();</div><div class=\"line\"></div><div class=\"line\">    commonInit();</div><div class=\"line\">    nativeZygoteInit();</div><div class=\"line\">    applicationInit(targetSdkVersion, argv, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>重定向log输出</li>\n<li>commonInit,进行通用的一些设置如时区。</li>\n<li>zygote初始化</li>\n<li>应用初始化</li>\n</ul>\n<h3 id=\"12-nativeZygoteInit\"><a href=\"#12-nativeZygoteInit\" class=\"headerlink\" title=\"12.nativeZygoteInit\"></a>12.nativeZygoteInit</h3><p>该函数的实现在AndroidRuntime.cpp中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</div><div class=\"line\">&#123;</div><div class=\"line\">    gCurRuntime-&gt;onZygoteInit();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里onZygoteInit在app_main.cpp中，这里就不多说了。</p>\n<h3 id=\"13-RuntimeInit-applicationInit\"><a href=\"#13-RuntimeInit-applicationInit\" class=\"headerlink\" title=\"13.RuntimeInit.applicationInit\"></a>13.RuntimeInit.applicationInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    // If the application calls System.exit(), terminate the process</div><div class=\"line\">    // immediately without running any shutdown hooks.  It is not possible to</div><div class=\"line\">    // shutdown an Android application gracefully.  Among other things, the</div><div class=\"line\">    // Android runtime shutdown hooks close the Binder driver, which can cause</div><div class=\"line\">    // leftover running threads to crash before the process actually exits.</div><div class=\"line\">    nativeSetExitWithoutCleanup(true);</div><div class=\"line\"></div><div class=\"line\">    // We want to be fairly aggressive about heap utilization, to avoid</div><div class=\"line\">    // holding on to a lot of memory that isn&apos;t needed.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</div><div class=\"line\">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">    final Arguments args;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        args = new Arguments(argv);</div><div class=\"line\">    &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">        Slog.e(TAG, ex.getMessage());</div><div class=\"line\">        // let the process exit</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The end of of the RuntimeInit event (see #zygoteInit).</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class=\"line\"></div><div class=\"line\">    // Remaining arguments are passed to the start class&apos;s static main</div><div class=\"line\">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    Class&lt;?&gt; cl;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        cl = Class.forName(className, true, classLoader);</div><div class=\"line\">    &#125; catch (ClassNotFoundException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing class when invoking static main &quot; + className,</div><div class=\"line\">                ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Method m;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</div><div class=\"line\">    &#125; catch (NoSuchMethodException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing static main on &quot; + className, ex);</div><div class=\"line\">    &#125; catch (SecurityException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Problem getting static main on &quot; + className, ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int modifiers = m.getModifiers();</div><div class=\"line\">    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Main method is not public and static on &quot; + className);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * This throw gets caught in ZygoteInit.main(), which responds</div><div class=\"line\">     * by invoking the exception&apos;s run() method. This arrangement</div><div class=\"line\">     * clears up all the stack frames that were required in setting</div><div class=\"line\">     * up the process.</div><div class=\"line\">     */</div><div class=\"line\">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</div><div class=\"line\">    &#125; catch (IllegalAccessException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125; catch (InvocationTargetException ex) &#123;</div><div class=\"line\">        Throwable cause = ex.getCause();</div><div class=\"line\">        if (cause instanceof RuntimeException) &#123;</div><div class=\"line\">            throw (RuntimeException) cause;</div><div class=\"line\">        &#125; else if (cause instanceof Error) &#123;</div><div class=\"line\">            throw (Error) cause;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：</p>\n<p>在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</div><div class=\"line\">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</div><div class=\"line\">        app.processName);</div><div class=\"line\">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</div><div class=\"line\">Process.ProcessStartResult startResult = Process.start(entryPoint,</div><div class=\"line\">        app.processName, uid, uid, gids, debugFlags, mountExternal,</div><div class=\"line\">        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</div><div class=\"line\">        app.info.dataDir, entryPointArgs);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中entryPoint是进程的运行入口</li>\n</ul>\n<h3 id=\"2-Process-start\"><a href=\"#2-Process-start\" class=\"headerlink\" title=\"2.Process#start\"></a>2.Process#start</h3><p>在start方法中，会调用startViaZygote方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static ProcessStartResult startViaZygote(final String processClass,</div><div class=\"line\">                              final String niceName,</div><div class=\"line\">                              final int uid, final int gid,</div><div class=\"line\">                              final int[] gids,</div><div class=\"line\">                              int debugFlags, int mountExternal,</div><div class=\"line\">                              int targetSdkVersion,</div><div class=\"line\">                              String seInfo,</div><div class=\"line\">                              String abi,</div><div class=\"line\">                              String instructionSet,</div><div class=\"line\">                              String appDataDir,</div><div class=\"line\">                              String[] extraArgs)</div><div class=\"line\">                              throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    synchronized(Process.class) &#123;</div><div class=\"line\">        ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\">        // --runtime-args, --setuid=, --setgid=,</div><div class=\"line\">        // and --setgroups= must go first</div><div class=\"line\">        argsForZygote.add(&quot;--runtime-args&quot;);</div><div class=\"line\">        argsForZygote.add(&quot;--setuid=&quot; + uid);</div><div class=\"line\">        argsForZygote.add(&quot;--setgid=&quot; + gid);</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jni-logging&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-safemode&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-checkjni&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jit&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--generate-debug-info&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-assert&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-default&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-read&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-write&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">        //TODO optionally enable debuger</div><div class=\"line\">        //argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\"></div><div class=\"line\">        // --setgroups is a comma-separated list</div><div class=\"line\">        if (gids != null &amp;&amp; gids.length &gt; 0) &#123;</div><div class=\"line\">            StringBuilder sb = new StringBuilder();</div><div class=\"line\">            sb.append(&quot;--setgroups=&quot;);</div><div class=\"line\"></div><div class=\"line\">            int sz = gids.length;</div><div class=\"line\">            for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">                if (i != 0) &#123;</div><div class=\"line\">                    sb.append(&apos;,&apos;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                sb.append(gids[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            argsForZygote.add(sb.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (niceName != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--nice-name=&quot; + niceName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (seInfo != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--seinfo=&quot; + seInfo);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (instructionSet != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--instruction-set=&quot; + instructionSet);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (appDataDir != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        argsForZygote.add(processClass);</div><div class=\"line\"></div><div class=\"line\">        if (extraArgs != null) &#123;</div><div class=\"line\">            for (String arg : extraArgs) &#123;</div><div class=\"line\">                argsForZygote.add(arg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？</p>\n<h3 id=\"3-Process-openZygoteSocketIfNeeded\"><a href=\"#3-Process-openZygoteSocketIfNeeded\" class=\"headerlink\" title=\"3.Process#openZygoteSocketIfNeeded\"></a>3.Process#openZygoteSocketIfNeeded</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (primaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return primaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The primary zygote didn&apos;t match. Try the secondary.</div><div class=\"line\">    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (secondaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return secondaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。</p>\n<h3 id=\"4-Process-zygoteSendArgsAndGetResult\"><a href=\"#4-Process-zygoteSendArgsAndGetResult\" class=\"headerlink\" title=\"4. Process#zygoteSendArgsAndGetResult\"></a>4. Process#zygoteSendArgsAndGetResult</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">final BufferedWriter writer = zygoteState.writer;</div><div class=\"line\">final DataInputStream inputStream = zygoteState.inputStream;</div><div class=\"line\"></div><div class=\"line\">writer.write(Integer.toString(args.size()));</div><div class=\"line\">writer.newLine();</div><div class=\"line\"></div><div class=\"line\">int sz = args.size();</div><div class=\"line\">for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">    String arg = args.get(i);</div><div class=\"line\">    if (arg.indexOf(&apos;\\n&apos;) &gt;= 0) &#123;</div><div class=\"line\">        throw new ZygoteStartFailedEx(</div><div class=\"line\">                &quot;embedded newlines not allowed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    writer.write(arg);</div><div class=\"line\">    writer.newLine();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">writer.flush();</div><div class=\"line\"></div><div class=\"line\">// Should there be a timeout on this?</div><div class=\"line\">ProcessStartResult result = new ProcessStartResult();</div><div class=\"line\">result.pid = inputStream.readInt();</div><div class=\"line\">if (result.pid &lt; 0) &#123;</div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">result.usingWrapper = inputStream.readBoolean();</div><div class=\"line\">return result;</div></pre></td></tr></table></figure>\n<p>在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。</p>\n<p>那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。</p>\n<h3 id=\"5-ZygoteInit-runSelectLoop\"><a href=\"#5-ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"5. ZygoteInit#runSelectLoop\"></a>5. ZygoteInit#runSelectLoop</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</div><div class=\"line\">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</div><div class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</div><div class=\"line\"></div><div class=\"line\">    fds.add(sServerSocket.getFileDescriptor());</div><div class=\"line\">    peers.add(null);</div><div class=\"line\"></div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</div><div class=\"line\">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</div><div class=\"line\">            pollFds[i] = new StructPollfd();</div><div class=\"line\">            pollFds[i].fd = fds.get(i);</div><div class=\"line\">            pollFds[i].events = (short) POLLIN;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.poll(pollFds, -1);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;poll failed&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class=\"line\">                peers.add(newPeer);</div><div class=\"line\">                fds.add(newPeer.getFileDesciptor());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                boolean done = peers.get(i).runOnce();</div><div class=\"line\">                if (done) &#123;</div><div class=\"line\">                    peers.remove(i);</div><div class=\"line\">                    fds.remove(i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。</p>\n<h3 id=\"6-ZygoteConnection-runOnce\"><a href=\"#6-ZygoteConnection-runOnce\" class=\"headerlink\" title=\"6.ZygoteConnection#runOnce\"></a>6.ZygoteConnection#runOnce</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">     String args[];</div><div class=\"line\">     Arguments parsedArgs = null;</div><div class=\"line\">     FileDescriptor[] descriptors;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         args = readArgumentList();</div><div class=\"line\">         descriptors = mSocket.getAncillaryFileDescriptors();</div><div class=\"line\">     &#125; catch (IOException ex) &#123;</div><div class=\"line\">         Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage());</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     if (args == null) &#123;</div><div class=\"line\">         // EOF reached.</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     /** the stderr of the most recent request, if avail */</div><div class=\"line\">     PrintStream newStderr = null;</div><div class=\"line\"></div><div class=\"line\">     if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123;</div><div class=\"line\">         newStderr = new PrintStream(</div><div class=\"line\">                 new FileOutputStream(descriptors[2]));</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     int pid = -1;</div><div class=\"line\">     FileDescriptor childPipeFd = null;</div><div class=\"line\">     FileDescriptor serverPipeFd = null;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         parsedArgs = new Arguments(args);</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.abiListQuery) &#123;</div><div class=\"line\">             return handleAbiListQuery();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123;</div><div class=\"line\">             throw new ZygoteSecurityException(&quot;Client may not specify capabilities: &quot; +</div><div class=\"line\">                     &quot;permitted=0x&quot; + Long.toHexString(parsedArgs.permittedCapabilities) +</div><div class=\"line\">                     &quot;, effective=0x&quot; + Long.toHexString(parsedArgs.effectiveCapabilities));</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         applyUidSecurityPolicy(parsedArgs, peer);</div><div class=\"line\">         applyInvokeWithSecurityPolicy(parsedArgs, peer);</div><div class=\"line\"></div><div class=\"line\">         applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">         applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">         int[][] rlimits = null;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.rlimits != null) &#123;</div><div class=\"line\">             rlimits = parsedArgs.rlimits.toArray(intArray2d);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">             FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</div><div class=\"line\">             childPipeFd = pipeFds[1];</div><div class=\"line\">             serverPipeFd = pipeFds[0];</div><div class=\"line\">             Os.fcntlInt(childPipeFd, F_SETFD, 0);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         /**</div><div class=\"line\">          * In order to avoid leaking descriptors to the Zygote child,</div><div class=\"line\">          * the native code must close the two Zygote socket descriptors</div><div class=\"line\">          * in the child process before it switches from Zygote-root to</div><div class=\"line\">          * the UID and privileges of the application being launched.</div><div class=\"line\">          *</div><div class=\"line\">          * In order to avoid &quot;bad file descriptor&quot; errors when the</div><div class=\"line\">          * two LocalSocket objects are closed, the Posix file</div><div class=\"line\">          * descriptors are released via a dup2() call which closes</div><div class=\"line\">          * the socket and substitutes an open descriptor to /dev/null.</div><div class=\"line\">          */</div><div class=\"line\"></div><div class=\"line\">         int [] fdsToClose = &#123; -1, -1 &#125;;</div><div class=\"line\"></div><div class=\"line\">         FileDescriptor fd = mSocket.getFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[0] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = ZygoteInit.getServerSocketFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[1] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = null;</div><div class=\"line\"></div><div class=\"line\">         pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class=\"line\">                 parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class=\"line\">                 parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class=\"line\">                 parsedArgs.appDataDir);</div><div class=\"line\">     &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex);</div><div class=\"line\">     &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex);</div><div class=\"line\">     &#125; catch (ZygoteSecurityException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr,</div><div class=\"line\">                 &quot;Zygote security policy prevents request: &quot;, ex);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (pid == 0) &#123;</div><div class=\"line\">             // in child</div><div class=\"line\">             IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">             serverPipeFd = null;</div><div class=\"line\">             handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">             // should never get here, the child is expected to either</div><div class=\"line\">             // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">             return true;</div><div class=\"line\">         &#125; else &#123;</div><div class=\"line\">             // in parent...pid of &lt; 0 means failure</div><div class=\"line\">             IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">             childPipeFd = null;</div><div class=\"line\">             return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">         IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>readArgumentList读区启动参数</li>\n<li>构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数</li>\n<li>随后进行参数检查和配置</li>\n<li>调用Zygote.forkAndSpecialize进行fork进程，返回进程id</li>\n</ul>\n<h3 id=\"7-Zygote-forkAndSpecialize\"><a href=\"#7-Zygote-forkAndSpecialize\" class=\"headerlink\" title=\"7.Zygote#forkAndSpecialize\"></a>7.Zygote#forkAndSpecialize</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();</div><div class=\"line\">    int pid = nativeForkAndSpecialize(</div><div class=\"line\">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class=\"line\">              instructionSet, appDataDir);</div><div class=\"line\">    // Enable tracing as soon as possible for the child process.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\"></div><div class=\"line\">        // Note that this event ends at the end of handleChildProc,</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon();</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>VM_HOOKS是ZygoteHooks</li>\n<li><p>在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePreFork, &quot;()J&quot;),</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, &quot;(JILjava/lang/String;)V&quot;),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。</p>\n</li>\n<li>调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。</li>\n</ul>\n<h3 id=\"8-nativePreFork\"><a href=\"#8-nativePreFork\" class=\"headerlink\" title=\"8. nativePreFork\"></a>8. nativePreFork</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</div><div class=\"line\">  Runtime* runtime = Runtime::Current();</div><div class=\"line\">  CHECK(runtime-&gt;IsZygote()) &lt;&lt; &quot;runtime instance not started with -Xzygote&quot;;</div><div class=\"line\"></div><div class=\"line\">  runtime-&gt;PreZygoteFork();</div><div class=\"line\"></div><div class=\"line\">  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</div><div class=\"line\">    // Tracing active, pause it.</div><div class=\"line\">    Trace::Pause();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.</div><div class=\"line\">  return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略</p>\n<h3 id=\"9-nativeForkAndSpecialize\"><a href=\"#9-nativeForkAndSpecialize\" class=\"headerlink\" title=\"9. nativeForkAndSpecialize\"></a>9. nativeForkAndSpecialize</h3><p>在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div></pre></td><td class=\"code\"><pre><div class=\"line\">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</div><div class=\"line\">                                     jint debug_flags, jobjectArray javaRlimits,</div><div class=\"line\">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</div><div class=\"line\">                                     jint mount_external,</div><div class=\"line\">                                     jstring java_se_info, jstring java_se_name,</div><div class=\"line\">                                     bool is_system_server, jintArray fdsToClose,</div><div class=\"line\">                                     jstring instructionSet, jstring dataDir) &#123;</div><div class=\"line\">  SetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">  pid_t pid = fork();</div><div class=\"line\"></div><div class=\"line\">  if (pid == 0) &#123;</div><div class=\"line\">    // The child process.</div><div class=\"line\">    gMallocLeakZygoteChild = 1;</div><div class=\"line\"></div><div class=\"line\">    // Clean up any descriptors which must be closed immediately</div><div class=\"line\">    DetachDescriptors(env, fdsToClose);</div><div class=\"line\"></div><div class=\"line\">    // Keep capabilities across UID change, unless we&apos;re staying root.</div><div class=\"line\">    if (uid != 0) &#123;</div><div class=\"line\">      EnableKeepCapabilities(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    DropCapabilitiesBoundingSet(env);</div><div class=\"line\"></div><div class=\"line\">    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)</div><div class=\"line\">        &amp;&amp; android::NativeBridgeAvailable();</div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (use_native_bridge &amp;&amp; dataDir == NULL) &#123;</div><div class=\"line\">      // dataDir should never be null if we need to use a native bridge.</div><div class=\"line\">      // In general, dataDir will never be null for normal applications. It can only happen in</div><div class=\"line\">      // special cases (for isolated processes which are not associated with any app). These are</div><div class=\"line\">      // launched by the framework and should not be emulated anyway.</div><div class=\"line\">      use_native_bridge = false;</div><div class=\"line\">      ALOGW(&quot;Native bridge will not be used because dataDir == NULL.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</div><div class=\"line\">      ALOGW(&quot;Failed to mount emulated storage: %s&quot;, strerror(errno));</div><div class=\"line\">      if (errno == ENOTCONN || errno == EROFS) &#123;</div><div class=\"line\">        // When device is actively encrypting, we get ENOTCONN here</div><div class=\"line\">        // since FUSE was mounted before the framework restarted.</div><div class=\"line\">        // When encrypted device is booting, we get EROFS since</div><div class=\"line\">        // FUSE hasn&apos;t been created yet by init.</div><div class=\"line\">        // In either case, continue without external storage.</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        ALOGE(&quot;Cannot continue without emulated storage&quot;);</div><div class=\"line\">        RuntimeAbort(env);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!is_system_server) &#123;</div><div class=\"line\">        int rc = createProcessGroup(uid, getpid());</div><div class=\"line\">        if (rc != 0) &#123;</div><div class=\"line\">            if (rc == -EROFS) &#123;</div><div class=\"line\">                ALOGW(&quot;createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                ALOGE(&quot;createProcessGroup(%d, %d) failed: %s&quot;, uid, pid, strerror(-rc));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetGids(env, javaGids);</div><div class=\"line\"></div><div class=\"line\">    SetRLimits(env, javaRlimits);</div><div class=\"line\"></div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      ScopedUtfChars data_dir(env, dataDir);</div><div class=\"line\">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int rc = setresgid(gid, gid, gid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresgid(%d) failed: %s&quot;, gid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    rc = setresuid(uid, uid, uid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresuid(%d) failed: %s&quot;, uid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (NeedsNoRandomizeWorkaround()) &#123;</div><div class=\"line\">        // Work around ARM kernel ASLR lossage (http://b/5817320).</div><div class=\"line\">        int old_personality = personality(0xffffffff);</div><div class=\"line\">        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</div><div class=\"line\">        if (new_personality == -1) &#123;</div><div class=\"line\">            ALOGW(&quot;personality(%d) failed: %s&quot;, new_personality, strerror(errno));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</div><div class=\"line\"></div><div class=\"line\">    SetSchedulerPolicy(env);</div><div class=\"line\"></div><div class=\"line\">    const char* se_info_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_info = NULL;</div><div class=\"line\">    if (java_se_info != NULL) &#123;</div><div class=\"line\">        se_info = new ScopedUtfChars(env, java_se_info);</div><div class=\"line\">        se_info_c_str = se_info-&gt;c_str();</div><div class=\"line\">        if (se_info_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_info_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const char* se_name_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_name = NULL;</div><div class=\"line\">    if (java_se_name != NULL) &#123;</div><div class=\"line\">        se_name = new ScopedUtfChars(env, java_se_name);</div><div class=\"line\">        se_name_c_str = se_name-&gt;c_str();</div><div class=\"line\">        if (se_name_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_name_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;selinux_android_setcontext(%d, %d, \\&quot;%s\\&quot;, \\&quot;%s\\&quot;) failed&quot;, uid,</div><div class=\"line\">            is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Make it easier to debug audit logs by setting the main thread&apos;s name to the</div><div class=\"line\">    // nice name rather than &quot;app_process&quot;.</div><div class=\"line\">    if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</div><div class=\"line\">      se_name_c_str = &quot;system_server&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (se_info_c_str != NULL) &#123;</div><div class=\"line\">      SetThreadName(se_name_c_str);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    delete se_info;</div><div class=\"line\">    delete se_name;</div><div class=\"line\"></div><div class=\"line\">    UnsetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</div><div class=\"line\">                              is_system_server ? NULL : instructionSet);</div><div class=\"line\">    if (env-&gt;ExceptionCheck()) &#123;</div><div class=\"line\">      ALOGE(&quot;Error calling post fork hooks.&quot;);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else if (pid &gt; 0) &#123;</div><div class=\"line\">    // the parent process</div><div class=\"line\">  &#125;</div><div class=\"line\">  return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>设置子进程的signal信号处理函数 SetSigChldHandler函数</li>\n<li>fork进程，fork函数</li>\n<li>pid为0，进入子进程<ul>\n<li>DetachDescriptors 关闭清理文件描述符</li>\n<li>SetGids 设置group</li>\n<li>SetRLimits 设置资源限制</li>\n<li>进行其他的初始化设置</li>\n<li>CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。</li>\n<li>…</li>\n</ul>\n</li>\n<li>父进程分支，啥也不做</li>\n<li>返回pid<br>当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        // in child</div><div class=\"line\">        IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">        serverPipeFd = null;</div><div class=\"line\">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">        // should never get here, the child is expected to either</div><div class=\"line\">        // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // in parent...pid of &lt; 0 means failure</div><div class=\"line\">        IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">        childPipeFd = null;</div><div class=\"line\">        return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">    IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们重点看handleChildProc。</p>\n<h3 id=\"10-ZygoteConnection-handleChildProc\"><a href=\"#10-ZygoteConnection-handleChildProc\" class=\"headerlink\" title=\"10.ZygoteConnection#handleChildProc\"></a>10.ZygoteConnection#handleChildProc</h3><p>在这个方法中，有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">    WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">            parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">            VMRuntime.getCurrentInstructionSet(),</div><div class=\"line\">            pipeFd, parsedArgs.remainingArgs);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</div><div class=\"line\">            parsedArgs.remainingArgs, null /* classLoader */);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大部分情况下，invokeWith为null，所以我们看下面的分支。</p>\n<h3 id=\"11-RuntimeInit-zygoteInit\"><a href=\"#11-RuntimeInit-zygoteInit\" class=\"headerlink\" title=\"11.RuntimeInit.zygoteInit\"></a>11.RuntimeInit.zygoteInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</div><div class=\"line\"></div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</div><div class=\"line\">    redirectLogStreams();</div><div class=\"line\"></div><div class=\"line\">    commonInit();</div><div class=\"line\">    nativeZygoteInit();</div><div class=\"line\">    applicationInit(targetSdkVersion, argv, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>重定向log输出</li>\n<li>commonInit,进行通用的一些设置如时区。</li>\n<li>zygote初始化</li>\n<li>应用初始化</li>\n</ul>\n<h3 id=\"12-nativeZygoteInit\"><a href=\"#12-nativeZygoteInit\" class=\"headerlink\" title=\"12.nativeZygoteInit\"></a>12.nativeZygoteInit</h3><p>该函数的实现在AndroidRuntime.cpp中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</div><div class=\"line\">&#123;</div><div class=\"line\">    gCurRuntime-&gt;onZygoteInit();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里onZygoteInit在app_main.cpp中，这里就不多说了。</p>\n<h3 id=\"13-RuntimeInit-applicationInit\"><a href=\"#13-RuntimeInit-applicationInit\" class=\"headerlink\" title=\"13.RuntimeInit.applicationInit\"></a>13.RuntimeInit.applicationInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    // If the application calls System.exit(), terminate the process</div><div class=\"line\">    // immediately without running any shutdown hooks.  It is not possible to</div><div class=\"line\">    // shutdown an Android application gracefully.  Among other things, the</div><div class=\"line\">    // Android runtime shutdown hooks close the Binder driver, which can cause</div><div class=\"line\">    // leftover running threads to crash before the process actually exits.</div><div class=\"line\">    nativeSetExitWithoutCleanup(true);</div><div class=\"line\"></div><div class=\"line\">    // We want to be fairly aggressive about heap utilization, to avoid</div><div class=\"line\">    // holding on to a lot of memory that isn&apos;t needed.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</div><div class=\"line\">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">    final Arguments args;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        args = new Arguments(argv);</div><div class=\"line\">    &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">        Slog.e(TAG, ex.getMessage());</div><div class=\"line\">        // let the process exit</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The end of of the RuntimeInit event (see #zygoteInit).</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class=\"line\"></div><div class=\"line\">    // Remaining arguments are passed to the start class&apos;s static main</div><div class=\"line\">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    Class&lt;?&gt; cl;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        cl = Class.forName(className, true, classLoader);</div><div class=\"line\">    &#125; catch (ClassNotFoundException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing class when invoking static main &quot; + className,</div><div class=\"line\">                ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Method m;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</div><div class=\"line\">    &#125; catch (NoSuchMethodException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing static main on &quot; + className, ex);</div><div class=\"line\">    &#125; catch (SecurityException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Problem getting static main on &quot; + className, ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int modifiers = m.getModifiers();</div><div class=\"line\">    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Main method is not public and static on &quot; + className);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * This throw gets caught in ZygoteInit.main(), which responds</div><div class=\"line\">     * by invoking the exception&apos;s run() method. This arrangement</div><div class=\"line\">     * clears up all the stack frames that were required in setting</div><div class=\"line\">     * up the process.</div><div class=\"line\">     */</div><div class=\"line\">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</div><div class=\"line\">    &#125; catch (IllegalAccessException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125; catch (InvocationTargetException ex) &#123;</div><div class=\"line\">        Throwable cause = ex.getCause();</div><div class=\"line\">        if (cause instanceof RuntimeException) &#123;</div><div class=\"line\">            throw (RuntimeException) cause;</div><div class=\"line\">        &#125; else if (cause instanceof Error) &#123;</div><div class=\"line\">            throw (Error) cause;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：</p>\n<p>在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco内存管理","date":"2016-12-14T06:24:25.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. Fresco中的内存管理模块\n\nfresco中的内存分为两个部分，\n\n* 解码的\n\t* 在5.0之上存在java堆中\n\t* 在5.0之下位于Ashmem中 \t\n* 未解码的\n\t* 位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。\n\t\n而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2. 匿名共享内存部分\n\n这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。\n\n光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。\n\n\n```\nAndroidBitmap_lockPixels\nAndroidBitmap_unlockPixels\n\n```\n\npin和release实现的部分在Bitmaps.c部分。\n\n\n### 3. 从NetworkFetchProducer开始谈 native heap的管理\n\n\nNetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：\n\n```\n  private void onResponse(\n      FetchState fetchState,\n      InputStream responseData,\n      int responseContentLength)\n      throws IOException {\n    final PooledByteBufferOutputStream pooledOutputStream;\n    if (responseContentLength > 0) {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);\n    } else {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();\n    }\n    final byte[] ioArray = mByteArrayPool.get(READ_SIZE);\n    try {\n      int length;\n      while ((length = responseData.read(ioArray)) >= 0) {\n        if (length > 0) {\n          pooledOutputStream.write(ioArray, 0, length);\n          maybeHandleIntermediateResult(pooledOutputStream, fetchState);\n          float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);\n          fetchState.getConsumer().onProgressUpdate(progress);\n        }\n      }\n      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());\n      handleFinalResult(pooledOutputStream, fetchState);\n    } finally {\n      mByteArrayPool.release(ioArray);\n      pooledOutputStream.close();\n    }\n  }\n```\n\n* 通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流\n* 将内容输入\n* 通知上层处理\n\n我们分段来看\n\n#### 3.1 构造输出流\n\nPooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。\n\n这样就构造出一个输出流。\n\n#### 3.2 输出数据\n\n上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。\n\n\n```\n    ensureValid();\n    realloc(mCount + count);\n    mBufRef.get().write(mCount, buffer, offset, count);\n    mCount += count;\n```\n\n* 校验有效性\n* 重新申请内存\n* 将原来来写入到内存中的数据加上现在数据，复制到新的native内存中\n\n```\n    NativeMemoryChunk newbuf = mPool.get(newLength);\n    mBufRef.get().copy(0, newbuf, 0, mCount);\n    mBufRef.close();\n    mBufRef = CloseableReference.of(newbuf, mPool);\n```\n\nmPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。\n\n然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。\n\n\n最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。\n\n### 4. 对应的native操作。\n\n上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。\n\n![](/images/fresco/fresco_4.png)\n\n下面就来对其中一些进行说明。\n\n#### 4.1 NativeMemoryChunk_nativeAllocate\n\n这个是用来申请内存的。\n\n```\nstatic jlong NativeMemoryChunk_nativeAllocate(\n    JNIEnv* env,\n    jclass clzz,\n    jint size) {\n  UNUSED(clzz);\n  void* pointer = malloc(size);\n  if (!pointer) {\n    (*env)->ThrowNew(env, jRuntimeException_class, \"could not allocate memory\");\n    return 0;\n  }\n  return PTR_TO_JLONG(pointer);\n}\n```\n\n* 通过malloc申请size大小的一块内存\n* 通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。\n\n因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型\n\n#### 4.2 NativeMemoryChunk_nativeMemcpy\n\n这个方法很简单。\n\n```\nmemcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);\n```\n* 这里的参数，分别对应java中的两个NativeMemoryChunk，和大小\n* 首先用JLONG_TO_PTR这个宏，将long专为指针\n* 用memcpy函数，进行复制操作，\n\n\n#### 4.3 NativeMemoryChunk_nativeFree\n\n\n```\nfree(JLONG_TO_PTR(lpointer));\n```\n\n调用free函数将指针对应位置的内存释放掉。\n\n其他的几个函数 这里就不说了。\n\n\n\n需要注意的是，native内存管理实对应NativeMemoryChunkPool。\n\n\n### 5 以native内存为例，了解fresco内存池\n\n我们需要先来了解几个东西。\n\n* 池 负责存储某类型的数据\n* 桶 将池分为若干大小的块，每一个块就是一个桶\n* 每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。\n\n那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。\n\n![](/images/fresco/fresco_5.png)\n\n\n了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。\n\n#### 5.1 BasePool#get\n\n这个方法比较长，分段来看。\n\n```\n    int bucketedSize = getBucketedSize(size);\n    int sizeInBytes = -1;\n\n    synchronized (this) {\n      Bucket<V> bucket = getBucket(bucketedSize);\n\n      if (bucket != null) {\n        // find an existing value that we can reuse\n        V value = bucket.get();\n        if (value != null) {\n          Preconditions.checkState(mInUseValues.add(value));\n\n          // It is possible that we got a 'larger' value than we asked for.\n          // lets recompute size in bytes here\n          bucketedSize = getBucketedSizeForValue(value);\n          sizeInBytes = getSizeInBytes(bucketedSize);\n          mUsed.increment(sizeInBytes);\n          mFree.decrement(sizeInBytes);\n          mPoolStatsTracker.onValueReuse(sizeInBytes);\n          logStats();\n          if (FLog.isLoggable(FLog.VERBOSE)) {\n            FLog.v(\n                TAG,\n                \"get (reuse) (object, size) = (%x, %s)\",\n                System.identityHashCode(value),\n                bucketedSize);\n          }\n          return value;\n        }\n        // fall through\n      }\n      // check to see if we can allocate a value of the given size without exceeding the hard cap\n      sizeInBytes = getSizeInBytes(bucketedSize);\n      if (!canAllocate(sizeInBytes)) {\n        throw new PoolSizeViolationException(\n            mPoolParams.maxSizeHardCap,\n            mUsed.mNumBytes,\n            mFree.mNumBytes,\n            sizeInBytes);\n      }\n\n      // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes\n      mUsed.increment(sizeInBytes);\n      if (bucket != null) {\n        bucket.incrementInUseCount();\n      }\n    }\n```\n\n* 首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小\n* 通过getBucket方法获取对应桶容量的桶\n\t* 如果没有找到，就创建一个新的桶 \n* 如果桶不为null\n\t* 通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能\n\t* Counter 纪录使用容量和空闲容量\n\t* 状态追踪以及其他操作\n\t* 返回\n\n```\n    V value = null;\n    try {\n      // allocate the value outside the synchronized block, because it can be pretty expensive\n      // we could have done the allocation inside the synchronized block,\n      // but that would have blocked out other operations on the pool\n      value = alloc(bucketedSize);\n    } catch (Throwable e) {\n      // Assumption we made previously is not valid - allocation failed. We need to fix internal\n      // counters.\n      synchronized (this) {\n        mUsed.decrement(sizeInBytes);\n        Bucket<V> bucket = getBucket(bucketedSize);\n        if (bucket != null) {\n          bucket.decrementInUseCount();\n        }\n      }\n      Throwables.propagateIfPossible(e);\n    }\n        synchronized(this) {\n      Preconditions.checkState(mInUseValues.add(value));\n      // If we're over the pool's max size, try to trim the pool appropriately\n      trimToSoftCap();\n      mPoolStatsTracker.onAlloc(sizeInBytes);\n      logStats();\n      if (FLog.isLoggable(FLog.VERBOSE)) {\n        FLog.v(\n            TAG,\n            \"get (alloc) (object, size) = (%x, %s)\",\n            System.identityHashCode(value),\n            bucketedSize);\n      }\n    }\n\n    return value;\n```\n\n* 没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有\n* 如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。\n\n#### 5.2 BasePool#release\n\n这个方法是我们主动释放一个对象所占用的内存。\n\n实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/fresco内存管理.md","raw":"---\ntitle: fresco内存管理\ndate: 2016-12-14 14:24:25\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. Fresco中的内存管理模块\n\nfresco中的内存分为两个部分，\n\n* 解码的\n\t* 在5.0之上存在java堆中\n\t* 在5.0之下位于Ashmem中 \t\n* 未解码的\n\t* 位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。\n\t\n而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2. 匿名共享内存部分\n\n这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。\n\n光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。\n\n\n```\nAndroidBitmap_lockPixels\nAndroidBitmap_unlockPixels\n\n```\n\npin和release实现的部分在Bitmaps.c部分。\n\n\n### 3. 从NetworkFetchProducer开始谈 native heap的管理\n\n\nNetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：\n\n```\n  private void onResponse(\n      FetchState fetchState,\n      InputStream responseData,\n      int responseContentLength)\n      throws IOException {\n    final PooledByteBufferOutputStream pooledOutputStream;\n    if (responseContentLength > 0) {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);\n    } else {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();\n    }\n    final byte[] ioArray = mByteArrayPool.get(READ_SIZE);\n    try {\n      int length;\n      while ((length = responseData.read(ioArray)) >= 0) {\n        if (length > 0) {\n          pooledOutputStream.write(ioArray, 0, length);\n          maybeHandleIntermediateResult(pooledOutputStream, fetchState);\n          float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);\n          fetchState.getConsumer().onProgressUpdate(progress);\n        }\n      }\n      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());\n      handleFinalResult(pooledOutputStream, fetchState);\n    } finally {\n      mByteArrayPool.release(ioArray);\n      pooledOutputStream.close();\n    }\n  }\n```\n\n* 通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流\n* 将内容输入\n* 通知上层处理\n\n我们分段来看\n\n#### 3.1 构造输出流\n\nPooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。\n\n这样就构造出一个输出流。\n\n#### 3.2 输出数据\n\n上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。\n\n\n```\n    ensureValid();\n    realloc(mCount + count);\n    mBufRef.get().write(mCount, buffer, offset, count);\n    mCount += count;\n```\n\n* 校验有效性\n* 重新申请内存\n* 将原来来写入到内存中的数据加上现在数据，复制到新的native内存中\n\n```\n    NativeMemoryChunk newbuf = mPool.get(newLength);\n    mBufRef.get().copy(0, newbuf, 0, mCount);\n    mBufRef.close();\n    mBufRef = CloseableReference.of(newbuf, mPool);\n```\n\nmPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。\n\n然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。\n\n\n最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。\n\n### 4. 对应的native操作。\n\n上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。\n\n![](/images/fresco/fresco_4.png)\n\n下面就来对其中一些进行说明。\n\n#### 4.1 NativeMemoryChunk_nativeAllocate\n\n这个是用来申请内存的。\n\n```\nstatic jlong NativeMemoryChunk_nativeAllocate(\n    JNIEnv* env,\n    jclass clzz,\n    jint size) {\n  UNUSED(clzz);\n  void* pointer = malloc(size);\n  if (!pointer) {\n    (*env)->ThrowNew(env, jRuntimeException_class, \"could not allocate memory\");\n    return 0;\n  }\n  return PTR_TO_JLONG(pointer);\n}\n```\n\n* 通过malloc申请size大小的一块内存\n* 通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。\n\n因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型\n\n#### 4.2 NativeMemoryChunk_nativeMemcpy\n\n这个方法很简单。\n\n```\nmemcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);\n```\n* 这里的参数，分别对应java中的两个NativeMemoryChunk，和大小\n* 首先用JLONG_TO_PTR这个宏，将long专为指针\n* 用memcpy函数，进行复制操作，\n\n\n#### 4.3 NativeMemoryChunk_nativeFree\n\n\n```\nfree(JLONG_TO_PTR(lpointer));\n```\n\n调用free函数将指针对应位置的内存释放掉。\n\n其他的几个函数 这里就不说了。\n\n\n\n需要注意的是，native内存管理实对应NativeMemoryChunkPool。\n\n\n### 5 以native内存为例，了解fresco内存池\n\n我们需要先来了解几个东西。\n\n* 池 负责存储某类型的数据\n* 桶 将池分为若干大小的块，每一个块就是一个桶\n* 每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。\n\n那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。\n\n![](/images/fresco/fresco_5.png)\n\n\n了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。\n\n#### 5.1 BasePool#get\n\n这个方法比较长，分段来看。\n\n```\n    int bucketedSize = getBucketedSize(size);\n    int sizeInBytes = -1;\n\n    synchronized (this) {\n      Bucket<V> bucket = getBucket(bucketedSize);\n\n      if (bucket != null) {\n        // find an existing value that we can reuse\n        V value = bucket.get();\n        if (value != null) {\n          Preconditions.checkState(mInUseValues.add(value));\n\n          // It is possible that we got a 'larger' value than we asked for.\n          // lets recompute size in bytes here\n          bucketedSize = getBucketedSizeForValue(value);\n          sizeInBytes = getSizeInBytes(bucketedSize);\n          mUsed.increment(sizeInBytes);\n          mFree.decrement(sizeInBytes);\n          mPoolStatsTracker.onValueReuse(sizeInBytes);\n          logStats();\n          if (FLog.isLoggable(FLog.VERBOSE)) {\n            FLog.v(\n                TAG,\n                \"get (reuse) (object, size) = (%x, %s)\",\n                System.identityHashCode(value),\n                bucketedSize);\n          }\n          return value;\n        }\n        // fall through\n      }\n      // check to see if we can allocate a value of the given size without exceeding the hard cap\n      sizeInBytes = getSizeInBytes(bucketedSize);\n      if (!canAllocate(sizeInBytes)) {\n        throw new PoolSizeViolationException(\n            mPoolParams.maxSizeHardCap,\n            mUsed.mNumBytes,\n            mFree.mNumBytes,\n            sizeInBytes);\n      }\n\n      // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes\n      mUsed.increment(sizeInBytes);\n      if (bucket != null) {\n        bucket.incrementInUseCount();\n      }\n    }\n```\n\n* 首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小\n* 通过getBucket方法获取对应桶容量的桶\n\t* 如果没有找到，就创建一个新的桶 \n* 如果桶不为null\n\t* 通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能\n\t* Counter 纪录使用容量和空闲容量\n\t* 状态追踪以及其他操作\n\t* 返回\n\n```\n    V value = null;\n    try {\n      // allocate the value outside the synchronized block, because it can be pretty expensive\n      // we could have done the allocation inside the synchronized block,\n      // but that would have blocked out other operations on the pool\n      value = alloc(bucketedSize);\n    } catch (Throwable e) {\n      // Assumption we made previously is not valid - allocation failed. We need to fix internal\n      // counters.\n      synchronized (this) {\n        mUsed.decrement(sizeInBytes);\n        Bucket<V> bucket = getBucket(bucketedSize);\n        if (bucket != null) {\n          bucket.decrementInUseCount();\n        }\n      }\n      Throwables.propagateIfPossible(e);\n    }\n        synchronized(this) {\n      Preconditions.checkState(mInUseValues.add(value));\n      // If we're over the pool's max size, try to trim the pool appropriately\n      trimToSoftCap();\n      mPoolStatsTracker.onAlloc(sizeInBytes);\n      logStats();\n      if (FLog.isLoggable(FLog.VERBOSE)) {\n        FLog.v(\n            TAG,\n            \"get (alloc) (object, size) = (%x, %s)\",\n            System.identityHashCode(value),\n            bucketedSize);\n      }\n    }\n\n    return value;\n```\n\n* 没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有\n* 如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。\n\n#### 5.2 BasePool#release\n\n这个方法是我们主动释放一个对象所占用的内存。\n\n实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"fresco内存管理","published":1,"updated":"2017-01-06T05:31:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yf0011uaxayz6c5a72","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-Fresco中的内存管理模块\"><a href=\"#1-Fresco中的内存管理模块\" class=\"headerlink\" title=\"1. Fresco中的内存管理模块\"></a>1. Fresco中的内存管理模块</h3><p>fresco中的内存分为两个部分，</p>\n<ul>\n<li>解码的<ul>\n<li>在5.0之上存在java堆中</li>\n<li>在5.0之下位于Ashmem中     </li>\n</ul>\n</li>\n<li>未解码的<ul>\n<li>位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。</li>\n</ul>\n</li>\n</ul>\n<p>而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n</the></li>\n</ul>\n<h3 id=\"2-匿名共享内存部分\"><a href=\"#2-匿名共享内存部分\" class=\"headerlink\" title=\"2. 匿名共享内存部分\"></a>2. 匿名共享内存部分</h3><p>这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。</p>\n<p>光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AndroidBitmap_lockPixels</div><div class=\"line\">AndroidBitmap_unlockPixels</div></pre></td></tr></table></figure>\n<p>pin和release实现的部分在Bitmaps.c部分。</p>\n<h3 id=\"3-从NetworkFetchProducer开始谈-native-heap的管理\"><a href=\"#3-从NetworkFetchProducer开始谈-native-heap的管理\" class=\"headerlink\" title=\"3. 从NetworkFetchProducer开始谈 native heap的管理\"></a>3. 从NetworkFetchProducer开始谈 native heap的管理</h3><p>NetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onResponse(</div><div class=\"line\">    FetchState fetchState,</div><div class=\"line\">    InputStream responseData,</div><div class=\"line\">    int responseContentLength)</div><div class=\"line\">    throws IOException &#123;</div><div class=\"line\">  final PooledByteBufferOutputStream pooledOutputStream;</div><div class=\"line\">  if (responseContentLength &gt; 0) &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream();</div><div class=\"line\">  &#125;</div><div class=\"line\">  final byte[] ioArray = mByteArrayPool.get(READ_SIZE);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    int length;</div><div class=\"line\">    while ((length = responseData.read(ioArray)) &gt;= 0) &#123;</div><div class=\"line\">      if (length &gt; 0) &#123;</div><div class=\"line\">        pooledOutputStream.write(ioArray, 0, length);</div><div class=\"line\">        maybeHandleIntermediateResult(pooledOutputStream, fetchState);</div><div class=\"line\">        float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);</div><div class=\"line\">        fetchState.getConsumer().onProgressUpdate(progress);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());</div><div class=\"line\">    handleFinalResult(pooledOutputStream, fetchState);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    mByteArrayPool.release(ioArray);</div><div class=\"line\">    pooledOutputStream.close();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流</li>\n<li>将内容输入</li>\n<li>通知上层处理</li>\n</ul>\n<p>我们分段来看</p>\n<h4 id=\"3-1-构造输出流\"><a href=\"#3-1-构造输出流\" class=\"headerlink\" title=\"3.1 构造输出流\"></a>3.1 构造输出流</h4><p>PooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。</p>\n<p>这样就构造出一个输出流。</p>\n<h4 id=\"3-2-输出数据\"><a href=\"#3-2-输出数据\" class=\"headerlink\" title=\"3.2 输出数据\"></a>3.2 输出数据</h4><p>上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ensureValid();</div><div class=\"line\">realloc(mCount + count);</div><div class=\"line\">mBufRef.get().write(mCount, buffer, offset, count);</div><div class=\"line\">mCount += count;</div></pre></td></tr></table></figure>\n<ul>\n<li>校验有效性</li>\n<li>重新申请内存</li>\n<li>将原来来写入到内存中的数据加上现在数据，复制到新的native内存中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMemoryChunk newbuf = mPool.get(newLength);</div><div class=\"line\">mBufRef.get().copy(0, newbuf, 0, mCount);</div><div class=\"line\">mBufRef.close();</div><div class=\"line\">mBufRef = CloseableReference.of(newbuf, mPool);</div></pre></td></tr></table></figure>\n<p>mPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。</p>\n<p>然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。</p>\n<p>最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。</p>\n<h3 id=\"4-对应的native操作。\"><a href=\"#4-对应的native操作。\" class=\"headerlink\" title=\"4. 对应的native操作。\"></a>4. 对应的native操作。</h3><p>上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。</p>\n<p><img src=\"/images/fresco/fresco_4.png\" alt=\"\"></p>\n<p>下面就来对其中一些进行说明。</p>\n<h4 id=\"4-1-NativeMemoryChunk-nativeAllocate\"><a href=\"#4-1-NativeMemoryChunk-nativeAllocate\" class=\"headerlink\" title=\"4.1 NativeMemoryChunk_nativeAllocate\"></a>4.1 NativeMemoryChunk_nativeAllocate</h4><p>这个是用来申请内存的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong NativeMemoryChunk_nativeAllocate(</div><div class=\"line\">    JNIEnv* env,</div><div class=\"line\">    jclass clzz,</div><div class=\"line\">    jint size) &#123;</div><div class=\"line\">  UNUSED(clzz);</div><div class=\"line\">  void* pointer = malloc(size);</div><div class=\"line\">  if (!pointer) &#123;</div><div class=\"line\">    (*env)-&gt;ThrowNew(env, jRuntimeException_class, &quot;could not allocate memory&quot;);</div><div class=\"line\">    return 0;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return PTR_TO_JLONG(pointer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过malloc申请size大小的一块内存</li>\n<li>通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。</li>\n</ul>\n<p>因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型</p>\n<h4 id=\"4-2-NativeMemoryChunk-nativeMemcpy\"><a href=\"#4-2-NativeMemoryChunk-nativeMemcpy\" class=\"headerlink\" title=\"4.2 NativeMemoryChunk_nativeMemcpy\"></a>4.2 NativeMemoryChunk_nativeMemcpy</h4><p>这个方法很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">memcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);</div></pre></td></tr></table></figure>\n<ul>\n<li>这里的参数，分别对应java中的两个NativeMemoryChunk，和大小</li>\n<li>首先用JLONG_TO_PTR这个宏，将long专为指针</li>\n<li>用memcpy函数，进行复制操作，</li>\n</ul>\n<h4 id=\"4-3-NativeMemoryChunk-nativeFree\"><a href=\"#4-3-NativeMemoryChunk-nativeFree\" class=\"headerlink\" title=\"4.3 NativeMemoryChunk_nativeFree\"></a>4.3 NativeMemoryChunk_nativeFree</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">free(JLONG_TO_PTR(lpointer));</div></pre></td></tr></table></figure>\n<p>调用free函数将指针对应位置的内存释放掉。</p>\n<p>其他的几个函数 这里就不说了。</p>\n<p>需要注意的是，native内存管理实对应NativeMemoryChunkPool。</p>\n<h3 id=\"5-以native内存为例，了解fresco内存池\"><a href=\"#5-以native内存为例，了解fresco内存池\" class=\"headerlink\" title=\"5 以native内存为例，了解fresco内存池\"></a>5 以native内存为例，了解fresco内存池</h3><p>我们需要先来了解几个东西。</p>\n<ul>\n<li>池 负责存储某类型的数据</li>\n<li>桶 将池分为若干大小的块，每一个块就是一个桶</li>\n<li>每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。</li>\n</ul>\n<p>那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。</p>\n<p><img src=\"/images/fresco/fresco_5.png\" alt=\"\"></p>\n<p>了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。</p>\n<h4 id=\"5-1-BasePool-get\"><a href=\"#5-1-BasePool-get\" class=\"headerlink\" title=\"5.1 BasePool#get\"></a>5.1 BasePool#get</h4><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">int bucketedSize = getBucketedSize(size);</div><div class=\"line\">int sizeInBytes = -1;</div><div class=\"line\"></div><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">  Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\"></div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    // find an existing value that we can reuse</div><div class=\"line\">    V value = bucket.get();</div><div class=\"line\">    if (value != null) &#123;</div><div class=\"line\">      Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\"></div><div class=\"line\">      // It is possible that we got a &apos;larger&apos; value than we asked for.</div><div class=\"line\">      // lets recompute size in bytes here</div><div class=\"line\">      bucketedSize = getBucketedSizeForValue(value);</div><div class=\"line\">      sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">      mUsed.increment(sizeInBytes);</div><div class=\"line\">      mFree.decrement(sizeInBytes);</div><div class=\"line\">      mPoolStatsTracker.onValueReuse(sizeInBytes);</div><div class=\"line\">      logStats();</div><div class=\"line\">      if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">        FLog.v(</div><div class=\"line\">            TAG,</div><div class=\"line\">            &quot;get (reuse) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">            System.identityHashCode(value),</div><div class=\"line\">            bucketedSize);</div><div class=\"line\">      &#125;</div><div class=\"line\">      return value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // fall through</div><div class=\"line\">  &#125;</div><div class=\"line\">  // check to see if we can allocate a value of the given size without exceeding the hard cap</div><div class=\"line\">  sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">  if (!canAllocate(sizeInBytes)) &#123;</div><div class=\"line\">    throw new PoolSizeViolationException(</div><div class=\"line\">        mPoolParams.maxSizeHardCap,</div><div class=\"line\">        mUsed.mNumBytes,</div><div class=\"line\">        mFree.mNumBytes,</div><div class=\"line\">        sizeInBytes);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes</div><div class=\"line\">  mUsed.increment(sizeInBytes);</div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    bucket.incrementInUseCount();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小</li>\n<li>通过getBucket方法获取对应桶容量的桶<ul>\n<li>如果没有找到，就创建一个新的桶 </li>\n</ul>\n</li>\n<li>如果桶不为null<ul>\n<li>通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能</li>\n<li>Counter 纪录使用容量和空闲容量</li>\n<li>状态追踪以及其他操作</li>\n<li>返回</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">V value = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">  // allocate the value outside the synchronized block, because it can be pretty expensive</div><div class=\"line\">  // we could have done the allocation inside the synchronized block,</div><div class=\"line\">  // but that would have blocked out other operations on the pool</div><div class=\"line\">  value = alloc(bucketedSize);</div><div class=\"line\">&#125; catch (Throwable e) &#123;</div><div class=\"line\">  // Assumption we made previously is not valid - allocation failed. We need to fix internal</div><div class=\"line\">  // counters.</div><div class=\"line\">  synchronized (this) &#123;</div><div class=\"line\">    mUsed.decrement(sizeInBytes);</div><div class=\"line\">    Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\">    if (bucket != null) &#123;</div><div class=\"line\">      bucket.decrementInUseCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Throwables.propagateIfPossible(e);</div><div class=\"line\">&#125;</div><div class=\"line\">    synchronized(this) &#123;</div><div class=\"line\">  Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\">  // If we&apos;re over the pool&apos;s max size, try to trim the pool appropriately</div><div class=\"line\">  trimToSoftCap();</div><div class=\"line\">  mPoolStatsTracker.onAlloc(sizeInBytes);</div><div class=\"line\">  logStats();</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;get (alloc) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">        System.identityHashCode(value),</div><div class=\"line\">        bucketedSize);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return value;</div></pre></td></tr></table></figure>\n<ul>\n<li>没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有</li>\n<li>如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。</li>\n</ul>\n<h4 id=\"5-2-BasePool-release\"><a href=\"#5-2-BasePool-release\" class=\"headerlink\" title=\"5.2 BasePool#release\"></a>5.2 BasePool#release</h4><p>这个方法是我们主动释放一个对象所占用的内存。</p>\n<p>实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-Fresco中的内存管理模块\"><a href=\"#1-Fresco中的内存管理模块\" class=\"headerlink\" title=\"1. Fresco中的内存管理模块\"></a>1. Fresco中的内存管理模块</h3><p>fresco中的内存分为两个部分，</p>\n<ul>\n<li>解码的<ul>\n<li>在5.0之上存在java堆中</li>\n<li>在5.0之下位于Ashmem中     </li>\n</ul>\n</li>\n<li>未解码的<ul>\n<li>位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。</li>\n</ul>\n</li>\n</ul>\n<p>而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n\n</li>\n</ul>\n<h3 id=\"2-匿名共享内存部分\"><a href=\"#2-匿名共享内存部分\" class=\"headerlink\" title=\"2. 匿名共享内存部分\"></a>2. 匿名共享内存部分</h3><p>这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。</p>\n<p>光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AndroidBitmap_lockPixels</div><div class=\"line\">AndroidBitmap_unlockPixels</div></pre></td></tr></table></figure>\n<p>pin和release实现的部分在Bitmaps.c部分。</p>\n<h3 id=\"3-从NetworkFetchProducer开始谈-native-heap的管理\"><a href=\"#3-从NetworkFetchProducer开始谈-native-heap的管理\" class=\"headerlink\" title=\"3. 从NetworkFetchProducer开始谈 native heap的管理\"></a>3. 从NetworkFetchProducer开始谈 native heap的管理</h3><p>NetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onResponse(</div><div class=\"line\">    FetchState fetchState,</div><div class=\"line\">    InputStream responseData,</div><div class=\"line\">    int responseContentLength)</div><div class=\"line\">    throws IOException &#123;</div><div class=\"line\">  final PooledByteBufferOutputStream pooledOutputStream;</div><div class=\"line\">  if (responseContentLength &gt; 0) &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream();</div><div class=\"line\">  &#125;</div><div class=\"line\">  final byte[] ioArray = mByteArrayPool.get(READ_SIZE);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    int length;</div><div class=\"line\">    while ((length = responseData.read(ioArray)) &gt;= 0) &#123;</div><div class=\"line\">      if (length &gt; 0) &#123;</div><div class=\"line\">        pooledOutputStream.write(ioArray, 0, length);</div><div class=\"line\">        maybeHandleIntermediateResult(pooledOutputStream, fetchState);</div><div class=\"line\">        float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);</div><div class=\"line\">        fetchState.getConsumer().onProgressUpdate(progress);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());</div><div class=\"line\">    handleFinalResult(pooledOutputStream, fetchState);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    mByteArrayPool.release(ioArray);</div><div class=\"line\">    pooledOutputStream.close();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流</li>\n<li>将内容输入</li>\n<li>通知上层处理</li>\n</ul>\n<p>我们分段来看</p>\n<h4 id=\"3-1-构造输出流\"><a href=\"#3-1-构造输出流\" class=\"headerlink\" title=\"3.1 构造输出流\"></a>3.1 构造输出流</h4><p>PooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。</p>\n<p>这样就构造出一个输出流。</p>\n<h4 id=\"3-2-输出数据\"><a href=\"#3-2-输出数据\" class=\"headerlink\" title=\"3.2 输出数据\"></a>3.2 输出数据</h4><p>上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ensureValid();</div><div class=\"line\">realloc(mCount + count);</div><div class=\"line\">mBufRef.get().write(mCount, buffer, offset, count);</div><div class=\"line\">mCount += count;</div></pre></td></tr></table></figure>\n<ul>\n<li>校验有效性</li>\n<li>重新申请内存</li>\n<li>将原来来写入到内存中的数据加上现在数据，复制到新的native内存中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMemoryChunk newbuf = mPool.get(newLength);</div><div class=\"line\">mBufRef.get().copy(0, newbuf, 0, mCount);</div><div class=\"line\">mBufRef.close();</div><div class=\"line\">mBufRef = CloseableReference.of(newbuf, mPool);</div></pre></td></tr></table></figure>\n<p>mPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。</p>\n<p>然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。</p>\n<p>最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。</p>\n<h3 id=\"4-对应的native操作。\"><a href=\"#4-对应的native操作。\" class=\"headerlink\" title=\"4. 对应的native操作。\"></a>4. 对应的native操作。</h3><p>上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。</p>\n<p><img src=\"/images/fresco/fresco_4.png\" alt=\"\"></p>\n<p>下面就来对其中一些进行说明。</p>\n<h4 id=\"4-1-NativeMemoryChunk-nativeAllocate\"><a href=\"#4-1-NativeMemoryChunk-nativeAllocate\" class=\"headerlink\" title=\"4.1 NativeMemoryChunk_nativeAllocate\"></a>4.1 NativeMemoryChunk_nativeAllocate</h4><p>这个是用来申请内存的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong NativeMemoryChunk_nativeAllocate(</div><div class=\"line\">    JNIEnv* env,</div><div class=\"line\">    jclass clzz,</div><div class=\"line\">    jint size) &#123;</div><div class=\"line\">  UNUSED(clzz);</div><div class=\"line\">  void* pointer = malloc(size);</div><div class=\"line\">  if (!pointer) &#123;</div><div class=\"line\">    (*env)-&gt;ThrowNew(env, jRuntimeException_class, &quot;could not allocate memory&quot;);</div><div class=\"line\">    return 0;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return PTR_TO_JLONG(pointer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过malloc申请size大小的一块内存</li>\n<li>通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。</li>\n</ul>\n<p>因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型</p>\n<h4 id=\"4-2-NativeMemoryChunk-nativeMemcpy\"><a href=\"#4-2-NativeMemoryChunk-nativeMemcpy\" class=\"headerlink\" title=\"4.2 NativeMemoryChunk_nativeMemcpy\"></a>4.2 NativeMemoryChunk_nativeMemcpy</h4><p>这个方法很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">memcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);</div></pre></td></tr></table></figure>\n<ul>\n<li>这里的参数，分别对应java中的两个NativeMemoryChunk，和大小</li>\n<li>首先用JLONG_TO_PTR这个宏，将long专为指针</li>\n<li>用memcpy函数，进行复制操作，</li>\n</ul>\n<h4 id=\"4-3-NativeMemoryChunk-nativeFree\"><a href=\"#4-3-NativeMemoryChunk-nativeFree\" class=\"headerlink\" title=\"4.3 NativeMemoryChunk_nativeFree\"></a>4.3 NativeMemoryChunk_nativeFree</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">free(JLONG_TO_PTR(lpointer));</div></pre></td></tr></table></figure>\n<p>调用free函数将指针对应位置的内存释放掉。</p>\n<p>其他的几个函数 这里就不说了。</p>\n<p>需要注意的是，native内存管理实对应NativeMemoryChunkPool。</p>\n<h3 id=\"5-以native内存为例，了解fresco内存池\"><a href=\"#5-以native内存为例，了解fresco内存池\" class=\"headerlink\" title=\"5 以native内存为例，了解fresco内存池\"></a>5 以native内存为例，了解fresco内存池</h3><p>我们需要先来了解几个东西。</p>\n<ul>\n<li>池 负责存储某类型的数据</li>\n<li>桶 将池分为若干大小的块，每一个块就是一个桶</li>\n<li>每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。</li>\n</ul>\n<p>那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。</p>\n<p><img src=\"/images/fresco/fresco_5.png\" alt=\"\"></p>\n<p>了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。</p>\n<h4 id=\"5-1-BasePool-get\"><a href=\"#5-1-BasePool-get\" class=\"headerlink\" title=\"5.1 BasePool#get\"></a>5.1 BasePool#get</h4><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">int bucketedSize = getBucketedSize(size);</div><div class=\"line\">int sizeInBytes = -1;</div><div class=\"line\"></div><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">  Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\"></div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    // find an existing value that we can reuse</div><div class=\"line\">    V value = bucket.get();</div><div class=\"line\">    if (value != null) &#123;</div><div class=\"line\">      Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\"></div><div class=\"line\">      // It is possible that we got a &apos;larger&apos; value than we asked for.</div><div class=\"line\">      // lets recompute size in bytes here</div><div class=\"line\">      bucketedSize = getBucketedSizeForValue(value);</div><div class=\"line\">      sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">      mUsed.increment(sizeInBytes);</div><div class=\"line\">      mFree.decrement(sizeInBytes);</div><div class=\"line\">      mPoolStatsTracker.onValueReuse(sizeInBytes);</div><div class=\"line\">      logStats();</div><div class=\"line\">      if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">        FLog.v(</div><div class=\"line\">            TAG,</div><div class=\"line\">            &quot;get (reuse) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">            System.identityHashCode(value),</div><div class=\"line\">            bucketedSize);</div><div class=\"line\">      &#125;</div><div class=\"line\">      return value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // fall through</div><div class=\"line\">  &#125;</div><div class=\"line\">  // check to see if we can allocate a value of the given size without exceeding the hard cap</div><div class=\"line\">  sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">  if (!canAllocate(sizeInBytes)) &#123;</div><div class=\"line\">    throw new PoolSizeViolationException(</div><div class=\"line\">        mPoolParams.maxSizeHardCap,</div><div class=\"line\">        mUsed.mNumBytes,</div><div class=\"line\">        mFree.mNumBytes,</div><div class=\"line\">        sizeInBytes);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes</div><div class=\"line\">  mUsed.increment(sizeInBytes);</div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    bucket.incrementInUseCount();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小</li>\n<li>通过getBucket方法获取对应桶容量的桶<ul>\n<li>如果没有找到，就创建一个新的桶 </li>\n</ul>\n</li>\n<li>如果桶不为null<ul>\n<li>通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能</li>\n<li>Counter 纪录使用容量和空闲容量</li>\n<li>状态追踪以及其他操作</li>\n<li>返回</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">V value = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">  // allocate the value outside the synchronized block, because it can be pretty expensive</div><div class=\"line\">  // we could have done the allocation inside the synchronized block,</div><div class=\"line\">  // but that would have blocked out other operations on the pool</div><div class=\"line\">  value = alloc(bucketedSize);</div><div class=\"line\">&#125; catch (Throwable e) &#123;</div><div class=\"line\">  // Assumption we made previously is not valid - allocation failed. We need to fix internal</div><div class=\"line\">  // counters.</div><div class=\"line\">  synchronized (this) &#123;</div><div class=\"line\">    mUsed.decrement(sizeInBytes);</div><div class=\"line\">    Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\">    if (bucket != null) &#123;</div><div class=\"line\">      bucket.decrementInUseCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Throwables.propagateIfPossible(e);</div><div class=\"line\">&#125;</div><div class=\"line\">    synchronized(this) &#123;</div><div class=\"line\">  Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\">  // If we&apos;re over the pool&apos;s max size, try to trim the pool appropriately</div><div class=\"line\">  trimToSoftCap();</div><div class=\"line\">  mPoolStatsTracker.onAlloc(sizeInBytes);</div><div class=\"line\">  logStats();</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;get (alloc) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">        System.identityHashCode(value),</div><div class=\"line\">        bucketedSize);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return value;</div></pre></td></tr></table></figure>\n<ul>\n<li>没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有</li>\n<li>如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。</li>\n</ul>\n<h4 id=\"5-2-BasePool-release\"><a href=\"#5-2-BasePool-release\" class=\"headerlink\" title=\"5.2 BasePool#release\"></a>5.2 BasePool#release</h4><p>这个方法是我们主动释放一个对象所占用的内存。</p>\n<p>实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco加载数据","date":"2016-12-12T15:51:23.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n![](/images/fresco/fresco_1.png)\n\n\n### 2.SimpleDraweeView#setImageURI\n\n在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\n* 根据attrs更新GenericDraweeHierarchyBuilder\n* 更新图像的宽高比\n* 设置Hierarchy\n\n在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。\n\n继续看DraweeView#setImageURI\n\n```\n  public void setImageURI(Uri uri, @Nullable Object callerContext) {\n    DraweeController controller = mSimpleDraweeControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\n    setController(controller);\n  }er.setImageURI(uri);\n  }\n```\n\n先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：\n\n```\n  public void setController(@Nullable DraweeController draweeController) {\n    boolean wasAttached = mIsControllerAttached;\n    if (wasAttached) {\n      detachController();\n    }\n\n    // Clear the old controller\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);\n      mController.setHierarchy(null);\n    }\n    mController = draweeController;\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);\n      mController.setHierarchy(mHierarchy);\n    } else {\n      mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);\n    }\n\n    if (wasAttached) {\n      attachController();\n    }\n  }\n\n```\n\n* 如果已经关联过controller，则取消与拿来的关联\n* 如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，\n* 如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件\n* 关联controller\n\n在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。\n\n### 3.AbstractDraweeController#onAttach\n\n```\n  public void onAttach() {\n    if (FLog.isLoggable(FLog.VERBOSE)) {\n      FLog.v(\n          TAG,\n          \"controller %x %s: onAttach: %s\",\n          System.identityHashCode(this),\n          mId,\n          mIsRequestSubmitted ? \"request already submitted\" : \"request needs submit\");\n    }\n    mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);\n    Preconditions.checkNotNull(mSettableDraweeHierarchy);\n    mDeferredReleaser.cancelDeferredRelease(this);\n    mIsAttached = true;\n    if (!mIsRequestSubmitted) {\n      submitRequest();\n    }\n  }\n```\n\n\n* 打印日志\n* 纪录事件\n* 发送请求\n\n### 4. submitRequest\n\n这个方法分为俩个部分。\n\n* 读取memory cache 同步\n* 读取除了memorycache 的其他部分\n\n\n#### 4.1 读取缓存部分\n\n```\n    final T closeableImage = getCachedImage();\n    if (closeableImage != null) {\n      mDataSource = null;\n      mIsRequestSubmitted = true;\n      mHasFetchFailed = false;\n      mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);\n      getControllerListener().onSubmit(mId, mCallerContext);\n      onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);\n      return;\n    }\n```\n\n* 通过getCachedImage 获取缓存数据\n* 纪录缓存命中事件\n* 回调，后面再将\n\n我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中\n\n```\n  @Override\n  protected CloseableReference<CloseableImage> getCachedImage() {\n    if (mMemoryCache == null || mCacheKey == null) {\n      return null;\n    }\n    // We get the CacheKey\n    CloseableReference<CloseableImage> closeableImage = mMemoryCache.get(mCacheKey);\n    if (closeableImage != null && !closeableImage.get().getQualityInfo().isOfFullQuality()) {\n      closeableImage.close();\n      return null;\n    }\n    return closeableImage;\n  }\n```\n\n可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。\n\n现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。\n\n从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。\n\n\n到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方\n\n* ImagePipelineFactory#getBitmapMemoryCache\n* BitmapMemoryCacheFactory\n* InstrumentedMemoryCache\n\n```\n  @Override\n  public CloseableReference<V> get(K key) {\n    CloseableReference<V> result = mDelegate.get(key);\n    if (result == null) {\n      mTracker.onCacheMiss();\n    } else {\n      mTracker.onCacheHit(key);\n    }\n    return result;\n  }\n```\n\n我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。\n\n#### 4.2 其他部分\n\n首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。\n\n而从其他部分获取的关键就在于fetchDecodedImage中的如下代码\n\n```\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext);\n```\n我们看看getDecodedImageProducerSequence的具体实现。\n\n```\n  public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(\n      ImageRequest imageRequest) {\n    Producer<CloseableReference<CloseableImage>> pipelineSequence =\n        getBasicDecodedImageSequence(imageRequest);\n    if (imageRequest.getPostprocessor() != null) {\n      return getPostprocessorSequence(pipelineSequence);\n    } else {\n      return pipelineSequence;\n    }\n  }\n```\n\n我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。\n\n> swallow result if prefetch -> bitmap cache get ->\n  background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->\n  encoded cache -> disk cache -> (webp transcode) -> network fetch.\n\n\n这里的具体细节我们不管，继续看submitFetchRequest，\n在submitFetchRequest函数中做了三件事：\n\n* 取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；\n* 将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。\n* 创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。\n\n至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。\n\n\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","source":"_posts/fresco加载数据.md","raw":"---\ntitle: fresco加载数据\ndate: 2016-12-12 23:51:23\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n![](/images/fresco/fresco_1.png)\n\n\n### 2.SimpleDraweeView#setImageURI\n\n在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\n* 根据attrs更新GenericDraweeHierarchyBuilder\n* 更新图像的宽高比\n* 设置Hierarchy\n\n在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。\n\n继续看DraweeView#setImageURI\n\n```\n  public void setImageURI(Uri uri, @Nullable Object callerContext) {\n    DraweeController controller = mSimpleDraweeControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\n    setController(controller);\n  }er.setImageURI(uri);\n  }\n```\n\n先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：\n\n```\n  public void setController(@Nullable DraweeController draweeController) {\n    boolean wasAttached = mIsControllerAttached;\n    if (wasAttached) {\n      detachController();\n    }\n\n    // Clear the old controller\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);\n      mController.setHierarchy(null);\n    }\n    mController = draweeController;\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);\n      mController.setHierarchy(mHierarchy);\n    } else {\n      mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);\n    }\n\n    if (wasAttached) {\n      attachController();\n    }\n  }\n\n```\n\n* 如果已经关联过controller，则取消与拿来的关联\n* 如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，\n* 如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件\n* 关联controller\n\n在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。\n\n### 3.AbstractDraweeController#onAttach\n\n```\n  public void onAttach() {\n    if (FLog.isLoggable(FLog.VERBOSE)) {\n      FLog.v(\n          TAG,\n          \"controller %x %s: onAttach: %s\",\n          System.identityHashCode(this),\n          mId,\n          mIsRequestSubmitted ? \"request already submitted\" : \"request needs submit\");\n    }\n    mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);\n    Preconditions.checkNotNull(mSettableDraweeHierarchy);\n    mDeferredReleaser.cancelDeferredRelease(this);\n    mIsAttached = true;\n    if (!mIsRequestSubmitted) {\n      submitRequest();\n    }\n  }\n```\n\n\n* 打印日志\n* 纪录事件\n* 发送请求\n\n### 4. submitRequest\n\n这个方法分为俩个部分。\n\n* 读取memory cache 同步\n* 读取除了memorycache 的其他部分\n\n\n#### 4.1 读取缓存部分\n\n```\n    final T closeableImage = getCachedImage();\n    if (closeableImage != null) {\n      mDataSource = null;\n      mIsRequestSubmitted = true;\n      mHasFetchFailed = false;\n      mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);\n      getControllerListener().onSubmit(mId, mCallerContext);\n      onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);\n      return;\n    }\n```\n\n* 通过getCachedImage 获取缓存数据\n* 纪录缓存命中事件\n* 回调，后面再将\n\n我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中\n\n```\n  @Override\n  protected CloseableReference<CloseableImage> getCachedImage() {\n    if (mMemoryCache == null || mCacheKey == null) {\n      return null;\n    }\n    // We get the CacheKey\n    CloseableReference<CloseableImage> closeableImage = mMemoryCache.get(mCacheKey);\n    if (closeableImage != null && !closeableImage.get().getQualityInfo().isOfFullQuality()) {\n      closeableImage.close();\n      return null;\n    }\n    return closeableImage;\n  }\n```\n\n可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。\n\n现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。\n\n从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。\n\n\n到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方\n\n* ImagePipelineFactory#getBitmapMemoryCache\n* BitmapMemoryCacheFactory\n* InstrumentedMemoryCache\n\n```\n  @Override\n  public CloseableReference<V> get(K key) {\n    CloseableReference<V> result = mDelegate.get(key);\n    if (result == null) {\n      mTracker.onCacheMiss();\n    } else {\n      mTracker.onCacheHit(key);\n    }\n    return result;\n  }\n```\n\n我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。\n\n#### 4.2 其他部分\n\n首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。\n\n而从其他部分获取的关键就在于fetchDecodedImage中的如下代码\n\n```\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext);\n```\n我们看看getDecodedImageProducerSequence的具体实现。\n\n```\n  public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(\n      ImageRequest imageRequest) {\n    Producer<CloseableReference<CloseableImage>> pipelineSequence =\n        getBasicDecodedImageSequence(imageRequest);\n    if (imageRequest.getPostprocessor() != null) {\n      return getPostprocessorSequence(pipelineSequence);\n    } else {\n      return pipelineSequence;\n    }\n  }\n```\n\n我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。\n\n> swallow result if prefetch -> bitmap cache get ->\n  background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->\n  encoded cache -> disk cache -> (webp transcode) -> network fetch.\n\n\n这里的具体细节我们不管，继续看submitFetchRequest，\n在submitFetchRequest函数中做了三件事：\n\n* 取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；\n* 将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。\n* 创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。\n\n至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。\n\n\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","slug":"fresco加载数据","published":1,"updated":"2017-01-06T05:30:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yi0014uaxacnqab987","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<p><img src=\"/images/fresco/fresco_1.png\" alt=\"\"></p>\n<h3 id=\"2-SimpleDraweeView-setImageURI\"><a href=\"#2-SimpleDraweeView-setImageURI\" class=\"headerlink\" title=\"2.SimpleDraweeView#setImageURI\"></a>2.SimpleDraweeView#setImageURI</h3><p>在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据attrs更新GenericDraweeHierarchyBuilder</li>\n<li>更新图像的宽高比</li>\n<li>设置Hierarchy</li>\n</ul>\n<p>在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。</p>\n<p>继续看DraweeView#setImageURI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setImageURI(Uri uri, @Nullable Object callerContext) &#123;</div><div class=\"line\">  DraweeController controller = mSimpleDraweeControllerBuilder</div><div class=\"line\">      .setCallerContext(callerContext)</div><div class=\"line\">      .setUri(uri)</div><div class=\"line\">      .setOldController(getController())</div><div class=\"line\">      .build();</div><div class=\"line\">  setController(controller);</div><div class=\"line\">&#125;er.setImageURI(uri);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setController(@Nullable DraweeController draweeController) &#123;</div><div class=\"line\">  boolean wasAttached = mIsControllerAttached;</div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    detachController();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Clear the old controller</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(null);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mController = draweeController;</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(mHierarchy);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    attachController();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果已经关联过controller，则取消与拿来的关联</li>\n<li>如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，</li>\n<li>如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件</li>\n<li>关联controller</li>\n</ul>\n<p>在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。</p>\n<h3 id=\"3-AbstractDraweeController-onAttach\"><a href=\"#3-AbstractDraweeController-onAttach\" class=\"headerlink\" title=\"3.AbstractDraweeController#onAttach\"></a>3.AbstractDraweeController#onAttach</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void onAttach() &#123;</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;controller %x %s: onAttach: %s&quot;,</div><div class=\"line\">        System.identityHashCode(this),</div><div class=\"line\">        mId,</div><div class=\"line\">        mIsRequestSubmitted ? &quot;request already submitted&quot; : &quot;request needs submit&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</div><div class=\"line\">  Preconditions.checkNotNull(mSettableDraweeHierarchy);</div><div class=\"line\">  mDeferredReleaser.cancelDeferredRelease(this);</div><div class=\"line\">  mIsAttached = true;</div><div class=\"line\">  if (!mIsRequestSubmitted) &#123;</div><div class=\"line\">    submitRequest();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>打印日志</li>\n<li>纪录事件</li>\n<li>发送请求</li>\n</ul>\n<h3 id=\"4-submitRequest\"><a href=\"#4-submitRequest\" class=\"headerlink\" title=\"4. submitRequest\"></a>4. submitRequest</h3><p>这个方法分为俩个部分。</p>\n<ul>\n<li>读取memory cache 同步</li>\n<li>读取除了memorycache 的其他部分</li>\n</ul>\n<h4 id=\"4-1-读取缓存部分\"><a href=\"#4-1-读取缓存部分\" class=\"headerlink\" title=\"4.1 读取缓存部分\"></a>4.1 读取缓存部分</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">final T closeableImage = getCachedImage();</div><div class=\"line\">if (closeableImage != null) &#123;</div><div class=\"line\">  mDataSource = null;</div><div class=\"line\">  mIsRequestSubmitted = true;</div><div class=\"line\">  mHasFetchFailed = false;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);</div><div class=\"line\">  getControllerListener().onSubmit(mId, mCallerContext);</div><div class=\"line\">  onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);</div><div class=\"line\">  return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过getCachedImage 获取缓存数据</li>\n<li>纪录缓存命中事件</li>\n<li>回调，后面再将</li>\n</ul>\n<p>我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected CloseableReference&lt;CloseableImage&gt; getCachedImage() &#123;</div><div class=\"line\">  if (mMemoryCache == null || mCacheKey == null) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  // We get the CacheKey</div><div class=\"line\">  CloseableReference&lt;CloseableImage&gt; closeableImage = mMemoryCache.get(mCacheKey);</div><div class=\"line\">  if (closeableImage != null &amp;&amp; !closeableImage.get().getQualityInfo().isOfFullQuality()) &#123;</div><div class=\"line\">    closeableImage.close();</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return closeableImage;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。</p>\n<p>现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。</p>\n<p>从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。</p>\n<p>到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方</p>\n<ul>\n<li>ImagePipelineFactory#getBitmapMemoryCache</li>\n<li>BitmapMemoryCacheFactory</li>\n<li>InstrumentedMemoryCache</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;V&gt; get(K key) &#123;</div><div class=\"line\">  CloseableReference&lt;V&gt; result = mDelegate.get(key);</div><div class=\"line\">  if (result == null) &#123;</div><div class=\"line\">    mTracker.onCacheMiss();</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mTracker.onCacheHit(key);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。</p>\n<h4 id=\"4-2-其他部分\"><a href=\"#4-2-其他部分\" class=\"headerlink\" title=\"4.2 其他部分\"></a>4.2 其他部分</h4><p>首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。</p>\n<p>而从其他部分获取的关键就在于fetchDecodedImage中的如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</div><div class=\"line\">    mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</div><div class=\"line\">return submitFetchRequest(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    imageRequest,</div><div class=\"line\">    lowestPermittedRequestLevelOnSubmit,</div><div class=\"line\">    callerContext);</div></pre></td></tr></table></figure>\n<p>我们看看getDecodedImageProducerSequence的具体实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDecodedImageProducerSequence(</div><div class=\"line\">    ImageRequest imageRequest) &#123;</div><div class=\"line\">  Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; pipelineSequence =</div><div class=\"line\">      getBasicDecodedImageSequence(imageRequest);</div><div class=\"line\">  if (imageRequest.getPostprocessor() != null) &#123;</div><div class=\"line\">    return getPostprocessorSequence(pipelineSequence);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    return pipelineSequence;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。</p>\n<blockquote>\n<p>swallow result if prefetch -&gt; bitmap cache get -&gt;<br>  background thread hand-off -&gt; multiplex -&gt; bitmap cache -&gt; decode -&gt; multiplex -&gt;<br>  encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.</p>\n</blockquote>\n<p>这里的具体细节我们不管，继续看submitFetchRequest，<br>在submitFetchRequest函数中做了三件事：</p>\n<ul>\n<li>取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；</li>\n<li>将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。</li>\n<li>创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。</li>\n</ul>\n<p>至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n</excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<p><img src=\"/images/fresco/fresco_1.png\" alt=\"\"></p>\n<h3 id=\"2-SimpleDraweeView-setImageURI\"><a href=\"#2-SimpleDraweeView-setImageURI\" class=\"headerlink\" title=\"2.SimpleDraweeView#setImageURI\"></a>2.SimpleDraweeView#setImageURI</h3><p>在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据attrs更新GenericDraweeHierarchyBuilder</li>\n<li>更新图像的宽高比</li>\n<li>设置Hierarchy</li>\n</ul>\n<p>在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。</p>\n<p>继续看DraweeView#setImageURI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setImageURI(Uri uri, @Nullable Object callerContext) &#123;</div><div class=\"line\">  DraweeController controller = mSimpleDraweeControllerBuilder</div><div class=\"line\">      .setCallerContext(callerContext)</div><div class=\"line\">      .setUri(uri)</div><div class=\"line\">      .setOldController(getController())</div><div class=\"line\">      .build();</div><div class=\"line\">  setController(controller);</div><div class=\"line\">&#125;er.setImageURI(uri);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setController(@Nullable DraweeController draweeController) &#123;</div><div class=\"line\">  boolean wasAttached = mIsControllerAttached;</div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    detachController();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Clear the old controller</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(null);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mController = draweeController;</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(mHierarchy);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    attachController();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果已经关联过controller，则取消与拿来的关联</li>\n<li>如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，</li>\n<li>如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件</li>\n<li>关联controller</li>\n</ul>\n<p>在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。</p>\n<h3 id=\"3-AbstractDraweeController-onAttach\"><a href=\"#3-AbstractDraweeController-onAttach\" class=\"headerlink\" title=\"3.AbstractDraweeController#onAttach\"></a>3.AbstractDraweeController#onAttach</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void onAttach() &#123;</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;controller %x %s: onAttach: %s&quot;,</div><div class=\"line\">        System.identityHashCode(this),</div><div class=\"line\">        mId,</div><div class=\"line\">        mIsRequestSubmitted ? &quot;request already submitted&quot; : &quot;request needs submit&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</div><div class=\"line\">  Preconditions.checkNotNull(mSettableDraweeHierarchy);</div><div class=\"line\">  mDeferredReleaser.cancelDeferredRelease(this);</div><div class=\"line\">  mIsAttached = true;</div><div class=\"line\">  if (!mIsRequestSubmitted) &#123;</div><div class=\"line\">    submitRequest();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>打印日志</li>\n<li>纪录事件</li>\n<li>发送请求</li>\n</ul>\n<h3 id=\"4-submitRequest\"><a href=\"#4-submitRequest\" class=\"headerlink\" title=\"4. submitRequest\"></a>4. submitRequest</h3><p>这个方法分为俩个部分。</p>\n<ul>\n<li>读取memory cache 同步</li>\n<li>读取除了memorycache 的其他部分</li>\n</ul>\n<h4 id=\"4-1-读取缓存部分\"><a href=\"#4-1-读取缓存部分\" class=\"headerlink\" title=\"4.1 读取缓存部分\"></a>4.1 读取缓存部分</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">final T closeableImage = getCachedImage();</div><div class=\"line\">if (closeableImage != null) &#123;</div><div class=\"line\">  mDataSource = null;</div><div class=\"line\">  mIsRequestSubmitted = true;</div><div class=\"line\">  mHasFetchFailed = false;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);</div><div class=\"line\">  getControllerListener().onSubmit(mId, mCallerContext);</div><div class=\"line\">  onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);</div><div class=\"line\">  return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过getCachedImage 获取缓存数据</li>\n<li>纪录缓存命中事件</li>\n<li>回调，后面再将</li>\n</ul>\n<p>我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected CloseableReference&lt;CloseableImage&gt; getCachedImage() &#123;</div><div class=\"line\">  if (mMemoryCache == null || mCacheKey == null) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  // We get the CacheKey</div><div class=\"line\">  CloseableReference&lt;CloseableImage&gt; closeableImage = mMemoryCache.get(mCacheKey);</div><div class=\"line\">  if (closeableImage != null &amp;&amp; !closeableImage.get().getQualityInfo().isOfFullQuality()) &#123;</div><div class=\"line\">    closeableImage.close();</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return closeableImage;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。</p>\n<p>现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。</p>\n<p>从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。</p>\n<p>到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方</p>\n<ul>\n<li>ImagePipelineFactory#getBitmapMemoryCache</li>\n<li>BitmapMemoryCacheFactory</li>\n<li>InstrumentedMemoryCache</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;V&gt; get(K key) &#123;</div><div class=\"line\">  CloseableReference&lt;V&gt; result = mDelegate.get(key);</div><div class=\"line\">  if (result == null) &#123;</div><div class=\"line\">    mTracker.onCacheMiss();</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mTracker.onCacheHit(key);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。</p>\n<h4 id=\"4-2-其他部分\"><a href=\"#4-2-其他部分\" class=\"headerlink\" title=\"4.2 其他部分\"></a>4.2 其他部分</h4><p>首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。</p>\n<p>而从其他部分获取的关键就在于fetchDecodedImage中的如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</div><div class=\"line\">    mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</div><div class=\"line\">return submitFetchRequest(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    imageRequest,</div><div class=\"line\">    lowestPermittedRequestLevelOnSubmit,</div><div class=\"line\">    callerContext);</div></pre></td></tr></table></figure>\n<p>我们看看getDecodedImageProducerSequence的具体实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDecodedImageProducerSequence(</div><div class=\"line\">    ImageRequest imageRequest) &#123;</div><div class=\"line\">  Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; pipelineSequence =</div><div class=\"line\">      getBasicDecodedImageSequence(imageRequest);</div><div class=\"line\">  if (imageRequest.getPostprocessor() != null) &#123;</div><div class=\"line\">    return getPostprocessorSequence(pipelineSequence);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    return pipelineSequence;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。</p>\n<blockquote>\n<p>swallow result if prefetch -&gt; bitmap cache get -&gt;<br>  background thread hand-off -&gt; multiplex -&gt; bitmap cache -&gt; decode -&gt; multiplex -&gt;<br>  encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.</p>\n</blockquote>\n<p>这里的具体细节我们不管，继续看submitFetchRequest，<br>在submitFetchRequest函数中做了三件事：</p>\n<ul>\n<li>取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；</li>\n<li>将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。</li>\n<li>创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。</li>\n</ul>\n<p>至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco初始化过程","date":"2016-12-12T06:27:31.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1.初始化相关\n\n* ImagePipelineFactory\n* PipelineDraweeControllerBuilderSupplier\n* SimpleDraweeView\n\n在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n* AnimatedImageFactory 负责解析 动态图，gif和webp\n* Bitmap.Config 图片质量\n* Supplier<MemoryCacheParams> 内存cache的配置参数\n* CacheKeyFactory 生成cachekey的工厂\n* Context\n* mDownsampleEnabled 是否允许下载相同的图片\n* mDecodeMemoryFileEnabled \n* FileCacheFactory 文件缓存的工厂\n* mEncodedMemoryCacheParamsSupplier \n* mExecutorSupplier 线程池集\n* ImageCacheStatsTracker 图片缓存状态跟踪器\n* ImageDecoder 图片解析\n* mIsPrefetchEnabledSupplier\n* mMainDiskCacheConfig disk磁盘缓存配置\n* mMemoryTrimmableRegistry 内存检测注入\n* NetworkFetcher 网络访问，用于封装网络\n* PlatformBitmapFactory 配置bitmap 平台信息\n* PoolFactory poolfactory\n* ProgressiveJpegConfig \n* mRequestListeners 请求监听器\n* mResizeAndRotateEnabledForNetwork 是否允许调整和旋转\n* mSmallImageDiskCacheConfig small disk config\n* ImagePipelineExperiments.Builder\n\n\n其中，大部分我们并不需要配置。\n\n#### 1.1 MemoryCacheParams\n\n内部含有五个成员\n\n* maxCacheSize cache 最大容量\n* maxCacheEntries cache中 最多呢个存多少个item（块）\n* maxEvictionQueueSize 准备回收 但是还没回收的 容量\n* maxEvictionQueueEntries 每个块的最大回收数\n* maxCacheEntrySize 每个块的最大的数\n\n从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，\n\n#### 1.2 CacheKeyFactory\n\n生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。\n\n\n默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。\n\n\n#### 1.3 FileCacheFactory中的DiskCacheConfig\n\n配置版本，cache路径，大小，error log等\n\n#### 1.4 ImageCacheStatsTracker\n\ncache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，\n\n#### 1.5 ImageDecoder\n\n图片解码的入口类。\n\n#### 1.6 NetworkFetcher\n\n网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的\n\n#### 1.7 PlatformBitmapFactory\n\n用于createbitmap，并且添加引用信息有三个实现类。\n\n* GingerbreadBitmapFactory\n* HoneycombBitmapFactory 对应kikat\n* ArtBitmapFactory 对应arm\n\n\n具体的实现这里暂时忽略。\n\n\n\n#### 1.8 PoolFactory\n根据PoolConfig，配置PoolFactory。\n\n```\n   private final PoolParams mBitmapPoolParams;\n  private final PoolStatsTracker mBitmapPoolStatsTracker;\n  private final PoolParams mFlexByteArrayPoolParams;\n  private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;\n  private final PoolParams mNativeMemoryChunkPoolParams;\n  private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;\n  private final PoolParams mSmallByteArrayPoolParams;\n  private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;\n  \n```\n\npoolparams负责配置各种参数，内含三种参数类型。\n\n* PoolParams\n\t* maxSizeSoftCap 最大软 size\n\t* maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存\n\t* bucketSizes 每个桶及其对应的容量\n\t* minBucketSize 桶最小size\n\t* maxBucketSize 桶最大size\n* PoolStatsTracker 状态监测，包括释放 申请内存等\n* MemoryTrimmableRegistry\n\n\n#### 1.9 ProgressiveJpegConfig\n\n渐近式jpeg，\n\n#### 1.10 DiskCacheConfig\n\n磁盘配置。略\n\n### 2. PipelineDraweeControllerBuilderSupplier\n\n\n构造出PipelineDraweeControllerBuilder。\n\n```\n  public PipelineDraweeControllerBuilderSupplier(\n      Context context,\n      ImagePipelineFactory imagePipelineFactory,\n      Set<ControllerListener> boundControllerListeners) {\n    mContext = context;\n    mImagePipeline = imagePipelineFactory.getImagePipeline();\n\n    final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();\n    AnimatedDrawableFactory animatedDrawableFactory = null;\n    if (animatedFactory != null) {\n      animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);\n    }\n\n    mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(\n        context.getResources(),\n        DeferredReleaser.getInstance(),\n        animatedDrawableFactory,\n        UiThreadImmediateExecutorService.getInstance(),\n        mImagePipeline.getBitmapMemoryCache());\n    mBoundControllerListeners = boundControllerListeners;\n  }\n```\n\n* imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。\n* mPipelineDraweeControllerFactory\n* mBoundControllerListeners 默认为null\n\n#### 2.1 ImagePipelineFactory\n\n内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。\n\n#### 2.2 PipelineDraweeControllerFactory\n\n负责构造PipelineDraweeController。有几个默认的参数。\n\n* Resources\n* DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。\n* AnimatedDrawableFactory\n* Executor\n* MemoryCache<CacheKey, CloseableImage>\n\n\n### 3 SimpleDraweeView#initialize\n\n只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/fresco初始化过程.md","raw":"---\ntitle: fresco初始化过程\ndate: 2016-12-12 14:27:31\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1.初始化相关\n\n* ImagePipelineFactory\n* PipelineDraweeControllerBuilderSupplier\n* SimpleDraweeView\n\n在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n* AnimatedImageFactory 负责解析 动态图，gif和webp\n* Bitmap.Config 图片质量\n* Supplier<MemoryCacheParams> 内存cache的配置参数\n* CacheKeyFactory 生成cachekey的工厂\n* Context\n* mDownsampleEnabled 是否允许下载相同的图片\n* mDecodeMemoryFileEnabled \n* FileCacheFactory 文件缓存的工厂\n* mEncodedMemoryCacheParamsSupplier \n* mExecutorSupplier 线程池集\n* ImageCacheStatsTracker 图片缓存状态跟踪器\n* ImageDecoder 图片解析\n* mIsPrefetchEnabledSupplier\n* mMainDiskCacheConfig disk磁盘缓存配置\n* mMemoryTrimmableRegistry 内存检测注入\n* NetworkFetcher 网络访问，用于封装网络\n* PlatformBitmapFactory 配置bitmap 平台信息\n* PoolFactory poolfactory\n* ProgressiveJpegConfig \n* mRequestListeners 请求监听器\n* mResizeAndRotateEnabledForNetwork 是否允许调整和旋转\n* mSmallImageDiskCacheConfig small disk config\n* ImagePipelineExperiments.Builder\n\n\n其中，大部分我们并不需要配置。\n\n#### 1.1 MemoryCacheParams\n\n内部含有五个成员\n\n* maxCacheSize cache 最大容量\n* maxCacheEntries cache中 最多呢个存多少个item（块）\n* maxEvictionQueueSize 准备回收 但是还没回收的 容量\n* maxEvictionQueueEntries 每个块的最大回收数\n* maxCacheEntrySize 每个块的最大的数\n\n从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，\n\n#### 1.2 CacheKeyFactory\n\n生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。\n\n\n默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。\n\n\n#### 1.3 FileCacheFactory中的DiskCacheConfig\n\n配置版本，cache路径，大小，error log等\n\n#### 1.4 ImageCacheStatsTracker\n\ncache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，\n\n#### 1.5 ImageDecoder\n\n图片解码的入口类。\n\n#### 1.6 NetworkFetcher\n\n网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的\n\n#### 1.7 PlatformBitmapFactory\n\n用于createbitmap，并且添加引用信息有三个实现类。\n\n* GingerbreadBitmapFactory\n* HoneycombBitmapFactory 对应kikat\n* ArtBitmapFactory 对应arm\n\n\n具体的实现这里暂时忽略。\n\n\n\n#### 1.8 PoolFactory\n根据PoolConfig，配置PoolFactory。\n\n```\n   private final PoolParams mBitmapPoolParams;\n  private final PoolStatsTracker mBitmapPoolStatsTracker;\n  private final PoolParams mFlexByteArrayPoolParams;\n  private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;\n  private final PoolParams mNativeMemoryChunkPoolParams;\n  private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;\n  private final PoolParams mSmallByteArrayPoolParams;\n  private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;\n  \n```\n\npoolparams负责配置各种参数，内含三种参数类型。\n\n* PoolParams\n\t* maxSizeSoftCap 最大软 size\n\t* maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存\n\t* bucketSizes 每个桶及其对应的容量\n\t* minBucketSize 桶最小size\n\t* maxBucketSize 桶最大size\n* PoolStatsTracker 状态监测，包括释放 申请内存等\n* MemoryTrimmableRegistry\n\n\n#### 1.9 ProgressiveJpegConfig\n\n渐近式jpeg，\n\n#### 1.10 DiskCacheConfig\n\n磁盘配置。略\n\n### 2. PipelineDraweeControllerBuilderSupplier\n\n\n构造出PipelineDraweeControllerBuilder。\n\n```\n  public PipelineDraweeControllerBuilderSupplier(\n      Context context,\n      ImagePipelineFactory imagePipelineFactory,\n      Set<ControllerListener> boundControllerListeners) {\n    mContext = context;\n    mImagePipeline = imagePipelineFactory.getImagePipeline();\n\n    final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();\n    AnimatedDrawableFactory animatedDrawableFactory = null;\n    if (animatedFactory != null) {\n      animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);\n    }\n\n    mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(\n        context.getResources(),\n        DeferredReleaser.getInstance(),\n        animatedDrawableFactory,\n        UiThreadImmediateExecutorService.getInstance(),\n        mImagePipeline.getBitmapMemoryCache());\n    mBoundControllerListeners = boundControllerListeners;\n  }\n```\n\n* imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。\n* mPipelineDraweeControllerFactory\n* mBoundControllerListeners 默认为null\n\n#### 2.1 ImagePipelineFactory\n\n内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。\n\n#### 2.2 PipelineDraweeControllerFactory\n\n负责构造PipelineDraweeController。有几个默认的参数。\n\n* Resources\n* DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。\n* AnimatedDrawableFactory\n* Executor\n* MemoryCache<CacheKey, CloseableImage>\n\n\n### 3 SimpleDraweeView#initialize\n\n只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"fresco初始化过程","published":1,"updated":"2017-01-06T05:30:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yk0018uaxa43k31022","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-初始化相关\"><a href=\"#1-初始化相关\" class=\"headerlink\" title=\"1.初始化相关\"></a>1.初始化相关</h3><ul>\n<li>ImagePipelineFactory</li>\n<li>PipelineDraweeControllerBuilderSupplier</li>\n<li>SimpleDraweeView</li>\n</ul>\n<p>在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n</the></li>\n</ul>\n<ul>\n<li>AnimatedImageFactory 负责解析 动态图，gif和webp</li>\n<li>Bitmap.Config 图片质量</li>\n<li>Supplier<memorycacheparams> 内存cache的配置参数</memorycacheparams></li>\n<li>CacheKeyFactory 生成cachekey的工厂</li>\n<li>Context</li>\n<li>mDownsampleEnabled 是否允许下载相同的图片</li>\n<li>mDecodeMemoryFileEnabled </li>\n<li>FileCacheFactory 文件缓存的工厂</li>\n<li>mEncodedMemoryCacheParamsSupplier </li>\n<li>mExecutorSupplier 线程池集</li>\n<li>ImageCacheStatsTracker 图片缓存状态跟踪器</li>\n<li>ImageDecoder 图片解析</li>\n<li>mIsPrefetchEnabledSupplier</li>\n<li>mMainDiskCacheConfig disk磁盘缓存配置</li>\n<li>mMemoryTrimmableRegistry 内存检测注入</li>\n<li>NetworkFetcher 网络访问，用于封装网络</li>\n<li>PlatformBitmapFactory 配置bitmap 平台信息</li>\n<li>PoolFactory poolfactory</li>\n<li>ProgressiveJpegConfig </li>\n<li>mRequestListeners 请求监听器</li>\n<li>mResizeAndRotateEnabledForNetwork 是否允许调整和旋转</li>\n<li>mSmallImageDiskCacheConfig small disk config</li>\n<li>ImagePipelineExperiments.Builder</li>\n</ul>\n<p>其中，大部分我们并不需要配置。</p>\n<h4 id=\"1-1-MemoryCacheParams\"><a href=\"#1-1-MemoryCacheParams\" class=\"headerlink\" title=\"1.1 MemoryCacheParams\"></a>1.1 MemoryCacheParams</h4><p>内部含有五个成员</p>\n<ul>\n<li>maxCacheSize cache 最大容量</li>\n<li>maxCacheEntries cache中 最多呢个存多少个item（块）</li>\n<li>maxEvictionQueueSize 准备回收 但是还没回收的 容量</li>\n<li>maxEvictionQueueEntries 每个块的最大回收数</li>\n<li>maxCacheEntrySize 每个块的最大的数</li>\n</ul>\n<p>从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，</p>\n<h4 id=\"1-2-CacheKeyFactory\"><a href=\"#1-2-CacheKeyFactory\" class=\"headerlink\" title=\"1.2 CacheKeyFactory\"></a>1.2 CacheKeyFactory</h4><p>生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。</p>\n<p>默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。</p>\n<h4 id=\"1-3-FileCacheFactory中的DiskCacheConfig\"><a href=\"#1-3-FileCacheFactory中的DiskCacheConfig\" class=\"headerlink\" title=\"1.3 FileCacheFactory中的DiskCacheConfig\"></a>1.3 FileCacheFactory中的DiskCacheConfig</h4><p>配置版本，cache路径，大小，error log等</p>\n<h4 id=\"1-4-ImageCacheStatsTracker\"><a href=\"#1-4-ImageCacheStatsTracker\" class=\"headerlink\" title=\"1.4 ImageCacheStatsTracker\"></a>1.4 ImageCacheStatsTracker</h4><p>cache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，</p>\n<h4 id=\"1-5-ImageDecoder\"><a href=\"#1-5-ImageDecoder\" class=\"headerlink\" title=\"1.5 ImageDecoder\"></a>1.5 ImageDecoder</h4><p>图片解码的入口类。</p>\n<h4 id=\"1-6-NetworkFetcher\"><a href=\"#1-6-NetworkFetcher\" class=\"headerlink\" title=\"1.6 NetworkFetcher\"></a>1.6 NetworkFetcher</h4><p>网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的</p>\n<h4 id=\"1-7-PlatformBitmapFactory\"><a href=\"#1-7-PlatformBitmapFactory\" class=\"headerlink\" title=\"1.7 PlatformBitmapFactory\"></a>1.7 PlatformBitmapFactory</h4><p>用于createbitmap，并且添加引用信息有三个实现类。</p>\n<ul>\n<li>GingerbreadBitmapFactory</li>\n<li>HoneycombBitmapFactory 对应kikat</li>\n<li>ArtBitmapFactory 对应arm</li>\n</ul>\n<p>具体的实现这里暂时忽略。</p>\n<h4 id=\"1-8-PoolFactory\"><a href=\"#1-8-PoolFactory\" class=\"headerlink\" title=\"1.8 PoolFactory\"></a>1.8 PoolFactory</h4><p>根据PoolConfig，配置PoolFactory。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private final PoolParams mBitmapPoolParams;</div><div class=\"line\">private final PoolStatsTracker mBitmapPoolStatsTracker;</div><div class=\"line\">private final PoolParams mFlexByteArrayPoolParams;</div><div class=\"line\">private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;</div><div class=\"line\">private final PoolParams mNativeMemoryChunkPoolParams;</div><div class=\"line\">private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;</div><div class=\"line\">private final PoolParams mSmallByteArrayPoolParams;</div><div class=\"line\">private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;</div></pre></td></tr></table></figure>\n<p>poolparams负责配置各种参数，内含三种参数类型。</p>\n<ul>\n<li>PoolParams<ul>\n<li>maxSizeSoftCap 最大软 size</li>\n<li>maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存</li>\n<li>bucketSizes 每个桶及其对应的容量</li>\n<li>minBucketSize 桶最小size</li>\n<li>maxBucketSize 桶最大size</li>\n</ul>\n</li>\n<li>PoolStatsTracker 状态监测，包括释放 申请内存等</li>\n<li>MemoryTrimmableRegistry</li>\n</ul>\n<h4 id=\"1-9-ProgressiveJpegConfig\"><a href=\"#1-9-ProgressiveJpegConfig\" class=\"headerlink\" title=\"1.9 ProgressiveJpegConfig\"></a>1.9 ProgressiveJpegConfig</h4><p>渐近式jpeg，</p>\n<h4 id=\"1-10-DiskCacheConfig\"><a href=\"#1-10-DiskCacheConfig\" class=\"headerlink\" title=\"1.10 DiskCacheConfig\"></a>1.10 DiskCacheConfig</h4><p>磁盘配置。略</p>\n<h3 id=\"2-PipelineDraweeControllerBuilderSupplier\"><a href=\"#2-PipelineDraweeControllerBuilderSupplier\" class=\"headerlink\" title=\"2. PipelineDraweeControllerBuilderSupplier\"></a>2. PipelineDraweeControllerBuilderSupplier</h3><p>构造出PipelineDraweeControllerBuilder。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public PipelineDraweeControllerBuilderSupplier(</div><div class=\"line\">    Context context,</div><div class=\"line\">    ImagePipelineFactory imagePipelineFactory,</div><div class=\"line\">    Set&lt;ControllerListener&gt; boundControllerListeners) &#123;</div><div class=\"line\">  mContext = context;</div><div class=\"line\">  mImagePipeline = imagePipelineFactory.getImagePipeline();</div><div class=\"line\"></div><div class=\"line\">  final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();</div><div class=\"line\">  AnimatedDrawableFactory animatedDrawableFactory = null;</div><div class=\"line\">  if (animatedFactory != null) &#123;</div><div class=\"line\">    animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(</div><div class=\"line\">      context.getResources(),</div><div class=\"line\">      DeferredReleaser.getInstance(),</div><div class=\"line\">      animatedDrawableFactory,</div><div class=\"line\">      UiThreadImmediateExecutorService.getInstance(),</div><div class=\"line\">      mImagePipeline.getBitmapMemoryCache());</div><div class=\"line\">  mBoundControllerListeners = boundControllerListeners;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。</li>\n<li>mPipelineDraweeControllerFactory</li>\n<li>mBoundControllerListeners 默认为null</li>\n</ul>\n<h4 id=\"2-1-ImagePipelineFactory\"><a href=\"#2-1-ImagePipelineFactory\" class=\"headerlink\" title=\"2.1 ImagePipelineFactory\"></a>2.1 ImagePipelineFactory</h4><p>内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。</p>\n<h4 id=\"2-2-PipelineDraweeControllerFactory\"><a href=\"#2-2-PipelineDraweeControllerFactory\" class=\"headerlink\" title=\"2.2 PipelineDraweeControllerFactory\"></a>2.2 PipelineDraweeControllerFactory</h4><p>负责构造PipelineDraweeController。有几个默认的参数。</p>\n<ul>\n<li>Resources</li>\n<li>DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。</li>\n<li>AnimatedDrawableFactory</li>\n<li>Executor</li>\n<li>MemoryCache<cachekey, closeableimage=\"\"></cachekey,></li>\n</ul>\n<h3 id=\"3-SimpleDraweeView-initialize\"><a href=\"#3-SimpleDraweeView-initialize\" class=\"headerlink\" title=\"3 SimpleDraweeView#initialize\"></a>3 SimpleDraweeView#initialize</h3><p>只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n</excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-初始化相关\"><a href=\"#1-初始化相关\" class=\"headerlink\" title=\"1.初始化相关\"></a>1.初始化相关</h3><ul>\n<li>ImagePipelineFactory</li>\n<li>PipelineDraweeControllerBuilderSupplier</li>\n<li>SimpleDraweeView</li>\n</ul>\n<p>在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n\n</li>\n</ul>\n<ul>\n<li>AnimatedImageFactory 负责解析 动态图，gif和webp</li>\n<li>Bitmap.Config 图片质量</li>\n<li>Supplier<MemoryCacheParams> 内存cache的配置参数</li>\n<li>CacheKeyFactory 生成cachekey的工厂</li>\n<li>Context</li>\n<li>mDownsampleEnabled 是否允许下载相同的图片</li>\n<li>mDecodeMemoryFileEnabled </li>\n<li>FileCacheFactory 文件缓存的工厂</li>\n<li>mEncodedMemoryCacheParamsSupplier </li>\n<li>mExecutorSupplier 线程池集</li>\n<li>ImageCacheStatsTracker 图片缓存状态跟踪器</li>\n<li>ImageDecoder 图片解析</li>\n<li>mIsPrefetchEnabledSupplier</li>\n<li>mMainDiskCacheConfig disk磁盘缓存配置</li>\n<li>mMemoryTrimmableRegistry 内存检测注入</li>\n<li>NetworkFetcher 网络访问，用于封装网络</li>\n<li>PlatformBitmapFactory 配置bitmap 平台信息</li>\n<li>PoolFactory poolfactory</li>\n<li>ProgressiveJpegConfig </li>\n<li>mRequestListeners 请求监听器</li>\n<li>mResizeAndRotateEnabledForNetwork 是否允许调整和旋转</li>\n<li>mSmallImageDiskCacheConfig small disk config</li>\n<li>ImagePipelineExperiments.Builder</li>\n</ul>\n<p>其中，大部分我们并不需要配置。</p>\n<h4 id=\"1-1-MemoryCacheParams\"><a href=\"#1-1-MemoryCacheParams\" class=\"headerlink\" title=\"1.1 MemoryCacheParams\"></a>1.1 MemoryCacheParams</h4><p>内部含有五个成员</p>\n<ul>\n<li>maxCacheSize cache 最大容量</li>\n<li>maxCacheEntries cache中 最多呢个存多少个item（块）</li>\n<li>maxEvictionQueueSize 准备回收 但是还没回收的 容量</li>\n<li>maxEvictionQueueEntries 每个块的最大回收数</li>\n<li>maxCacheEntrySize 每个块的最大的数</li>\n</ul>\n<p>从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，</p>\n<h4 id=\"1-2-CacheKeyFactory\"><a href=\"#1-2-CacheKeyFactory\" class=\"headerlink\" title=\"1.2 CacheKeyFactory\"></a>1.2 CacheKeyFactory</h4><p>生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。</p>\n<p>默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。</p>\n<h4 id=\"1-3-FileCacheFactory中的DiskCacheConfig\"><a href=\"#1-3-FileCacheFactory中的DiskCacheConfig\" class=\"headerlink\" title=\"1.3 FileCacheFactory中的DiskCacheConfig\"></a>1.3 FileCacheFactory中的DiskCacheConfig</h4><p>配置版本，cache路径，大小，error log等</p>\n<h4 id=\"1-4-ImageCacheStatsTracker\"><a href=\"#1-4-ImageCacheStatsTracker\" class=\"headerlink\" title=\"1.4 ImageCacheStatsTracker\"></a>1.4 ImageCacheStatsTracker</h4><p>cache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，</p>\n<h4 id=\"1-5-ImageDecoder\"><a href=\"#1-5-ImageDecoder\" class=\"headerlink\" title=\"1.5 ImageDecoder\"></a>1.5 ImageDecoder</h4><p>图片解码的入口类。</p>\n<h4 id=\"1-6-NetworkFetcher\"><a href=\"#1-6-NetworkFetcher\" class=\"headerlink\" title=\"1.6 NetworkFetcher\"></a>1.6 NetworkFetcher</h4><p>网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的</p>\n<h4 id=\"1-7-PlatformBitmapFactory\"><a href=\"#1-7-PlatformBitmapFactory\" class=\"headerlink\" title=\"1.7 PlatformBitmapFactory\"></a>1.7 PlatformBitmapFactory</h4><p>用于createbitmap，并且添加引用信息有三个实现类。</p>\n<ul>\n<li>GingerbreadBitmapFactory</li>\n<li>HoneycombBitmapFactory 对应kikat</li>\n<li>ArtBitmapFactory 对应arm</li>\n</ul>\n<p>具体的实现这里暂时忽略。</p>\n<h4 id=\"1-8-PoolFactory\"><a href=\"#1-8-PoolFactory\" class=\"headerlink\" title=\"1.8 PoolFactory\"></a>1.8 PoolFactory</h4><p>根据PoolConfig，配置PoolFactory。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private final PoolParams mBitmapPoolParams;</div><div class=\"line\">private final PoolStatsTracker mBitmapPoolStatsTracker;</div><div class=\"line\">private final PoolParams mFlexByteArrayPoolParams;</div><div class=\"line\">private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;</div><div class=\"line\">private final PoolParams mNativeMemoryChunkPoolParams;</div><div class=\"line\">private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;</div><div class=\"line\">private final PoolParams mSmallByteArrayPoolParams;</div><div class=\"line\">private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;</div></pre></td></tr></table></figure>\n<p>poolparams负责配置各种参数，内含三种参数类型。</p>\n<ul>\n<li>PoolParams<ul>\n<li>maxSizeSoftCap 最大软 size</li>\n<li>maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存</li>\n<li>bucketSizes 每个桶及其对应的容量</li>\n<li>minBucketSize 桶最小size</li>\n<li>maxBucketSize 桶最大size</li>\n</ul>\n</li>\n<li>PoolStatsTracker 状态监测，包括释放 申请内存等</li>\n<li>MemoryTrimmableRegistry</li>\n</ul>\n<h4 id=\"1-9-ProgressiveJpegConfig\"><a href=\"#1-9-ProgressiveJpegConfig\" class=\"headerlink\" title=\"1.9 ProgressiveJpegConfig\"></a>1.9 ProgressiveJpegConfig</h4><p>渐近式jpeg，</p>\n<h4 id=\"1-10-DiskCacheConfig\"><a href=\"#1-10-DiskCacheConfig\" class=\"headerlink\" title=\"1.10 DiskCacheConfig\"></a>1.10 DiskCacheConfig</h4><p>磁盘配置。略</p>\n<h3 id=\"2-PipelineDraweeControllerBuilderSupplier\"><a href=\"#2-PipelineDraweeControllerBuilderSupplier\" class=\"headerlink\" title=\"2. PipelineDraweeControllerBuilderSupplier\"></a>2. PipelineDraweeControllerBuilderSupplier</h3><p>构造出PipelineDraweeControllerBuilder。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public PipelineDraweeControllerBuilderSupplier(</div><div class=\"line\">    Context context,</div><div class=\"line\">    ImagePipelineFactory imagePipelineFactory,</div><div class=\"line\">    Set&lt;ControllerListener&gt; boundControllerListeners) &#123;</div><div class=\"line\">  mContext = context;</div><div class=\"line\">  mImagePipeline = imagePipelineFactory.getImagePipeline();</div><div class=\"line\"></div><div class=\"line\">  final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();</div><div class=\"line\">  AnimatedDrawableFactory animatedDrawableFactory = null;</div><div class=\"line\">  if (animatedFactory != null) &#123;</div><div class=\"line\">    animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(</div><div class=\"line\">      context.getResources(),</div><div class=\"line\">      DeferredReleaser.getInstance(),</div><div class=\"line\">      animatedDrawableFactory,</div><div class=\"line\">      UiThreadImmediateExecutorService.getInstance(),</div><div class=\"line\">      mImagePipeline.getBitmapMemoryCache());</div><div class=\"line\">  mBoundControllerListeners = boundControllerListeners;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。</li>\n<li>mPipelineDraweeControllerFactory</li>\n<li>mBoundControllerListeners 默认为null</li>\n</ul>\n<h4 id=\"2-1-ImagePipelineFactory\"><a href=\"#2-1-ImagePipelineFactory\" class=\"headerlink\" title=\"2.1 ImagePipelineFactory\"></a>2.1 ImagePipelineFactory</h4><p>内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。</p>\n<h4 id=\"2-2-PipelineDraweeControllerFactory\"><a href=\"#2-2-PipelineDraweeControllerFactory\" class=\"headerlink\" title=\"2.2 PipelineDraweeControllerFactory\"></a>2.2 PipelineDraweeControllerFactory</h4><p>负责构造PipelineDraweeController。有几个默认的参数。</p>\n<ul>\n<li>Resources</li>\n<li>DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。</li>\n<li>AnimatedDrawableFactory</li>\n<li>Executor</li>\n<li>MemoryCache<CacheKey, CloseableImage></li>\n</ul>\n<h3 id=\"3-SimpleDraweeView-initialize\"><a href=\"#3-SimpleDraweeView-initialize\" class=\"headerlink\" title=\"3 SimpleDraweeView#initialize\"></a>3 SimpleDraweeView#initialize</h3><p>只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco图片decode的大体流程","date":"2016-12-13T08:10:51.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 从DecodeProducer说fresco的解码过程\n\nDecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n  @Override\n  public void produceResults(\n      final Consumer<CloseableReference<CloseableImage>> consumer,\n      final ProducerContext producerContext) {\n    final ImageRequest imageRequest = producerContext.getImageRequest();\n    ProgressiveDecoder progressiveDecoder;\n    if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {\n      progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);\n    } else {\n      ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);\n      progressiveDecoder = new NetworkImagesProgressiveDecoder(\n          consumer,\n          producerContext,\n          jpegParser,\n          mProgressiveJpegConfig);\n    }\n    mInputProducer.produceResults(progressiveDecoder, producerContext);\n  }\n```\n\n* 通过判断uri的类型 选择不同的渐近式解释器\n* local和network都继承自ProgressiveDecoder\n\n在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。\n\n### 2. ImageDecoder\n\n这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。\n\n```\n  public CloseableImage decodeImage(\n      final EncodedImage encodedImage,\n      final int length,\n      final QualityInfo qualityInfo,\n      final ImageDecodeOptions options) {\n    ImageFormat imageFormat = encodedImage.getImageFormat();\n    if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) {\n      imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(\n          encodedImage.getInputStream());\n      encodedImage.setImageFormat(imageFormat);\n    }\n    if (imageFormat == DefaultImageFormats.JPEG) {\n      return decodeJpeg(encodedImage, length, qualityInfo);\n    } else if (imageFormat == DefaultImageFormats.GIF) {\n      return decodeGif(encodedImage, options);\n    } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {\n      return decodeAnimatedWebp(encodedImage, options);\n    } else if (imageFormat == ImageFormat.UNKNOWN) {\n      throw new IllegalArgumentException(\"unknown image format\");\n    }\n    return decodeStaticImage(encodedImage);\n  }\n```\n\n* 先判断未解码的图片类型\n* 根据不同的图片类型选择不同的解码方式\n\n#### 2.1 ImageFormatChecker\n\n这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为\n\n```\n  private static final byte[] PNG_HEADER = new byte[] {\n      (byte) 0x89,\n      'P', 'N', 'G',\n      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};\n```\n\n如果不熟ascll表的话，可以去查阅'P''N''G'在ascll表中对应的16进制。\n\n\n#### 2.2 解析种类\n\n根据代码能看出，这里分为几种。\n\n* JPEG\n* GIF\n* WEBP_ANIMATED\n* 其他\n\n从是否静态图上来看，为两种，\n\n* 可动 ，用AnimatedImageFactory进行解析\n* 不可动，用PlatformDecoder进行解析\n\n\n### 3. AnimatedImageFactory\n\n\nAnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。\n\n在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。\n\n```\n  private static AnimatedImageDecoder loadIfPresent(final String className) {\n    try {\n      Class<?> clazz = Class.forName(className);\n      return (AnimatedImageDecoder) clazz.newInstance();\n    } catch (Throwable e) {\n      return null;\n    }\n  }\n\n  static {\n    sGifAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.gif.GifImage\");\n    sWebpAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.webp.WebPImage\");\n  }\n```\n\n解析分为两个步骤。\n\n* 通过AnimatedImageDecoder解析出AnimatedImage\n* 利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。\n\n关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。\n\ngetCloseableImage的逻辑如下：\n\n* 用decodeAllFrames解析出所有帧\n* 用createPreviewBitmap构造预览的bitmap\n* 构造AnimatedImageResult对象\n* 用AnimatedImageResult构造CloseableAnimatedImage对象。\n\n这里就不再多说了，等到后面学习webp和gif的时候再说。\n\n### 4.PlatformDecoder\n\nPlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。\n\n![](/images/fresco/fresco_3.png)\n\n从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。\n\n* 在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的\n* 5.0以下，则是存在Ashmem匿名共享内存中。\n\n\n5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，\n\n```\n  @Override\n  public CloseableReference<Bitmap> decodeFromEncodedImage(\n      final EncodedImage encodedImage,\n      Bitmap.Config bitmapConfig) {\n    BitmapFactory.Options options = getBitmapFactoryOptions(\n        encodedImage.getSampleSize(),\n        bitmapConfig);\n    CloseableReference<PooledByteBuffer> bytesRef = encodedImage.getByteBufferRef();\n    Preconditions.checkNotNull(bytesRef);\n    try {\n      Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);\n      return pinBitmap(bitmap);\n    } finally {\n      CloseableReference.closeSafely(bytesRef);\n    }\n  }\n```\n\n* getBitmapFactoryOptions 获取BitmapFactory.Options\n* decodeByteArrayAsPurgeable 获取bitmap\n* pinBitmap 真正的decode\n\n我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。\n\n而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","source":"_posts/fresco图片decode的大体流程.md","raw":"---\ntitle: fresco图片decode的大体流程\ndate: 2016-12-13 16:10:51\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 从DecodeProducer说fresco的解码过程\n\nDecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n  @Override\n  public void produceResults(\n      final Consumer<CloseableReference<CloseableImage>> consumer,\n      final ProducerContext producerContext) {\n    final ImageRequest imageRequest = producerContext.getImageRequest();\n    ProgressiveDecoder progressiveDecoder;\n    if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {\n      progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);\n    } else {\n      ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);\n      progressiveDecoder = new NetworkImagesProgressiveDecoder(\n          consumer,\n          producerContext,\n          jpegParser,\n          mProgressiveJpegConfig);\n    }\n    mInputProducer.produceResults(progressiveDecoder, producerContext);\n  }\n```\n\n* 通过判断uri的类型 选择不同的渐近式解释器\n* local和network都继承自ProgressiveDecoder\n\n在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。\n\n### 2. ImageDecoder\n\n这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。\n\n```\n  public CloseableImage decodeImage(\n      final EncodedImage encodedImage,\n      final int length,\n      final QualityInfo qualityInfo,\n      final ImageDecodeOptions options) {\n    ImageFormat imageFormat = encodedImage.getImageFormat();\n    if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) {\n      imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(\n          encodedImage.getInputStream());\n      encodedImage.setImageFormat(imageFormat);\n    }\n    if (imageFormat == DefaultImageFormats.JPEG) {\n      return decodeJpeg(encodedImage, length, qualityInfo);\n    } else if (imageFormat == DefaultImageFormats.GIF) {\n      return decodeGif(encodedImage, options);\n    } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {\n      return decodeAnimatedWebp(encodedImage, options);\n    } else if (imageFormat == ImageFormat.UNKNOWN) {\n      throw new IllegalArgumentException(\"unknown image format\");\n    }\n    return decodeStaticImage(encodedImage);\n  }\n```\n\n* 先判断未解码的图片类型\n* 根据不同的图片类型选择不同的解码方式\n\n#### 2.1 ImageFormatChecker\n\n这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为\n\n```\n  private static final byte[] PNG_HEADER = new byte[] {\n      (byte) 0x89,\n      'P', 'N', 'G',\n      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};\n```\n\n如果不熟ascll表的话，可以去查阅'P''N''G'在ascll表中对应的16进制。\n\n\n#### 2.2 解析种类\n\n根据代码能看出，这里分为几种。\n\n* JPEG\n* GIF\n* WEBP_ANIMATED\n* 其他\n\n从是否静态图上来看，为两种，\n\n* 可动 ，用AnimatedImageFactory进行解析\n* 不可动，用PlatformDecoder进行解析\n\n\n### 3. AnimatedImageFactory\n\n\nAnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。\n\n在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。\n\n```\n  private static AnimatedImageDecoder loadIfPresent(final String className) {\n    try {\n      Class<?> clazz = Class.forName(className);\n      return (AnimatedImageDecoder) clazz.newInstance();\n    } catch (Throwable e) {\n      return null;\n    }\n  }\n\n  static {\n    sGifAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.gif.GifImage\");\n    sWebpAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.webp.WebPImage\");\n  }\n```\n\n解析分为两个步骤。\n\n* 通过AnimatedImageDecoder解析出AnimatedImage\n* 利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。\n\n关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。\n\ngetCloseableImage的逻辑如下：\n\n* 用decodeAllFrames解析出所有帧\n* 用createPreviewBitmap构造预览的bitmap\n* 构造AnimatedImageResult对象\n* 用AnimatedImageResult构造CloseableAnimatedImage对象。\n\n这里就不再多说了，等到后面学习webp和gif的时候再说。\n\n### 4.PlatformDecoder\n\nPlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。\n\n![](/images/fresco/fresco_3.png)\n\n从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。\n\n* 在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的\n* 5.0以下，则是存在Ashmem匿名共享内存中。\n\n\n5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，\n\n```\n  @Override\n  public CloseableReference<Bitmap> decodeFromEncodedImage(\n      final EncodedImage encodedImage,\n      Bitmap.Config bitmapConfig) {\n    BitmapFactory.Options options = getBitmapFactoryOptions(\n        encodedImage.getSampleSize(),\n        bitmapConfig);\n    CloseableReference<PooledByteBuffer> bytesRef = encodedImage.getByteBufferRef();\n    Preconditions.checkNotNull(bytesRef);\n    try {\n      Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);\n      return pinBitmap(bitmap);\n    } finally {\n      CloseableReference.closeSafely(bytesRef);\n    }\n  }\n```\n\n* getBitmapFactoryOptions 获取BitmapFactory.Options\n* decodeByteArrayAsPurgeable 获取bitmap\n* pinBitmap 真正的decode\n\n我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。\n\n而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","slug":"fresco图片decode的大体流程","published":1,"updated":"2017-01-06T05:31:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85ym001buaxaae8gzfsg","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-从DecodeProducer说fresco的解码过程\"><a href=\"#1-从DecodeProducer说fresco的解码过程\" class=\"headerlink\" title=\"1. 从DecodeProducer说fresco的解码过程\"></a>1. 从DecodeProducer说fresco的解码过程</h3><p>DecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n</the></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void produceResults(</div><div class=\"line\">    final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,</div><div class=\"line\">    final ProducerContext producerContext) &#123;</div><div class=\"line\">  final ImageRequest imageRequest = producerContext.getImageRequest();</div><div class=\"line\">  ProgressiveDecoder progressiveDecoder;</div><div class=\"line\">  if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) &#123;</div><div class=\"line\">    progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);</div><div class=\"line\">    progressiveDecoder = new NetworkImagesProgressiveDecoder(</div><div class=\"line\">        consumer,</div><div class=\"line\">        producerContext,</div><div class=\"line\">        jpegParser,</div><div class=\"line\">        mProgressiveJpegConfig);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mInputProducer.produceResults(progressiveDecoder, producerContext);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过判断uri的类型 选择不同的渐近式解释器</li>\n<li>local和network都继承自ProgressiveDecoder</li>\n</ul>\n<p>在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。</p>\n<h3 id=\"2-ImageDecoder\"><a href=\"#2-ImageDecoder\" class=\"headerlink\" title=\"2. ImageDecoder\"></a>2. ImageDecoder</h3><p>这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public CloseableImage decodeImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    final int length,</div><div class=\"line\">    final QualityInfo qualityInfo,</div><div class=\"line\">    final ImageDecodeOptions options) &#123;</div><div class=\"line\">  ImageFormat imageFormat = encodedImage.getImageFormat();</div><div class=\"line\">  if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(</div><div class=\"line\">        encodedImage.getInputStream());</div><div class=\"line\">    encodedImage.setImageFormat(imageFormat);</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (imageFormat == DefaultImageFormats.JPEG) &#123;</div><div class=\"line\">    return decodeJpeg(encodedImage, length, qualityInfo);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.GIF) &#123;</div><div class=\"line\">    return decodeGif(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) &#123;</div><div class=\"line\">    return decodeAnimatedWebp(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    throw new IllegalArgumentException(&quot;unknown image format&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return decodeStaticImage(encodedImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先判断未解码的图片类型</li>\n<li>根据不同的图片类型选择不同的解码方式</li>\n</ul>\n<h4 id=\"2-1-ImageFormatChecker\"><a href=\"#2-1-ImageFormatChecker\" class=\"headerlink\" title=\"2.1 ImageFormatChecker\"></a>2.1 ImageFormatChecker</h4><p>这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final byte[] PNG_HEADER = new byte[] &#123;</div><div class=\"line\">    (byte) 0x89,</div><div class=\"line\">    &apos;P&apos;, &apos;N&apos;, &apos;G&apos;,</div><div class=\"line\">    (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A&#125;;</div></pre></td></tr></table></figure>\n<p>如果不熟ascll表的话，可以去查阅’P’’N’’G’在ascll表中对应的16进制。</p>\n<h4 id=\"2-2-解析种类\"><a href=\"#2-2-解析种类\" class=\"headerlink\" title=\"2.2 解析种类\"></a>2.2 解析种类</h4><p>根据代码能看出，这里分为几种。</p>\n<ul>\n<li>JPEG</li>\n<li>GIF</li>\n<li>WEBP_ANIMATED</li>\n<li>其他</li>\n</ul>\n<p>从是否静态图上来看，为两种，</p>\n<ul>\n<li>可动 ，用AnimatedImageFactory进行解析</li>\n<li>不可动，用PlatformDecoder进行解析</li>\n</ul>\n<h3 id=\"3-AnimatedImageFactory\"><a href=\"#3-AnimatedImageFactory\" class=\"headerlink\" title=\"3. AnimatedImageFactory\"></a>3. AnimatedImageFactory</h3><p>AnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。</p>\n<p>在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static AnimatedImageDecoder loadIfPresent(final String className) &#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Class&lt;?&gt; clazz = Class.forName(className);</div><div class=\"line\">    return (AnimatedImageDecoder) clazz.newInstance();</div><div class=\"line\">  &#125; catch (Throwable e) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">  sGifAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.gif.GifImage&quot;);</div><div class=\"line\">  sWebpAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.webp.WebPImage&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析分为两个步骤。</p>\n<ul>\n<li>通过AnimatedImageDecoder解析出AnimatedImage</li>\n<li>利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。</li>\n</ul>\n<p>关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。</p>\n<p>getCloseableImage的逻辑如下：</p>\n<ul>\n<li>用decodeAllFrames解析出所有帧</li>\n<li>用createPreviewBitmap构造预览的bitmap</li>\n<li>构造AnimatedImageResult对象</li>\n<li>用AnimatedImageResult构造CloseableAnimatedImage对象。</li>\n</ul>\n<p>这里就不再多说了，等到后面学习webp和gif的时候再说。</p>\n<h3 id=\"4-PlatformDecoder\"><a href=\"#4-PlatformDecoder\" class=\"headerlink\" title=\"4.PlatformDecoder\"></a>4.PlatformDecoder</h3><p>PlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。</p>\n<p><img src=\"/images/fresco/fresco_3.png\" alt=\"\"></p>\n<p>从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。</p>\n<ul>\n<li>在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的</li>\n<li>5.0以下，则是存在Ashmem匿名共享内存中。</li>\n</ul>\n<p>5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    Bitmap.Config bitmapConfig) &#123;</div><div class=\"line\">  BitmapFactory.Options options = getBitmapFactoryOptions(</div><div class=\"line\">      encodedImage.getSampleSize(),</div><div class=\"line\">      bitmapConfig);</div><div class=\"line\">  CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef();</div><div class=\"line\">  Preconditions.checkNotNull(bytesRef);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);</div><div class=\"line\">    return pinBitmap(bitmap);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    CloseableReference.closeSafely(bytesRef);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getBitmapFactoryOptions 获取BitmapFactory.Options</li>\n<li>decodeByteArrayAsPurgeable 获取bitmap</li>\n<li>pinBitmap 真正的decode</li>\n</ul>\n<p>我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。</p>\n<p>而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-从DecodeProducer说fresco的解码过程\"><a href=\"#1-从DecodeProducer说fresco的解码过程\" class=\"headerlink\" title=\"1. 从DecodeProducer说fresco的解码过程\"></a>1. 从DecodeProducer说fresco的解码过程</h3><p>DecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void produceResults(</div><div class=\"line\">    final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,</div><div class=\"line\">    final ProducerContext producerContext) &#123;</div><div class=\"line\">  final ImageRequest imageRequest = producerContext.getImageRequest();</div><div class=\"line\">  ProgressiveDecoder progressiveDecoder;</div><div class=\"line\">  if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) &#123;</div><div class=\"line\">    progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);</div><div class=\"line\">    progressiveDecoder = new NetworkImagesProgressiveDecoder(</div><div class=\"line\">        consumer,</div><div class=\"line\">        producerContext,</div><div class=\"line\">        jpegParser,</div><div class=\"line\">        mProgressiveJpegConfig);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mInputProducer.produceResults(progressiveDecoder, producerContext);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过判断uri的类型 选择不同的渐近式解释器</li>\n<li>local和network都继承自ProgressiveDecoder</li>\n</ul>\n<p>在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。</p>\n<h3 id=\"2-ImageDecoder\"><a href=\"#2-ImageDecoder\" class=\"headerlink\" title=\"2. ImageDecoder\"></a>2. ImageDecoder</h3><p>这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public CloseableImage decodeImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    final int length,</div><div class=\"line\">    final QualityInfo qualityInfo,</div><div class=\"line\">    final ImageDecodeOptions options) &#123;</div><div class=\"line\">  ImageFormat imageFormat = encodedImage.getImageFormat();</div><div class=\"line\">  if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(</div><div class=\"line\">        encodedImage.getInputStream());</div><div class=\"line\">    encodedImage.setImageFormat(imageFormat);</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (imageFormat == DefaultImageFormats.JPEG) &#123;</div><div class=\"line\">    return decodeJpeg(encodedImage, length, qualityInfo);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.GIF) &#123;</div><div class=\"line\">    return decodeGif(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) &#123;</div><div class=\"line\">    return decodeAnimatedWebp(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    throw new IllegalArgumentException(&quot;unknown image format&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return decodeStaticImage(encodedImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先判断未解码的图片类型</li>\n<li>根据不同的图片类型选择不同的解码方式</li>\n</ul>\n<h4 id=\"2-1-ImageFormatChecker\"><a href=\"#2-1-ImageFormatChecker\" class=\"headerlink\" title=\"2.1 ImageFormatChecker\"></a>2.1 ImageFormatChecker</h4><p>这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final byte[] PNG_HEADER = new byte[] &#123;</div><div class=\"line\">    (byte) 0x89,</div><div class=\"line\">    &apos;P&apos;, &apos;N&apos;, &apos;G&apos;,</div><div class=\"line\">    (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A&#125;;</div></pre></td></tr></table></figure>\n<p>如果不熟ascll表的话，可以去查阅’P’’N’’G’在ascll表中对应的16进制。</p>\n<h4 id=\"2-2-解析种类\"><a href=\"#2-2-解析种类\" class=\"headerlink\" title=\"2.2 解析种类\"></a>2.2 解析种类</h4><p>根据代码能看出，这里分为几种。</p>\n<ul>\n<li>JPEG</li>\n<li>GIF</li>\n<li>WEBP_ANIMATED</li>\n<li>其他</li>\n</ul>\n<p>从是否静态图上来看，为两种，</p>\n<ul>\n<li>可动 ，用AnimatedImageFactory进行解析</li>\n<li>不可动，用PlatformDecoder进行解析</li>\n</ul>\n<h3 id=\"3-AnimatedImageFactory\"><a href=\"#3-AnimatedImageFactory\" class=\"headerlink\" title=\"3. AnimatedImageFactory\"></a>3. AnimatedImageFactory</h3><p>AnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。</p>\n<p>在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static AnimatedImageDecoder loadIfPresent(final String className) &#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Class&lt;?&gt; clazz = Class.forName(className);</div><div class=\"line\">    return (AnimatedImageDecoder) clazz.newInstance();</div><div class=\"line\">  &#125; catch (Throwable e) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">  sGifAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.gif.GifImage&quot;);</div><div class=\"line\">  sWebpAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.webp.WebPImage&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析分为两个步骤。</p>\n<ul>\n<li>通过AnimatedImageDecoder解析出AnimatedImage</li>\n<li>利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。</li>\n</ul>\n<p>关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。</p>\n<p>getCloseableImage的逻辑如下：</p>\n<ul>\n<li>用decodeAllFrames解析出所有帧</li>\n<li>用createPreviewBitmap构造预览的bitmap</li>\n<li>构造AnimatedImageResult对象</li>\n<li>用AnimatedImageResult构造CloseableAnimatedImage对象。</li>\n</ul>\n<p>这里就不再多说了，等到后面学习webp和gif的时候再说。</p>\n<h3 id=\"4-PlatformDecoder\"><a href=\"#4-PlatformDecoder\" class=\"headerlink\" title=\"4.PlatformDecoder\"></a>4.PlatformDecoder</h3><p>PlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。</p>\n<p><img src=\"/images/fresco/fresco_3.png\" alt=\"\"></p>\n<p>从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。</p>\n<ul>\n<li>在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的</li>\n<li>5.0以下，则是存在Ashmem匿名共享内存中。</li>\n</ul>\n<p>5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    Bitmap.Config bitmapConfig) &#123;</div><div class=\"line\">  BitmapFactory.Options options = getBitmapFactoryOptions(</div><div class=\"line\">      encodedImage.getSampleSize(),</div><div class=\"line\">      bitmapConfig);</div><div class=\"line\">  CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef();</div><div class=\"line\">  Preconditions.checkNotNull(bytesRef);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);</div><div class=\"line\">    return pinBitmap(bitmap);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    CloseableReference.closeSafely(bytesRef);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getBitmapFactoryOptions 获取BitmapFactory.Options</li>\n<li>decodeByteArrayAsPurgeable 获取bitmap</li>\n<li>pinBitmap 真正的decode</li>\n</ul>\n<p>我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。</p>\n<p>而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco生产者Producer","date":"2016-12-13T03:26:58.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 从ImagePipeline#submitFetchRequest说起\n\n上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：\n\n* 从未解码的memory cache中获取\n* 从disk cache中获取\n* 从net中获取\n\n```\n      return CloseableProducerToDataSourceAdapter.create(\n          producerSequence,\n          settableProducerContext,\n          requestListener);\n```\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。\n\n\n### 2. Producer 生产者\n\n先看下相关的结构。\n\n![](/images/fresco/fresco_2.png)\n\n可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。\n\n\n### 3. 从已解码的内存中获取－BitmapMemoryCacheProducer\n\n\n这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。\n\n### 4. 从未解码的内存中获取－EncodedMemoryCacheProducer\n\n\n在这里要说明下\n\n* EncodedImage 未解码的载体\n* PooledByteBuffer 存储的字节码\n* CloseableBitmap 已解码的载体\n\n\n先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。\n\n### 5. 从本地文件获取－DiskCacheProducer\n\n文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。\n\n### 6. 从网络中获取－NetworkFetchProducer\n\n略，思路一致。\n\n\n_ _ _\n\n* [参考资料](https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/fresco生产者Producer.md","raw":"---\ntitle: fresco生产者Producer\ndate: 2016-12-13 11:26:58\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 从ImagePipeline#submitFetchRequest说起\n\n上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：\n\n* 从未解码的memory cache中获取\n* 从disk cache中获取\n* 从net中获取\n\n```\n      return CloseableProducerToDataSourceAdapter.create(\n          producerSequence,\n          settableProducerContext,\n          requestListener);\n```\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。\n\n\n### 2. Producer 生产者\n\n先看下相关的结构。\n\n![](/images/fresco/fresco_2.png)\n\n可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。\n\n\n### 3. 从已解码的内存中获取－BitmapMemoryCacheProducer\n\n\n这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。\n\n### 4. 从未解码的内存中获取－EncodedMemoryCacheProducer\n\n\n在这里要说明下\n\n* EncodedImage 未解码的载体\n* PooledByteBuffer 存储的字节码\n* CloseableBitmap 已解码的载体\n\n\n先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。\n\n### 5. 从本地文件获取－DiskCacheProducer\n\n文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。\n\n### 6. 从网络中获取－NetworkFetchProducer\n\n略，思路一致。\n\n\n_ _ _\n\n* [参考资料](https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"fresco生产者Producer","published":1,"updated":"2017-01-06T05:31:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yn001euaxanjln9k6o","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-从ImagePipeline-submitFetchRequest说起\"><a href=\"#1-从ImagePipeline-submitFetchRequest说起\" class=\"headerlink\" title=\"1. 从ImagePipeline#submitFetchRequest说起\"></a>1. 从ImagePipeline#submitFetchRequest说起</h3><p>上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：</p>\n<ul>\n<li>从未解码的memory cache中获取</li>\n<li>从disk cache中获取</li>\n<li>从net中获取</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">return CloseableProducerToDataSourceAdapter.create(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    settableProducerContext,</div><div class=\"line\">    requestListener);</div></pre></td></tr></table></figure>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n</the></li>\n</ul>\n<p>在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。</p>\n<h3 id=\"2-Producer-生产者\"><a href=\"#2-Producer-生产者\" class=\"headerlink\" title=\"2. Producer 生产者\"></a>2. Producer 生产者</h3><p>先看下相关的结构。</p>\n<p><img src=\"/images/fresco/fresco_2.png\" alt=\"\"></p>\n<p>可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。</p>\n<h3 id=\"3-从已解码的内存中获取－BitmapMemoryCacheProducer\"><a href=\"#3-从已解码的内存中获取－BitmapMemoryCacheProducer\" class=\"headerlink\" title=\"3. 从已解码的内存中获取－BitmapMemoryCacheProducer\"></a>3. 从已解码的内存中获取－BitmapMemoryCacheProducer</h3><p>这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。</p>\n<h3 id=\"4-从未解码的内存中获取－EncodedMemoryCacheProducer\"><a href=\"#4-从未解码的内存中获取－EncodedMemoryCacheProducer\" class=\"headerlink\" title=\"4. 从未解码的内存中获取－EncodedMemoryCacheProducer\"></a>4. 从未解码的内存中获取－EncodedMemoryCacheProducer</h3><p>在这里要说明下</p>\n<ul>\n<li>EncodedImage 未解码的载体</li>\n<li>PooledByteBuffer 存储的字节码</li>\n<li>CloseableBitmap 已解码的载体</li>\n</ul>\n<p>先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。</p>\n<h3 id=\"5-从本地文件获取－DiskCacheProducer\"><a href=\"#5-从本地文件获取－DiskCacheProducer\" class=\"headerlink\" title=\"5. 从本地文件获取－DiskCacheProducer\"></a>5. 从本地文件获取－DiskCacheProducer</h3><p>文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。</p>\n<h3 id=\"6-从网络中获取－NetworkFetchProducer\"><a href=\"#6-从网络中获取－NetworkFetchProducer\" class=\"headerlink\" title=\"6. 从网络中获取－NetworkFetchProducer\"></a>6. 从网络中获取－NetworkFetchProducer</h3><p>略，思路一致。</p>\n<hr>\n<ul>\n<li><a href=\"https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5\" target=\"_blank\" rel=\"external\">参考资料</a>%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-从ImagePipeline-submitFetchRequest说起\"><a href=\"#1-从ImagePipeline-submitFetchRequest说起\" class=\"headerlink\" title=\"1. 从ImagePipeline#submitFetchRequest说起\"></a>1. 从ImagePipeline#submitFetchRequest说起</h3><p>上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：</p>\n<ul>\n<li>从未解码的memory cache中获取</li>\n<li>从disk cache中获取</li>\n<li>从net中获取</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">return CloseableProducerToDataSourceAdapter.create(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    settableProducerContext,</div><div class=\"line\">    requestListener);</div></pre></td></tr></table></figure>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n</li>\n</ul>\n<p>在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。</p>\n<h3 id=\"2-Producer-生产者\"><a href=\"#2-Producer-生产者\" class=\"headerlink\" title=\"2. Producer 生产者\"></a>2. Producer 生产者</h3><p>先看下相关的结构。</p>\n<p><img src=\"/images/fresco/fresco_2.png\" alt=\"\"></p>\n<p>可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。</p>\n<h3 id=\"3-从已解码的内存中获取－BitmapMemoryCacheProducer\"><a href=\"#3-从已解码的内存中获取－BitmapMemoryCacheProducer\" class=\"headerlink\" title=\"3. 从已解码的内存中获取－BitmapMemoryCacheProducer\"></a>3. 从已解码的内存中获取－BitmapMemoryCacheProducer</h3><p>这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。</p>\n<h3 id=\"4-从未解码的内存中获取－EncodedMemoryCacheProducer\"><a href=\"#4-从未解码的内存中获取－EncodedMemoryCacheProducer\" class=\"headerlink\" title=\"4. 从未解码的内存中获取－EncodedMemoryCacheProducer\"></a>4. 从未解码的内存中获取－EncodedMemoryCacheProducer</h3><p>在这里要说明下</p>\n<ul>\n<li>EncodedImage 未解码的载体</li>\n<li>PooledByteBuffer 存储的字节码</li>\n<li>CloseableBitmap 已解码的载体</li>\n</ul>\n<p>先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。</p>\n<h3 id=\"5-从本地文件获取－DiskCacheProducer\"><a href=\"#5-从本地文件获取－DiskCacheProducer\" class=\"headerlink\" title=\"5. 从本地文件获取－DiskCacheProducer\"></a>5. 从本地文件获取－DiskCacheProducer</h3><p>文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。</p>\n<h3 id=\"6-从网络中获取－NetworkFetchProducer\"><a href=\"#6-从网络中获取－NetworkFetchProducer\" class=\"headerlink\" title=\"6. 从网络中获取－NetworkFetchProducer\"></a>6. 从网络中获取－NetworkFetchProducer</h3><p>略，思路一致。</p>\n<hr>\n<ul>\n<li><a href=\"https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5\">参考资料</a>%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco用法","date":"2016-12-12T06:27:12.000Z","_content":"<Excerpt in index | 首页摘要>\n### 0.前言\n\n在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 1.fresco中的关键概念\n\n* Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式\n\t* DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可\n\t* DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。\n\t* DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。\n如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。\n\t* DraweeControllerBuilder \nDraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改\n\t* Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。\n* The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。\n在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。\nSimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 \n\n### 3.支持的URI类型\n\n* http|https\n* file://\n* content://\n* asset://\n* res://\n* data:mime/type;base64 uri中指定图片数据\n\n### 4.支持的xml属性\n\n[支持的xml属性](https://www.fresco-cn.org/docs/using-drawees-xml.html)\n\n### 5.在java中使用Drawees\n\n#### 5.1 自定义DraweeHierarchy\n\n```\n        GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());\n        GenericDraweeHierarchy hierarchy = builder\n                .setFadeDuration(300)\n                //and so on\n                .build();\n        image.setHierarchy(hierarchy);\n```\n\n从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\nxml中对应的属性，由hierarchy控制。\n\n#### 5.2 运行时修改 DraweeHierarchy\n\n要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。\n\n```\n        GenericDraweeHierarchy hierarchy = image.getHierarchy();\n        hierarchy.setFadeDuration(400);\n```\n\n其他属性同理。\n\n#### 5.3 配置效果\n\n我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。\n\n在ControllerBuilder 中如下设置:\n\n```\n.setTapToRetryEnabled(true)\n```\n\n* XML 中属性值: retryImage\n* Hierarchy builder中的方法: setRetryImage\n\n#### 5.4 进度条\n\n构建GenericDraweeHierarchy的时候\n\n\n```\n.setProgressBarImage(new ProgressBarDrawable())\n```\n，我们也可以自定义，实现Drawable.onLevelChange。\n\n\n### 6 DraweeController增加对图片的控制\n\n```\nControllerListener listener = new BaseControllerListener() {...}\n\nDraweeController controller = Fresco.newDraweeControllerBuilder()\n    .setUri(uri)\n    .setTapToRetryEnabled(true)\n    .setOldController(mSimpleDraweeView.getController())\n    .setControllerListener(listener)\n    .build();\n\nmSimpleDraweeView.setController(controller);\n```\n\n* 使用渐进式jpeg图。\n\n    ```\n    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(\"xxx\"))\n                //打开渐进 渲染\n                .setProgressiveRenderingEnabled(true)\n                .build();\n\t```\n\t\n* 动画自动播放\n\t\n\t```\n\tdraweeController.setAutoPlayAnimations(true)\n\t```\n* 动画手动播放，\n\n\t```\n\t        ControllerListener listener = new BaseControllerListener<ImageInfo>(){\n            @Override\n            public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) {\n                super.onFinalImageSet(id, imageInfo, animatable);\n                if (animatable != null){\n                    animatable.start();\n                }\n            }\n        };\n        \n        draweeController.setControllerListener(listener)\n\t```\n* 后处理器Postprocessor 对图片进行后期处理\n\n```\nPostprocessor redMeshPostprocessor = new BasePostprocessor() {\n  @Override\n  public String getName() {\n    return \"redMeshPostprocessor\";\n  }\n\n  @Override\n  public void process(Bitmap bitmap) {\n    for (int x = 0; x < bitmap.getWidth(); x+=2) {\n      for (int y = 0; y < bitmap.getHeight(); y+=2) {\n        bitmap.setPixel(x, y, Color.RED);\n      }\n    }\n  }\n}\n\nImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)\n    .setPostprocessor(redMeshPostprocessor)\n    .build();\n```\n\n### 7.Image Requests\n\n使用ImageRequestBuilder来做更多的事情。\n\n```\nUri uri;\n\nImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()\n    .setBackgroundColor(Color.GREEN)\n    .build();\n\nImageRequest request = ImageRequestBuilder\n    .newBuilderWithSource(uri)\n    .setImageDecodeOptions(decodeOptions)\n    .setAutoRotateEnabled(true)\n    .setLocalThumbnailPreviewsEnabled(true)\n    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    \n    .setProgressiveRenderingEnabled(false)\n    .setResizeOptions(new ResizeOptions(width, height))\n    .build();\n```\n\n### 8.Image Pipeline\nImage pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。\n\n```\nImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)\n    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)\n    .setCacheKeyFactory(cacheKeyFactory)\n    .setDownsampleEnabled(true)\n    .setWebpSupportEnabled(true)\n    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)\n    .setExecutorSupplier(executorSupplier)\n    .setImageCacheStatsTracker(imageCacheStatsTracker)\n    .setMainDiskCacheConfig(mainDiskCacheConfig)\n    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)\n    .setNetworkFetchProducer(networkFetchProducer)\n    .setPoolFactory(poolFactory)\n    .setProgressiveJpegConfig(progressiveJpegConfig)\n    .setRequestListeners(requestListeners)\n    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)\n    .build();\nFresco.initialize(context, config);\n```\n\n上面的可配置项会因为版本的不同有稍微的区别。\n\n#### 8.1 缓存\n\n在fresco里面，\n\n* bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上\n* 未解码图片的内存缓存\n* 磁盘缓存\n\n我们可以通过imagepipeline判断bitmap是否被缓存，\n\n```\n        ImagePipeline imagePipeline = Fresco.getImagePipeline();\n        imagePipeline.isInBitmapMemoryCache(Uri.parse(\"\"));\n        imagePipeline.isInDiskCache(Uri.parse(\"xxx\"));\n```\n\n删除指定缓存\n\n```\n        Uri uri = Uri.parse(\"xxx\");\n        imagePipeline.evictFromCache(uri);\n        imagePipeline.evictFromDiskCache(uri);\n```\n\n\n使用imagepipeline可以对整个工程加入一些控制。更多用法[文档](https://www.fresco-cn.org/docs/using-image-pipeline.html)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/fresco用法.md","raw":"---\ntitle: fresco用法\ndate: 2016-12-12 14:27:12\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 0.前言\n\n在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 1.fresco中的关键概念\n\n* Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式\n\t* DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可\n\t* DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。\n\t* DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。\n如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。\n\t* DraweeControllerBuilder \nDraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改\n\t* Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。\n* The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。\n在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。\nSimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 \n\n### 3.支持的URI类型\n\n* http|https\n* file://\n* content://\n* asset://\n* res://\n* data:mime/type;base64 uri中指定图片数据\n\n### 4.支持的xml属性\n\n[支持的xml属性](https://www.fresco-cn.org/docs/using-drawees-xml.html)\n\n### 5.在java中使用Drawees\n\n#### 5.1 自定义DraweeHierarchy\n\n```\n        GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());\n        GenericDraweeHierarchy hierarchy = builder\n                .setFadeDuration(300)\n                //and so on\n                .build();\n        image.setHierarchy(hierarchy);\n```\n\n从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\nxml中对应的属性，由hierarchy控制。\n\n#### 5.2 运行时修改 DraweeHierarchy\n\n要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。\n\n```\n        GenericDraweeHierarchy hierarchy = image.getHierarchy();\n        hierarchy.setFadeDuration(400);\n```\n\n其他属性同理。\n\n#### 5.3 配置效果\n\n我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。\n\n在ControllerBuilder 中如下设置:\n\n```\n.setTapToRetryEnabled(true)\n```\n\n* XML 中属性值: retryImage\n* Hierarchy builder中的方法: setRetryImage\n\n#### 5.4 进度条\n\n构建GenericDraweeHierarchy的时候\n\n\n```\n.setProgressBarImage(new ProgressBarDrawable())\n```\n，我们也可以自定义，实现Drawable.onLevelChange。\n\n\n### 6 DraweeController增加对图片的控制\n\n```\nControllerListener listener = new BaseControllerListener() {...}\n\nDraweeController controller = Fresco.newDraweeControllerBuilder()\n    .setUri(uri)\n    .setTapToRetryEnabled(true)\n    .setOldController(mSimpleDraweeView.getController())\n    .setControllerListener(listener)\n    .build();\n\nmSimpleDraweeView.setController(controller);\n```\n\n* 使用渐进式jpeg图。\n\n    ```\n    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(\"xxx\"))\n                //打开渐进 渲染\n                .setProgressiveRenderingEnabled(true)\n                .build();\n\t```\n\t\n* 动画自动播放\n\t\n\t```\n\tdraweeController.setAutoPlayAnimations(true)\n\t```\n* 动画手动播放，\n\n\t```\n\t        ControllerListener listener = new BaseControllerListener<ImageInfo>(){\n            @Override\n            public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) {\n                super.onFinalImageSet(id, imageInfo, animatable);\n                if (animatable != null){\n                    animatable.start();\n                }\n            }\n        };\n        \n        draweeController.setControllerListener(listener)\n\t```\n* 后处理器Postprocessor 对图片进行后期处理\n\n```\nPostprocessor redMeshPostprocessor = new BasePostprocessor() {\n  @Override\n  public String getName() {\n    return \"redMeshPostprocessor\";\n  }\n\n  @Override\n  public void process(Bitmap bitmap) {\n    for (int x = 0; x < bitmap.getWidth(); x+=2) {\n      for (int y = 0; y < bitmap.getHeight(); y+=2) {\n        bitmap.setPixel(x, y, Color.RED);\n      }\n    }\n  }\n}\n\nImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)\n    .setPostprocessor(redMeshPostprocessor)\n    .build();\n```\n\n### 7.Image Requests\n\n使用ImageRequestBuilder来做更多的事情。\n\n```\nUri uri;\n\nImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()\n    .setBackgroundColor(Color.GREEN)\n    .build();\n\nImageRequest request = ImageRequestBuilder\n    .newBuilderWithSource(uri)\n    .setImageDecodeOptions(decodeOptions)\n    .setAutoRotateEnabled(true)\n    .setLocalThumbnailPreviewsEnabled(true)\n    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    \n    .setProgressiveRenderingEnabled(false)\n    .setResizeOptions(new ResizeOptions(width, height))\n    .build();\n```\n\n### 8.Image Pipeline\nImage pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。\n\n```\nImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)\n    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)\n    .setCacheKeyFactory(cacheKeyFactory)\n    .setDownsampleEnabled(true)\n    .setWebpSupportEnabled(true)\n    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)\n    .setExecutorSupplier(executorSupplier)\n    .setImageCacheStatsTracker(imageCacheStatsTracker)\n    .setMainDiskCacheConfig(mainDiskCacheConfig)\n    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)\n    .setNetworkFetchProducer(networkFetchProducer)\n    .setPoolFactory(poolFactory)\n    .setProgressiveJpegConfig(progressiveJpegConfig)\n    .setRequestListeners(requestListeners)\n    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)\n    .build();\nFresco.initialize(context, config);\n```\n\n上面的可配置项会因为版本的不同有稍微的区别。\n\n#### 8.1 缓存\n\n在fresco里面，\n\n* bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上\n* 未解码图片的内存缓存\n* 磁盘缓存\n\n我们可以通过imagepipeline判断bitmap是否被缓存，\n\n```\n        ImagePipeline imagePipeline = Fresco.getImagePipeline();\n        imagePipeline.isInBitmapMemoryCache(Uri.parse(\"\"));\n        imagePipeline.isInDiskCache(Uri.parse(\"xxx\"));\n```\n\n删除指定缓存\n\n```\n        Uri uri = Uri.parse(\"xxx\");\n        imagePipeline.evictFromCache(uri);\n        imagePipeline.evictFromDiskCache(uri);\n```\n\n\n使用imagepipeline可以对整个工程加入一些控制。更多用法[文档](https://www.fresco-cn.org/docs/using-image-pipeline.html)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"fresco用法","published":1,"updated":"2017-01-06T05:31:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yo001iuaxa6l72cr17","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0.前言\"></a>0.前言</h3><p>在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<h3 id=\"1-fresco中的关键概念\"><a href=\"#1-fresco中的关键概念\" class=\"headerlink\" title=\"1.fresco中的关键概念\"></a>1.fresco中的关键概念</h3><ul>\n<li>Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式<ul>\n<li>DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可</li>\n<li>DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。</li>\n<li>DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。<br>如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。</li>\n<li>DraweeControllerBuilder<br>DraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改</li>\n<li>Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。</li>\n</ul>\n</li>\n<li>The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。<br>在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。<br>SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 </li>\n</ul>\n<h3 id=\"3-支持的URI类型\"><a href=\"#3-支持的URI类型\" class=\"headerlink\" title=\"3.支持的URI类型\"></a>3.支持的URI类型</h3><ul>\n<li>http|https</li>\n<li>file://</li>\n<li>content://</li>\n<li>asset://</li>\n<li>res://</li>\n<li>data:mime/type;base64 uri中指定图片数据</li>\n</ul>\n<h3 id=\"4-支持的xml属性\"><a href=\"#4-支持的xml属性\" class=\"headerlink\" title=\"4.支持的xml属性\"></a>4.支持的xml属性</h3><p><a href=\"https://www.fresco-cn.org/docs/using-drawees-xml.html\" target=\"_blank\" rel=\"external\">支持的xml属性</a></p>\n<h3 id=\"5-在java中使用Drawees\"><a href=\"#5-在java中使用Drawees\" class=\"headerlink\" title=\"5.在java中使用Drawees\"></a>5.在java中使用Drawees</h3><h4 id=\"5-1-自定义DraweeHierarchy\"><a href=\"#5-1-自定义DraweeHierarchy\" class=\"headerlink\" title=\"5.1 自定义DraweeHierarchy\"></a>5.1 自定义DraweeHierarchy</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());</div><div class=\"line\">GenericDraweeHierarchy hierarchy = builder</div><div class=\"line\">        .setFadeDuration(300)</div><div class=\"line\">        //and so on</div><div class=\"line\">        .build();</div><div class=\"line\">image.setHierarchy(hierarchy);</div></pre></td></tr></table></figure>\n<p>从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>xml中对应的属性，由hierarchy控制。</p>\n<h4 id=\"5-2-运行时修改-DraweeHierarchy\"><a href=\"#5-2-运行时修改-DraweeHierarchy\" class=\"headerlink\" title=\"5.2 运行时修改 DraweeHierarchy\"></a>5.2 运行时修改 DraweeHierarchy</h4><p>要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchy hierarchy = image.getHierarchy();</div><div class=\"line\">hierarchy.setFadeDuration(400);</div></pre></td></tr></table></figure>\n<p>其他属性同理。</p>\n<h4 id=\"5-3-配置效果\"><a href=\"#5-3-配置效果\" class=\"headerlink\" title=\"5.3 配置效果\"></a>5.3 配置效果</h4><p>我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。</p>\n<p>在ControllerBuilder 中如下设置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setTapToRetryEnabled(true)</div></pre></td></tr></table></figure>\n<ul>\n<li>XML 中属性值: retryImage</li>\n<li>Hierarchy builder中的方法: setRetryImage</li>\n</ul>\n<h4 id=\"5-4-进度条\"><a href=\"#5-4-进度条\" class=\"headerlink\" title=\"5.4 进度条\"></a>5.4 进度条</h4><p>构建GenericDraweeHierarchy的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setProgressBarImage(new ProgressBarDrawable())</div></pre></td></tr></table></figure>\n<p>，我们也可以自定义，实现Drawable.onLevelChange。</p>\n<h3 id=\"6-DraweeController增加对图片的控制\"><a href=\"#6-DraweeController增加对图片的控制\" class=\"headerlink\" title=\"6 DraweeController增加对图片的控制\"></a>6 DraweeController增加对图片的控制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ControllerListener listener = new BaseControllerListener() &#123;...&#125;</div><div class=\"line\"></div><div class=\"line\">DraweeController controller = Fresco.newDraweeControllerBuilder()</div><div class=\"line\">    .setUri(uri)</div><div class=\"line\">    .setTapToRetryEnabled(true)</div><div class=\"line\">    .setOldController(mSimpleDraweeView.getController())</div><div class=\"line\">    .setControllerListener(listener)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">mSimpleDraweeView.setController(controller);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>使用渐进式jpeg图。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(&quot;xxx&quot;))</div><div class=\"line\">            //打开渐进 渲染</div><div class=\"line\">            .setProgressiveRenderingEnabled(true)</div><div class=\"line\">            .build();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>动画自动播放</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">draweeController.setAutoPlayAnimations(true)</div></pre></td></tr></table></figure>\n</li>\n<li><p>动画手动播放，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ControllerListener listener = new BaseControllerListener&lt;ImageInfo&gt;()&#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) &#123;</div><div class=\"line\">        super.onFinalImageSet(id, imageInfo, animatable);</div><div class=\"line\">        if (animatable != null)&#123;</div><div class=\"line\">            animatable.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">draweeController.setControllerListener(listener)</div></pre></td></tr></table></figure>\n</li>\n<li><p>后处理器Postprocessor 对图片进行后期处理</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Postprocessor redMeshPostprocessor = new BasePostprocessor() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public String getName() &#123;</div><div class=\"line\">    return &quot;redMeshPostprocessor&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void process(Bitmap bitmap) &#123;</div><div class=\"line\">    for (int x = 0; x &lt; bitmap.getWidth(); x+=2) &#123;</div><div class=\"line\">      for (int y = 0; y &lt; bitmap.getHeight(); y+=2) &#123;</div><div class=\"line\">        bitmap.setPixel(x, y, Color.RED);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)</div><div class=\"line\">    .setPostprocessor(redMeshPostprocessor)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"7-Image-Requests\"><a href=\"#7-Image-Requests\" class=\"headerlink\" title=\"7.Image Requests\"></a>7.Image Requests</h3><p>使用ImageRequestBuilder来做更多的事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri;</div><div class=\"line\"></div><div class=\"line\">ImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()</div><div class=\"line\">    .setBackgroundColor(Color.GREEN)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder</div><div class=\"line\">    .newBuilderWithSource(uri)</div><div class=\"line\">    .setImageDecodeOptions(decodeOptions)</div><div class=\"line\">    .setAutoRotateEnabled(true)</div><div class=\"line\">    .setLocalThumbnailPreviewsEnabled(true)</div><div class=\"line\">    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    </div><div class=\"line\">    .setProgressiveRenderingEnabled(false)</div><div class=\"line\">    .setResizeOptions(new ResizeOptions(width, height))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"8-Image-Pipeline\"><a href=\"#8-Image-Pipeline\" class=\"headerlink\" title=\"8.Image Pipeline\"></a>8.Image Pipeline</h3><p>Image pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)</div><div class=\"line\">    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)</div><div class=\"line\">    .setCacheKeyFactory(cacheKeyFactory)</div><div class=\"line\">    .setDownsampleEnabled(true)</div><div class=\"line\">    .setWebpSupportEnabled(true)</div><div class=\"line\">    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)</div><div class=\"line\">    .setExecutorSupplier(executorSupplier)</div><div class=\"line\">    .setImageCacheStatsTracker(imageCacheStatsTracker)</div><div class=\"line\">    .setMainDiskCacheConfig(mainDiskCacheConfig)</div><div class=\"line\">    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)</div><div class=\"line\">    .setNetworkFetchProducer(networkFetchProducer)</div><div class=\"line\">    .setPoolFactory(poolFactory)</div><div class=\"line\">    .setProgressiveJpegConfig(progressiveJpegConfig)</div><div class=\"line\">    .setRequestListeners(requestListeners)</div><div class=\"line\">    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)</div><div class=\"line\">    .build();</div><div class=\"line\">Fresco.initialize(context, config);</div></pre></td></tr></table></figure>\n<p>上面的可配置项会因为版本的不同有稍微的区别。</p>\n<h4 id=\"8-1-缓存\"><a href=\"#8-1-缓存\" class=\"headerlink\" title=\"8.1 缓存\"></a>8.1 缓存</h4><p>在fresco里面，</p>\n<ul>\n<li>bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上</li>\n<li>未解码图片的内存缓存</li>\n<li>磁盘缓存</li>\n</ul>\n<p>我们可以通过imagepipeline判断bitmap是否被缓存，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipeline imagePipeline = Fresco.getImagePipeline();</div><div class=\"line\">imagePipeline.isInBitmapMemoryCache(Uri.parse(&quot;&quot;));</div><div class=\"line\">imagePipeline.isInDiskCache(Uri.parse(&quot;xxx&quot;));</div></pre></td></tr></table></figure>\n<p>删除指定缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(&quot;xxx&quot;);</div><div class=\"line\">imagePipeline.evictFromCache(uri);</div><div class=\"line\">imagePipeline.evictFromDiskCache(uri);</div></pre></td></tr></table></figure>\n<p>使用imagepipeline可以对整个工程加入一些控制。更多用法<a href=\"https://www.fresco-cn.org/docs/using-image-pipeline.html\" target=\"_blank\" rel=\"external\">文档</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0.前言\"></a>0.前言</h3><p>在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<h3 id=\"1-fresco中的关键概念\"><a href=\"#1-fresco中的关键概念\" class=\"headerlink\" title=\"1.fresco中的关键概念\"></a>1.fresco中的关键概念</h3><ul>\n<li>Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式<ul>\n<li>DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可</li>\n<li>DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。</li>\n<li>DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。<br>如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。</li>\n<li>DraweeControllerBuilder<br>DraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改</li>\n<li>Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。</li>\n</ul>\n</li>\n<li>The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。<br>在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。<br>SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 </li>\n</ul>\n<h3 id=\"3-支持的URI类型\"><a href=\"#3-支持的URI类型\" class=\"headerlink\" title=\"3.支持的URI类型\"></a>3.支持的URI类型</h3><ul>\n<li>http|https</li>\n<li>file://</li>\n<li>content://</li>\n<li>asset://</li>\n<li>res://</li>\n<li>data:mime/type;base64 uri中指定图片数据</li>\n</ul>\n<h3 id=\"4-支持的xml属性\"><a href=\"#4-支持的xml属性\" class=\"headerlink\" title=\"4.支持的xml属性\"></a>4.支持的xml属性</h3><p><a href=\"https://www.fresco-cn.org/docs/using-drawees-xml.html\">支持的xml属性</a></p>\n<h3 id=\"5-在java中使用Drawees\"><a href=\"#5-在java中使用Drawees\" class=\"headerlink\" title=\"5.在java中使用Drawees\"></a>5.在java中使用Drawees</h3><h4 id=\"5-1-自定义DraweeHierarchy\"><a href=\"#5-1-自定义DraweeHierarchy\" class=\"headerlink\" title=\"5.1 自定义DraweeHierarchy\"></a>5.1 自定义DraweeHierarchy</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());</div><div class=\"line\">GenericDraweeHierarchy hierarchy = builder</div><div class=\"line\">        .setFadeDuration(300)</div><div class=\"line\">        //and so on</div><div class=\"line\">        .build();</div><div class=\"line\">image.setHierarchy(hierarchy);</div></pre></td></tr></table></figure>\n<p>从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>xml中对应的属性，由hierarchy控制。</p>\n<h4 id=\"5-2-运行时修改-DraweeHierarchy\"><a href=\"#5-2-运行时修改-DraweeHierarchy\" class=\"headerlink\" title=\"5.2 运行时修改 DraweeHierarchy\"></a>5.2 运行时修改 DraweeHierarchy</h4><p>要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchy hierarchy = image.getHierarchy();</div><div class=\"line\">hierarchy.setFadeDuration(400);</div></pre></td></tr></table></figure>\n<p>其他属性同理。</p>\n<h4 id=\"5-3-配置效果\"><a href=\"#5-3-配置效果\" class=\"headerlink\" title=\"5.3 配置效果\"></a>5.3 配置效果</h4><p>我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。</p>\n<p>在ControllerBuilder 中如下设置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setTapToRetryEnabled(true)</div></pre></td></tr></table></figure>\n<ul>\n<li>XML 中属性值: retryImage</li>\n<li>Hierarchy builder中的方法: setRetryImage</li>\n</ul>\n<h4 id=\"5-4-进度条\"><a href=\"#5-4-进度条\" class=\"headerlink\" title=\"5.4 进度条\"></a>5.4 进度条</h4><p>构建GenericDraweeHierarchy的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setProgressBarImage(new ProgressBarDrawable())</div></pre></td></tr></table></figure>\n<p>，我们也可以自定义，实现Drawable.onLevelChange。</p>\n<h3 id=\"6-DraweeController增加对图片的控制\"><a href=\"#6-DraweeController增加对图片的控制\" class=\"headerlink\" title=\"6 DraweeController增加对图片的控制\"></a>6 DraweeController增加对图片的控制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ControllerListener listener = new BaseControllerListener() &#123;...&#125;</div><div class=\"line\"></div><div class=\"line\">DraweeController controller = Fresco.newDraweeControllerBuilder()</div><div class=\"line\">    .setUri(uri)</div><div class=\"line\">    .setTapToRetryEnabled(true)</div><div class=\"line\">    .setOldController(mSimpleDraweeView.getController())</div><div class=\"line\">    .setControllerListener(listener)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">mSimpleDraweeView.setController(controller);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>使用渐进式jpeg图。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(&quot;xxx&quot;))</div><div class=\"line\">            //打开渐进 渲染</div><div class=\"line\">            .setProgressiveRenderingEnabled(true)</div><div class=\"line\">            .build();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>动画自动播放</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">draweeController.setAutoPlayAnimations(true)</div></pre></td></tr></table></figure>\n</li>\n<li><p>动画手动播放，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ControllerListener listener = new BaseControllerListener&lt;ImageInfo&gt;()&#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) &#123;</div><div class=\"line\">        super.onFinalImageSet(id, imageInfo, animatable);</div><div class=\"line\">        if (animatable != null)&#123;</div><div class=\"line\">            animatable.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">draweeController.setControllerListener(listener)</div></pre></td></tr></table></figure>\n</li>\n<li><p>后处理器Postprocessor 对图片进行后期处理</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Postprocessor redMeshPostprocessor = new BasePostprocessor() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public String getName() &#123;</div><div class=\"line\">    return &quot;redMeshPostprocessor&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void process(Bitmap bitmap) &#123;</div><div class=\"line\">    for (int x = 0; x &lt; bitmap.getWidth(); x+=2) &#123;</div><div class=\"line\">      for (int y = 0; y &lt; bitmap.getHeight(); y+=2) &#123;</div><div class=\"line\">        bitmap.setPixel(x, y, Color.RED);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)</div><div class=\"line\">    .setPostprocessor(redMeshPostprocessor)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"7-Image-Requests\"><a href=\"#7-Image-Requests\" class=\"headerlink\" title=\"7.Image Requests\"></a>7.Image Requests</h3><p>使用ImageRequestBuilder来做更多的事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri;</div><div class=\"line\"></div><div class=\"line\">ImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()</div><div class=\"line\">    .setBackgroundColor(Color.GREEN)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder</div><div class=\"line\">    .newBuilderWithSource(uri)</div><div class=\"line\">    .setImageDecodeOptions(decodeOptions)</div><div class=\"line\">    .setAutoRotateEnabled(true)</div><div class=\"line\">    .setLocalThumbnailPreviewsEnabled(true)</div><div class=\"line\">    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    </div><div class=\"line\">    .setProgressiveRenderingEnabled(false)</div><div class=\"line\">    .setResizeOptions(new ResizeOptions(width, height))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"8-Image-Pipeline\"><a href=\"#8-Image-Pipeline\" class=\"headerlink\" title=\"8.Image Pipeline\"></a>8.Image Pipeline</h3><p>Image pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)</div><div class=\"line\">    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)</div><div class=\"line\">    .setCacheKeyFactory(cacheKeyFactory)</div><div class=\"line\">    .setDownsampleEnabled(true)</div><div class=\"line\">    .setWebpSupportEnabled(true)</div><div class=\"line\">    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)</div><div class=\"line\">    .setExecutorSupplier(executorSupplier)</div><div class=\"line\">    .setImageCacheStatsTracker(imageCacheStatsTracker)</div><div class=\"line\">    .setMainDiskCacheConfig(mainDiskCacheConfig)</div><div class=\"line\">    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)</div><div class=\"line\">    .setNetworkFetchProducer(networkFetchProducer)</div><div class=\"line\">    .setPoolFactory(poolFactory)</div><div class=\"line\">    .setProgressiveJpegConfig(progressiveJpegConfig)</div><div class=\"line\">    .setRequestListeners(requestListeners)</div><div class=\"line\">    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)</div><div class=\"line\">    .build();</div><div class=\"line\">Fresco.initialize(context, config);</div></pre></td></tr></table></figure>\n<p>上面的可配置项会因为版本的不同有稍微的区别。</p>\n<h4 id=\"8-1-缓存\"><a href=\"#8-1-缓存\" class=\"headerlink\" title=\"8.1 缓存\"></a>8.1 缓存</h4><p>在fresco里面，</p>\n<ul>\n<li>bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上</li>\n<li>未解码图片的内存缓存</li>\n<li>磁盘缓存</li>\n</ul>\n<p>我们可以通过imagepipeline判断bitmap是否被缓存，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipeline imagePipeline = Fresco.getImagePipeline();</div><div class=\"line\">imagePipeline.isInBitmapMemoryCache(Uri.parse(&quot;&quot;));</div><div class=\"line\">imagePipeline.isInDiskCache(Uri.parse(&quot;xxx&quot;));</div></pre></td></tr></table></figure>\n<p>删除指定缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(&quot;xxx&quot;);</div><div class=\"line\">imagePipeline.evictFromCache(uri);</div><div class=\"line\">imagePipeline.evictFromDiskCache(uri);</div></pre></td></tr></table></figure>\n<p>使用imagepipeline可以对整个工程加入一些控制。更多用法<a href=\"https://www.fresco-cn.org/docs/using-image-pipeline.html\">文档</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"layout":"使用hexo+githb","title":"pages搭建个人博客","date":"2016-11-29T03:49:42.000Z","_content":"<Excerpt in index | 首页摘要> \n### 搭建步骤\n\n1. 下载nodejs并安装\n2. 安装hexo npm install -g hexo-cli\n+ <!-- more -->\n<The rest of contents | 余下全文>\n3. 初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx\n4. 进入本地仓库，初始化hexo站点，hexo init\n5. 修改配置_config.yml，public_dir 为 ./\n6. 修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下\n7. 修改root目录下的_congig.yml文件，修改```theme: spfk``` 并且修改deploy 为 \n\t\n\t```\ndeploy:\n  type: git\n  repo: https://github.com/Guolei1130/Guolei1130.github.io.git\n  branch: master \n\t``` \n根据需求或者主题需要，修改其他相应的配置\n\n8. hexo generate 重新生成静态网页\n9. hexo new blogname，生成你的blog\n10. push到github,进行测试\n\n\n\n### 一些基本操作\n\n* hexo new blogname 生成blog\n* hexo generate(g)  重新生成静态页面\n* hexo server(s)  启动本地服务器\n\n### 关于博客中的图片\n\n个人建议放在_posts同级目录，规则按image/年/月/文章/来放\n\n### 关于删除文章\n\n直接删除_post下的即可\n\n\n\n### 多说\n\n大部分主题支持pv统计和多说，pv统计，大多数我们不需要改\n去http://duoshuo.com/create-site/注册，并修改theme中的配置\n\n```\nduoshuo: \n  on: true\n  domain: guolei1130\n  # 是否开启多说评论，http://duoshuo.com/create-site/\n  # 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\n  # http://<要填的部分>.duoshuo.com (domain只填上<>里的内容，不要填整个网址)\n```\n\n配置完push到github，就可在多说管理后台进行管理\n\n### 关于全文模式\n先在主题的配置文件中，添加\n```\nauto_excerpt:\nenable: false\nlength: 150\n```\n\n然后在文章的最前面加\n\n```\n<Excerpt in index | 首页摘要> \n```\n\n在文章最后增加 \n\n```\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n```\n\n### 关于图片资源问题\n\n有两种办法\n\n* 将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法\n* 找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/hexo+github pages搭建个人博客.md","raw":"layout: 使用hexo+githb\ntitle: pages搭建个人博客\ncategories: hexo\ndate: 2016-11-29 11:49:42\ntags: hexo\n\n---\n<Excerpt in index | 首页摘要> \n### 搭建步骤\n\n1. 下载nodejs并安装\n2. 安装hexo npm install -g hexo-cli\n+ <!-- more -->\n<The rest of contents | 余下全文>\n3. 初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx\n4. 进入本地仓库，初始化hexo站点，hexo init\n5. 修改配置_config.yml，public_dir 为 ./\n6. 修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下\n7. 修改root目录下的_congig.yml文件，修改```theme: spfk``` 并且修改deploy 为 \n\t\n\t```\ndeploy:\n  type: git\n  repo: https://github.com/Guolei1130/Guolei1130.github.io.git\n  branch: master \n\t``` \n根据需求或者主题需要，修改其他相应的配置\n\n8. hexo generate 重新生成静态网页\n9. hexo new blogname，生成你的blog\n10. push到github,进行测试\n\n\n\n### 一些基本操作\n\n* hexo new blogname 生成blog\n* hexo generate(g)  重新生成静态页面\n* hexo server(s)  启动本地服务器\n\n### 关于博客中的图片\n\n个人建议放在_posts同级目录，规则按image/年/月/文章/来放\n\n### 关于删除文章\n\n直接删除_post下的即可\n\n\n\n### 多说\n\n大部分主题支持pv统计和多说，pv统计，大多数我们不需要改\n去http://duoshuo.com/create-site/注册，并修改theme中的配置\n\n```\nduoshuo: \n  on: true\n  domain: guolei1130\n  # 是否开启多说评论，http://duoshuo.com/create-site/\n  # 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\n  # http://<要填的部分>.duoshuo.com (domain只填上<>里的内容，不要填整个网址)\n```\n\n配置完push到github，就可在多说管理后台进行管理\n\n### 关于全文模式\n先在主题的配置文件中，添加\n```\nauto_excerpt:\nenable: false\nlength: 150\n```\n\n然后在文章的最前面加\n\n```\n<Excerpt in index | 首页摘要> \n```\n\n在文章最后增加 \n\n```\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n```\n\n### 关于图片资源问题\n\n有两种办法\n\n* 将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法\n* 找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"hexo+github pages搭建个人博客","published":1,"updated":"2017-01-06T05:31:51.000Z","comments":1,"photos":[],"link":"","_id":"cixld85yr001luaxa2okuwtfs","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"> </excerpt></p>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3><ol>\n<li>下载nodejs并安装</li>\n<li>安装hexo npm install -g hexo-cli</li>\n</ol>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\"></the></li>\n</ul>\n<ol>\n<li>初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx</li>\n<li>进入本地仓库，初始化hexo站点，hexo init</li>\n<li>修改配置_config.yml，public_dir 为 ./</li>\n<li>修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下</li>\n<li>修改root目录下的_congig.yml文件，修改<figure class=\"highlight plain\"><figcaption><span>spfk``` 并且修改deploy 为 </span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t</div></pre></td></tr></table></figure></li>\n</ol>\n<p>deploy:<br>  type: git<br>  repo: <a href=\"https://github.com/Guolei1130/Guolei1130.github.io.git\" target=\"_blank\" rel=\"external\">https://github.com/Guolei1130/Guolei1130.github.io.git</a><br>  branch: master<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据需求或者主题需要，修改其他相应的配置</div><div class=\"line\"></div><div class=\"line\">8. hexo generate 重新生成静态网页</div><div class=\"line\">9. hexo new blogname，生成你的blog</div><div class=\"line\">10. push到github,进行测试</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 一些基本操作</div><div class=\"line\"></div><div class=\"line\">* hexo new blogname 生成blog</div><div class=\"line\">* hexo generate(g)  重新生成静态页面</div><div class=\"line\">* hexo server(s)  启动本地服务器</div><div class=\"line\"></div><div class=\"line\">### 关于博客中的图片</div><div class=\"line\"></div><div class=\"line\">个人建议放在_posts同级目录，规则按image/年/月/文章/来放</div><div class=\"line\"></div><div class=\"line\">### 关于删除文章</div><div class=\"line\"></div><div class=\"line\">直接删除_post下的即可</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 多说</div><div class=\"line\"></div><div class=\"line\">大部分主题支持pv统计和多说，pv统计，大多数我们不需要改</div><div class=\"line\">去http://duoshuo.com/create-site/注册，并修改theme中的配置</div></pre></td></tr></table></figure></p>\n<p>duoshuo:<br>  on: true<br>  domain: guolei1130</p>\n<h1 id=\"是否开启多说评论，http-duoshuo-com-create-site\"><a href=\"#是否开启多说评论，http-duoshuo-com-create-site\" class=\"headerlink\" title=\"是否开启多说评论，http://duoshuo.com/create-site/\"></a>是否开启多说评论，<a href=\"http://duoshuo.com/create-site/\" target=\"_blank\" rel=\"external\">http://duoshuo.com/create-site/</a></h1><h1 id=\"使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\"><a href=\"#使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\" class=\"headerlink\" title=\"使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\"></a>使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分</h1><h1 id=\"http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\"><a href=\"#http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\" class=\"headerlink\" title=\"http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)\"></a>http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">配置完push到github，就可在多说管理后台进行管理</div><div class=\"line\"></div><div class=\"line\">### 关于全文模式</div><div class=\"line\">先在主题的配置文件中，添加</div></pre></td></tr></table></figure>\n<p>auto_excerpt:<br>enable: false<br>length: 150<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后在文章的最前面加</div></pre></td></tr></table></figure></p>\n<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在文章最后增加</div></pre></td></tr></table></figure></excerpt></p>\n<ul>\n<li><!-- more -->\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n</the></li>\n</ul>\n<p>```</p>\n<h3 id=\"关于图片资源问题\"><a href=\"#关于图片资源问题\" class=\"headerlink\" title=\"关于图片资源问题\"></a>关于图片资源问题</h3><p>有两种办法</p>\n<ul>\n<li>将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法</li>\n<li>找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","excerpt":"<p><Excerpt in index | 首页摘要> </p>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3><ol>\n<li>下载nodejs并安装</li>\n<li>安装hexo npm install -g hexo-cli</li>\n</ol>\n<ul>\n<li>","more":"<The rest of contents | 余下全文></li>\n</ul>\n<ol>\n<li>初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx</li>\n<li>进入本地仓库，初始化hexo站点，hexo init</li>\n<li>修改配置_config.yml，public_dir 为 ./</li>\n<li>修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下</li>\n<li>修改root目录下的_congig.yml文件，修改<figure class=\"highlight plain\"><figcaption><span>spfk``` 并且修改deploy 为 </span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t</div></pre></td></tr></table></figure></li>\n</ol>\n<p>deploy:<br>  type: git<br>  repo: <a href=\"https://github.com/Guolei1130/Guolei1130.github.io.git\">https://github.com/Guolei1130/Guolei1130.github.io.git</a><br>  branch: master<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据需求或者主题需要，修改其他相应的配置</div><div class=\"line\"></div><div class=\"line\">8. hexo generate 重新生成静态网页</div><div class=\"line\">9. hexo new blogname，生成你的blog</div><div class=\"line\">10. push到github,进行测试</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 一些基本操作</div><div class=\"line\"></div><div class=\"line\">* hexo new blogname 生成blog</div><div class=\"line\">* hexo generate(g)  重新生成静态页面</div><div class=\"line\">* hexo server(s)  启动本地服务器</div><div class=\"line\"></div><div class=\"line\">### 关于博客中的图片</div><div class=\"line\"></div><div class=\"line\">个人建议放在_posts同级目录，规则按image/年/月/文章/来放</div><div class=\"line\"></div><div class=\"line\">### 关于删除文章</div><div class=\"line\"></div><div class=\"line\">直接删除_post下的即可</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 多说</div><div class=\"line\"></div><div class=\"line\">大部分主题支持pv统计和多说，pv统计，大多数我们不需要改</div><div class=\"line\">去http://duoshuo.com/create-site/注册，并修改theme中的配置</div></pre></td></tr></table></figure></p>\n<p>duoshuo:<br>  on: true<br>  domain: guolei1130</p>\n<h1 id=\"是否开启多说评论，http-duoshuo-com-create-site\"><a href=\"#是否开启多说评论，http-duoshuo-com-create-site\" class=\"headerlink\" title=\"是否开启多说评论，http://duoshuo.com/create-site/\"></a>是否开启多说评论，<a href=\"http://duoshuo.com/create-site/\">http://duoshuo.com/create-site/</a></h1><h1 id=\"使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\"><a href=\"#使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\" class=\"headerlink\" title=\"使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\"></a>使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分</h1><h1 id=\"http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\"><a href=\"#http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\" class=\"headerlink\" title=\"http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)\"></a>http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">配置完push到github，就可在多说管理后台进行管理</div><div class=\"line\"></div><div class=\"line\">### 关于全文模式</div><div class=\"line\">先在主题的配置文件中，添加</div></pre></td></tr></table></figure>\n<p>auto_excerpt:<br>enable: false<br>length: 150<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后在文章的最前面加</div></pre></td></tr></table></figure></p>\n<p><Excerpt in index | 首页摘要><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在文章最后增加</div></pre></td></tr></table></figure></p>\n<ul>\n<li><!-- more -->\n<The rest of contents | 余下全文>\n\n</li>\n</ul>\n<p>```</p>\n<h3 id=\"关于图片资源问题\"><a href=\"#关于图片资源问题\" class=\"headerlink\" title=\"关于图片资源问题\"></a>关于图片资源问题</h3><p>有两种办法</p>\n<ul>\n<li>将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法</li>\n<li>找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解gradle（一）","date":"2016-12-05T13:27:31.000Z","_content":"<Excerpt in index | 首页摘要>\n想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。\n\n### 1.依赖管理\n\n```\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n    testCompile group: 'junit', name: 'junit', version: '4.+'\n}\n```\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n* respositories 声明我们要使用的仓库\n* dependencies 我们要依赖的一些东西\n\t* compile 依赖需要编译生产项目的来源\n\t* runtime 依赖运行时字节码\n\t* testCompile 依赖测试代码\n\t* testRuntime \n\t\n通常，我们声明仓库有两种方式\n\n* 使用中央仓库 mavenCentral()\n* 使用自己的仓库\n\t* 使用远程仓库\n\t\n\t\t```\n\trepositories {\n    maven {\n    \t// 自己远程仓库地址\n        url \"http://repo.mycompany.com/maven2\"\n    }\n}\n\t```\n\t* 使用本地仓库\t \n\t\n\t\t```\n\t\trepositories {\n    ivy {\n        // URL can refer to a local directory\n        url \"../local-repo\"\n    }\n}\n\t\t```\n\t\t\n\t\t\n\t\t\n再说我们的依赖包管理，同样有两种方式\n\n```\n// 1\ncompile 'org.hibernate:hibernate-core:3.6.7.Final'\n// 2\ncompile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n```\n\n我们最常用的是第一种方法。\n\n有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除\n\n```\n    compile(\"com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version\") {\n        exclude group: 'com.squareup.retrofit2'\n    }\n```\n\n关于如何上传仓库这里暂时不介绍,[可以看这里](https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle)\n\n### 2.编写gradle脚本\n\n#### 2.1 Project API\n\n```\nprintln project.buildDir\n```\n\n我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。\n\n#### 2.2 如何定义变量\n\n\n\n和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。\n\n```\ndef my_name = \"guolei\"\nprintln my_nme\n```\n\n#### 2.3 Extra 属性\n\n```\next {\n    my_name = \"guolei\"\n}\n\nprintln ext.my_name;\n```\n\n#### 2.4 TASK \n\ngradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。[gradle api文档地址](https://docs.gradle.org/current/javadoc/)，关于Api的使用，这里就不介绍了，文档上使用方法很全。\n\n#### 2.5 TASK之间的依赖关系\n\n我们可以使用dependsOn来指明task之间的关系。\n\n```\ntaskX.dependsOn taskY\n\n```\n\n如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。\n\n\n#### 2.6 有序的TASKS\n\n* shouldRunAfter\n* mustRunAfter\n\n\n#### 2.7 给task添加描述\n\n```\ntask a {\n\tdescription \"xxx\"\n\tprintln \"xx\"\n}\n\n```\n\n#### 2.8 跳过task不执行\n\n* onlyIf,满足条件的情况下才执行\n\n```\ntask hello {\n    doLast {\n        println 'hello world'\n    }\n}\n\nhello.onlyIf { !project.hasProperty('skipHello') }\n```\n\n* 用异常\n\n```\ncompile.doFirst {\n    // Here you would put arbitrary conditions in real life.\n    // But this is used in an integration test so we want defined behavior.\n    if (true) { throw new StopExecutionException() }\n}\n```\n\n* enabled属性\n\n```\ntask.enabled = false\n```\n\n### 3.如何操作文件\n\n\n我们可以利用Project.file 方法去获取文件\n\n```\n// Using a relative path\nFile configFile = file('src/config.xml')\n\n// Using an absolute path\nconfigFile = file(configFile.absolutePath)\n\n// Using a File object with a relative path\nconfigFile = file(new File('src/config.xml'))\n```\n\n\n然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）\n\n```\n\nFileCollection collection = files('src/file1.txt',new File('src/file2.txt'),['src/file3.txt', 'src/file4.txt'])\n```\n\n可以利用Project.fileTree获取文件树。\n\n```\n// Create a file tree with a base directory\nFileTree tree = fileTree(dir: 'src/main')\n\n// Add include and exclude patterns to the tree\ntree.include '**/*.java'\ntree.exclude '**/Abstract*'\n\n// Create a tree using path\ntree = fileTree('src').include('**/*.java')\n\n// Create a tree using closure\ntree = fileTree('src') {\n    include '**/*.java'\n}\n\n// Create a tree using a map\ntree = fileTree(dir: 'src', include: '**/*.java')\ntree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])\ntree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')\n\n```\n\n我们可以操作压缩文件。\n\n```\n\n// Create a ZIP file tree using path\nFileTree zip = zipTree('someFile.zip')\n\n// Create a TAR file tree using path\nFileTree tar = tarTree('someFile.tar')\n\n//tar tree attempts to guess the compression based on the file extension\n//however if you must specify the compression explicitly you can:\nFileTree someTar = tarTree(resources.gzip('someTar.ext'))\n```\n\n文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。\n\n关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。\n\n\n### 4. 如何打log\n\n我们可以通过logger的一些方法输出log日志\n\n```\nogger.quiet('An info log message which is always logged.')\nlogger.error('An error log message.')\nlogger.warn('A warning log message.')\nlogger.lifecycle('A lifecycle info log message.')\nlogger.info('An info log message.')\nlogger.debug('A debug log message.')\nlogger.trace('A trace log message.')\n```\n\n### 5. gradle plugins\n\n```\napply from: 'other.gradle'\n```\n\n```\nplugins {\n    id «plugin id» version «plugin version» [apply «false»]\n}\n```\n\n```\n apply plugin: 'org.gradle.sample.goodbye'\n```\n\n三种方式。\n\n### 6.总结 \n\n上面的一些用法，全部来自于文档.\n\n[gradle 文档地址](https://docs.gradle.org/current/userguide/)\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/了解gradle（一）.md","raw":"---\ntitle: 了解gradle（一）\ndate: 2016-12-05 21:27:31\ncategories: Gradle\ntags: gradle\n\n---\n<Excerpt in index | 首页摘要>\n想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。\n\n### 1.依赖管理\n\n```\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n    testCompile group: 'junit', name: 'junit', version: '4.+'\n}\n```\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n* respositories 声明我们要使用的仓库\n* dependencies 我们要依赖的一些东西\n\t* compile 依赖需要编译生产项目的来源\n\t* runtime 依赖运行时字节码\n\t* testCompile 依赖测试代码\n\t* testRuntime \n\t\n通常，我们声明仓库有两种方式\n\n* 使用中央仓库 mavenCentral()\n* 使用自己的仓库\n\t* 使用远程仓库\n\t\n\t\t```\n\trepositories {\n    maven {\n    \t// 自己远程仓库地址\n        url \"http://repo.mycompany.com/maven2\"\n    }\n}\n\t```\n\t* 使用本地仓库\t \n\t\n\t\t```\n\t\trepositories {\n    ivy {\n        // URL can refer to a local directory\n        url \"../local-repo\"\n    }\n}\n\t\t```\n\t\t\n\t\t\n\t\t\n再说我们的依赖包管理，同样有两种方式\n\n```\n// 1\ncompile 'org.hibernate:hibernate-core:3.6.7.Final'\n// 2\ncompile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n```\n\n我们最常用的是第一种方法。\n\n有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除\n\n```\n    compile(\"com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version\") {\n        exclude group: 'com.squareup.retrofit2'\n    }\n```\n\n关于如何上传仓库这里暂时不介绍,[可以看这里](https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle)\n\n### 2.编写gradle脚本\n\n#### 2.1 Project API\n\n```\nprintln project.buildDir\n```\n\n我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。\n\n#### 2.2 如何定义变量\n\n\n\n和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。\n\n```\ndef my_name = \"guolei\"\nprintln my_nme\n```\n\n#### 2.3 Extra 属性\n\n```\next {\n    my_name = \"guolei\"\n}\n\nprintln ext.my_name;\n```\n\n#### 2.4 TASK \n\ngradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。[gradle api文档地址](https://docs.gradle.org/current/javadoc/)，关于Api的使用，这里就不介绍了，文档上使用方法很全。\n\n#### 2.5 TASK之间的依赖关系\n\n我们可以使用dependsOn来指明task之间的关系。\n\n```\ntaskX.dependsOn taskY\n\n```\n\n如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。\n\n\n#### 2.6 有序的TASKS\n\n* shouldRunAfter\n* mustRunAfter\n\n\n#### 2.7 给task添加描述\n\n```\ntask a {\n\tdescription \"xxx\"\n\tprintln \"xx\"\n}\n\n```\n\n#### 2.8 跳过task不执行\n\n* onlyIf,满足条件的情况下才执行\n\n```\ntask hello {\n    doLast {\n        println 'hello world'\n    }\n}\n\nhello.onlyIf { !project.hasProperty('skipHello') }\n```\n\n* 用异常\n\n```\ncompile.doFirst {\n    // Here you would put arbitrary conditions in real life.\n    // But this is used in an integration test so we want defined behavior.\n    if (true) { throw new StopExecutionException() }\n}\n```\n\n* enabled属性\n\n```\ntask.enabled = false\n```\n\n### 3.如何操作文件\n\n\n我们可以利用Project.file 方法去获取文件\n\n```\n// Using a relative path\nFile configFile = file('src/config.xml')\n\n// Using an absolute path\nconfigFile = file(configFile.absolutePath)\n\n// Using a File object with a relative path\nconfigFile = file(new File('src/config.xml'))\n```\n\n\n然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）\n\n```\n\nFileCollection collection = files('src/file1.txt',new File('src/file2.txt'),['src/file3.txt', 'src/file4.txt'])\n```\n\n可以利用Project.fileTree获取文件树。\n\n```\n// Create a file tree with a base directory\nFileTree tree = fileTree(dir: 'src/main')\n\n// Add include and exclude patterns to the tree\ntree.include '**/*.java'\ntree.exclude '**/Abstract*'\n\n// Create a tree using path\ntree = fileTree('src').include('**/*.java')\n\n// Create a tree using closure\ntree = fileTree('src') {\n    include '**/*.java'\n}\n\n// Create a tree using a map\ntree = fileTree(dir: 'src', include: '**/*.java')\ntree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])\ntree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')\n\n```\n\n我们可以操作压缩文件。\n\n```\n\n// Create a ZIP file tree using path\nFileTree zip = zipTree('someFile.zip')\n\n// Create a TAR file tree using path\nFileTree tar = tarTree('someFile.tar')\n\n//tar tree attempts to guess the compression based on the file extension\n//however if you must specify the compression explicitly you can:\nFileTree someTar = tarTree(resources.gzip('someTar.ext'))\n```\n\n文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。\n\n关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。\n\n\n### 4. 如何打log\n\n我们可以通过logger的一些方法输出log日志\n\n```\nogger.quiet('An info log message which is always logged.')\nlogger.error('An error log message.')\nlogger.warn('A warning log message.')\nlogger.lifecycle('A lifecycle info log message.')\nlogger.info('An info log message.')\nlogger.debug('A debug log message.')\nlogger.trace('A trace log message.')\n```\n\n### 5. gradle plugins\n\n```\napply from: 'other.gradle'\n```\n\n```\nplugins {\n    id «plugin id» version «plugin version» [apply «false»]\n}\n```\n\n```\n apply plugin: 'org.gradle.sample.goodbye'\n```\n\n三种方式。\n\n### 6.总结 \n\n上面的一些用法，全部来自于文档.\n\n[gradle 文档地址](https://docs.gradle.org/current/userguide/)\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"了解gradle（一）","published":1,"updated":"2017-01-06T05:29:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yu001puaxaaawfuyoe","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br>想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。</excerpt></p>\n<h3 id=\"1-依赖管理\"><a href=\"#1-依赖管理\" class=\"headerlink\" title=\"1.依赖管理\"></a>1.依赖管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div><div class=\"line\">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.+&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<ul>\n<li>respositories 声明我们要使用的仓库</li>\n<li>dependencies 我们要依赖的一些东西<ul>\n<li>compile 依赖需要编译生产项目的来源</li>\n<li>runtime 依赖运行时字节码</li>\n<li>testCompile 依赖测试代码</li>\n<li>testRuntime </li>\n</ul>\n</li>\n</ul>\n<p>通常，我们声明仓库有两种方式</p>\n<ul>\n<li>使用中央仓库 mavenCentral()</li>\n<li><p>使用自己的仓库</p>\n<ul>\n<li><p>使用远程仓库</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\trepositories &#123;</div><div class=\"line\">    maven &#123;</div><div class=\"line\">    \t// 自己远程仓库地址</div><div class=\"line\">        url &quot;http://repo.mycompany.com/maven2&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用本地仓库     </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\trepositories &#123;</div><div class=\"line\">    ivy &#123;</div><div class=\"line\">        // URL can refer to a local directory</div><div class=\"line\">        url &quot;../local-repo&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>再说我们的依赖包管理，同样有两种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos;</div><div class=\"line\">// 2</div><div class=\"line\">compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div></pre></td></tr></table></figure>\n<p>我们最常用的是第一种方法。</p>\n<p>有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile(&quot;com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version&quot;) &#123;</div><div class=\"line\">    exclude group: &apos;com.squareup.retrofit2&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于如何上传仓库这里暂时不介绍,<a href=\"https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle\" target=\"_blank\" rel=\"external\">可以看这里</a></p>\n<h3 id=\"2-编写gradle脚本\"><a href=\"#2-编写gradle脚本\" class=\"headerlink\" title=\"2.编写gradle脚本\"></a>2.编写gradle脚本</h3><h4 id=\"2-1-Project-API\"><a href=\"#2-1-Project-API\" class=\"headerlink\" title=\"2.1 Project API\"></a>2.1 Project API</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">println project.buildDir</div></pre></td></tr></table></figure>\n<p>我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。</p>\n<h4 id=\"2-2-如何定义变量\"><a href=\"#2-2-如何定义变量\" class=\"headerlink\" title=\"2.2 如何定义变量\"></a>2.2 如何定义变量</h4><p>和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def my_name = &quot;guolei&quot;</div><div class=\"line\">println my_nme</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-Extra-属性\"><a href=\"#2-3-Extra-属性\" class=\"headerlink\" title=\"2.3 Extra 属性\"></a>2.3 Extra 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ext &#123;</div><div class=\"line\">    my_name = &quot;guolei&quot;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">println ext.my_name;</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-TASK\"><a href=\"#2-4-TASK\" class=\"headerlink\" title=\"2.4 TASK\"></a>2.4 TASK</h4><p>gradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。<a href=\"https://docs.gradle.org/current/javadoc/\" target=\"_blank\" rel=\"external\">gradle api文档地址</a>，关于Api的使用，这里就不介绍了，文档上使用方法很全。</p>\n<h4 id=\"2-5-TASK之间的依赖关系\"><a href=\"#2-5-TASK之间的依赖关系\" class=\"headerlink\" title=\"2.5 TASK之间的依赖关系\"></a>2.5 TASK之间的依赖关系</h4><p>我们可以使用dependsOn来指明task之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">taskX.dependsOn taskY</div></pre></td></tr></table></figure>\n<p>如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。</p>\n<h4 id=\"2-6-有序的TASKS\"><a href=\"#2-6-有序的TASKS\" class=\"headerlink\" title=\"2.6 有序的TASKS\"></a>2.6 有序的TASKS</h4><ul>\n<li>shouldRunAfter</li>\n<li>mustRunAfter</li>\n</ul>\n<h4 id=\"2-7-给task添加描述\"><a href=\"#2-7-给task添加描述\" class=\"headerlink\" title=\"2.7 给task添加描述\"></a>2.7 给task添加描述</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">task a &#123;</div><div class=\"line\">\tdescription &quot;xxx&quot;</div><div class=\"line\">\tprintln &quot;xx&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-8-跳过task不执行\"><a href=\"#2-8-跳过task不执行\" class=\"headerlink\" title=\"2.8 跳过task不执行\"></a>2.8 跳过task不执行</h4><ul>\n<li>onlyIf,满足条件的情况下才执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">task hello &#123;</div><div class=\"line\">    doLast &#123;</div><div class=\"line\">        println &apos;hello world&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">hello.onlyIf &#123; !project.hasProperty(&apos;skipHello&apos;) &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>用异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile.doFirst &#123;</div><div class=\"line\">    // Here you would put arbitrary conditions in real life.</div><div class=\"line\">    // But this is used in an integration test so we want defined behavior.</div><div class=\"line\">    if (true) &#123; throw new StopExecutionException() &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>enabled属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task.enabled = false</div></pre></td></tr></table></figure>\n<h3 id=\"3-如何操作文件\"><a href=\"#3-如何操作文件\" class=\"headerlink\" title=\"3.如何操作文件\"></a>3.如何操作文件</h3><p>我们可以利用Project.file 方法去获取文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Using a relative path</div><div class=\"line\">File configFile = file(&apos;src/config.xml&apos;)</div><div class=\"line\"></div><div class=\"line\">// Using an absolute path</div><div class=\"line\">configFile = file(configFile.absolutePath)</div><div class=\"line\"></div><div class=\"line\">// Using a File object with a relative path</div><div class=\"line\">configFile = file(new File(&apos;src/config.xml&apos;))</div></pre></td></tr></table></figure>\n<p>然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">FileCollection collection = files(&apos;src/file1.txt&apos;,new File(&apos;src/file2.txt&apos;),[&apos;src/file3.txt&apos;, &apos;src/file4.txt&apos;])</div></pre></td></tr></table></figure>\n<p>可以利用Project.fileTree获取文件树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Create a file tree with a base directory</div><div class=\"line\">FileTree tree = fileTree(dir: &apos;src/main&apos;)</div><div class=\"line\"></div><div class=\"line\">// Add include and exclude patterns to the tree</div><div class=\"line\">tree.include &apos;**/*.java&apos;</div><div class=\"line\">tree.exclude &apos;**/Abstract*&apos;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using path</div><div class=\"line\">tree = fileTree(&apos;src&apos;).include(&apos;**/*.java&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a tree using closure</div><div class=\"line\">tree = fileTree(&apos;src&apos;) &#123;</div><div class=\"line\">    include &apos;**/*.java&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using a map</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;)</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, includes: [&apos;**/*.java&apos;, &apos;**/*.xml&apos;])</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;, exclude: &apos;**/*test*/**&apos;)</div></pre></td></tr></table></figure>\n<p>我们可以操作压缩文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// Create a ZIP file tree using path</div><div class=\"line\">FileTree zip = zipTree(&apos;someFile.zip&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a TAR file tree using path</div><div class=\"line\">FileTree tar = tarTree(&apos;someFile.tar&apos;)</div><div class=\"line\"></div><div class=\"line\">//tar tree attempts to guess the compression based on the file extension</div><div class=\"line\">//however if you must specify the compression explicitly you can:</div><div class=\"line\">FileTree someTar = tarTree(resources.gzip(&apos;someTar.ext&apos;))</div></pre></td></tr></table></figure>\n<p>文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。</p>\n<p>关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。</p>\n<h3 id=\"4-如何打log\"><a href=\"#4-如何打log\" class=\"headerlink\" title=\"4. 如何打log\"></a>4. 如何打log</h3><p>我们可以通过logger的一些方法输出log日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ogger.quiet(&apos;An info log message which is always logged.&apos;)</div><div class=\"line\">logger.error(&apos;An error log message.&apos;)</div><div class=\"line\">logger.warn(&apos;A warning log message.&apos;)</div><div class=\"line\">logger.lifecycle(&apos;A lifecycle info log message.&apos;)</div><div class=\"line\">logger.info(&apos;An info log message.&apos;)</div><div class=\"line\">logger.debug(&apos;A debug log message.&apos;)</div><div class=\"line\">logger.trace(&apos;A trace log message.&apos;)</div></pre></td></tr></table></figure>\n<h3 id=\"5-gradle-plugins\"><a href=\"#5-gradle-plugins\" class=\"headerlink\" title=\"5. gradle plugins\"></a>5. gradle plugins</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply from: &apos;other.gradle&apos;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins &#123;</div><div class=\"line\">    id «plugin id» version «plugin version» [apply «false»]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;org.gradle.sample.goodbye&apos;</div></pre></td></tr></table></figure>\n<p>三种方式。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>上面的一些用法，全部来自于文档.</p>\n<p><a href=\"https://docs.gradle.org/current/userguide/\" target=\"_blank\" rel=\"external\">gradle 文档地址</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","excerpt":"<p><Excerpt in index | 首页摘要><br>想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。</p>\n<h3 id=\"1-依赖管理\"><a href=\"#1-依赖管理\" class=\"headerlink\" title=\"1.依赖管理\"></a>1.依赖管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div><div class=\"line\">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.+&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<ul>\n<li>respositories 声明我们要使用的仓库</li>\n<li>dependencies 我们要依赖的一些东西<ul>\n<li>compile 依赖需要编译生产项目的来源</li>\n<li>runtime 依赖运行时字节码</li>\n<li>testCompile 依赖测试代码</li>\n<li>testRuntime </li>\n</ul>\n</li>\n</ul>\n<p>通常，我们声明仓库有两种方式</p>\n<ul>\n<li>使用中央仓库 mavenCentral()</li>\n<li><p>使用自己的仓库</p>\n<ul>\n<li><p>使用远程仓库</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\trepositories &#123;</div><div class=\"line\">    maven &#123;</div><div class=\"line\">    \t// 自己远程仓库地址</div><div class=\"line\">        url &quot;http://repo.mycompany.com/maven2&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用本地仓库     </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\trepositories &#123;</div><div class=\"line\">    ivy &#123;</div><div class=\"line\">        // URL can refer to a local directory</div><div class=\"line\">        url &quot;../local-repo&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>再说我们的依赖包管理，同样有两种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos;</div><div class=\"line\">// 2</div><div class=\"line\">compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div></pre></td></tr></table></figure>\n<p>我们最常用的是第一种方法。</p>\n<p>有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile(&quot;com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version&quot;) &#123;</div><div class=\"line\">    exclude group: &apos;com.squareup.retrofit2&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于如何上传仓库这里暂时不介绍,<a href=\"https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle\">可以看这里</a></p>\n<h3 id=\"2-编写gradle脚本\"><a href=\"#2-编写gradle脚本\" class=\"headerlink\" title=\"2.编写gradle脚本\"></a>2.编写gradle脚本</h3><h4 id=\"2-1-Project-API\"><a href=\"#2-1-Project-API\" class=\"headerlink\" title=\"2.1 Project API\"></a>2.1 Project API</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">println project.buildDir</div></pre></td></tr></table></figure>\n<p>我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。</p>\n<h4 id=\"2-2-如何定义变量\"><a href=\"#2-2-如何定义变量\" class=\"headerlink\" title=\"2.2 如何定义变量\"></a>2.2 如何定义变量</h4><p>和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def my_name = &quot;guolei&quot;</div><div class=\"line\">println my_nme</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-Extra-属性\"><a href=\"#2-3-Extra-属性\" class=\"headerlink\" title=\"2.3 Extra 属性\"></a>2.3 Extra 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ext &#123;</div><div class=\"line\">    my_name = &quot;guolei&quot;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">println ext.my_name;</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-TASK\"><a href=\"#2-4-TASK\" class=\"headerlink\" title=\"2.4 TASK\"></a>2.4 TASK</h4><p>gradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。<a href=\"https://docs.gradle.org/current/javadoc/\">gradle api文档地址</a>，关于Api的使用，这里就不介绍了，文档上使用方法很全。</p>\n<h4 id=\"2-5-TASK之间的依赖关系\"><a href=\"#2-5-TASK之间的依赖关系\" class=\"headerlink\" title=\"2.5 TASK之间的依赖关系\"></a>2.5 TASK之间的依赖关系</h4><p>我们可以使用dependsOn来指明task之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">taskX.dependsOn taskY</div></pre></td></tr></table></figure>\n<p>如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。</p>\n<h4 id=\"2-6-有序的TASKS\"><a href=\"#2-6-有序的TASKS\" class=\"headerlink\" title=\"2.6 有序的TASKS\"></a>2.6 有序的TASKS</h4><ul>\n<li>shouldRunAfter</li>\n<li>mustRunAfter</li>\n</ul>\n<h4 id=\"2-7-给task添加描述\"><a href=\"#2-7-给task添加描述\" class=\"headerlink\" title=\"2.7 给task添加描述\"></a>2.7 给task添加描述</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">task a &#123;</div><div class=\"line\">\tdescription &quot;xxx&quot;</div><div class=\"line\">\tprintln &quot;xx&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-8-跳过task不执行\"><a href=\"#2-8-跳过task不执行\" class=\"headerlink\" title=\"2.8 跳过task不执行\"></a>2.8 跳过task不执行</h4><ul>\n<li>onlyIf,满足条件的情况下才执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">task hello &#123;</div><div class=\"line\">    doLast &#123;</div><div class=\"line\">        println &apos;hello world&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">hello.onlyIf &#123; !project.hasProperty(&apos;skipHello&apos;) &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>用异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile.doFirst &#123;</div><div class=\"line\">    // Here you would put arbitrary conditions in real life.</div><div class=\"line\">    // But this is used in an integration test so we want defined behavior.</div><div class=\"line\">    if (true) &#123; throw new StopExecutionException() &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>enabled属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task.enabled = false</div></pre></td></tr></table></figure>\n<h3 id=\"3-如何操作文件\"><a href=\"#3-如何操作文件\" class=\"headerlink\" title=\"3.如何操作文件\"></a>3.如何操作文件</h3><p>我们可以利用Project.file 方法去获取文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Using a relative path</div><div class=\"line\">File configFile = file(&apos;src/config.xml&apos;)</div><div class=\"line\"></div><div class=\"line\">// Using an absolute path</div><div class=\"line\">configFile = file(configFile.absolutePath)</div><div class=\"line\"></div><div class=\"line\">// Using a File object with a relative path</div><div class=\"line\">configFile = file(new File(&apos;src/config.xml&apos;))</div></pre></td></tr></table></figure>\n<p>然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">FileCollection collection = files(&apos;src/file1.txt&apos;,new File(&apos;src/file2.txt&apos;),[&apos;src/file3.txt&apos;, &apos;src/file4.txt&apos;])</div></pre></td></tr></table></figure>\n<p>可以利用Project.fileTree获取文件树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Create a file tree with a base directory</div><div class=\"line\">FileTree tree = fileTree(dir: &apos;src/main&apos;)</div><div class=\"line\"></div><div class=\"line\">// Add include and exclude patterns to the tree</div><div class=\"line\">tree.include &apos;**/*.java&apos;</div><div class=\"line\">tree.exclude &apos;**/Abstract*&apos;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using path</div><div class=\"line\">tree = fileTree(&apos;src&apos;).include(&apos;**/*.java&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a tree using closure</div><div class=\"line\">tree = fileTree(&apos;src&apos;) &#123;</div><div class=\"line\">    include &apos;**/*.java&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using a map</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;)</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, includes: [&apos;**/*.java&apos;, &apos;**/*.xml&apos;])</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;, exclude: &apos;**/*test*/**&apos;)</div></pre></td></tr></table></figure>\n<p>我们可以操作压缩文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// Create a ZIP file tree using path</div><div class=\"line\">FileTree zip = zipTree(&apos;someFile.zip&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a TAR file tree using path</div><div class=\"line\">FileTree tar = tarTree(&apos;someFile.tar&apos;)</div><div class=\"line\"></div><div class=\"line\">//tar tree attempts to guess the compression based on the file extension</div><div class=\"line\">//however if you must specify the compression explicitly you can:</div><div class=\"line\">FileTree someTar = tarTree(resources.gzip(&apos;someTar.ext&apos;))</div></pre></td></tr></table></figure>\n<p>文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。</p>\n<p>关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。</p>\n<h3 id=\"4-如何打log\"><a href=\"#4-如何打log\" class=\"headerlink\" title=\"4. 如何打log\"></a>4. 如何打log</h3><p>我们可以通过logger的一些方法输出log日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ogger.quiet(&apos;An info log message which is always logged.&apos;)</div><div class=\"line\">logger.error(&apos;An error log message.&apos;)</div><div class=\"line\">logger.warn(&apos;A warning log message.&apos;)</div><div class=\"line\">logger.lifecycle(&apos;A lifecycle info log message.&apos;)</div><div class=\"line\">logger.info(&apos;An info log message.&apos;)</div><div class=\"line\">logger.debug(&apos;A debug log message.&apos;)</div><div class=\"line\">logger.trace(&apos;A trace log message.&apos;)</div></pre></td></tr></table></figure>\n<h3 id=\"5-gradle-plugins\"><a href=\"#5-gradle-plugins\" class=\"headerlink\" title=\"5. gradle plugins\"></a>5. gradle plugins</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply from: &apos;other.gradle&apos;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins &#123;</div><div class=\"line\">    id «plugin id» version «plugin version» [apply «false»]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;org.gradle.sample.goodbye&apos;</div></pre></td></tr></table></figure>\n<p>三种方式。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>上面的一些用法，全部来自于文档.</p>\n<p><a href=\"https://docs.gradle.org/current/userguide/\">gradle 文档地址</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解gradle（二）-扩展gradle","date":"2016-12-06T03:41:32.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n```Groovy\ntask printString(type:GettingTask)\n```\n\n那么问题来了，我们如何向其中传递参数呢？\n\n* 首先，我们在class里面加成员变量\n* 然后，我们调用的时候，传入值\n\n\n\n\t```Groovy\n\ttask testPrint(type:GettingTask){\n\t// 这里用＝ 或者空格\n    string = \"guolei\"\n}\n\nclass GettingTask extends DefaultTask{\n\n    String string = \"xxxx\"\n\n    @TaskAction\n    def greet(){\n        println string\n    }\n}\n\t```\n\t\n\t\n\n### 2. 编写独立的插件程序\n\n可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。\n\n然后，在gradle中，依赖groovy\n\n```Groovy\napply plugin: 'groovy'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n```\n\n在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。\n\n接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建\"plugin_id\".properties目录，用来配置gradle插件，在文件中配置插件。\n\n```Groovy\nimplementation-class=com.gl.HelloPlugin\n```\n后面对应插件实现。\n\n最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。\n\n```Groovy\napply plugin: 'groovy'\napply plugin: 'maven'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n\nrepositories {\n    mavenCentral()\n}\n\ngroup='com.gl.HelloPlugin'\nversion='1.0.0'\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri('../repo'))\n        }\n    }\n}\n\n```\n\n在右侧图形界面或者命令执行uploadArchives，就发布成功了。\n\n如何使用，首先我们在跟目录下配置mevan仓库。\n\n```Groovy\nmaven {\n            url uri('./repo')\n        }\n        \n```\n\n然后依赖插件\n\n```Groovy\nclasspath 'com.gl.HelloPlugin:gradleplugin:1.0.0'\n```\n\n解释一下，后面分为三个部分\n\n* 第一部分，插件实现的路径\n* 你创建插件时候的model 名\n* 插件版本\n\n\n这三个也可以通过查看 repo下的路径得到，\n\n最后，在我们想用的地方\n\n```Groovy\napply plugin:'com.gl.plugin'\n```\n\n* 后面跟的是pluginid，也就是我们上面properties文件的前半部分。\n\n\n可以看到，开发过程基本和apt 编译时注解流程一致。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/了解gradle（二）-扩展gradle.md","raw":"---\ntitle: 了解gradle（二）-扩展gradle\ndate: 2016-12-06 11:41:32\ncategories: Gradle\ntags: gradle\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n```Groovy\ntask printString(type:GettingTask)\n```\n\n那么问题来了，我们如何向其中传递参数呢？\n\n* 首先，我们在class里面加成员变量\n* 然后，我们调用的时候，传入值\n\n\n\n\t```Groovy\n\ttask testPrint(type:GettingTask){\n\t// 这里用＝ 或者空格\n    string = \"guolei\"\n}\n\nclass GettingTask extends DefaultTask{\n\n    String string = \"xxxx\"\n\n    @TaskAction\n    def greet(){\n        println string\n    }\n}\n\t```\n\t\n\t\n\n### 2. 编写独立的插件程序\n\n可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。\n\n然后，在gradle中，依赖groovy\n\n```Groovy\napply plugin: 'groovy'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n```\n\n在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。\n\n接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建\"plugin_id\".properties目录，用来配置gradle插件，在文件中配置插件。\n\n```Groovy\nimplementation-class=com.gl.HelloPlugin\n```\n后面对应插件实现。\n\n最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。\n\n```Groovy\napply plugin: 'groovy'\napply plugin: 'maven'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n\nrepositories {\n    mavenCentral()\n}\n\ngroup='com.gl.HelloPlugin'\nversion='1.0.0'\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri('../repo'))\n        }\n    }\n}\n\n```\n\n在右侧图形界面或者命令执行uploadArchives，就发布成功了。\n\n如何使用，首先我们在跟目录下配置mevan仓库。\n\n```Groovy\nmaven {\n            url uri('./repo')\n        }\n        \n```\n\n然后依赖插件\n\n```Groovy\nclasspath 'com.gl.HelloPlugin:gradleplugin:1.0.0'\n```\n\n解释一下，后面分为三个部分\n\n* 第一部分，插件实现的路径\n* 你创建插件时候的model 名\n* 插件版本\n\n\n这三个也可以通过查看 repo下的路径得到，\n\n最后，在我们想用的地方\n\n```Groovy\napply plugin:'com.gl.plugin'\n```\n\n* 后面跟的是pluginid，也就是我们上面properties文件的前半部分。\n\n\n可以看到，开发过程基本和apt 编译时注解流程一致。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"了解gradle（二）-扩展gradle","published":1,"updated":"2017-01-06T05:29:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yv001tuaxaldnv2xrr","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-如何编写一个task类\"><a href=\"#1-如何编写一个task类\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n</the></li>\n</ul>\n<h3 id=\"1-如何编写一个task类-1\"><a href=\"#1-如何编写一个task类-1\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task printString(<span class=\"string\">type:</span>GettingTask)</div></pre></td></tr></table></figure>\n<p>那么问题来了，我们如何向其中传递参数呢？</p>\n<ul>\n<li>首先，我们在class里面加成员变量</li>\n<li>然后，我们调用的时候，传入值</li>\n</ul>\n<pre><code><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttask testPrint(<span class=\"string\">type:</span>GettingTask)&#123;</div><div class=\"line\">\t<span class=\"comment\">// 这里用＝ 或者空格</span></div><div class=\"line\">    string = <span class=\"string\">\"guolei\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\"></div><div class=\"line\">    String string = <span class=\"string\">\"xxxx\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println string</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</code></pre><h3 id=\"2-编写独立的插件程序\"><a href=\"#2-编写独立的插件程序\" class=\"headerlink\" title=\"2. 编写独立的插件程序\"></a>2. 编写独立的插件程序</h3><p>可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。</p>\n<p>然后，在gradle中，依赖groovy</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<project>接口，实现apply方法。</project></p>\n<p>接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建”plugin_id”.properties目录，用来配置gradle插件，在文件中配置插件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">implementation-<span class=\"class\"><span class=\"keyword\">class</span>=<span class=\"title\">com</span>.<span class=\"title\">gl</span>.<span class=\"title\">HelloPlugin</span></span></div></pre></td></tr></table></figure>\n<p>后面对应插件实现。</p>\n<p>最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'maven'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">group=<span class=\"string\">'com.gl.HelloPlugin'</span></div><div class=\"line\">version=<span class=\"string\">'1.0.0'</span></div><div class=\"line\">uploadArchives &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        mavenDeployer &#123;</div><div class=\"line\">            repository(<span class=\"string\">url:</span> uri(<span class=\"string\">'../repo'</span>))</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在右侧图形界面或者命令执行uploadArchives，就发布成功了。</p>\n<p>如何使用，首先我们在跟目录下配置mevan仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">maven &#123;</div><div class=\"line\">            url uri(<span class=\"string\">'./repo'</span>)</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>然后依赖插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classpath <span class=\"string\">'com.gl.HelloPlugin:gradleplugin:1.0.0'</span></div></pre></td></tr></table></figure>\n<p>解释一下，后面分为三个部分</p>\n<ul>\n<li>第一部分，插件实现的路径</li>\n<li>你创建插件时候的model 名</li>\n<li>插件版本</li>\n</ul>\n<p>这三个也可以通过查看 repo下的路径得到，</p>\n<p>最后，在我们想用的地方</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span><span class=\"string\">'com.gl.plugin'</span></div></pre></td></tr></table></figure>\n<ul>\n<li>后面跟的是pluginid，也就是我们上面properties文件的前半部分。</li>\n</ul>\n<p>可以看到，开发过程基本和apt 编译时注解流程一致。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-如何编写一个task类\"><a href=\"#1-如何编写一个task类\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n</li>\n</ul>\n<h3 id=\"1-如何编写一个task类-1\"><a href=\"#1-如何编写一个task类-1\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task printString(<span class=\"string\">type:</span>GettingTask)</div></pre></td></tr></table></figure>\n<p>那么问题来了，我们如何向其中传递参数呢？</p>\n<ul>\n<li>首先，我们在class里面加成员变量</li>\n<li>然后，我们调用的时候，传入值</li>\n</ul>\n<pre><code><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttask testPrint(<span class=\"string\">type:</span>GettingTask)&#123;</div><div class=\"line\">\t<span class=\"comment\">// 这里用＝ 或者空格</span></div><div class=\"line\">    string = <span class=\"string\">\"guolei\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\"></div><div class=\"line\">    String string = <span class=\"string\">\"xxxx\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println string</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</code></pre><h3 id=\"2-编写独立的插件程序\"><a href=\"#2-编写独立的插件程序\" class=\"headerlink\" title=\"2. 编写独立的插件程序\"></a>2. 编写独立的插件程序</h3><p>可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。</p>\n<p>然后，在gradle中，依赖groovy</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。</p>\n<p>接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建”plugin_id”.properties目录，用来配置gradle插件，在文件中配置插件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">implementation-<span class=\"class\"><span class=\"keyword\">class</span>=<span class=\"title\">com</span>.<span class=\"title\">gl</span>.<span class=\"title\">HelloPlugin</span></span></div></pre></td></tr></table></figure>\n<p>后面对应插件实现。</p>\n<p>最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'maven'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">group=<span class=\"string\">'com.gl.HelloPlugin'</span></div><div class=\"line\">version=<span class=\"string\">'1.0.0'</span></div><div class=\"line\">uploadArchives &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        mavenDeployer &#123;</div><div class=\"line\">            repository(<span class=\"string\">url:</span> uri(<span class=\"string\">'../repo'</span>))</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在右侧图形界面或者命令执行uploadArchives，就发布成功了。</p>\n<p>如何使用，首先我们在跟目录下配置mevan仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">maven &#123;</div><div class=\"line\">            url uri(<span class=\"string\">'./repo'</span>)</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>然后依赖插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classpath <span class=\"string\">'com.gl.HelloPlugin:gradleplugin:1.0.0'</span></div></pre></td></tr></table></figure>\n<p>解释一下，后面分为三个部分</p>\n<ul>\n<li>第一部分，插件实现的路径</li>\n<li>你创建插件时候的model 名</li>\n<li>插件版本</li>\n</ul>\n<p>这三个也可以通过查看 repo下的路径得到，</p>\n<p>最后，在我们想用的地方</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span><span class=\"string\">'com.gl.plugin'</span></div></pre></td></tr></table></figure>\n<ul>\n<li>后面跟的是pluginid，也就是我们上面properties文件的前半部分。</li>\n</ul>\n<p>可以看到，开发过程基本和apt 编译时注解流程一致。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"消息机制在多进程的应用","date":"2017-01-01T13:40:11.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2. 如何使用Messenger\n\n#### 2.1 Messenger 服务端\n\n首先我们需要一个messenger，并传入一个handler。\n\n```java\nprivate Messenger messenger = new Messenger(new MessengerHandler());\n```\n\n其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。\n\n```java\n    @Override\n    public IBinder onBind(Intent intent) {\n        return messenger.getBinder();\n    }\n```\n\n在这个handler的handleMessage方法中，获取客户端发送的消息。\n\n```java\n    private class MessengerHandler extends Handler{\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_CLIENT:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    Messenger client = msg.replyTo;\n                    if (client != null){\n                        Message message = Message.obtain(null,Constants.MSG_FROM_SERVER);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(Constants.MSG_DATA,\"from server\");\n                        message.setData(bundle);\n                        try {\n                            client.send(message);\n                        } catch (RemoteException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    }\n```\n\n最后，在配置文件中，将这个service开启process，开启另一个进程。\n\n#### 2.2 客户端\n\n想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，\n\n```java\n    public Handler getFromServer = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_SERVER:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    };\n\n    private Messenger getReplyMessenger = new Messenger(getFromServer);\n\n    public ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            messenger = new Messenger(service);\n            Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);\n            Bundle bundle = new Bundle();\n            bundle.putString(Constants.MSG_DATA,\"from client\");\n            msg.setData(bundle);\n            msg.replyTo=getReplyMessenger;\n            try {\n                messenger.send(msg);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n```\n\n### 3. 简单分析\n\n之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。\n\n首先是Messenger的getBinder方法，这个方法返回一个binder对象。\n\n```java\n    public IBinder getBinder() {\n        return mTarget.asBinder();\n    }\n```\n\n其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。\n\n```java\n    private final class MessengerImpl extends IMessenger.Stub {\n        public void send(Message msg) {\n            msg.sendingUid = Binder.getCallingUid();\n            Handler.this.sendMessage(msg);\n        }\n    }\n```\n\n而Messenger的send方法。就是调用这里的send方法。\n\n\n### 4. 总结\n\n其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","source":"_posts/消息机制在多进程的应用.md","raw":"---\ntitle: 消息机制在多进程的应用\ndate: 2017-01-01 21:40:11\ncategories: Android\ntags: [android,消息机制]\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2. 如何使用Messenger\n\n#### 2.1 Messenger 服务端\n\n首先我们需要一个messenger，并传入一个handler。\n\n```java\nprivate Messenger messenger = new Messenger(new MessengerHandler());\n```\n\n其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。\n\n```java\n    @Override\n    public IBinder onBind(Intent intent) {\n        return messenger.getBinder();\n    }\n```\n\n在这个handler的handleMessage方法中，获取客户端发送的消息。\n\n```java\n    private class MessengerHandler extends Handler{\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_CLIENT:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    Messenger client = msg.replyTo;\n                    if (client != null){\n                        Message message = Message.obtain(null,Constants.MSG_FROM_SERVER);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(Constants.MSG_DATA,\"from server\");\n                        message.setData(bundle);\n                        try {\n                            client.send(message);\n                        } catch (RemoteException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    }\n```\n\n最后，在配置文件中，将这个service开启process，开启另一个进程。\n\n#### 2.2 客户端\n\n想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，\n\n```java\n    public Handler getFromServer = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_SERVER:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    };\n\n    private Messenger getReplyMessenger = new Messenger(getFromServer);\n\n    public ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            messenger = new Messenger(service);\n            Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);\n            Bundle bundle = new Bundle();\n            bundle.putString(Constants.MSG_DATA,\"from client\");\n            msg.setData(bundle);\n            msg.replyTo=getReplyMessenger;\n            try {\n                messenger.send(msg);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n```\n\n### 3. 简单分析\n\n之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。\n\n首先是Messenger的getBinder方法，这个方法返回一个binder对象。\n\n```java\n    public IBinder getBinder() {\n        return mTarget.asBinder();\n    }\n```\n\n其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。\n\n```java\n    private final class MessengerImpl extends IMessenger.Stub {\n        public void send(Message msg) {\n            msg.sendingUid = Binder.getCallingUid();\n            Handler.this.sendMessage(msg);\n        }\n    }\n```\n\n而Messenger的send方法。就是调用这里的send方法。\n\n\n### 4. 总结\n\n其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","slug":"消息机制在多进程的应用","published":1,"updated":"2017-01-06T05:29:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yw001xuaxa561d3m4b","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<h3 id=\"2-如何使用Messenger\"><a href=\"#2-如何使用Messenger\" class=\"headerlink\" title=\"2. 如何使用Messenger\"></a>2. 如何使用Messenger</h3><h4 id=\"2-1-Messenger-服务端\"><a href=\"#2-1-Messenger-服务端\" class=\"headerlink\" title=\"2.1 Messenger 服务端\"></a>2.1 Messenger 服务端</h4><p>首先我们需要一个messenger，并传入一个handler。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Messenger messenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> MessengerHandler());</div></pre></td></tr></table></figure>\n<p>其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> messenger.getBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个handler的handleMessage方法中，获取客户端发送的消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_CLIENT:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                Messenger client = msg.replyTo;</div><div class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">                    Message message = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_SERVER);</div><div class=\"line\">                    Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">                    bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from server\"</span>);</div><div class=\"line\">                    message.setData(bundle);</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        client.send(message);</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">                        e.printStackTrace();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在配置文件中，将这个service开启process，开启另一个进程。</p>\n<h4 id=\"2-2-客户端\"><a href=\"#2-2-客户端\" class=\"headerlink\" title=\"2.2 客户端\"></a>2.2 客户端</h4><p>想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> Handler getFromServer = <span class=\"keyword\">new</span> Handler()&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_SERVER:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Messenger getReplyMessenger = <span class=\"keyword\">new</span> Messenger(getFromServer);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> ServiceConnection connection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class=\"line\">        messenger = <span class=\"keyword\">new</span> Messenger(service);</div><div class=\"line\">        Message msg = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_CLIENT);</div><div class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">        bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from client\"</span>);</div><div class=\"line\">        msg.setData(bundle);</div><div class=\"line\">        msg.replyTo=getReplyMessenger;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            messenger.send(msg);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-简单分析\"><a href=\"#3-简单分析\" class=\"headerlink\" title=\"3. 简单分析\"></a>3. 简单分析</h3><p>之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。</p>\n<p>首先是Messenger的getBinder方法，这个方法返回一个binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">getBinder</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mTarget.asBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        msg.sendingUid = Binder.getCallingUid();</div><div class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而Messenger的send方法。就是调用这里的send方法。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<h3 id=\"2-如何使用Messenger\"><a href=\"#2-如何使用Messenger\" class=\"headerlink\" title=\"2. 如何使用Messenger\"></a>2. 如何使用Messenger</h3><h4 id=\"2-1-Messenger-服务端\"><a href=\"#2-1-Messenger-服务端\" class=\"headerlink\" title=\"2.1 Messenger 服务端\"></a>2.1 Messenger 服务端</h4><p>首先我们需要一个messenger，并传入一个handler。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Messenger messenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> MessengerHandler());</div></pre></td></tr></table></figure>\n<p>其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> messenger.getBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个handler的handleMessage方法中，获取客户端发送的消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_CLIENT:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                Messenger client = msg.replyTo;</div><div class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">                    Message message = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_SERVER);</div><div class=\"line\">                    Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">                    bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from server\"</span>);</div><div class=\"line\">                    message.setData(bundle);</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        client.send(message);</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">                        e.printStackTrace();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在配置文件中，将这个service开启process，开启另一个进程。</p>\n<h4 id=\"2-2-客户端\"><a href=\"#2-2-客户端\" class=\"headerlink\" title=\"2.2 客户端\"></a>2.2 客户端</h4><p>想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> Handler getFromServer = <span class=\"keyword\">new</span> Handler()&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_SERVER:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Messenger getReplyMessenger = <span class=\"keyword\">new</span> Messenger(getFromServer);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> ServiceConnection connection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class=\"line\">        messenger = <span class=\"keyword\">new</span> Messenger(service);</div><div class=\"line\">        Message msg = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_CLIENT);</div><div class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">        bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from client\"</span>);</div><div class=\"line\">        msg.setData(bundle);</div><div class=\"line\">        msg.replyTo=getReplyMessenger;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            messenger.send(msg);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-简单分析\"><a href=\"#3-简单分析\" class=\"headerlink\" title=\"3. 简单分析\"></a>3. 简单分析</h3><p>之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。</p>\n<p>首先是Messenger的getBinder方法，这个方法返回一个binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">getBinder</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mTarget.asBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        msg.sendingUid = Binder.getCallingUid();</div><div class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而Messenger的send方法。就是调用这里的send方法。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"记不住adb命令？试试shell吧","date":"2016-12-20T15:06:36.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. push and pull file\n\n要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。\n\n```shell\n#!/bin/bash\n\nbasedir=\"pull_dir\"\n\nmkdir ${basedir}\n\ntopath=\"./${basedir}/\"\n\nif [ $# = 0 ]\nthen\n\techo 'please input fromfile'\n\texit\nfi\n\nfrompath=$1\n\nadb pull $1 ${topath}\n\n```\n\n```shell\ntopath=\"sdcard/\"\n\nif [ $# = 0 ]\nthen\n\techo \"please input file path\"\n\texit\nfi\n\nfilepath=$1\n\nif [ $# = 2 ]\nthen\n\ttopath=$2\nfi\n\nadb push ${filepath} ${topath}\n\n```\n\n### 3. dumps 一些信息\n\n有时候我们需要dump一些信息出来，比如内存，电量等等。\n\n```shell\n\nfilepath=`./custom.sh`\n\nresult=\"\"\n\nfilename=\"\"\n\nif [ $# = 0 ]\nthen\n\tfilename=\"meminfo_all\"\n\tresult=`adb shell dumpsys meminfo`\nelse\n\tfilename=\"memoinfo_pkg\"\n\tresult=`adb shell dumpsys meminfo $1`\nfi\n\n#echo \"hello\" >> \"${filepath}${filename}\"\necho \"$result\" >> \"${filepath}${filename}\"\n```\n\n```shell\nfilepath=`./custom.sh`\n\nresult=`adb shell dumpsys power`\n\nfilename=\"power_state\"\n\n```\n\n### 4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\n\n[Android测试中常用到的脚本](https://github.com/gb112211/AndroidTestScripts)\n\n### 5. 总结\n\n总之，用shell 和 python等一些脚本，能够做出很多好玩的事。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/记不住adb命令？试试shell吧.md","raw":"---\ntitle: 记不住adb命令？试试shell吧\ndate: 2016-12-20 23:06:36\ncategories: shell\ntags: shell\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. push and pull file\n\n要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。\n\n```shell\n#!/bin/bash\n\nbasedir=\"pull_dir\"\n\nmkdir ${basedir}\n\ntopath=\"./${basedir}/\"\n\nif [ $# = 0 ]\nthen\n\techo 'please input fromfile'\n\texit\nfi\n\nfrompath=$1\n\nadb pull $1 ${topath}\n\n```\n\n```shell\ntopath=\"sdcard/\"\n\nif [ $# = 0 ]\nthen\n\techo \"please input file path\"\n\texit\nfi\n\nfilepath=$1\n\nif [ $# = 2 ]\nthen\n\ttopath=$2\nfi\n\nadb push ${filepath} ${topath}\n\n```\n\n### 3. dumps 一些信息\n\n有时候我们需要dump一些信息出来，比如内存，电量等等。\n\n```shell\n\nfilepath=`./custom.sh`\n\nresult=\"\"\n\nfilename=\"\"\n\nif [ $# = 0 ]\nthen\n\tfilename=\"meminfo_all\"\n\tresult=`adb shell dumpsys meminfo`\nelse\n\tfilename=\"memoinfo_pkg\"\n\tresult=`adb shell dumpsys meminfo $1`\nfi\n\n#echo \"hello\" >> \"${filepath}${filename}\"\necho \"$result\" >> \"${filepath}${filename}\"\n```\n\n```shell\nfilepath=`./custom.sh`\n\nresult=`adb shell dumpsys power`\n\nfilename=\"power_state\"\n\n```\n\n### 4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\n\n[Android测试中常用到的脚本](https://github.com/gb112211/AndroidTestScripts)\n\n### 5. 总结\n\n总之，用shell 和 python等一些脚本，能够做出很多好玩的事。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"记不住adb命令？试试shell吧","published":1,"updated":"2017-01-06T05:28:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yx0020uaxawyscvcld","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n</the></li>\n</ul>\n<h3 id=\"2-push-and-pull-file\"><a href=\"#2-push-and-pull-file\" class=\"headerlink\" title=\"2. push and pull file\"></a>2. push and pull file</h3><p>要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">basedir=&quot;pull_dir&quot;</div><div class=\"line\"></div><div class=\"line\">mkdir $&#123;basedir&#125;</div><div class=\"line\"></div><div class=\"line\">topath=&quot;./$&#123;basedir&#125;/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &apos;please input fromfile&apos;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">frompath=$1</div><div class=\"line\"></div><div class=\"line\">adb pull $1 $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">topath=&quot;sdcard/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &quot;please input file path&quot;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">filepath=$1</div><div class=\"line\"></div><div class=\"line\">if [ $# = 2 ]</div><div class=\"line\">then</div><div class=\"line\">\ttopath=$2</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">adb push $&#123;filepath&#125; $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-dumps-一些信息\"><a href=\"#3-dumps-一些信息\" class=\"headerlink\" title=\"3. dumps 一些信息\"></a>3. dumps 一些信息</h3><p>有时候我们需要dump一些信息出来，比如内存，电量等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">filename=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\tfilename=&quot;meminfo_all&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo`</div><div class=\"line\">else</div><div class=\"line\">\tfilename=&quot;memoinfo_pkg&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo $1`</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">#echo &quot;hello&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div><div class=\"line\">echo &quot;$result&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=`adb shell dumpsys power`</div><div class=\"line\"></div><div class=\"line\">filename=&quot;power_state&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"4-可以利用python-＋-adb命令，实现自动化一些自动化测试\"><a href=\"#4-可以利用python-＋-adb命令，实现自动化一些自动化测试\" class=\"headerlink\" title=\"4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\"></a>4. 可以利用python ＋ adb命令，实现自动化一些自动化测试</h3><p><a href=\"https://github.com/gb112211/AndroidTestScripts\" target=\"_blank\" rel=\"external\">Android测试中常用到的脚本</a></p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>总之，用shell 和 python等一些脚本，能够做出很多好玩的事。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n</li>\n</ul>\n<h3 id=\"2-push-and-pull-file\"><a href=\"#2-push-and-pull-file\" class=\"headerlink\" title=\"2. push and pull file\"></a>2. push and pull file</h3><p>要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">basedir=&quot;pull_dir&quot;</div><div class=\"line\"></div><div class=\"line\">mkdir $&#123;basedir&#125;</div><div class=\"line\"></div><div class=\"line\">topath=&quot;./$&#123;basedir&#125;/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &apos;please input fromfile&apos;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">frompath=$1</div><div class=\"line\"></div><div class=\"line\">adb pull $1 $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">topath=&quot;sdcard/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &quot;please input file path&quot;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">filepath=$1</div><div class=\"line\"></div><div class=\"line\">if [ $# = 2 ]</div><div class=\"line\">then</div><div class=\"line\">\ttopath=$2</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">adb push $&#123;filepath&#125; $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-dumps-一些信息\"><a href=\"#3-dumps-一些信息\" class=\"headerlink\" title=\"3. dumps 一些信息\"></a>3. dumps 一些信息</h3><p>有时候我们需要dump一些信息出来，比如内存，电量等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">filename=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\tfilename=&quot;meminfo_all&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo`</div><div class=\"line\">else</div><div class=\"line\">\tfilename=&quot;memoinfo_pkg&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo $1`</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">#echo &quot;hello&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div><div class=\"line\">echo &quot;$result&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=`adb shell dumpsys power`</div><div class=\"line\"></div><div class=\"line\">filename=&quot;power_state&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"4-可以利用python-＋-adb命令，实现自动化一些自动化测试\"><a href=\"#4-可以利用python-＋-adb命令，实现自动化一些自动化测试\" class=\"headerlink\" title=\"4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\"></a>4. 可以利用python ＋ adb命令，实现自动化一些自动化测试</h3><p><a href=\"https://github.com/gb112211/AndroidTestScripts\">Android测试中常用到的脚本</a></p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>总之，用shell 和 python等一些脚本，能够做出很多好玩的事。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"脚本打怪-shell篇","date":"2016-12-02T17:05:38.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.什么是shell\n\n什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.shell能干什么\n\nshell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。\n\n### 3.shell基础语法\n\n#### 3.1 变量\n```shell\n#变量名＝变量值\nmyname=\"guolei\"\necho ${myname}\n```\nshell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。\n\n如果我们想要定义一个数组怎么办？\n\n```shell\narr=(1 2 3 4)\necho $arr[0]\n```\n\n注意，元素之间没有逗号。\n\n#### 3.2 传递参数\n\n作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0... ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件\n\n\n#### 3.3 输出\n\nshell中有两种输出方式，\n\n* echo \n* printf\n\necho是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。\n\n\n\n### 4.shell运算符\n\n这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 ` `之内，如\n\n```shell\n`expr 2 + 2`\n```\n\n要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。\n\n而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算\n\n* -eq 是否相等,\n* -ne 是否不等\n* -gt 左边是否大于右边\n* -ge 左边是否大于等于右边\n* -lt 左边是否小于右边\n* -le 左边是否小于等于右边\n\n\n老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。\n\n布尔运算也是同理。\n\n* ! 非\n* -o 或\n* -a 与\n\nshell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。\n\n\n\n### 5.shell流程控制\n\nshell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。\n\n```shell\nif\nthen\n\tcommend...\nelse\n\tcommend...\nelif\n\tcommend...\nfi\n\nfor var in 1 2 3 4\ndo\n\tcommend...\ndone\n\nwhile xxx\ndo\n\tcommend...\ndone\n\n//until循环，\nuntil xxx\ndo\n\tcommend\ndone\n\n//case 比较恶心，我很不喜欢，需要用我再去学，嘿\n\nbreak，continue 什么也是有的\n```\n\n\n\n### 6.函数\n\n```shell\nsay(){\n\techo $i\n}\n\nsay 1\n```\n没错，上面就是函数的简单用法。\n\n* 我们不需要手动指定参数\n* 同样用$i 去获取参数\n* 像命令一样say 1 2 3，传递参数\n\n但是，从${10}开始，我们需要用大括号，扩起来。。\n\n### 7. 输入输出重定向\n\n略过略过，> < 将输入输出定向到其他位置（文件）\n\n### 8. 总结\n\nshell脚本学起来 编写起来都挺简单的。\n\n* \\* @，这些都表示全部，比如 $* $@,\n* \\# 哈，可以表示长度，如字符串长度，数组容量\n* 变量赋值 key=value 注意 中间不能有空格\n* 大小比较 -ge那些\n* 函数，通过$? 能获取到返回值，而不能通过赋值来获取\n* 如果参数大于10个，要用$(n)去获取\n\n不过，shell最好的一点是批命令处理。\n\n### 9. 举个小例子？\n\n```shell\ngit pull\n\ngit add ./\n\ngit commit -m \"xxx\"\n\ngit push\n```\n\n很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？\n\n```shell\ncms=\"update\"\n\nhexo g\n\ngit add ./\n\nif [ $# -ge 1 ]\nthen\n\tcms=$1\nfi\n\ngit commit -m $cms\n\ngit push\n\n```\n\n这不，我们通过shell 脚本，每次./update.sh ,多方便啊。\n\n### 10. 想法\n\n想什么呢？还不赶紧去get shell脚本这个技巧。\n\n不写脚本释放双手的程序员，不是好程序员。\n\n\n### 11. 入门链接\n\n[入门教程，看了还不会就可以转行了](http://www.runoob.com/linux/linux-shell.html)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/脚本打怪-shell篇.md","raw":"---\ntitle: 脚本打怪-shell篇\ndate: 2016-12-03 01:05:38\ncategories: shell\ntags: shell\n\n---\n<Excerpt in index | 首页摘要>\n### 1.什么是shell\n\n什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。\n\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.shell能干什么\n\nshell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。\n\n### 3.shell基础语法\n\n#### 3.1 变量\n```shell\n#变量名＝变量值\nmyname=\"guolei\"\necho ${myname}\n```\nshell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。\n\n如果我们想要定义一个数组怎么办？\n\n```shell\narr=(1 2 3 4)\necho $arr[0]\n```\n\n注意，元素之间没有逗号。\n\n#### 3.2 传递参数\n\n作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0... ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件\n\n\n#### 3.3 输出\n\nshell中有两种输出方式，\n\n* echo \n* printf\n\necho是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。\n\n\n\n### 4.shell运算符\n\n这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 ` `之内，如\n\n```shell\n`expr 2 + 2`\n```\n\n要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。\n\n而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算\n\n* -eq 是否相等,\n* -ne 是否不等\n* -gt 左边是否大于右边\n* -ge 左边是否大于等于右边\n* -lt 左边是否小于右边\n* -le 左边是否小于等于右边\n\n\n老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。\n\n布尔运算也是同理。\n\n* ! 非\n* -o 或\n* -a 与\n\nshell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。\n\n\n\n### 5.shell流程控制\n\nshell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。\n\n```shell\nif\nthen\n\tcommend...\nelse\n\tcommend...\nelif\n\tcommend...\nfi\n\nfor var in 1 2 3 4\ndo\n\tcommend...\ndone\n\nwhile xxx\ndo\n\tcommend...\ndone\n\n//until循环，\nuntil xxx\ndo\n\tcommend\ndone\n\n//case 比较恶心，我很不喜欢，需要用我再去学，嘿\n\nbreak，continue 什么也是有的\n```\n\n\n\n### 6.函数\n\n```shell\nsay(){\n\techo $i\n}\n\nsay 1\n```\n没错，上面就是函数的简单用法。\n\n* 我们不需要手动指定参数\n* 同样用$i 去获取参数\n* 像命令一样say 1 2 3，传递参数\n\n但是，从${10}开始，我们需要用大括号，扩起来。。\n\n### 7. 输入输出重定向\n\n略过略过，> < 将输入输出定向到其他位置（文件）\n\n### 8. 总结\n\nshell脚本学起来 编写起来都挺简单的。\n\n* \\* @，这些都表示全部，比如 $* $@,\n* \\# 哈，可以表示长度，如字符串长度，数组容量\n* 变量赋值 key=value 注意 中间不能有空格\n* 大小比较 -ge那些\n* 函数，通过$? 能获取到返回值，而不能通过赋值来获取\n* 如果参数大于10个，要用$(n)去获取\n\n不过，shell最好的一点是批命令处理。\n\n### 9. 举个小例子？\n\n```shell\ngit pull\n\ngit add ./\n\ngit commit -m \"xxx\"\n\ngit push\n```\n\n很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？\n\n```shell\ncms=\"update\"\n\nhexo g\n\ngit add ./\n\nif [ $# -ge 1 ]\nthen\n\tcms=$1\nfi\n\ngit commit -m $cms\n\ngit push\n\n```\n\n这不，我们通过shell 脚本，每次./update.sh ,多方便啊。\n\n### 10. 想法\n\n想什么呢？还不赶紧去get shell脚本这个技巧。\n\n不写脚本释放双手的程序员，不是好程序员。\n\n\n### 11. 入门链接\n\n[入门教程，看了还不会就可以转行了](http://www.runoob.com/linux/linux-shell.html)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"脚本打怪-shell篇","published":1,"updated":"2017-01-06T05:28:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixld85yy0024uaxauk0iuoz7","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-什么是shell\"><a href=\"#1-什么是shell\" class=\"headerlink\" title=\"1.什么是shell\"></a>1.什么是shell</h3><p>什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。</p>\n<ul>\n<li><a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n</the></li>\n</ul>\n<h3 id=\"2-shell能干什么\"><a href=\"#2-shell能干什么\" class=\"headerlink\" title=\"2.shell能干什么\"></a>2.shell能干什么</h3><p>shell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。</p>\n<h3 id=\"3-shell基础语法\"><a href=\"#3-shell基础语法\" class=\"headerlink\" title=\"3.shell基础语法\"></a>3.shell基础语法</h3><h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#变量名＝变量值</div><div class=\"line\">myname=&quot;guolei&quot;</div><div class=\"line\">echo $&#123;myname&#125;</div></pre></td></tr></table></figure>\n<p>shell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。</p>\n<p>如果我们想要定义一个数组怎么办？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr=(1 2 3 4)</div><div class=\"line\">echo $arr[0]</div></pre></td></tr></table></figure>\n<p>注意，元素之间没有逗号。</p>\n<h4 id=\"3-2-传递参数\"><a href=\"#3-2-传递参数\" class=\"headerlink\" title=\"3.2 传递参数\"></a>3.2 传递参数</h4><p>作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0… ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件</p>\n<h4 id=\"3-3-输出\"><a href=\"#3-3-输出\" class=\"headerlink\" title=\"3.3 输出\"></a>3.3 输出</h4><p>shell中有两种输出方式，</p>\n<ul>\n<li>echo </li>\n<li>printf</li>\n</ul>\n<p>echo是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。</p>\n<h3 id=\"4-shell运算符\"><a href=\"#4-shell运算符\" class=\"headerlink\" title=\"4.shell运算符\"></a>4.shell运算符</h3><p>这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 <code> </code>之内，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">`expr 2 + 2`</div></pre></td></tr></table></figure>\n<p>要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。</p>\n<p>而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算</p>\n<ul>\n<li>-eq 是否相等,</li>\n<li>-ne 是否不等</li>\n<li>-gt 左边是否大于右边</li>\n<li>-ge 左边是否大于等于右边</li>\n<li>-lt 左边是否小于右边</li>\n<li>-le 左边是否小于等于右边</li>\n</ul>\n<p>老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。</p>\n<p>布尔运算也是同理。</p>\n<ul>\n<li>! 非</li>\n<li>-o 或</li>\n<li>-a 与</li>\n</ul>\n<p>shell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。</p>\n<h3 id=\"5-shell流程控制\"><a href=\"#5-shell流程控制\" class=\"headerlink\" title=\"5.shell流程控制\"></a>5.shell流程控制</h3><p>shell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">if</div><div class=\"line\">then</div><div class=\"line\">\tcommend...</div><div class=\"line\">else</div><div class=\"line\">\tcommend...</div><div class=\"line\">elif</div><div class=\"line\">\tcommend...</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">for var in 1 2 3 4</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">while xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//until循环，</div><div class=\"line\">until xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//case 比较恶心，我很不喜欢，需要用我再去学，嘿</div><div class=\"line\"></div><div class=\"line\">break，continue 什么也是有的</div></pre></td></tr></table></figure>\n<h3 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6.函数\"></a>6.函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">say()&#123;</div><div class=\"line\">\techo $i</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">say 1</div></pre></td></tr></table></figure>\n<p>没错，上面就是函数的简单用法。</p>\n<ul>\n<li>我们不需要手动指定参数</li>\n<li>同样用$i 去获取参数</li>\n<li>像命令一样say 1 2 3，传递参数</li>\n</ul>\n<p>但是，从${10}开始，我们需要用大括号，扩起来。。</p>\n<h3 id=\"7-输入输出重定向\"><a href=\"#7-输入输出重定向\" class=\"headerlink\" title=\"7. 输入输出重定向\"></a>7. 输入输出重定向</h3><p>略过略过，&gt; &lt; 将输入输出定向到其他位置（文件）</p>\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h3><p>shell脚本学起来 编写起来都挺简单的。</p>\n<ul>\n<li>* @，这些都表示全部，比如 $* $@,</li>\n<li># 哈，可以表示长度，如字符串长度，数组容量</li>\n<li>变量赋值 key=value 注意 中间不能有空格</li>\n<li>大小比较 -ge那些</li>\n<li>函数，通过$? 能获取到返回值，而不能通过赋值来获取</li>\n<li>如果参数大于10个，要用$(n)去获取</li>\n</ul>\n<p>不过，shell最好的一点是批命令处理。</p>\n<h3 id=\"9-举个小例子？\"><a href=\"#9-举个小例子？\" class=\"headerlink\" title=\"9. 举个小例子？\"></a>9. 举个小例子？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">git commit -m &quot;xxx&quot;</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cms=&quot;update&quot;</div><div class=\"line\"></div><div class=\"line\">hexo g</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">if [ $# -ge 1 ]</div><div class=\"line\">then</div><div class=\"line\">\tcms=$1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">git commit -m $cms</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>这不，我们通过shell 脚本，每次./update.sh ,多方便啊。</p>\n<h3 id=\"10-想法\"><a href=\"#10-想法\" class=\"headerlink\" title=\"10. 想法\"></a>10. 想法</h3><p>想什么呢？还不赶紧去get shell脚本这个技巧。</p>\n<p>不写脚本释放双手的程序员，不是好程序员。</p>\n<h3 id=\"11-入门链接\"><a href=\"#11-入门链接\" class=\"headerlink\" title=\"11. 入门链接\"></a>11. 入门链接</h3><p><a href=\"http://www.runoob.com/linux/linux-shell.html\" target=\"_blank\" rel=\"external\">入门教程，看了还不会就可以转行了</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-什么是shell\"><a href=\"#1-什么是shell\" class=\"headerlink\" title=\"1.什么是shell\"></a>1.什么是shell</h3><p>什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。</p>\n<ul>\n<li>","more":"<The rest of contents | 余下全文>\n\n\n\n</li>\n</ul>\n<h3 id=\"2-shell能干什么\"><a href=\"#2-shell能干什么\" class=\"headerlink\" title=\"2.shell能干什么\"></a>2.shell能干什么</h3><p>shell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。</p>\n<h3 id=\"3-shell基础语法\"><a href=\"#3-shell基础语法\" class=\"headerlink\" title=\"3.shell基础语法\"></a>3.shell基础语法</h3><h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#变量名＝变量值</div><div class=\"line\">myname=&quot;guolei&quot;</div><div class=\"line\">echo $&#123;myname&#125;</div></pre></td></tr></table></figure>\n<p>shell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。</p>\n<p>如果我们想要定义一个数组怎么办？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr=(1 2 3 4)</div><div class=\"line\">echo $arr[0]</div></pre></td></tr></table></figure>\n<p>注意，元素之间没有逗号。</p>\n<h4 id=\"3-2-传递参数\"><a href=\"#3-2-传递参数\" class=\"headerlink\" title=\"3.2 传递参数\"></a>3.2 传递参数</h4><p>作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0… ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件</p>\n<h4 id=\"3-3-输出\"><a href=\"#3-3-输出\" class=\"headerlink\" title=\"3.3 输出\"></a>3.3 输出</h4><p>shell中有两种输出方式，</p>\n<ul>\n<li>echo </li>\n<li>printf</li>\n</ul>\n<p>echo是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。</p>\n<h3 id=\"4-shell运算符\"><a href=\"#4-shell运算符\" class=\"headerlink\" title=\"4.shell运算符\"></a>4.shell运算符</h3><p>这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 <code> </code>之内，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">`expr 2 + 2`</div></pre></td></tr></table></figure>\n<p>要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。</p>\n<p>而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算</p>\n<ul>\n<li>-eq 是否相等,</li>\n<li>-ne 是否不等</li>\n<li>-gt 左边是否大于右边</li>\n<li>-ge 左边是否大于等于右边</li>\n<li>-lt 左边是否小于右边</li>\n<li>-le 左边是否小于等于右边</li>\n</ul>\n<p>老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。</p>\n<p>布尔运算也是同理。</p>\n<ul>\n<li>! 非</li>\n<li>-o 或</li>\n<li>-a 与</li>\n</ul>\n<p>shell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。</p>\n<h3 id=\"5-shell流程控制\"><a href=\"#5-shell流程控制\" class=\"headerlink\" title=\"5.shell流程控制\"></a>5.shell流程控制</h3><p>shell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">if</div><div class=\"line\">then</div><div class=\"line\">\tcommend...</div><div class=\"line\">else</div><div class=\"line\">\tcommend...</div><div class=\"line\">elif</div><div class=\"line\">\tcommend...</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">for var in 1 2 3 4</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">while xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//until循环，</div><div class=\"line\">until xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//case 比较恶心，我很不喜欢，需要用我再去学，嘿</div><div class=\"line\"></div><div class=\"line\">break，continue 什么也是有的</div></pre></td></tr></table></figure>\n<h3 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6.函数\"></a>6.函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">say()&#123;</div><div class=\"line\">\techo $i</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">say 1</div></pre></td></tr></table></figure>\n<p>没错，上面就是函数的简单用法。</p>\n<ul>\n<li>我们不需要手动指定参数</li>\n<li>同样用$i 去获取参数</li>\n<li>像命令一样say 1 2 3，传递参数</li>\n</ul>\n<p>但是，从${10}开始，我们需要用大括号，扩起来。。</p>\n<h3 id=\"7-输入输出重定向\"><a href=\"#7-输入输出重定向\" class=\"headerlink\" title=\"7. 输入输出重定向\"></a>7. 输入输出重定向</h3><p>略过略过，&gt; &lt; 将输入输出定向到其他位置（文件）</p>\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h3><p>shell脚本学起来 编写起来都挺简单的。</p>\n<ul>\n<li>* @，这些都表示全部，比如 $* $@,</li>\n<li># 哈，可以表示长度，如字符串长度，数组容量</li>\n<li>变量赋值 key=value 注意 中间不能有空格</li>\n<li>大小比较 -ge那些</li>\n<li>函数，通过$? 能获取到返回值，而不能通过赋值来获取</li>\n<li>如果参数大于10个，要用$(n)去获取</li>\n</ul>\n<p>不过，shell最好的一点是批命令处理。</p>\n<h3 id=\"9-举个小例子？\"><a href=\"#9-举个小例子？\" class=\"headerlink\" title=\"9. 举个小例子？\"></a>9. 举个小例子？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">git commit -m &quot;xxx&quot;</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cms=&quot;update&quot;</div><div class=\"line\"></div><div class=\"line\">hexo g</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">if [ $# -ge 1 ]</div><div class=\"line\">then</div><div class=\"line\">\tcms=$1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">git commit -m $cms</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>这不，我们通过shell 脚本，每次./update.sh ,多方便啊。</p>\n<h3 id=\"10-想法\"><a href=\"#10-想法\" class=\"headerlink\" title=\"10. 想法\"></a>10. 想法</h3><p>想什么呢？还不赶紧去get shell脚本这个技巧。</p>\n<p>不写脚本释放双手的程序员，不是好程序员。</p>\n<h3 id=\"11-入门链接\"><a href=\"#11-入门链接\" class=\"headerlink\" title=\"11. 入门链接\"></a>11. 入门链接</h3><p><a href=\"http://www.runoob.com/linux/linux-shell.html\">入门教程，看了还不会就可以转行了</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cixld85xo0006uaxab7cvtd30","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85xy000cuaxax28tnchi"},{"post_id":"cixld85xd0001uaxaimf50nhj","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85y2000huaxaw92f0lhf"},{"post_id":"cixld85xp0007uaxa9ywv9x9h","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85y4000kuaxa7lfzqgj0"},{"post_id":"cixld85xu000buaxa88v30ilx","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85y5000nuaxanf7hnak7"},{"post_id":"cixld85xi0002uaxakpckexi1","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85y8000quaxabnj37olu"},{"post_id":"cixld85xz000euaxazckuyv9l","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85y9000tuaxaj8r7p54m"},{"post_id":"cixld85y2000juaxatrvk3ry9","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yb000wuaxa9xc9d5mr"},{"post_id":"cixld85xn0005uaxa1ftr06ng","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yf000zuaxa9y7s34du"},{"post_id":"cixld85y4000muaxasbjb2906","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yh0012uaxakp0lsixa"},{"post_id":"cixld85y6000puaxap1ut39p1","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yk0016uaxawqphucli"},{"post_id":"cixld85y8000suaxawlqvfyug","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yl0019uaxaojn6ol8x"},{"post_id":"cixld85y9000vuaxana6nyiao","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yn001cuaxaxqtgcjgy"},{"post_id":"cixld85yc000yuaxa32km4vzf","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yo001guaxalu0xqeil"},{"post_id":"cixld85yf0011uaxayz6c5a72","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yr001juaxakbd8xup6"},{"post_id":"cixld85yi0014uaxacnqab987","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yt001nuaxarx5aijqd"},{"post_id":"cixld85yk0018uaxa43k31022","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yv001ruaxabfweyirx"},{"post_id":"cixld85ym001buaxaae8gzfsg","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yw001vuaxadcdxu1eu"},{"post_id":"cixld85yn001euaxanjln9k6o","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yw001yuaxarz9sv0ec"},{"post_id":"cixld85yo001iuaxa6l72cr17","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yy0023uaxaadsssp7w"},{"post_id":"cixld85yw001xuaxa561d3m4b","category_id":"cixld85xl0003uaxadw08nb5a","_id":"cixld85yz0026uaxa70qfyq83"},{"post_id":"cixld85yr001luaxa2okuwtfs","category_id":"cixld85yu001quaxaz0q2j2ai","_id":"cixld85z00029uaxatm6hyr1t"},{"post_id":"cixld85yu001puaxaaawfuyoe","category_id":"cixld85yx0021uaxag1gtoo3d","_id":"cixld85z0002buaxaqdpusqq6"},{"post_id":"cixld85yv001tuaxaldnv2xrr","category_id":"cixld85yx0021uaxag1gtoo3d","_id":"cixld85z2002fuaxasjmdc3cv"},{"post_id":"cixld85yx0020uaxawyscvcld","category_id":"cixld85z1002cuaxajhw3jntg","_id":"cixld85z3002iuaxabc963gjo"},{"post_id":"cixld85yy0024uaxauk0iuoz7","category_id":"cixld85z1002cuaxajhw3jntg","_id":"cixld85z4002luaxa4namqrai"}],"PostTag":[{"post_id":"cixld85xo0006uaxab7cvtd30","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85xu000auaxavn6i6arc"},{"post_id":"cixld85xd0001uaxaimf50nhj","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85xy000duaxacb0j2ei1"},{"post_id":"cixld85xp0007uaxa9ywv9x9h","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85y2000iuaxam77lb2p3"},{"post_id":"cixld85xu000buaxa88v30ilx","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85y4000luaxabuplutg3"},{"post_id":"cixld85xi0002uaxakpckexi1","tag_id":"cixld85xr0009uaxalbu3c0gy","_id":"cixld85y5000ouaxa8uvblel8"},{"post_id":"cixld85xz000euaxazckuyv9l","tag_id":"cixld85xr0009uaxalbu3c0gy","_id":"cixld85y8000ruaxa6rxwh3am"},{"post_id":"cixld85y2000juaxatrvk3ry9","tag_id":"cixld85xr0009uaxalbu3c0gy","_id":"cixld85y9000uuaxa63tdxmb4"},{"post_id":"cixld85xn0005uaxa1ftr06ng","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85yb000xuaxak07y4jxg"},{"post_id":"cixld85y4000muaxasbjb2906","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85yf0010uaxazaxen0n7"},{"post_id":"cixld85y6000puaxap1ut39p1","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85yi0013uaxaj0e3itqg"},{"post_id":"cixld85y8000suaxawlqvfyug","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85yk0017uaxai3ya52k7"},{"post_id":"cixld85y9000vuaxana6nyiao","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85yl001auaxa5lp0ede8"},{"post_id":"cixld85yc000yuaxa32km4vzf","tag_id":"cixld85xm0004uaxagolk0mv2","_id":"cixld85yn001duaxa02b58vgz"},{"post_id":"cixld85ym001buaxaae8gzfsg","tag_id":"cixld85yk0015uaxa08ekx45z","_id":"cixld85yo001huaxanp8opmke"},{"post_id":"cixld85yf0011uaxayz6c5a72","tag_id":"cixld85yk0015uaxa08ekx45z","_id":"cixld85yr001kuaxadq7c1mbf"},{"post_id":"cixld85yn001euaxanjln9k6o","tag_id":"cixld85yk0015uaxa08ekx45z","_id":"cixld85yt001ouaxai7h4ll8w"},{"post_id":"cixld85yo001iuaxa6l72cr17","tag_id":"cixld85yk0015uaxa08ekx45z","_id":"cixld85yv001suaxa0bac7lne"},{"post_id":"cixld85yi0014uaxacnqab987","tag_id":"cixld85yk0015uaxa08ekx45z","_id":"cixld85yw001wuaxa42va2kah"},{"post_id":"cixld85yk0018uaxa43k31022","tag_id":"cixld85yk0015uaxa08ekx45z","_id":"cixld85yw001zuaxajq4w88rw"},{"post_id":"cixld85yr001luaxa2okuwtfs","tag_id":"cixld85yv001uuaxaje4cbsjj","_id":"cixld85yz0025uaxa5ka3x4ta"},{"post_id":"cixld85yu001puaxaaawfuyoe","tag_id":"cixld85yy0022uaxa8f9gvgre","_id":"cixld85z0002auaxaaadzk9tv"},{"post_id":"cixld85yv001tuaxaldnv2xrr","tag_id":"cixld85yy0022uaxa8f9gvgre","_id":"cixld85z2002euaxaupgubhf0"},{"post_id":"cixld85yw001xuaxa561d3m4b","tag_id":"cixld85z2002duaxafenmy7jb","_id":"cixld85z4002kuaxa1ckuywhp"},{"post_id":"cixld85yw001xuaxa561d3m4b","tag_id":"cixld85z3002huaxaafazyedl","_id":"cixld85z4002muaxa3tjymd9v"},{"post_id":"cixld85yx0020uaxawyscvcld","tag_id":"cixld85z4002juaxa4ptrlw4k","_id":"cixld85z4002ouaxa48aw9u4c"},{"post_id":"cixld85yy0024uaxauk0iuoz7","tag_id":"cixld85z4002juaxa4ptrlw4k","_id":"cixld85z5002puaxati0cxp21"}],"Tag":[{"name":"framework","_id":"cixld85xm0004uaxagolk0mv2"},{"name":"jni","_id":"cixld85xr0009uaxalbu3c0gy"},{"name":"fresco","_id":"cixld85yk0015uaxa08ekx45z"},{"name":"hexo","_id":"cixld85yv001uuaxaje4cbsjj"},{"name":"gradle","_id":"cixld85yy0022uaxa8f9gvgre"},{"name":"android","_id":"cixld85z2002duaxafenmy7jb"},{"name":"消息机制","_id":"cixld85z3002huaxaafazyedl"},{"name":"shell","_id":"cixld85z4002juaxa4ptrlw4k"}]}}