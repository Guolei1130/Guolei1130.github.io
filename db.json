{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"909a2b39bf012a9bb70865f9ba4569a08b165adb","modified":1523262899000},{"_id":"themes/next/README.en.md","hash":"3b0c7998cf17f9cf9e1a5bfcd65679a43a00c817","modified":1523262899000},{"_id":"themes/next/_config.yml","hash":"af02e70ea67bdd95059eec2d775be6c513efbf02","modified":1523262899000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1523262899000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1523262899000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1523262899000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1523262899000},{"_id":"source/_posts/17年2月面试经验.md","hash":"d3e28aa5bbb57ee89f4d567bd2988397b37708ac","modified":1523262899000},{"_id":"source/_posts/2017学习计划.md","hash":"d531ba63ebc503d6e41425f72c3033dd7ea773c8","modified":1523262899000},{"_id":"source/_posts/Activity启动流程.md","hash":"538e5474e9061e71c08de9ef65c214e12c5ee232","modified":1523262899000},{"_id":"source/_posts/Android7以上https证书问题适配.md","hash":"6d5f8333c254dfa71588994374999bff3cf2f90d","modified":1523262899000},{"_id":"source/_posts/AMS中的进程管理部分－上.md","hash":"74a2ff3347621aed25d0a3e99d579d4f847ed1f8","modified":1523262899000},{"_id":"source/_posts/Android8的一点适配问题.md","hash":"1c0e1a88aca0ff366fd1f4e2f52f81b730525f69","modified":1523262899000},{"_id":"source/_posts/AndroidJNI学习笔记（四）－数据类型映射以及native调用java.md","hash":"aa4a84909948e765fd062b9f2c48f5b230cfdf9e","modified":1523262899000},{"_id":"source/_posts/Android也需要防止SQL注入.md","hash":"972161a38e90c7d88a9667e3f66c144f58fa121b","modified":1523262899000},{"_id":"source/_posts/Android属性动画源码浅析.md","hash":"42ccb56c8ef5fc6e9317c883de9efdf0a1bc5df1","modified":1523262899000},{"_id":"source/_posts/Android应用的破解与保护.md","hash":"948c54d13d89352acfe4d2f6b96cc41469898c0b","modified":1523262899000},{"_id":"source/_posts/Android应用程序是如何安装的.md","hash":"b82740ab300e2ad83f96a827370d6981872a7c70","modified":1523262899000},{"_id":"source/_posts/Android消息机制浅析.md","hash":"0dab392311fd6ef7c85c84787a0503e9e8cf11c7","modified":1523262899000},{"_id":"source/_posts/Android消息机制－native层.md","hash":"0a87df7414e7c34abf172207114ceb50dca6e5bd","modified":1523262899000},{"_id":"source/_posts/AsyncTask浅析.md","hash":"d9f6d96602fa61f48406494165e716d9f259c9de","modified":1523262899000},{"_id":"source/_posts/ContentProvider水文(凑四大组件).md","hash":"b841e72ab1cdafb5cb391e141e3ec09bbcf45a8e","modified":1523262899000},{"_id":"source/_posts/JNI学习笔记（三）－编译文件makefile以及cmake.md","hash":"897cf4fe774f1af4e65e9872bcd4f5fd5646ea49","modified":1523262899000},{"_id":"source/_posts/JNI学习笔记（二）－动态注册native函数.md","hash":"ec5ad7c6f7ae8289aa70b460779c94a678c1e1c7","modified":1523262899000},{"_id":"source/_posts/LayoutInflater源码浅析.md","hash":"78670450c7b41b9fc87d6f76fa294a878555064f","modified":1523262899000},{"_id":"source/_posts/LruCache源码浅析.md","hash":"adae7038a82152527d061d20baa32ec107c7bc98","modified":1523262899000},{"_id":"source/_posts/MaterialDesign动画.md","hash":"effc6281af733eb0a74e789b91c83dd079130fb4","modified":1523262899000},{"_id":"source/_posts/MultiDex源码浅析.md","hash":"fbae6ca0dec073a84fd81b446976a55e26851e88","modified":1523262899000},{"_id":"source/_posts/Service启动流程.md","hash":"24ec92cbfe20f28dc9381807249623a4ce77b8c1","modified":1523262899000},{"_id":"source/_posts/PMS初始化做了什么.md","hash":"9c7fdfbb09693b20183c98ff481637d0f985736f","modified":1523262899000},{"_id":"source/_posts/SystemServer进程的初始化.md","hash":"0d0fbcb84edb34d653b257186ddef9ba161a58a8","modified":1523262899000},{"_id":"source/_posts/ThreadLocal源码浅析.md","hash":"2be1e17797d7902b1d7ab4b33bd331219f92f97c","modified":1523262899000},{"_id":"source/_posts/ViewModel的一些思考.md","hash":"f6b2d8a0219a3bd0ff7e01197bed62c04280fde5","modified":1523262899000},{"_id":"source/_posts/Xposed简介以及小米去桌面广告的简单实现.md","hash":"fe75e6486d93f5f8c4b21a8d26ff628ad2df7003","modified":1523262899000},{"_id":"source/_posts/ZeusPlugin浅析.md","hash":"36218c85dec1209240b371bc54311376089ec191","modified":1523262899000},{"_id":"source/_posts/Zygote进程的初始化.md","hash":"01dc0d3e14639a65cf6484c81f13e0bb8fc7ad9d","modified":1523262899000},{"_id":"source/_posts/activity从创建到显示的简单介绍.md","hash":"4a00e65756e6567705b70b903c7b94d288c87b84","modified":1523262899000},{"_id":"source/_posts/android应用进程是如何启动的.md","hash":"739827217e5a18c5356e5cb36c8f6c16ba3831c7","modified":1523262899000},{"_id":"source/_posts/broadcast流程浅析.md","hash":"1cc3801592d5a1d81b7c42bb9911fadc47039bcf","modified":1523262899000},{"_id":"source/_posts/databinding基础知识.md","hash":"7826dd0b526c441343d20b99773db891f51a2947","modified":1523262899000},{"_id":"source/_posts/databinding高级用法.md","hash":"2ccdc6f8127c624c84dbabdb3e43fb91d2fe1ba4","modified":1523262899000},{"_id":"source/_posts/fresco初始化过程.md","hash":"41eb86bd9b2bc2de633dca04865a999328887baa","modified":1523262899000},{"_id":"source/_posts/fresco图片decode的大体流程.md","hash":"229930cfb3b827a73107cf49c573df7f69dea175","modified":1523262899000},{"_id":"source/_posts/fresco生产者Producer.md","hash":"4897e9bbaf82ed49ded97e31c72685aa2caeb6a7","modified":1523262899000},{"_id":"source/_posts/fresco内存管理.md","hash":"9f50bd70b994022c42863485985c7e8266b3f995","modified":1523262899000},{"_id":"source/_posts/fresco加载数据.md","hash":"e9f93efc8c950612208068ccf5a0ac6a2b2da72b","modified":1523262899000},{"_id":"source/_posts/fresco用法.md","hash":"04fc8087db54722e50ed20fd8cd2822b8a52ca21","modified":1523262899000},{"_id":"source/_posts/gradle的几点小技巧.md","hash":"9fa24f16f91d50adcf3feeae8f79f4b2664ec20f","modified":1523262899000},{"_id":"source/_posts/hexo+github pages搭建个人博客.md","hash":"6e2893a01a6fe4e2c083b325ed0d1db7e8c9806e","modified":1523262899000},{"_id":"source/_posts/java内存区域.md","hash":"9821bdddcabbdafce7dd5f36792cafec3d033735","modified":1523262899000},{"_id":"source/_posts/jvm垃圾回收.md","hash":"b60f937c52f10c0606861ff8012d8b39b266d4b9","modified":1523262899000},{"_id":"source/_posts/jvm字节码执行引擎.md","hash":"8f780d309d9a393d0237971c4a30850615bc6cf6","modified":1523262899000},{"_id":"source/_posts/jvm类加载机制.md","hash":"f36cd677952e615cefac13756b39fdc6e19d9c9e","modified":1523262899000},{"_id":"source/_posts/jvm编译器优化.md","hash":"d6f910e246619089ffc0aa4075a9aaf62dc036f4","modified":1523262899000},{"_id":"source/_posts/jvm运行时优化.md","hash":"615078efffeb67d975a0ebf2e4e5f554f619cc53","modified":1523262899000},{"_id":"source/_posts/monkey和monkeyRunner.md","hash":"24c3dd441c4e86de085a0f37f1453f62b9de59fb","modified":1523262899000},{"_id":"source/_posts/tinker-diff和patch.md","hash":"703613deec7c034b5eaeb6a47cbea6b349a749be","modified":1523262899000},{"_id":"source/_posts/tinker-application.md","hash":"cf46dd30a87994e79224023ad3a98a58d5e06880","modified":1523262899000},{"_id":"source/_posts/tinker-loader部分.md","hash":"2e81f580cb4c0d88cbc631be52da8e01aa189677","modified":1523262899000},{"_id":"source/_posts/tinker-注解部分.md","hash":"c1fa2192b84a6f2b2d8e5d5f4353303330cf8aeb","modified":1523262899000},{"_id":"source/_posts/ubuntu下搭建ATC弱网测试环境.md","hash":"3e2085fc6628927b0b9f636fba9cbc2a7a1dee60","modified":1523262899000},{"_id":"source/_posts/一个仿qq图片上传的Drawable.md","hash":"888d08566c80d1ded92a66884348a417253e17af","modified":1523262899000},{"_id":"source/_posts/了解Drawable的ConstantState.md","hash":"86bb903067448665552217f318793fc4820f6924","modified":1523262899000},{"_id":"source/_posts/了解gradle（一）.md","hash":"d1a5345ed21ab21dc07d8eb2d1c20e5468d7fba6","modified":1523262899000},{"_id":"source/_posts/了解gradle（三）-编写简单的gradle插件，官方文档资料.md","hash":"339f28d30ebd9a49b3cbaa94adf58629041f91c9","modified":1523262899000},{"_id":"source/_posts/了解gradle（二）-扩展gradle.md","hash":"81add33d3dc61d41c959d8ef3a7982b2ba09757e","modified":1523262899000},{"_id":"source/_posts/了解gradle（四）-了解PatchPluginForZues.md","hash":"6d459d55ea0398b67abfe6cdbbc4ba6c71d8c057","modified":1523262899000},{"_id":"source/_posts/了解对象池.md","hash":"77c0a06aab4cb1a773df79a55af597fe6deb13d1","modified":1523262899000},{"_id":"source/_posts/使用cmake连接第三方so.md","hash":"fe43cd751574a3ff19b48288e10f59c2a5514c3d","modified":1523262899000},{"_id":"source/_posts/别再无脑拷贝代码.md","hash":"8ea4fca918f823c5c024988f09a12c277007ed20","modified":1523262899000},{"_id":"source/_posts/反编译随笔.md","hash":"5f35e7657861fddf0e04324d33f8fa9f492e3ff5","modified":1523262899000},{"_id":"source/_posts/浅析Android热修复.md","hash":"3137929da81907fac8a2e0c0b9e28085eb6ae84b","modified":1523263539000},{"_id":"source/_posts/浅谈客户端增量升级.md","hash":"8a4f84d609d3b8d1aeefc1830b538ac0d1194a51","modified":1523262899000},{"_id":"source/_posts/浅谈Android插件化.md","hash":"250f545b15349f3a111a0194124030162c74e247","modified":1523262899000},{"_id":"source/_posts/消息机制在多进程的应用.md","hash":"ac702f9303f54f43be1cda3241fde7ee4a7b6d3f","modified":1523262899000},{"_id":"source/_posts/系统资源的预加载过程.md","hash":"b1d5a2dbab7371bdb8d37f65789dfb2ec49af606","modified":1523262899000},{"_id":"source/_posts/脚本打怪-shell篇.md","hash":"233db99282b48bf0aeaf8a64479acf5d18ef8b21","modified":1523262899000},{"_id":"source/_posts/记一次折腾之旅-item2.md","hash":"cd77c5af45ceebb986c123a6fa083e6d3477568f","modified":1523262899000},{"_id":"source/_posts/记不住adb命令？试试shell吧.md","hash":"ed156a2f4191131999238f8e721cb5a75fc62cff","modified":1523262899000},{"_id":"source/me/index.md","hash":"dbcbd176383a48c9e1e191b763b4471069415f95","modified":1523262899000},{"_id":"source/categories/index.md","hash":"d24696dbb2f94391363d5cf384c115a00b9a68b0","modified":1523262899000},{"_id":"source/tags/index.md","hash":"32ec9646ff7f68226c93fb8b8d1aca5daab69378","modified":1523262899000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1523262899000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1523262899000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1523262899000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1523262899000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1523262899000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1523262899000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1523262899000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1523262899000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1523262899000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1523262899000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"48a16b71e0f56c76b9fc8283a10470a0fb28939b","modified":1523262899000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1523262899000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1523262899000},{"_id":"themes/next/layout/_layout.swig","hash":"2fa3c74066843a859fac77803324a1de51044da9","modified":1523262899000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1523262899000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1523262899000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1523262899000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1523262899000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1523262899000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1523262899000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1523262899000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1523262899000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1523262899000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1523262899000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1523262899000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523262899000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1523262899000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1523262899000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1523262899000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1523262899000},{"_id":"themes/next/layout/_macro/post.swig","hash":"e6016def9b512188f4c2725399c9adc7bc41cdae","modified":1523262899000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1523262899000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1523262899000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"78ccfc1dc915247c1fec3c86d742e0f4c2f6d99c","modified":1523262899000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1523262899000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1523262899000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1523262899000},{"_id":"themes/next/layout/_partials/header.swig","hash":"adab5c3f7b173f1b45454787f39dde07aea03483","modified":1523262899000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1523262899000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1523262899000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1523262899000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1523262899000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1523262899000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1523262899000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1523262899000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1523262899000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1523262899000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1523262899000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1523262899000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1523262899000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1523262899000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1523262899000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1523262899000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1523262899000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1523262899000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1523262899000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1523262899000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1523262899000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1523262899000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1523262899000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523262899000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523262899000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1523262899000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1523262899000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1523262899000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523262899000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523262899000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523262899000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523262899000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523262899000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523262899000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523262899000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1523262899000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1523262899000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1523262899000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1523262899000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1523262899000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1523262899000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1523262899000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1523262899000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1523262899000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1523262899000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1523262899000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1523262899000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"4abc01bc870e1d7a783cdbd26166edc782a6a4f4","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"e82b7257398c3a305bf29f052314416d1696da9e","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1523262899000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1523262899000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1523262899000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1523262899000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1523262899000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c459aa6d607d8bcb747544e74f6ad0b8374aa3b1","modified":1523262899000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fc185c6cec79593775d1c2440dbe2a71cfbe2e99","modified":1523262899000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1523262899000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1523262899000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1523262899000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1523262899000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1523262899000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1523262899000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1523262899000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1523262899000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1523262899000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1523262899000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1523262899000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1523262899000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1523262899000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1523262899000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1523262899000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1523262899000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1523262899000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1523262899000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1523262899000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1523262899000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1523262899000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1523262899000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1523262899000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1523262899000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1523262899000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1523262899000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1523262899000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"ea8078fa9e10be2bb042749d8b6a97adc38f914c","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1523262899000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1523262899000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1523262899000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1523262899000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1523262899000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1523262899000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1408209dfb9a22a0982a30bdbd14842c2b53f264","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1523262899000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1523262899000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1523262899000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1523262899000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1523262899000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1523262899000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"fdfadbb4483043c7e0afd541ee9712389e633517","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"c0c81317c8ef6fa5d2799fefe05d701b6ea0f039","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1523262899000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1523262899000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1523262899000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1523262899000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1523262899000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1523262899000},{"_id":"public/404.html","hash":"58e401faad2639177aa455886f9b6eff845ee603","modified":1523263569042},{"_id":"public/me/index.html","hash":"7c476507e84adf82edebc02629658e88b6c139cb","modified":1523263569045},{"_id":"public/categories/index.html","hash":"079c295659217c093a1feb74eba95288a3a83ec0","modified":1523263569045},{"_id":"public/tags/index.html","hash":"2c86c2ebdc75681c465213535565587f7ecd4d2e","modified":1523263569045},{"_id":"public/archives/page/8/index.html","hash":"5b7fbc9cdab7167014b0b4b77c2e4f1d9c6afd98","modified":1523263569045},{"_id":"public/archives/2016/11/index.html","hash":"3c08be894806602e4ba947004788cfb3cde9a7bf","modified":1523263569045},{"_id":"public/archives/2017/page/5/index.html","hash":"d3bba2afe2f907f39e2bca12e9d4e13fcff46e7d","modified":1523263569045},{"_id":"public/archives/2017/02/index.html","hash":"2ef0d8d5973563525ffa6bb3072ff2ece371a611","modified":1523263569046},{"_id":"public/archives/2017/03/index.html","hash":"4ebec74ff6bd35154869c6af9f0a56e998d95aba","modified":1523263569046},{"_id":"public/archives/2017/06/index.html","hash":"e81719a99438ef3e0aa447eb916312c29645be8a","modified":1523263569046},{"_id":"public/archives/2017/08/index.html","hash":"cf071be300e81f034a25f9f41a29ac29fe76ca70","modified":1523263569046},{"_id":"public/archives/2017/09/index.html","hash":"67899f9c7d5e23540a11530059f54d1761c968f4","modified":1523263569046},{"_id":"public/archives/2017/11/index.html","hash":"7037e539ffb011b7a88457168a27f8bb8a4b72b3","modified":1523263569046},{"_id":"public/archives/2018/03/index.html","hash":"a52307475bd431bb1fabede8db85d1481983fe4c","modified":1523263569046},{"_id":"public/archives/2018/04/index.html","hash":"7c67f345661b193479aa23c8191e9e12d5f5c709","modified":1523263569046},{"_id":"public/categories/随笔/index.html","hash":"e3269e8a5f7f284c2f14e5a4e652dccb5d68935d","modified":1523263569046},{"_id":"public/categories/安全/index.html","hash":"5af75c0ee850c3896b1b4db3d3e84618ed6aa16d","modified":1523263569046},{"_id":"public/categories/hexo/index.html","hash":"9df3fd32055d5fc0f3b5c0dc2e97e3a7169e3b2d","modified":1523263569046},{"_id":"public/categories/Java/index.html","hash":"b64abe149c3d0e00897d9cb1011bcdeb66451a93","modified":1523263569046},{"_id":"public/categories/自动化测试/index.html","hash":"85fc82ba666b151a6546c9f02274e8adafb6a016","modified":1523263569047},{"_id":"public/categories/Gradle/index.html","hash":"5837b94986684f41ed312b31dbdb6c42a30b9a7b","modified":1523263569047},{"_id":"public/categories/shell/index.html","hash":"b744758e610a3b5d61da03b27c84c2d836e5edc7","modified":1523263569047},{"_id":"public/tags/职业生涯/index.html","hash":"0a15cbc3231de16055bc5a2af10e5dfc37fb4ed4","modified":1523263569047},{"_id":"public/tags/计划总结/index.html","hash":"867c135d2a8c37951c4a51b33de012fbe0e9efe9","modified":1523263569047},{"_id":"public/tags/framework/page/2/index.html","hash":"14b8e26efdee5fc61e5f1cbd7a9ceb2e46c12751","modified":1523263569047},{"_id":"public/tags/jni/index.html","hash":"ee3b061056e64dbb77abd23abf6bd3b829a04787","modified":1523263569047},{"_id":"public/tags/安全/index.html","hash":"4dc432a7137bbc2aa550a810150fd4e9b5546ced","modified":1523263569047},{"_id":"public/tags/源码/index.html","hash":"45a5c7d5d83e9f61520d1322f3279407e8e9abfc","modified":1523263569047},{"_id":"public/tags/Andrid/index.html","hash":"8dadad4ac29a9ef6930efa106176afdb4af5808e","modified":1523263569047},{"_id":"public/tags/动画/index.html","hash":"0a4de25213a956c5d624efd6b891132acf6f7e33","modified":1523263569048},{"_id":"public/tags/Xposed/index.html","hash":"cfd7c1591a23209a1f047fcf824c3e885db1ade7","modified":1523263569048},{"_id":"public/tags/插件化/index.html","hash":"5e1ff4a858f45fb4c11fcd7c9aac8643fcf89fd3","modified":1523263569048},{"_id":"public/tags/Android源码/index.html","hash":"3b7f7c1a865c454b0a1a79a586b95769e6c2f1f0","modified":1523263569048},{"_id":"public/tags/fresco/index.html","hash":"28478841203d8081687949cfe8b7011f77612bd4","modified":1523263569048},{"_id":"public/tags/gradle/index.html","hash":"99fcd8e3f7693ddfc8fe5ab3b5cb704cc2fbba9b","modified":1523263569048},{"_id":"public/tags/hexo/index.html","hash":"e441d903962ca7cc826e213ca79e1157a54cd37f","modified":1523263569048},{"_id":"public/tags/jvm/index.html","hash":"f5f4dceafddf4e8d76901456014656dfe2cb6242","modified":1523263569048},{"_id":"public/tags/tinker/index.html","hash":"916b94c1f0ac16bfb24c14c52c4b6f3f9d97a31e","modified":1523263569048},{"_id":"public/tags/测试/index.html","hash":"642d7790cef1fdbeb138b2ebaf51be59ae64e83d","modified":1523263569048},{"_id":"public/tags/程序设计/index.html","hash":"bfd3fc93ebbc277b71fa8f3f46909524134e330c","modified":1523263569048},{"_id":"public/tags/杂谈/index.html","hash":"b0064cde392ef9090b56a285c12b1d965e7e85d9","modified":1523263569048},{"_id":"public/tags/增量升级/index.html","hash":"6efbd63fa9d796e772b590e2b342d591b046142c","modified":1523263569048},{"_id":"public/tags/android/index.html","hash":"6c8d66d12cbe0adf6ed2ed9f0d7ccfbf1cad72d2","modified":1523263569048},{"_id":"public/tags/消息机制/index.html","hash":"7696c32ca22fa13d3f2473b4e37fe9f97efcf26f","modified":1523263569048},{"_id":"public/tags/shell/index.html","hash":"1c40ae2da19fa9544fbb75d2795f60b96adbe9c2","modified":1523263569048},{"_id":"public/tags/杂技/index.html","hash":"c711251d691e216dbb94593cdbe8d7cb2331143b","modified":1523263569048},{"_id":"public/2018/04/03/浅谈Android插件化/index.html","hash":"647a850403846406f6003342cf06cbbbfcbcc38b","modified":1523263569048},{"_id":"public/2018/03/25/Android也需要防止SQL注入/index.html","hash":"a62300447898f7959581b20cba103fc572251283","modified":1523263569048},{"_id":"public/2018/01/27/MaterialDesign动画/index.html","hash":"67275a54ea510ad1a6d5d78cc9229d7c6d1366d9","modified":1523263569048},{"_id":"public/2018/01/27/Android应用的破解与保护/index.html","hash":"519a7801996b6080284e7a3a3ebe13f8de6b6658","modified":1523263569048},{"_id":"public/2018/01/22/一个仿qq图片上传的Drawable/index.html","hash":"8bb64bd94e6c04a5b5ffafc88b31adfccbd62a9c","modified":1523263569049},{"_id":"public/2018/01/21/ViewModel的一些思考/index.html","hash":"ef33cc24dddbc476918513e1d16411fb0d836c29","modified":1523263569049},{"_id":"public/2018/01/18/Android7以上https证书问题适配/index.html","hash":"c8254bd63571a68b19bd821f17a23a1dfc7f01be","modified":1523263569049},{"_id":"public/2018/01/18/Android8的一点适配问题/index.html","hash":"fc58543f90096a7fde9cd8110f86052dd241f561","modified":1523263569049},{"_id":"public/2017/11/29/activity从创建到显示的简单介绍/index.html","hash":"0a3ab03cdf3caf99e3ff84817f16b990cbed4302","modified":1523263569049},{"_id":"public/2017/11/18/Xposed简介以及小米去桌面广告的简单实现/index.html","hash":"1b47e95da153ceaf5325f669972c99605469d066","modified":1523263569049},{"_id":"public/2017/09/02/monkey和monkeyRunner/index.html","hash":"fa26ce5dea1b8fabd6e0af489670bfd5311357f7","modified":1523263569049},{"_id":"public/2017/08/26/databinding高级用法/index.html","hash":"1185b7fa52eec314ec2e970ba523d986628a140a","modified":1523263569049},{"_id":"public/2017/08/26/databinding基础知识/index.html","hash":"a25b418576cb1a77f12c4fa2fd990b693e10fde0","modified":1523263569049},{"_id":"public/2017/08/22/了解Drawable的ConstantState/index.html","hash":"9f810f34b03ef12b2ec7efd1b7dc6074c569fc6b","modified":1523263569049},{"_id":"public/2017/08/21/反编译随笔/index.html","hash":"297a32279b6b6f5f3abbdd9ed041e6f2e42d985b","modified":1523263569049},{"_id":"public/2017/06/22/使用cmake连接第三方so/index.html","hash":"ab43bf20ec80f13b70cc635104ed18369777ffff","modified":1523263569049},{"_id":"public/2017/06/18/别再无脑拷贝代码/index.html","hash":"b189bdc76d4b9c2991b041820883682a62ec1175","modified":1523263569049},{"_id":"public/2017/04/29/MultiDex源码浅析/index.html","hash":"8b568619f9da966f855fb4f2ee3c87f72a03db79","modified":1523263569049},{"_id":"public/2017/04/27/ubuntu下搭建ATC弱网测试环境/index.html","hash":"7bf98eba08bfa1f8b6a6005e18a0acb2d057c8e9","modified":1523263569049},{"_id":"public/2017/04/16/浅谈客户端增量升级/index.html","hash":"02c12c16adbeceec089d33fa0ae335926d1bdf8a","modified":1523263569049},{"_id":"public/2017/04/14/tinker-diff和patch/index.html","hash":"95f4bfd13be6abaeb5cd877ac51a4f953cddfff1","modified":1523263569049},{"_id":"public/2017/04/12/tinker-loader部分/index.html","hash":"0b10bb84ad205371e9e864d20ef8cac4634d0e3a","modified":1523263569050},{"_id":"public/2017/04/09/tinker-application/index.html","hash":"e2836b77a8698518e270d50f8c1f7bb88740c4ef","modified":1523263569050},{"_id":"public/2017/04/08/tinker-注解部分/index.html","hash":"d761111094fa5ba525d24ba7f0f5245568b388ca","modified":1523263569050},{"_id":"public/2017/04/02/记一次折腾之旅-item2/index.html","hash":"cd7013a577b081c18d859bc7178110207bad40ff","modified":1523263569050},{"_id":"public/2017/03/26/ZeusPlugin浅析/index.html","hash":"17e9c9915fbda18a00ce053c3080976077f437a0","modified":1523263569050},{"_id":"public/2017/03/25/了解gradle（四）-了解PatchPluginForZues/index.html","hash":"d832a2c176c9664c4f73838304a7ab2ab073eae4","modified":1523263569050},{"_id":"public/2017/03/21/了解gradle（三）-编写简单的gradle插件，官方文档资料/index.html","hash":"3d12acb61a6b4f7b483d6f60c50e43368dfe3722","modified":1523263569050},{"_id":"public/2017/03/14/gradle的几点小技巧/index.html","hash":"01c58430967b0be26b3650b16168b2d5cb6f888c","modified":1523263569050},{"_id":"public/2017/02/22/LayoutInflater源码浅析/index.html","hash":"fa4d86b88dd19b131f520d0098cf8ffbaea83e64","modified":1523263569050},{"_id":"public/2017/02/21/AsyncTask浅析/index.html","hash":"cee0589d69506aca267188aca2904c9a6aa479fc","modified":1523263569050},{"_id":"public/2017/02/16/17年2月面试经验/index.html","hash":"41ecea4054861dc051ce142c300a725fd2282f72","modified":1523263569050},{"_id":"public/2017/02/15/了解对象池/index.html","hash":"2e2e9cb1e61a83706d9822a2236ba769438c29f2","modified":1523263569050},{"_id":"public/2017/01/20/jvm运行时优化/index.html","hash":"e31f25da6246d628da4e1545fbb1558bf7487990","modified":1523263569050},{"_id":"public/2017/01/19/jvm编译器优化/index.html","hash":"5af54b7dc5a8afaf262aaf67cd9c72089d1ec961","modified":1523263569050},{"_id":"public/2017/01/19/Android属性动画源码浅析/index.html","hash":"22b56be9fd89fab22011543f5acc012c4abb4eb9","modified":1523263569050},{"_id":"public/2017/01/18/jvm字节码执行引擎/index.html","hash":"929e05da4de188d2e94f3a47afded8f92bf15ede","modified":1523263569050},{"_id":"public/2017/01/17/jvm类加载机制/index.html","hash":"6e4ba3cda543b13bc067ab8dbe538ccc5e2769de","modified":1523263569050},{"_id":"public/2017/01/14/jvm垃圾回收/index.html","hash":"6771cad73a44919ab9b98db8b9ce704db2cf7685","modified":1523263569050},{"_id":"public/2017/01/13/ThreadLocal源码浅析/index.html","hash":"e8ab2d0e26e9c0acb2ce2d0979db76d9290eb479","modified":1523263569050},{"_id":"public/2017/01/13/LruCache源码浅析/index.html","hash":"04b6e85980c147a6a22f44420a29caed24387840","modified":1523263569051},{"_id":"public/2017/01/12/java内存区域/index.html","hash":"bccac75ea0529b7a58deeb21419e0f22bdb28974","modified":1523263569051},{"_id":"public/2017/01/11/2017学习计划/index.html","hash":"70b0454919f424108bbc617180a9ea2b069dc7ca","modified":1523263569051},{"_id":"public/2017/01/09/系统资源的预加载过程/index.html","hash":"8b799e898a45eda4bc063c36971c7d5f8a660e60","modified":1523263569051},{"_id":"public/2017/01/07/SystemServer进程的初始化/index.html","hash":"77bf642e0376223d5118675e7051a9c9916bb418","modified":1523263569051},{"_id":"public/2017/01/07/Zygote进程的初始化/index.html","hash":"4e4fa3598cf6f1de4b518f6b9a05f97983e1ba26","modified":1523263569051},{"_id":"public/2017/01/05/PMS初始化做了什么/index.html","hash":"f15272fcebf76345631746ce139c1d6732973936","modified":1523263569051},{"_id":"public/2017/01/05/AMS中的进程管理部分－上/index.html","hash":"d7b22dcab0f0b014469ac4d3662380183e26a42e","modified":1523263569051},{"_id":"public/2017/01/04/Android应用程序是如何安装的/index.html","hash":"35b5d043c93410ddfbf5b1a2ee56b36aaa0e907b","modified":1523263569052},{"_id":"public/2017/01/02/android应用进程是如何启动的/index.html","hash":"f501bab587850d0db670e30df93bb7e4adb673aa","modified":1523263569052},{"_id":"public/2017/01/01/消息机制在多进程的应用/index.html","hash":"17918a83289abae27c48ee795772a59b83a01649","modified":1523263569052},{"_id":"public/2016/12/29/ContentProvider水文(凑四大组件)/index.html","hash":"6256583616827abf1631c3460894f4707bc6fa55","modified":1523263569052},{"_id":"public/2016/12/27/broadcast流程浅析/index.html","hash":"070e9d1391d13a8c66a6e337fe44f052236c2734","modified":1523263569052},{"_id":"public/2016/12/26/Service启动流程/index.html","hash":"337890c1a8f8bf24ba8d39483ee4af00f53c24e4","modified":1523263569052},{"_id":"public/2016/12/25/Activity启动流程/index.html","hash":"f3273ffb8502cc8a44a362526ad1d56b2f5239ab","modified":1523263569052},{"_id":"public/2016/12/24/Android消息机制－native层/index.html","hash":"b38c659e5e0479e6991ee0a7de86968a45a85130","modified":1523263569052},{"_id":"public/2016/12/21/Android消息机制浅析/index.html","hash":"02020192700f6067f11cca35caee2fbd1e0d7898","modified":1523263569052},{"_id":"public/2016/12/20/记不住adb命令？试试shell吧/index.html","hash":"ee15808c19878c426ec9141175bd87845b6891df","modified":1523263569052},{"_id":"public/2016/12/14/fresco内存管理/index.html","hash":"5c4f9d04c2d959264974ff07a7068b55a796d81e","modified":1523263569052},{"_id":"public/2016/12/13/fresco图片decode的大体流程/index.html","hash":"6751ea67f4052dd3dc47e2e9debafa0d47564a67","modified":1523263569052},{"_id":"public/2016/12/13/fresco生产者Producer/index.html","hash":"e76ab491050825eee4527a48789920e96e20a6f7","modified":1523263569052},{"_id":"public/2016/12/12/fresco加载数据/index.html","hash":"0a18bfb556f5762f83fa9299370134862f8e295f","modified":1523263569052},{"_id":"public/2016/12/12/fresco初始化过程/index.html","hash":"5df7b1d3ccef4404180d46ac8e58e12d82cad910","modified":1523263569052},{"_id":"public/2016/12/12/fresco用法/index.html","hash":"7f33b0bb5d2d2166de573cb500da7acdaeaae4b1","modified":1523263569052},{"_id":"public/2016/12/06/了解gradle（二）-扩展gradle/index.html","hash":"e97f873b54a2c0b88d36e1695072d9ff9651bfad","modified":1523263569052},{"_id":"public/2016/12/05/了解gradle（一）/index.html","hash":"2cc0ead5b090ada23c71eb5fa810e897cc80b144","modified":1523263569052},{"_id":"public/2016/12/03/脚本打怪-shell篇/index.html","hash":"f7c36eb72a47f9375bac89f3234493c4df949d7b","modified":1523263569053},{"_id":"public/2016/11/30/AndroidJNI学习笔记（四）－数据类型映射以及native调用java/index.html","hash":"6e6ae05653cc3cb0bdda724e0b9d3d7d04ed8d6b","modified":1523263569053},{"_id":"public/2016/11/29/JNI学习笔记（三）－编译文件makefile以及cmake/index.html","hash":"48bfaa38482f6540f05a86494f155af2a3d0e498","modified":1523263569053},{"_id":"public/2016/11/29/JNI学习笔记（二）－动态注册native函数/index.html","hash":"8e08223313042826ef1cfc2567eafc0a97e9f9dd","modified":1523263569053},{"_id":"public/2016/11/29/hexo+github pages搭建个人博客/index.html","hash":"3982013ecccbc8d73f5e52ec933f612f56000162","modified":1523263569053},{"_id":"public/archives/index.html","hash":"75896b9f3cf0541890a24388606d5bb554cd9e43","modified":1523263569053},{"_id":"public/archives/page/2/index.html","hash":"38ea871c2e0ad6cd951bbab13216e29e1fefa09b","modified":1523263569053},{"_id":"public/archives/page/3/index.html","hash":"bca1ea89cae99054f15a78627822706af326437a","modified":1523263569053},{"_id":"public/archives/page/4/index.html","hash":"dc2ef4e44c077b6e408f689d78d38803e1c319ce","modified":1523263569053},{"_id":"public/archives/page/5/index.html","hash":"b56edaefc37d63577aba2c399b7c2dc2cfe046f3","modified":1523263569053},{"_id":"public/archives/page/6/index.html","hash":"2ac0de1cf558829790c2ecb139fa30871557a6bc","modified":1523263569053},{"_id":"public/archives/page/7/index.html","hash":"5bb2d79388fda153c56d74a9070ed865f9ee7a16","modified":1523263569053},{"_id":"public/archives/2016/index.html","hash":"e4c6bb0e7f421f0430bdd6fc5769a90bbb008c3f","modified":1523263569053},{"_id":"public/archives/2016/page/2/index.html","hash":"aa9fec3827ee82ab4f46f9ccb4d1fe2323007387","modified":1523263569053},{"_id":"public/archives/2016/12/index.html","hash":"fafd58122c733e3dc50da4cc79084474599b7a2b","modified":1523263569053},{"_id":"public/archives/2016/12/page/2/index.html","hash":"836b0f1dfd41131a36b490e3406bb28e4390a40a","modified":1523263569053},{"_id":"public/archives/2017/index.html","hash":"ecf06322b9e2efecfe607fb2e5c2b93b4f7dda72","modified":1523263569053},{"_id":"public/archives/2017/page/2/index.html","hash":"f07afa84d738ab7c9494a734a76ee449a14f1d4f","modified":1523263569053},{"_id":"public/archives/2017/page/3/index.html","hash":"3354d15e635d0093c554dde71aeb5d025715668f","modified":1523263569053},{"_id":"public/archives/2017/page/4/index.html","hash":"11777f3f390e8658b5a802eb5ccd1e662cfe5001","modified":1523263569053},{"_id":"public/archives/2017/01/index.html","hash":"9f31cd056033bca8971befa5075c1e160ece5b1f","modified":1523263569053},{"_id":"public/archives/2017/01/page/2/index.html","hash":"d2c1694df45593985db2ab6931b83352d0de2def","modified":1523263569054},{"_id":"public/archives/2017/04/index.html","hash":"01be5cf9c76a38010849537bbde0232b3b206c3f","modified":1523263569054},{"_id":"public/archives/2018/index.html","hash":"f2d762e4aba2fb76fbe7717d59d53c04c5852f6d","modified":1523263569054},{"_id":"public/archives/2018/01/index.html","hash":"7577842158363a0215f6a9a2e3679af82c43cdbd","modified":1523263569054},{"_id":"public/page/2/index.html","hash":"4b5e693c46570444ca69a6d82ddf0fc90e9e3d7f","modified":1523263569054},{"_id":"public/page/3/index.html","hash":"dd854e9696cb9231577beb15148f639fcd087d43","modified":1523263569054},{"_id":"public/page/4/index.html","hash":"a26f74ffcb9e97e86ff3afb32a8fd11fa42e68d8","modified":1523263569054},{"_id":"public/page/5/index.html","hash":"e1cd7cf43679e647dcc0acee3fe8e27c0213ac62","modified":1523263569054},{"_id":"public/page/6/index.html","hash":"56ba823b3e74af3ff126b747e3f844543ccd8987","modified":1523263569055},{"_id":"public/page/7/index.html","hash":"75c345d9b7b5dce7cdae7dd6413753b999955efd","modified":1523263569055},{"_id":"public/page/8/index.html","hash":"3f2159127ee11200f871ce482463cb079e14a3f1","modified":1523263569055},{"_id":"public/categories/Android/index.html","hash":"ec9dc241549ee6a54159ddfb485fe9c612782a03","modified":1523263569055},{"_id":"public/categories/Android/page/2/index.html","hash":"fcc8f03b33687790128179023b40754044ff6a1b","modified":1523263569055},{"_id":"public/categories/Android/page/3/index.html","hash":"b1f3bee117b56fc2c6e4eb792d46d56efd96b481","modified":1523263569055},{"_id":"public/categories/Android/page/4/index.html","hash":"d93ab59fd4b94752a8063b204aac84e4ecb1a418","modified":1523263569055},{"_id":"public/tags/framework/index.html","hash":"7b3f9b216de87296c5151b8922a9d1dbea919870","modified":1523263569055},{"_id":"public/tags/Android/index.html","hash":"203dba74589d3d67c83c5cb935fc39ddaaa1fbc2","modified":1523263569055},{"_id":"public/categories/分类要填/index.html","hash":"835aaae05b9a44f3500c9084ba28adaae6890c9a","modified":1523263569074},{"_id":"public/2018/04/09/浅析Android热修复/index.html","hash":"753b4ac1ac839642ce1422225456a495a1999a39","modified":1523263569074},{"_id":"public/index.html","hash":"24207a42c5724de357607371e9940ebca0599e70","modified":1523263758669},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1523263569080},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1523263569080},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1523263569080},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1523263569080},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1523263569080},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1523263569080},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1523263569080},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1523263569080},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1523263569080},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523263569080},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523263569080},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1523263569080},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1523263569080},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1523263569080},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1523263569080},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1523263569080},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1523263569080},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1523263569080},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1523263569080},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1523263569080},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1523263569080},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1523263569080},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1523263569080},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1523263569080},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1523263569798},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1523263569815},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1523263569824},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1523263569824},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1523263569829},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1523263569829},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1523263569829},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1523263569830},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1523263569830},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1523263569830},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1523263569830},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1523263569830},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1523263569830},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1523263569830},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1523263569830},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1523263569830},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1523263569830},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1523263569830},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1523263569830},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1523263569830},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1523263569830},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1523263569830},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1523263569830},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1523263569830},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1523263569831},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1523263569831},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1523263569831},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1523263569831},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1523263569831},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1523263569831},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1523263569831},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1523263569831},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1523263569831},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1523263569831},{"_id":"public/css/main.css","hash":"dff5d47a213404ebf501e622b14c32101be54509","modified":1523263569831},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1523263569831},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1523263569831},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1523263569831},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1523263569831},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1523263569831},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1523263569831},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1523263569831},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1523263569832},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1523263569832},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1523263569832},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1523263569832},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1523263569844}],"Category":[{"name":"随笔","_id":"cjfrzslwz000819fyidwziwc0"},{"name":"Android","_id":"cjfrzslx4000e19fys76tj8j9"},{"name":"安全","_id":"cjfrzslxi000s19fynjk93z5v"},{"name":"hexo","_id":"cjfrzslz6003v19fyiuux455h"},{"name":"Java","_id":"cjfrzslzb004119fy3pt3jqie"},{"name":"自动化测试","_id":"cjfrzslzm004t19fyk9oixgti"},{"name":"Gradle","_id":"cjfrzslzz005519fy2q3pn1am"},{"name":"分类要填","_id":"cjfrzsm0c005v19fygnzi7dci"},{"name":"shell","_id":"cjfrzsm0h006c19fys6bx3btg"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>","date":"2018-04-09T08:34:59.000Z","updated":"2018-04-09T08:34:59.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjfrzslr9000019fy34ft8pd6","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\">\n</script>\n\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>"},{"title":"me","date":"2017-01-07T07:02:16.000Z","type":"me","comments":0,"_content":"\n不甘平凡Android新手一枚，长期混迹于各个交流群。\n\n求18-22周岁妹子收留。\n\n技能篇：\n\n* 熟悉面向对象编程，熟悉Java开发语言，了解JVM 、了解Groovy、Shell、Python等脚本（可以编写简单脚本提升工作效率）\n* 了解TCP/IP、HTTP等协议，熟悉Socket、熟悉Android网络编程\n* 熟悉常用设计模式以及应用场景\n* 熟悉常用的开发架构如mvc、mvp、mvvm\n* 熟悉Android开发技巧、了解自定义View，动画等，能够根据需求做出自定义效果\n* 熟悉常用的开源框架并了解其内部实现原理，如Retrofit、Okhttp、EventBus、Fresco等\n* 了解NDK编程，了解JNI开发基本流程\n* 了解Android FrameWork及其部分流程与实现原理\n","source":"me/index.md","raw":"---\ntitle: me\ndate: 2017-01-07 15:02:16\ntype: \"me\"\ncomments: false\n\n---\n\n不甘平凡Android新手一枚，长期混迹于各个交流群。\n\n求18-22周岁妹子收留。\n\n技能篇：\n\n* 熟悉面向对象编程，熟悉Java开发语言，了解JVM 、了解Groovy、Shell、Python等脚本（可以编写简单脚本提升工作效率）\n* 了解TCP/IP、HTTP等协议，熟悉Socket、熟悉Android网络编程\n* 熟悉常用设计模式以及应用场景\n* 熟悉常用的开发架构如mvc、mvp、mvvm\n* 熟悉Android开发技巧、了解自定义View，动画等，能够根据需求做出自定义效果\n* 熟悉常用的开源框架并了解其内部实现原理，如Retrofit、Okhttp、EventBus、Fresco等\n* 了解NDK编程，了解JNI开发基本流程\n* 了解Android FrameWork及其部分流程与实现原理\n","updated":"2018-04-09T08:34:59.000Z","path":"me/index.html","layout":"page","_id":"cjfrzslwl000219fy8ji4ljz5","content":"<p>不甘平凡Android新手一枚，长期混迹于各个交流群。</p>\n<p>求18-22周岁妹子收留。</p>\n<p>技能篇：</p>\n<ul>\n<li>熟悉面向对象编程，熟悉Java开发语言，了解JVM 、了解Groovy、Shell、Python等脚本（可以编写简单脚本提升工作效率）</li>\n<li>了解TCP/IP、HTTP等协议，熟悉Socket、熟悉Android网络编程</li>\n<li>熟悉常用设计模式以及应用场景</li>\n<li>熟悉常用的开发架构如mvc、mvp、mvvm</li>\n<li>熟悉Android开发技巧、了解自定义View，动画等，能够根据需求做出自定义效果</li>\n<li>熟悉常用的开源框架并了解其内部实现原理，如Retrofit、Okhttp、EventBus、Fresco等</li>\n<li>了解NDK编程，了解JNI开发基本流程</li>\n<li>了解Android FrameWork及其部分流程与实现原理</li>\n</ul>\n","excerpt":"","more":"<p>不甘平凡Android新手一枚，长期混迹于各个交流群。</p>\n<p>求18-22周岁妹子收留。</p>\n<p>技能篇：</p>\n<ul>\n<li>熟悉面向对象编程，熟悉Java开发语言，了解JVM 、了解Groovy、Shell、Python等脚本（可以编写简单脚本提升工作效率）</li>\n<li>了解TCP/IP、HTTP等协议，熟悉Socket、熟悉Android网络编程</li>\n<li>熟悉常用设计模式以及应用场景</li>\n<li>熟悉常用的开发架构如mvc、mvp、mvvm</li>\n<li>熟悉Android开发技巧、了解自定义View，动画等，能够根据需求做出自定义效果</li>\n<li>熟悉常用的开源框架并了解其内部实现原理，如Retrofit、Okhttp、EventBus、Fresco等</li>\n<li>了解NDK编程，了解JNI开发基本流程</li>\n<li>了解Android FrameWork及其部分流程与实现原理</li>\n</ul>\n"},{"title":"categories","date":"2017-01-06T03:45:57.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-01-06 11:45:57\ntype: \"categories\"\ncomments: false\n\n---\n","updated":"2018-04-09T08:34:59.000Z","path":"categories/index.html","layout":"page","_id":"cjfrzslwp000419fyq2f7trl8","content":"","excerpt":"","more":""},{"title":"All tags","type":"tags","comments":0,"date":"2017-01-06T03:43:49.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ntype: \"tags\"\ncomments: false\ndate: 2017-01-06 11:43:49\n\n---\n","updated":"2018-04-09T08:34:59.000Z","path":"tags/index.html","layout":"page","_id":"cjfrzslww000719fy3tyg7bsw","content":"","excerpt":"","more":""}],"Post":[{"title":"17年2月面试经验","date":"2017-02-16T12:23:13.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n小插曲：我年前就开始投简历，投了很长时间没人联系，结果年后回来一看，尼玛，电话写错了。\n\n又到了一年一度换工作的时候，我也不例外，因为去年一年都在乙方公司工作，自己不是很喜欢，因此想换家公司。由于目前还在职，因此只面试了四家。分别为X氧，X易贷，X邦集团，某创业公司。接下来就谈谈我对面试的感受。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### X氧\n\n很莫名奇妙的挂了，因为啥呢？我也不知道，后来问hr的时候，说经验不符，但我感觉不是这样子。\n\n这家公司面试很简单，几乎没啥难点，我也没记录东西，面了40分钟左右。面试官基本就问些 项目中的问题，一些基本的java、网络知识，等等。而且，我记忆犹新的一点是，那个面试官不知道webview播放视频，退出还有声音是没回收，内存泄漏的原因。\n\n* 基本的java、android、网络知识\n* 项目中的难点、解决办法\n\n* 无难点，挂的莫名其妙\n\n### X易贷\n\n握草，先做份题，不难，就两道，考察类锁、对象锁、方法锁的。\n\n然后两个面试在面我，其中一个几乎没问，问我的那个是个大神，以前做framework的。我把问题记录了下，如下：\n\n* 自我介绍，\n* 布局优化\n* recyclerview和listview的不同，他们的缓存机制\n* 6.0，7.0的特性\n* 事件传递机制\n* 自定义view\n* 挑两个framework说一说\n* 启动模式\n* 有序广播\n* pms的作用\n* 静态广播放在pms里么，动态广播呢？\n* 如何停掉静态广播\n* 发广播的时候，先查静态注册还是动态注册\n* 如何重启app\n* 如何清掉所有的activity，进行管理的activity，大小容量怎么设计中间有个activity太大怎么办\n* 内存泄露怎么检查，要是定位到framework，怎么确认\n* 如何让activity不被外部访问到\n* 你平常用shell干啥\n* 一些linux命令\n* view如何更新\n\n这个面试官问的时候，会逮住一点，一直问。难，很多没回答好。不出意外，一面就挂了。\n\n### X邦保险集团\n\n#### 一面\n\n额，好像没啥一面，内部内推的。\n\n#### 二面\n\n直接过去就是二面，问的是一些基础算法知识，难度不大。如下：\n\n* 平衡二叉树，应用场景有那些\n* 说出你知道的排序算法\n* 快排，时间复杂度\n* 哈弗曼树，压缩原理，一片纯英文的文章，压缩率多少\n* java堆和栈\n* jni原理，动态注册\n* 表达式求值(后缀表达式，逆波兰)\n\n#### 三面\n\n三面约在早上，等了会。\n\n* eventbus，如何实现跨进城，\n* 如何使用java堆，\n* fresco的内存管理，匿名共享内存，匿名共享内存是谁提出的，Android怎么实现，\n* 如何压缩图片，同时压缩一百张怎么做\n* android应用，官方给的可用内存是多少。\n\n有一部分没回答好，面试完之后，面试官说 挺好，我以为有戏，结果下午告诉我挂了。\n\n后来听说，二面 三面面试官，一个做塞班出身，一个做linux出身，膜拜。\n\n### 创业公司\n\n聊得挺hign，和第一家一样，就是项目中具体的一些问题，还有一部分说出来怕被笑话，就不说了。20人左右的研发团队，感觉还靠谱点。\n\n### 总结\n\n因为在之前很少面试，不对，不能说很少，就没有当面面试过一次，有些紧张和恐惧，导致很多问题短暂性忘记。\n\n* 不紧张，不怯场，此处不留爷，自有留爷处，处处不留爷，爷干个体户\n* 千万不要进入面试官的套路，要将他引入你擅长的部分\n* 如果数据结构和算法不行，花点时间，看看大话数据结构和剑指offer吧。\n\nPS:有疑问，留言。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/17年2月面试经验.md","raw":"---\ntitle: 17年2月面试经验\ndate: 2017-02-16 20:23:13\ntags: 职业生涯\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n小插曲：我年前就开始投简历，投了很长时间没人联系，结果年后回来一看，尼玛，电话写错了。\n\n又到了一年一度换工作的时候，我也不例外，因为去年一年都在乙方公司工作，自己不是很喜欢，因此想换家公司。由于目前还在职，因此只面试了四家。分别为X氧，X易贷，X邦集团，某创业公司。接下来就谈谈我对面试的感受。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### X氧\n\n很莫名奇妙的挂了，因为啥呢？我也不知道，后来问hr的时候，说经验不符，但我感觉不是这样子。\n\n这家公司面试很简单，几乎没啥难点，我也没记录东西，面了40分钟左右。面试官基本就问些 项目中的问题，一些基本的java、网络知识，等等。而且，我记忆犹新的一点是，那个面试官不知道webview播放视频，退出还有声音是没回收，内存泄漏的原因。\n\n* 基本的java、android、网络知识\n* 项目中的难点、解决办法\n\n* 无难点，挂的莫名其妙\n\n### X易贷\n\n握草，先做份题，不难，就两道，考察类锁、对象锁、方法锁的。\n\n然后两个面试在面我，其中一个几乎没问，问我的那个是个大神，以前做framework的。我把问题记录了下，如下：\n\n* 自我介绍，\n* 布局优化\n* recyclerview和listview的不同，他们的缓存机制\n* 6.0，7.0的特性\n* 事件传递机制\n* 自定义view\n* 挑两个framework说一说\n* 启动模式\n* 有序广播\n* pms的作用\n* 静态广播放在pms里么，动态广播呢？\n* 如何停掉静态广播\n* 发广播的时候，先查静态注册还是动态注册\n* 如何重启app\n* 如何清掉所有的activity，进行管理的activity，大小容量怎么设计中间有个activity太大怎么办\n* 内存泄露怎么检查，要是定位到framework，怎么确认\n* 如何让activity不被外部访问到\n* 你平常用shell干啥\n* 一些linux命令\n* view如何更新\n\n这个面试官问的时候，会逮住一点，一直问。难，很多没回答好。不出意外，一面就挂了。\n\n### X邦保险集团\n\n#### 一面\n\n额，好像没啥一面，内部内推的。\n\n#### 二面\n\n直接过去就是二面，问的是一些基础算法知识，难度不大。如下：\n\n* 平衡二叉树，应用场景有那些\n* 说出你知道的排序算法\n* 快排，时间复杂度\n* 哈弗曼树，压缩原理，一片纯英文的文章，压缩率多少\n* java堆和栈\n* jni原理，动态注册\n* 表达式求值(后缀表达式，逆波兰)\n\n#### 三面\n\n三面约在早上，等了会。\n\n* eventbus，如何实现跨进城，\n* 如何使用java堆，\n* fresco的内存管理，匿名共享内存，匿名共享内存是谁提出的，Android怎么实现，\n* 如何压缩图片，同时压缩一百张怎么做\n* android应用，官方给的可用内存是多少。\n\n有一部分没回答好，面试完之后，面试官说 挺好，我以为有戏，结果下午告诉我挂了。\n\n后来听说，二面 三面面试官，一个做塞班出身，一个做linux出身，膜拜。\n\n### 创业公司\n\n聊得挺hign，和第一家一样，就是项目中具体的一些问题，还有一部分说出来怕被笑话，就不说了。20人左右的研发团队，感觉还靠谱点。\n\n### 总结\n\n因为在之前很少面试，不对，不能说很少，就没有当面面试过一次，有些紧张和恐惧，导致很多问题短暂性忘记。\n\n* 不紧张，不怯场，此处不留爷，自有留爷处，处处不留爷，爷干个体户\n* 千万不要进入面试官的套路，要将他引入你擅长的部分\n* 如果数据结构和算法不行，花点时间，看看大话数据结构和剑指offer吧。\n\nPS:有疑问，留言。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"17年2月面试经验","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslwi000119fyk6ogdczt","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>小插曲：我年前就开始投简历，投了很长时间没人联系，结果年后回来一看，尼玛，电话写错了。</p>\n<p>又到了一年一度换工作的时候，我也不例外，因为去年一年都在乙方公司工作，自己不是很喜欢，因此想换家公司。由于目前还在职，因此只面试了四家。分别为X氧，X易贷，X邦集团，某创业公司。接下来就谈谈我对面试的感受。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"X氧\"><a href=\"#X氧\" class=\"headerlink\" title=\"X氧\"></a>X氧</h3><p>很莫名奇妙的挂了，因为啥呢？我也不知道，后来问hr的时候，说经验不符，但我感觉不是这样子。</p>\n<p>这家公司面试很简单，几乎没啥难点，我也没记录东西，面了40分钟左右。面试官基本就问些 项目中的问题，一些基本的java、网络知识，等等。而且，我记忆犹新的一点是，那个面试官不知道webview播放视频，退出还有声音是没回收，内存泄漏的原因。</p>\n<ul>\n<li>基本的java、android、网络知识</li>\n<li><p>项目中的难点、解决办法</p>\n</li>\n<li><p>无难点，挂的莫名其妙</p>\n</li>\n</ul>\n<h3 id=\"X易贷\"><a href=\"#X易贷\" class=\"headerlink\" title=\"X易贷\"></a>X易贷</h3><p>握草，先做份题，不难，就两道，考察类锁、对象锁、方法锁的。</p>\n<p>然后两个面试在面我，其中一个几乎没问，问我的那个是个大神，以前做framework的。我把问题记录了下，如下：</p>\n<ul>\n<li>自我介绍，</li>\n<li>布局优化</li>\n<li>recyclerview和listview的不同，他们的缓存机制</li>\n<li>6.0，7.0的特性</li>\n<li>事件传递机制</li>\n<li>自定义view</li>\n<li>挑两个framework说一说</li>\n<li>启动模式</li>\n<li>有序广播</li>\n<li>pms的作用</li>\n<li>静态广播放在pms里么，动态广播呢？</li>\n<li>如何停掉静态广播</li>\n<li>发广播的时候，先查静态注册还是动态注册</li>\n<li>如何重启app</li>\n<li>如何清掉所有的activity，进行管理的activity，大小容量怎么设计中间有个activity太大怎么办</li>\n<li>内存泄露怎么检查，要是定位到framework，怎么确认</li>\n<li>如何让activity不被外部访问到</li>\n<li>你平常用shell干啥</li>\n<li>一些linux命令</li>\n<li>view如何更新</li>\n</ul>\n<p>这个面试官问的时候，会逮住一点，一直问。难，很多没回答好。不出意外，一面就挂了。</p>\n<h3 id=\"X邦保险集团\"><a href=\"#X邦保险集团\" class=\"headerlink\" title=\"X邦保险集团\"></a>X邦保险集团</h3><h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><p>额，好像没啥一面，内部内推的。</p>\n<h4 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h4><p>直接过去就是二面，问的是一些基础算法知识，难度不大。如下：</p>\n<ul>\n<li>平衡二叉树，应用场景有那些</li>\n<li>说出你知道的排序算法</li>\n<li>快排，时间复杂度</li>\n<li>哈弗曼树，压缩原理，一片纯英文的文章，压缩率多少</li>\n<li>java堆和栈</li>\n<li>jni原理，动态注册</li>\n<li>表达式求值(后缀表达式，逆波兰)</li>\n</ul>\n<h4 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h4><p>三面约在早上，等了会。</p>\n<ul>\n<li>eventbus，如何实现跨进城，</li>\n<li>如何使用java堆，</li>\n<li>fresco的内存管理，匿名共享内存，匿名共享内存是谁提出的，Android怎么实现，</li>\n<li>如何压缩图片，同时压缩一百张怎么做</li>\n<li>android应用，官方给的可用内存是多少。</li>\n</ul>\n<p>有一部分没回答好，面试完之后，面试官说 挺好，我以为有戏，结果下午告诉我挂了。</p>\n<p>后来听说，二面 三面面试官，一个做塞班出身，一个做linux出身，膜拜。</p>\n<h3 id=\"创业公司\"><a href=\"#创业公司\" class=\"headerlink\" title=\"创业公司\"></a>创业公司</h3><p>聊得挺hign，和第一家一样，就是项目中具体的一些问题，还有一部分说出来怕被笑话，就不说了。20人左右的研发团队，感觉还靠谱点。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>因为在之前很少面试，不对，不能说很少，就没有当面面试过一次，有些紧张和恐惧，导致很多问题短暂性忘记。</p>\n<ul>\n<li>不紧张，不怯场，此处不留爷，自有留爷处，处处不留爷，爷干个体户</li>\n<li>千万不要进入面试官的套路，要将他引入你擅长的部分</li>\n<li>如果数据结构和算法不行，花点时间，看看大话数据结构和剑指offer吧。</li>\n</ul>\n<p>PS:有疑问，留言。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>小插曲：我年前就开始投简历，投了很长时间没人联系，结果年后回来一看，尼玛，电话写错了。</p>\n<p>又到了一年一度换工作的时候，我也不例外，因为去年一年都在乙方公司工作，自己不是很喜欢，因此想换家公司。由于目前还在职，因此只面试了四家。分别为X氧，X易贷，X邦集团，某创业公司。接下来就谈谈我对面试的感受。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"X氧\"><a href=\"#X氧\" class=\"headerlink\" title=\"X氧\"></a>X氧</h3><p>很莫名奇妙的挂了，因为啥呢？我也不知道，后来问hr的时候，说经验不符，但我感觉不是这样子。</p>\n<p>这家公司面试很简单，几乎没啥难点，我也没记录东西，面了40分钟左右。面试官基本就问些 项目中的问题，一些基本的java、网络知识，等等。而且，我记忆犹新的一点是，那个面试官不知道webview播放视频，退出还有声音是没回收，内存泄漏的原因。</p>\n<ul>\n<li>基本的java、android、网络知识</li>\n<li><p>项目中的难点、解决办法</p>\n</li>\n<li><p>无难点，挂的莫名其妙</p>\n</li>\n</ul>\n<h3 id=\"X易贷\"><a href=\"#X易贷\" class=\"headerlink\" title=\"X易贷\"></a>X易贷</h3><p>握草，先做份题，不难，就两道，考察类锁、对象锁、方法锁的。</p>\n<p>然后两个面试在面我，其中一个几乎没问，问我的那个是个大神，以前做framework的。我把问题记录了下，如下：</p>\n<ul>\n<li>自我介绍，</li>\n<li>布局优化</li>\n<li>recyclerview和listview的不同，他们的缓存机制</li>\n<li>6.0，7.0的特性</li>\n<li>事件传递机制</li>\n<li>自定义view</li>\n<li>挑两个framework说一说</li>\n<li>启动模式</li>\n<li>有序广播</li>\n<li>pms的作用</li>\n<li>静态广播放在pms里么，动态广播呢？</li>\n<li>如何停掉静态广播</li>\n<li>发广播的时候，先查静态注册还是动态注册</li>\n<li>如何重启app</li>\n<li>如何清掉所有的activity，进行管理的activity，大小容量怎么设计中间有个activity太大怎么办</li>\n<li>内存泄露怎么检查，要是定位到framework，怎么确认</li>\n<li>如何让activity不被外部访问到</li>\n<li>你平常用shell干啥</li>\n<li>一些linux命令</li>\n<li>view如何更新</li>\n</ul>\n<p>这个面试官问的时候，会逮住一点，一直问。难，很多没回答好。不出意外，一面就挂了。</p>\n<h3 id=\"X邦保险集团\"><a href=\"#X邦保险集团\" class=\"headerlink\" title=\"X邦保险集团\"></a>X邦保险集团</h3><h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><p>额，好像没啥一面，内部内推的。</p>\n<h4 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h4><p>直接过去就是二面，问的是一些基础算法知识，难度不大。如下：</p>\n<ul>\n<li>平衡二叉树，应用场景有那些</li>\n<li>说出你知道的排序算法</li>\n<li>快排，时间复杂度</li>\n<li>哈弗曼树，压缩原理，一片纯英文的文章，压缩率多少</li>\n<li>java堆和栈</li>\n<li>jni原理，动态注册</li>\n<li>表达式求值(后缀表达式，逆波兰)</li>\n</ul>\n<h4 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h4><p>三面约在早上，等了会。</p>\n<ul>\n<li>eventbus，如何实现跨进城，</li>\n<li>如何使用java堆，</li>\n<li>fresco的内存管理，匿名共享内存，匿名共享内存是谁提出的，Android怎么实现，</li>\n<li>如何压缩图片，同时压缩一百张怎么做</li>\n<li>android应用，官方给的可用内存是多少。</li>\n</ul>\n<p>有一部分没回答好，面试完之后，面试官说 挺好，我以为有戏，结果下午告诉我挂了。</p>\n<p>后来听说，二面 三面面试官，一个做塞班出身，一个做linux出身，膜拜。</p>\n<h3 id=\"创业公司\"><a href=\"#创业公司\" class=\"headerlink\" title=\"创业公司\"></a>创业公司</h3><p>聊得挺hign，和第一家一样，就是项目中具体的一些问题，还有一部分说出来怕被笑话，就不说了。20人左右的研发团队，感觉还靠谱点。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>因为在之前很少面试，不对，不能说很少，就没有当面面试过一次，有些紧张和恐惧，导致很多问题短暂性忘记。</p>\n<ul>\n<li>不紧张，不怯场，此处不留爷，自有留爷处，处处不留爷，爷干个体户</li>\n<li>千万不要进入面试官的套路，要将他引入你擅长的部分</li>\n<li>如果数据结构和算法不行，花点时间，看看大话数据结构和剑指offer吧。</li>\n</ul>\n<p>PS:有疑问，留言。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"2017学习计划","date":"2017-01-11T13:51:29.000Z","_content":"<Excerpt in index | 首页摘要>\n\n回顾2016，预定2017\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 郁闷\n最近想换份工作，尝试投了一些简历，然而，一个面试都没。这让我开始怀疑人生了，虽然说我从去年实习到现在只有一年多的时间，刚刚毕业半年，但是我每天晚上充电，可还是不行，可能是努力的还不够吧。\n\n### 2017计划\n\n* Android方面\n\t* 继续研究framework\n\t* 对插件话、热修复进行系统的分析(droidplugin、zuesplugin看完很长时间了，但是没写笔记)\n\t* 着手性能优化部分，如果可以的话，把公司项目，开一个分支出来，进行代码重构和优化吧，\n\t* 尝试对某一方面进行专题研究，如音视频、opengl等\n\t* 继续工作、工作\n* Java\n\t* 继续学习并发包中的内容\n\t* 继续学习数据结构在java中的实现\n\t* 继续学习jvm \t \n* Python\n\t* 想做一些好玩的东西\n\t* 尝试做下android自动化测试\n* 基础\n\t* 我的数据结构是真的烂\n\t* 我的算法是一窍不不同\n\t* 是时候改变一下了 \n\t\n* 其他\n\t* shell 随性吧\n\t* groovy\n\t* c++|c 为了能够看懂android native层次的代码，不能放弃\n\t* 想起来，再补\n\n### 学无止境\n\n为了更好的明天，加油吧。\n\t\n\t \n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/2017学习计划.md","raw":"---\ntitle: 2017学习计划\ndate: 2017-01-11 21:51:29\ncategories: 随笔\ntags: 计划总结\n\n---\n<Excerpt in index | 首页摘要>\n\n回顾2016，预定2017\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 郁闷\n最近想换份工作，尝试投了一些简历，然而，一个面试都没。这让我开始怀疑人生了，虽然说我从去年实习到现在只有一年多的时间，刚刚毕业半年，但是我每天晚上充电，可还是不行，可能是努力的还不够吧。\n\n### 2017计划\n\n* Android方面\n\t* 继续研究framework\n\t* 对插件话、热修复进行系统的分析(droidplugin、zuesplugin看完很长时间了，但是没写笔记)\n\t* 着手性能优化部分，如果可以的话，把公司项目，开一个分支出来，进行代码重构和优化吧，\n\t* 尝试对某一方面进行专题研究，如音视频、opengl等\n\t* 继续工作、工作\n* Java\n\t* 继续学习并发包中的内容\n\t* 继续学习数据结构在java中的实现\n\t* 继续学习jvm \t \n* Python\n\t* 想做一些好玩的东西\n\t* 尝试做下android自动化测试\n* 基础\n\t* 我的数据结构是真的烂\n\t* 我的算法是一窍不不同\n\t* 是时候改变一下了 \n\t\n* 其他\n\t* shell 随性吧\n\t* groovy\n\t* c++|c 为了能够看懂android native层次的代码，不能放弃\n\t* 想起来，再补\n\n### 学无止境\n\n为了更好的明天，加油吧。\n\t\n\t \n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"2017学习计划","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslwn000319fycsmqu1zc","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<p>回顾2016，预定2017</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"郁闷\"><a href=\"#郁闷\" class=\"headerlink\" title=\"郁闷\"></a>郁闷</h3><p>最近想换份工作，尝试投了一些简历，然而，一个面试都没。这让我开始怀疑人生了，虽然说我从去年实习到现在只有一年多的时间，刚刚毕业半年，但是我每天晚上充电，可还是不行，可能是努力的还不够吧。</p>\n<h3 id=\"2017计划\"><a href=\"#2017计划\" class=\"headerlink\" title=\"2017计划\"></a>2017计划</h3><ul>\n<li>Android方面<ul>\n<li>继续研究framework</li>\n<li>对插件话、热修复进行系统的分析(droidplugin、zuesplugin看完很长时间了，但是没写笔记)</li>\n<li>着手性能优化部分，如果可以的话，把公司项目，开一个分支出来，进行代码重构和优化吧，</li>\n<li>尝试对某一方面进行专题研究，如音视频、opengl等</li>\n<li>继续工作、工作</li>\n</ul>\n</li>\n<li>Java<ul>\n<li>继续学习并发包中的内容</li>\n<li>继续学习数据结构在java中的实现</li>\n<li>继续学习jvm      </li>\n</ul>\n</li>\n<li>Python<ul>\n<li>想做一些好玩的东西</li>\n<li>尝试做下android自动化测试</li>\n</ul>\n</li>\n<li><p>基础</p>\n<ul>\n<li>我的数据结构是真的烂</li>\n<li>我的算法是一窍不不同</li>\n<li>是时候改变一下了 </li>\n</ul>\n</li>\n<li><p>其他</p>\n<ul>\n<li>shell 随性吧</li>\n<li>groovy</li>\n<li>c++|c 为了能够看懂android native层次的代码，不能放弃</li>\n<li>想起来，再补</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"学无止境\"><a href=\"#学无止境\" class=\"headerlink\" title=\"学无止境\"></a>学无止境</h3><p>为了更好的明天，加油吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<p>回顾2016，预定2017</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"郁闷\"><a href=\"#郁闷\" class=\"headerlink\" title=\"郁闷\"></a>郁闷</h3><p>最近想换份工作，尝试投了一些简历，然而，一个面试都没。这让我开始怀疑人生了，虽然说我从去年实习到现在只有一年多的时间，刚刚毕业半年，但是我每天晚上充电，可还是不行，可能是努力的还不够吧。</p>\n<h3 id=\"2017计划\"><a href=\"#2017计划\" class=\"headerlink\" title=\"2017计划\"></a>2017计划</h3><ul>\n<li>Android方面<ul>\n<li>继续研究framework</li>\n<li>对插件话、热修复进行系统的分析(droidplugin、zuesplugin看完很长时间了，但是没写笔记)</li>\n<li>着手性能优化部分，如果可以的话，把公司项目，开一个分支出来，进行代码重构和优化吧，</li>\n<li>尝试对某一方面进行专题研究，如音视频、opengl等</li>\n<li>继续工作、工作</li>\n</ul>\n</li>\n<li>Java<ul>\n<li>继续学习并发包中的内容</li>\n<li>继续学习数据结构在java中的实现</li>\n<li>继续学习jvm      </li>\n</ul>\n</li>\n<li>Python<ul>\n<li>想做一些好玩的东西</li>\n<li>尝试做下android自动化测试</li>\n</ul>\n</li>\n<li><p>基础</p>\n<ul>\n<li>我的数据结构是真的烂</li>\n<li>我的算法是一窍不不同</li>\n<li>是时候改变一下了 </li>\n</ul>\n</li>\n<li><p>其他</p>\n<ul>\n<li>shell 随性吧</li>\n<li>groovy</li>\n<li>c++|c 为了能够看懂android native层次的代码，不能放弃</li>\n<li>想起来，再补</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"学无止境\"><a href=\"#学无止境\" class=\"headerlink\" title=\"学无止境\"></a>学无止境</h3><p>为了更好的明天，加油吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Activity启动流程","date":"2016-12-25T07:20:05.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2.从startActivity说起\n\n不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：\n\n```java\nInstrumentation.ActivityResult ar =\n    mInstrumentation.execStartActivity(\n        this, mMainThread.getApplicationThread(), mToken, this,\n        intent, requestCode, options);\nif (ar != null) {\n    mMainThread.sendActivityResult(\n        mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n        r.getResultData());\n}\n```\n\n* 通过Instrumentation去启动activiy，\n\n### 3.Instrumentation#execStartActivity\n\nInstrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。\n\n```java\n            int result = ActivityManagerNative.getDefault()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n                        token, target != null ? target.mEmbeddedID : null,\n                        requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n```\n\n* 通过AMS启动activity\n* 检查结果\n\nActivityManagerNative.getDefault()如下：\n\n```java\n    static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n```\n\n其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。\n\n### 4.ActivityManagerService#startActivity\n\n而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。\n\n```java\n    @Override\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n        enforceNotIsolatedCaller(\"startActivity\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                false, ALLOW_FULL_ONLY, \"startActivity\", null);\n        // TODO: Switch to user app stacks here.\n        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n                profilerInfo, null, null, options, false, userId, null, null);\n    }\n```\n\n这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。\n\n### 5.ActivityStackSupervisor#startActivityMayWait\n\n这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：\n\n```java\n            int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n                    voiceSession, voiceInteractor, resultTo, resultWho,\n                    requestCode, callingPid, callingUid, callingPackage,\n                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,\n                    componentSpecified, null, container, inTask);\n```\n\n而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：\n\n```java\n        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n                startFlags, true, options, inTask);\n```\n\nstartActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:\n\n```java\n        targetStack.mLastPausedActivity = null;\n        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n```\n\n* 其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as\n\n### 6.ActivityStack#startActivityLocked\n\n而这个方法的最下面有如下代码。\n\n```java\n        if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n```\n\n这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as\n\n```java\n result = targetStack.resumeTopActivityLocked(target, targetOptions);\n```\n\n绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked->resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用\n\n```java\nmStackSupervisor.startSpecificActivityLocked(next, true, false); \n```\n回到as，好吧，好绕。\n\n而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。\n\n```java\nrealStartActivityLocked(r, app, andResume, checkConfig);\n```\n\n在这个方法中做了什么呢？\n\n```java\n            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                    new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n```\n\n通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。\n\n\n### 7.ApplicationThread#scheduleLaunchActivity\n\n在这个方法中，发送一个消息，然后ActivityThread的H类去处理。\n\n```java\nsendMessage(H.LAUNCH_ACTIVITY, r);\n```\n\n接收到这个消息之后，调用handleLaunchActivity方法去处理。\n\n```java\nActivity a = performLaunchActivity(r, customIntent);\n```\n\n\n在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。\n\n```java\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n                    ...\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n```\n\n### 8.Instrumentation\n\n在这里，先是通过类加载器去构造类对象，\n\n```java\n(Activity)cl.loadClass(className).newInstance()\n```\n\n然后通过callActivityOnCreate方法，\n\n```java\n    public void callActivityOnCreate(Activity activity, Bundle icicle) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle);\n        postPerformCreate(activity);\n    }\n```\n调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。\n\n### 9.给张图吧。\n\n流程图不一定画的对。😢\n\n![](/images/framework/activity/Activity启动流程图.png)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/Activity启动流程.md","raw":"---\ntitle: Activity启动流程\ndate: 2016-12-25 15:20:05\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2.从startActivity说起\n\n不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：\n\n```java\nInstrumentation.ActivityResult ar =\n    mInstrumentation.execStartActivity(\n        this, mMainThread.getApplicationThread(), mToken, this,\n        intent, requestCode, options);\nif (ar != null) {\n    mMainThread.sendActivityResult(\n        mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n        r.getResultData());\n}\n```\n\n* 通过Instrumentation去启动activiy，\n\n### 3.Instrumentation#execStartActivity\n\nInstrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。\n\n```java\n            int result = ActivityManagerNative.getDefault()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n                        token, target != null ? target.mEmbeddedID : null,\n                        requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n```\n\n* 通过AMS启动activity\n* 检查结果\n\nActivityManagerNative.getDefault()如下：\n\n```java\n    static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n```\n\n其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。\n\n### 4.ActivityManagerService#startActivity\n\n而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。\n\n```java\n    @Override\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n        enforceNotIsolatedCaller(\"startActivity\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                false, ALLOW_FULL_ONLY, \"startActivity\", null);\n        // TODO: Switch to user app stacks here.\n        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n                profilerInfo, null, null, options, false, userId, null, null);\n    }\n```\n\n这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。\n\n### 5.ActivityStackSupervisor#startActivityMayWait\n\n这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：\n\n```java\n            int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n                    voiceSession, voiceInteractor, resultTo, resultWho,\n                    requestCode, callingPid, callingUid, callingPackage,\n                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,\n                    componentSpecified, null, container, inTask);\n```\n\n而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：\n\n```java\n        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n                startFlags, true, options, inTask);\n```\n\nstartActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:\n\n```java\n        targetStack.mLastPausedActivity = null;\n        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n```\n\n* 其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as\n\n### 6.ActivityStack#startActivityLocked\n\n而这个方法的最下面有如下代码。\n\n```java\n        if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n```\n\n这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as\n\n```java\n result = targetStack.resumeTopActivityLocked(target, targetOptions);\n```\n\n绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked->resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用\n\n```java\nmStackSupervisor.startSpecificActivityLocked(next, true, false); \n```\n回到as，好吧，好绕。\n\n而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。\n\n```java\nrealStartActivityLocked(r, app, andResume, checkConfig);\n```\n\n在这个方法中做了什么呢？\n\n```java\n            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                    new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n```\n\n通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。\n\n\n### 7.ApplicationThread#scheduleLaunchActivity\n\n在这个方法中，发送一个消息，然后ActivityThread的H类去处理。\n\n```java\nsendMessage(H.LAUNCH_ACTIVITY, r);\n```\n\n接收到这个消息之后，调用handleLaunchActivity方法去处理。\n\n```java\nActivity a = performLaunchActivity(r, customIntent);\n```\n\n\n在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。\n\n```java\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n                    ...\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n```\n\n### 8.Instrumentation\n\n在这里，先是通过类加载器去构造类对象，\n\n```java\n(Activity)cl.loadClass(className).newInstance()\n```\n\n然后通过callActivityOnCreate方法，\n\n```java\n    public void callActivityOnCreate(Activity activity, Bundle icicle) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle);\n        postPerformCreate(activity);\n    }\n```\n调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。\n\n### 9.给张图吧。\n\n流程图不一定画的对。😢\n\n![](/images/framework/activity/Activity启动流程图.png)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"Activity启动流程","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslwu000619fyet5dbx4x","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"2-从startActivity说起\"><a href=\"#2-从startActivity说起\" class=\"headerlink\" title=\"2.从startActivity说起\"></a>2.从startActivity说起</h3><p>不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Instrumentation.ActivityResult ar =</div><div class=\"line\">    mInstrumentation.execStartActivity(</div><div class=\"line\">        <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</div><div class=\"line\">        intent, requestCode, options);</div><div class=\"line\"><span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    mMainThread.sendActivityResult(</div><div class=\"line\">        mToken, mEmbeddedID, requestCode, ar.getResultCode(),</div><div class=\"line\">        r.getResultData());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Instrumentation去启动activiy，</li>\n</ul>\n<h3 id=\"3-Instrumentation-execStartActivity\"><a href=\"#3-Instrumentation-execStartActivity\" class=\"headerlink\" title=\"3.Instrumentation#execStartActivity\"></a>3.Instrumentation#execStartActivity</h3><p>Instrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</div><div class=\"line\">    .startActivity(whoThread, who.getBasePackageName(), intent,</div><div class=\"line\">            intent.resolveTypeIfNeeded(who.getContentResolver()),</div><div class=\"line\">            token, target != <span class=\"keyword\">null</span> ? target.mEmbeddedID : <span class=\"keyword\">null</span>,</div><div class=\"line\">            requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</div><div class=\"line\">checkStartActivityResult(result, intent);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过AMS启动activity</li>\n<li>检查结果</li>\n</ul>\n<p>ActivityManagerNative.getDefault()如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。</p>\n<h3 id=\"4-ActivityManagerService-startActivity\"><a href=\"#4-ActivityManagerService-startActivity\" class=\"headerlink\" title=\"4.ActivityManagerService#startActivity\"></a>4.ActivityManagerService#startActivity</h3><p>而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></div><div class=\"line\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</div><div class=\"line\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class=\"keyword\">int</span> userId) &#123;</div><div class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</div><div class=\"line\">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</div><div class=\"line\">            <span class=\"keyword\">false</span>, ALLOW_FULL_ONLY, <span class=\"string\">\"startActivity\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class=\"number\">1</span>, callingPackage, intent,</div><div class=\"line\">            resolvedType, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, resultTo, resultWho, requestCode, startFlags,</div><div class=\"line\">            profilerInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, options, <span class=\"keyword\">false</span>, userId, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。</p>\n<h3 id=\"5-ActivityStackSupervisor-startActivityMayWait\"><a href=\"#5-ActivityStackSupervisor-startActivityMayWait\" class=\"headerlink\" title=\"5.ActivityStackSupervisor#startActivityMayWait\"></a>5.ActivityStackSupervisor#startActivityMayWait</h3><p>这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> res = startActivityLocked(caller, intent, resolvedType, aInfo,</div><div class=\"line\">        voiceSession, voiceInteractor, resultTo, resultWho,</div><div class=\"line\">        requestCode, callingPid, callingUid, callingPackage,</div><div class=\"line\">        realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</div><div class=\"line\">        componentSpecified, <span class=\"keyword\">null</span>, container, inTask);</div></pre></td></tr></table></figure>\n<p>而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</div><div class=\"line\">        startFlags, <span class=\"keyword\">true</span>, options, inTask);</div></pre></td></tr></table></figure>\n<p>startActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">targetStack.mLastPausedActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as</li>\n</ul>\n<h3 id=\"6-ActivityStack-startActivityLocked\"><a href=\"#6-ActivityStack-startActivityLocked\" class=\"headerlink\" title=\"6.ActivityStack#startActivityLocked\"></a>6.ActivityStack#startActivityLocked</h3><p>而这个方法的最下面有如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (doResume) &#123;</div><div class=\"line\">    mStackSupervisor.resumeTopActivitiesLocked(<span class=\"keyword\">this</span>, r, options);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">result = targetStack.resumeTopActivityLocked(target, targetOptions);</div></pre></td></tr></table></figure>\n<p>绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked-&gt;resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>回到as，好吧，好绕。</p>\n<p>而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">realStartActivityLocked(r, app, andResume, checkConfig);</div></pre></td></tr></table></figure>\n<p>在这个方法中做了什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleLaunchActivity(<span class=\"keyword\">new</span> Intent(r.intent), r.appToken,</div><div class=\"line\">        System.identityHashCode(r), r.info, <span class=\"keyword\">new</span> Configuration(mService.mConfiguration),</div><div class=\"line\">        <span class=\"keyword\">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</div><div class=\"line\">        task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</div><div class=\"line\">        newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</div></pre></td></tr></table></figure>\n<p>通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。</p>\n<h3 id=\"7-ApplicationThread-scheduleLaunchActivity\"><a href=\"#7-ApplicationThread-scheduleLaunchActivity\" class=\"headerlink\" title=\"7.ApplicationThread#scheduleLaunchActivity\"></a>7.ApplicationThread#scheduleLaunchActivity</h3><p>在这个方法中，发送一个消息，然后ActivityThread的H类去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendMessage(H.LAUNCH_ACTIVITY, r);</div></pre></td></tr></table></figure>\n<p>接收到这个消息之后，调用handleLaunchActivity方法去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Activity a = performLaunchActivity(r, customIntent);</div></pre></td></tr></table></figure>\n<p>在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">activity = mInstrumentation.newActivity(</div><div class=\"line\">        cl, component.getClassName(), r.intent);</div><div class=\"line\">        ...</div><div class=\"line\">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div></pre></td></tr></table></figure>\n<h3 id=\"8-Instrumentation\"><a href=\"#8-Instrumentation\" class=\"headerlink\" title=\"8.Instrumentation\"></a>8.Instrumentation</h3><p>在这里，先是通过类加载器去构造类对象，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Activity)cl.loadClass(className).newInstance()</div></pre></td></tr></table></figure>\n<p>然后通过callActivityOnCreate方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle)</span> </span>&#123;</div><div class=\"line\">    prePerformCreate(activity);</div><div class=\"line\">    activity.performCreate(icicle);</div><div class=\"line\">    postPerformCreate(activity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。</p>\n<h3 id=\"9-给张图吧。\"><a href=\"#9-给张图吧。\" class=\"headerlink\" title=\"9.给张图吧。\"></a>9.给张图吧。</h3><p>流程图不一定画的对。😢</p>\n<p><img src=\"/images/framework/activity/Activity启动流程图.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"2-从startActivity说起\"><a href=\"#2-从startActivity说起\" class=\"headerlink\" title=\"2.从startActivity说起\"></a>2.从startActivity说起</h3><p>不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Instrumentation.ActivityResult ar =</div><div class=\"line\">    mInstrumentation.execStartActivity(</div><div class=\"line\">        <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</div><div class=\"line\">        intent, requestCode, options);</div><div class=\"line\"><span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    mMainThread.sendActivityResult(</div><div class=\"line\">        mToken, mEmbeddedID, requestCode, ar.getResultCode(),</div><div class=\"line\">        r.getResultData());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Instrumentation去启动activiy，</li>\n</ul>\n<h3 id=\"3-Instrumentation-execStartActivity\"><a href=\"#3-Instrumentation-execStartActivity\" class=\"headerlink\" title=\"3.Instrumentation#execStartActivity\"></a>3.Instrumentation#execStartActivity</h3><p>Instrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</div><div class=\"line\">    .startActivity(whoThread, who.getBasePackageName(), intent,</div><div class=\"line\">            intent.resolveTypeIfNeeded(who.getContentResolver()),</div><div class=\"line\">            token, target != <span class=\"keyword\">null</span> ? target.mEmbeddedID : <span class=\"keyword\">null</span>,</div><div class=\"line\">            requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</div><div class=\"line\">checkStartActivityResult(result, intent);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过AMS启动activity</li>\n<li>检查结果</li>\n</ul>\n<p>ActivityManagerNative.getDefault()如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。</p>\n<h3 id=\"4-ActivityManagerService-startActivity\"><a href=\"#4-ActivityManagerService-startActivity\" class=\"headerlink\" title=\"4.ActivityManagerService#startActivity\"></a>4.ActivityManagerService#startActivity</h3><p>而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</div><div class=\"line\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</div><div class=\"line\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class=\"keyword\">int</span> userId)</span> </span>&#123;</div><div class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</div><div class=\"line\">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</div><div class=\"line\">            <span class=\"keyword\">false</span>, ALLOW_FULL_ONLY, <span class=\"string\">\"startActivity\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class=\"number\">1</span>, callingPackage, intent,</div><div class=\"line\">            resolvedType, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, resultTo, resultWho, requestCode, startFlags,</div><div class=\"line\">            profilerInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, options, <span class=\"keyword\">false</span>, userId, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。</p>\n<h3 id=\"5-ActivityStackSupervisor-startActivityMayWait\"><a href=\"#5-ActivityStackSupervisor-startActivityMayWait\" class=\"headerlink\" title=\"5.ActivityStackSupervisor#startActivityMayWait\"></a>5.ActivityStackSupervisor#startActivityMayWait</h3><p>这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> res = startActivityLocked(caller, intent, resolvedType, aInfo,</div><div class=\"line\">        voiceSession, voiceInteractor, resultTo, resultWho,</div><div class=\"line\">        requestCode, callingPid, callingUid, callingPackage,</div><div class=\"line\">        realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</div><div class=\"line\">        componentSpecified, <span class=\"keyword\">null</span>, container, inTask);</div></pre></td></tr></table></figure>\n<p>而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</div><div class=\"line\">        startFlags, <span class=\"keyword\">true</span>, options, inTask);</div></pre></td></tr></table></figure>\n<p>startActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">targetStack.mLastPausedActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as</li>\n</ul>\n<h3 id=\"6-ActivityStack-startActivityLocked\"><a href=\"#6-ActivityStack-startActivityLocked\" class=\"headerlink\" title=\"6.ActivityStack#startActivityLocked\"></a>6.ActivityStack#startActivityLocked</h3><p>而这个方法的最下面有如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (doResume) &#123;</div><div class=\"line\">    mStackSupervisor.resumeTopActivitiesLocked(<span class=\"keyword\">this</span>, r, options);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">result = targetStack.resumeTopActivityLocked(target, targetOptions);</div></pre></td></tr></table></figure>\n<p>绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked-&gt;resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>回到as，好吧，好绕。</p>\n<p>而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">realStartActivityLocked(r, app, andResume, checkConfig);</div></pre></td></tr></table></figure>\n<p>在这个方法中做了什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleLaunchActivity(<span class=\"keyword\">new</span> Intent(r.intent), r.appToken,</div><div class=\"line\">        System.identityHashCode(r), r.info, <span class=\"keyword\">new</span> Configuration(mService.mConfiguration),</div><div class=\"line\">        <span class=\"keyword\">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</div><div class=\"line\">        task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</div><div class=\"line\">        newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</div></pre></td></tr></table></figure>\n<p>通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。</p>\n<h3 id=\"7-ApplicationThread-scheduleLaunchActivity\"><a href=\"#7-ApplicationThread-scheduleLaunchActivity\" class=\"headerlink\" title=\"7.ApplicationThread#scheduleLaunchActivity\"></a>7.ApplicationThread#scheduleLaunchActivity</h3><p>在这个方法中，发送一个消息，然后ActivityThread的H类去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendMessage(H.LAUNCH_ACTIVITY, r);</div></pre></td></tr></table></figure>\n<p>接收到这个消息之后，调用handleLaunchActivity方法去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Activity a = performLaunchActivity(r, customIntent);</div></pre></td></tr></table></figure>\n<p>在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">activity = mInstrumentation.newActivity(</div><div class=\"line\">        cl, component.getClassName(), r.intent);</div><div class=\"line\">        ...</div><div class=\"line\">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div></pre></td></tr></table></figure>\n<h3 id=\"8-Instrumentation\"><a href=\"#8-Instrumentation\" class=\"headerlink\" title=\"8.Instrumentation\"></a>8.Instrumentation</h3><p>在这里，先是通过类加载器去构造类对象，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Activity)cl.loadClass(className).newInstance()</div></pre></td></tr></table></figure>\n<p>然后通过callActivityOnCreate方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle)</span> </span>&#123;</div><div class=\"line\">    prePerformCreate(activity);</div><div class=\"line\">    activity.performCreate(icicle);</div><div class=\"line\">    postPerformCreate(activity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。</p>\n<h3 id=\"9-给张图吧。\"><a href=\"#9-给张图吧。\" class=\"headerlink\" title=\"9.给张图吧。\"></a>9.给张图吧。</h3><p>流程图不一定画的对。😢</p>\n<p><img src=\"/images/framework/activity/Activity启动流程图.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android","date":"2018-01-18T12:29:36.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 问题描述\n\n从7.0开始，https方面行为发生了变更。当我们的证书是一个默认不被系统信任的CA机构颁布的时候，就会出现问题。具体文档[security-config](https://developer.android.com/training/articles/security-config.html)\n\n我的情况是这样的，证书是一个不被系统认证的CA机构发的，我把这个CA的证书安装到手机的时候，7.0以下，行为正常，7.0以上行为不正常。用过查阅资料发现，是系统行为发生了变更。\n\n### 解决这个问题\n\n7.0以上，默认只信任系统信任的证书，也就是说，即使你安装了CA的证书，还是不被信任的。怎么处理这个问题呢？很简单。\n\n新建一个xml文件,我这里起名network_security_config。\n\n```\n<network-security-config>    \n   <base-config>  \n      <trust-anchors>\n          <certificates src=\"system\" />\n          <certificates src=\"user\" />\n      </trust-anchors>\n   </base-config>\n</network-security-config>\n```\n\n并在配置文件中配置\t```android:networkSecurityConfig=”@xml/network_security_config” ```\n\n这样就可以了。详细的资料，去看上面的那个链接吧。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Android7以上https证书问题适配.md","raw":"---\ntitle: Android\ndate: 2018-01-18 20:29:36\ntags: Android\n\n---\n<Excerpt in index | 首页摘要>\n\n### 问题描述\n\n从7.0开始，https方面行为发生了变更。当我们的证书是一个默认不被系统信任的CA机构颁布的时候，就会出现问题。具体文档[security-config](https://developer.android.com/training/articles/security-config.html)\n\n我的情况是这样的，证书是一个不被系统认证的CA机构发的，我把这个CA的证书安装到手机的时候，7.0以下，行为正常，7.0以上行为不正常。用过查阅资料发现，是系统行为发生了变更。\n\n### 解决这个问题\n\n7.0以上，默认只信任系统信任的证书，也就是说，即使你安装了CA的证书，还是不被信任的。怎么处理这个问题呢？很简单。\n\n新建一个xml文件,我这里起名network_security_config。\n\n```\n<network-security-config>    \n   <base-config>  \n      <trust-anchors>\n          <certificates src=\"system\" />\n          <certificates src=\"user\" />\n      </trust-anchors>\n   </base-config>\n</network-security-config>\n```\n\n并在配置文件中配置\t```android:networkSecurityConfig=”@xml/network_security_config” ```\n\n这样就可以了。详细的资料，去看上面的那个链接吧。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Android7以上https证书问题适配","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslwz000919fyc17sxdrt","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>从7.0开始，https方面行为发生了变更。当我们的证书是一个默认不被系统信任的CA机构颁布的时候，就会出现问题。具体文档<a href=\"https://developer.android.com/training/articles/security-config.html\" target=\"_blank\" rel=\"external\">security-config</a></p>\n<p>我的情况是这样的，证书是一个不被系统认证的CA机构发的，我把这个CA的证书安装到手机的时候，7.0以下，行为正常，7.0以上行为不正常。用过查阅资料发现，是系统行为发生了变更。</p>\n<h3 id=\"解决这个问题\"><a href=\"#解决这个问题\" class=\"headerlink\" title=\"解决这个问题\"></a>解决这个问题</h3><p>7.0以上，默认只信任系统信任的证书，也就是说，即使你安装了CA的证书，还是不被信任的。怎么处理这个问题呢？很简单。</p>\n<p>新建一个xml文件,我这里起名network_security_config。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;network-security-config&gt;    </div><div class=\"line\">   &lt;base-config&gt;  </div><div class=\"line\">      &lt;trust-anchors&gt;</div><div class=\"line\">          &lt;certificates src=&quot;system&quot; /&gt;</div><div class=\"line\">          &lt;certificates src=&quot;user&quot; /&gt;</div><div class=\"line\">      &lt;/trust-anchors&gt;</div><div class=\"line\">   &lt;/base-config&gt;</div><div class=\"line\">&lt;/network-security-config&gt;</div></pre></td></tr></table></figure>\n<p>并在配置文件中配置    <code>android:networkSecurityConfig=”@xml/network_security_config”</code></p>\n<p>这样就可以了。详细的资料，去看上面的那个链接吧。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>从7.0开始，https方面行为发生了变更。当我们的证书是一个默认不被系统信任的CA机构颁布的时候，就会出现问题。具体文档<a href=\"https://developer.android.com/training/articles/security-config.html\">security-config</a></p>\n<p>我的情况是这样的，证书是一个不被系统认证的CA机构发的，我把这个CA的证书安装到手机的时候，7.0以下，行为正常，7.0以上行为不正常。用过查阅资料发现，是系统行为发生了变更。</p>\n<h3 id=\"解决这个问题\"><a href=\"#解决这个问题\" class=\"headerlink\" title=\"解决这个问题\"></a>解决这个问题</h3><p>7.0以上，默认只信任系统信任的证书，也就是说，即使你安装了CA的证书，还是不被信任的。怎么处理这个问题呢？很简单。</p>\n<p>新建一个xml文件,我这里起名network_security_config。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;network-security-config&gt;    </div><div class=\"line\">   &lt;base-config&gt;  </div><div class=\"line\">      &lt;trust-anchors&gt;</div><div class=\"line\">          &lt;certificates src=&quot;system&quot; /&gt;</div><div class=\"line\">          &lt;certificates src=&quot;user&quot; /&gt;</div><div class=\"line\">      &lt;/trust-anchors&gt;</div><div class=\"line\">   &lt;/base-config&gt;</div><div class=\"line\">&lt;/network-security-config&gt;</div></pre></td></tr></table></figure>\n<p>并在配置文件中配置    <code>android:networkSecurityConfig=”@xml/network_security_config”</code></p>\n<p>这样就可以了。详细的资料，去看上面的那个链接吧。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"AMS中的进程管理部分－上","date":"2017-01-05T03:41:01.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1.前言\n\nActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 新建进程\n* 调整进程在mLruProcesses的位置\n* 调整进程OomAdj值\n* 杀进程\n\n而新建进程在前面有说到过，今天就来介绍下剩下的三个。\n\n### 2.调整位置的updateLruProcessLocked方法\n\n代码比较长，分段看。\n\n```\n        final boolean hasActivity = app.activities.size() > 0 || app.hasClientActivities\n                || app.treatLikeActivity;\n        final boolean hasService = false; // not impl yet. app.services.size() > 0;\n        if (!activityChange && hasActivity) {\n            // The process has activities, so we are only allowing activity-based adjustments\n            // to move it.  It should be kept in the front of the list with other\n            // processes that have activities, and we don't want those to change their\n            // order except due to activity operations.\n            return;\n        }\n\n        mLruSeq++;\n        final long now = SystemClock.uptimeMillis();\n        app.lastActivityTime = now;\n\n        // First a quick reject: if the app is already at the position we will\n        // put it, then there is nothing to do.\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (N > 0 && mLruProcesses.get(N-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top activity: \" + app);\n                return;\n            }\n        } else {\n            if (mLruProcessServiceStart > 0\n                    && mLruProcesses.get(mLruProcessServiceStart-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top other: \" + app);\n                return;\n            }\n        }\n\n        int lrui = mLruProcesses.lastIndexOf(app);\n\n        if (app.persistent && lrui >= 0) {\n            // We don't care about the position of persistent processes, as long as\n            // they are in the list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, persistent: \" + app);\n            return;\n        }\n```\n\n* 如果有activity，并且进程中activity没有发生变化，不需要调整\n* 如果有activity，但是当前进程就是在最后，不需要调整\n* 如果没有activity，但是在合适的位置，不需要调整\n* 如果有persistent标志，不需要调整\n* lrui 为当前进程在list中的索引(最后一个的索引)\n\n```\n        if (lrui >= 0) {\n            if (lrui < mLruProcessActivityStart) {\n                mLruProcessActivityStart--;\n            }\n            if (lrui < mLruProcessServiceStart) {\n                mLruProcessServiceStart--;\n            }\n            /*\n            if (addIndex > lrui) {\n                addIndex--;\n            }\n            if (nextIndex > lrui) {\n                nextIndex--;\n            }\n            */\n            mLruProcesses.remove(lrui);\n        }\n\n```\n\n如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。\n\n```\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (app.activities.size() == 0 && mLruProcessActivityStart < (N - 1)) {\n                // Process doesn't have activities, but has clients with\n                // activities...  move it up, but one below the top (the top\n                // should always have a real activity).\n                if (DEBUG_LRU) Slog.d(TAG_LRU,\n                        \"Adding to second-top of LRU activity list: \" + app);\n                mLruProcesses.add(N - 1, app);\n                // To keep it from spamming the LRU list (by making a bunch of clients),\n                // we will push down any other entries owned by the app.\n                final int uid = app.info.uid;\n                for (int i = N - 2; i > mLruProcessActivityStart; i--) {\n                    ProcessRecord subProc = mLruProcesses.get(i);\n                    if (subProc.info.uid == uid) {\n                        // We want to push this one down the list.  If the process after\n                        // it is for the same uid, however, don't do so, because we don't\n                        // want them internally to be re-ordered.\n                        if (mLruProcesses.get(i - 1).info.uid != uid) {\n                            if (DEBUG_LRU) Slog.d(TAG_LRU,\n                                    \"Pushing uid \" + uid + \" swapping at \" + i + \": \"\n                                    + mLruProcesses.get(i) + \" : \" + mLruProcesses.get(i - 1));\n                            ProcessRecord tmp = mLruProcesses.get(i);\n                            mLruProcesses.set(i, mLruProcesses.get(i - 1));\n                            mLruProcesses.set(i - 1, tmp);\n                            i--;\n                        }\n                    } else {\n                        // A gap, we can stop here.\n                        break;\n                    }\n                }\n            } else {\n                // Process has activities, put it at the very tipsy-top.\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU activity list: \" + app);\n                mLruProcesses.add(app);\n            }\n            nextIndex = mLruProcessServiceStart;\n        } else if (hasService) {\n            // Process has services, put it at the top of the service list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU service list: \" + app);\n            mLruProcesses.add(mLruProcessActivityStart, app);\n            nextIndex = mLruProcessServiceStart;\n            mLruProcessActivityStart++;\n        } else  {\n            // Process not otherwise of interest, it goes to the top of the non-service area.\n            int index = mLruProcessServiceStart;\n            if (client != null) {\n                // If there is a client, don't allow the process to be moved up higher\n                // in the list than that client.\n                int clientIndex = mLruProcesses.lastIndexOf(client);\n                if (DEBUG_LRU && clientIndex < 0) Slog.d(TAG_LRU, \"Unknown client \" + client\n                        + \" when updating \" + app);\n                if (clientIndex <= lrui) {\n                    // Don't allow the client index restriction to push it down farther in the\n                    // list than it already is.\n                    clientIndex = lrui;\n                }\n                if (clientIndex >= 0 && index > clientIndex) {\n                    index = clientIndex;\n                }\n            }\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding at \" + index + \" of LRU list: \" + app);\n            mLruProcesses.add(index, app);\n            nextIndex = index-1;\n            mLruProcessActivityStart++;\n            mLruProcessServiceStart++;\n        }\n\n```\n\n* hasActivity为true\n\t* 没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。\n\t* 直接添加到最后一个\n* hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置\n* 因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处\n\n\n```\n        for (int j=app.connections.size()-1; j>=0; j--) {\n            ConnectionRecord cr = app.connections.valueAt(j);\n            if (cr.binding != null && !cr.serviceDead && cr.binding.service != null\n                    && cr.binding.service.app != null\n                    && cr.binding.service.app.lruSeq != mLruSeq\n                    && !cr.binding.service.app.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,\n                        \"service connection\", cr, app);\n            }\n        }\n        for (int j=app.conProviders.size()-1; j>=0; j--) {\n            ContentProviderRecord cpr = app.conProviders.get(j).provider;\n            if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq && !cpr.proc.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,\n                        \"provider reference\", cpr, app);\n            }\n        }\n```\n\n把和这个进程关联的service和contentprovider调整到这个进程之后。\n\n### 3. 调整OomAdj值的updateOomAdjLocked方法\n\n方法较长，分段看。\n\n```\n        final ActivityRecord TOP_ACT = resumedAppLocked();\n        final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;\n        final long now = SystemClock.uptimeMillis();\n        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;\n        final int N = mLruProcesses.size();\n\n        if (false) {\n            RuntimeException e = new RuntimeException();\n            e.fillInStackTrace();\n            Slog.i(TAG, \"updateOomAdj: top=\" + TOP_ACT, e);\n        }\n\n        // Reset state in all uid records.\n        for (int i=mActiveUids.size()-1; i>=0; i--) {\n            final UidRecord uidRec = mActiveUids.valueAt(i);\n            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,\n                    \"Starting update of \" + uidRec);\n            uidRec.reset();\n        }\n\n        mAdjSeq++;\n        mNewNumServiceProcs = 0;\n        mNewNumAServiceProcs = 0;\n\n        final int emptyProcessLimit;\n        final int cachedProcessLimit;\n        if (mProcessLimit <= 0) {\n            emptyProcessLimit = cachedProcessLimit = 0;\n        } else if (mProcessLimit == 1) {\n            emptyProcessLimit = 1;\n            cachedProcessLimit = 0;\n        } else {\n            emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);\n            cachedProcessLimit = mProcessLimit - emptyProcessLimit;\n        }\n\n        // Let's determine how many processes we have running vs.\n        // how many slots we have for background processes; we may want\n        // to put multiple processes in a slot of there are enough of\n        // them.\n        int numSlots = (ProcessList.CACHED_APP_MAX_ADJ\n                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;\n        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;\n        if (numEmptyProcs > cachedProcessLimit) {\n            // If there are more empty processes than our limit on cached\n            // processes, then use the cached process limit for the factor.\n            // This ensures that the really old empty processes get pushed\n            // down to the bottom, so if we are running low on memory we will\n            // have a better chance at keeping around more cached processes\n            // instead of a gazillion empty processes.\n            numEmptyProcs = cachedProcessLimit;\n        }\n        int emptyFactor = numEmptyProcs/numSlots;\n        if (emptyFactor < 1) emptyFactor = 1;\n        int cachedFactor = (mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1)/numSlots;\n        if (cachedFactor < 1) cachedFactor = 1;\n        int stepCached = 0;\n        int stepEmpty = 0;\n        int numCached = 0;\n        int numEmpty = 0;\n        int numTrimming = 0;\n\n        mNumNonCachedProcs = 0;\n        mNumCachedHiddenProcs = 0;\n\n```\n\n这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。\n\n\n```\n int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextCachedAdj = curCachedAdj+1;\n        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextEmptyAdj = curEmptyAdj+2;\n        for (int i=N-1; i>=0; i--) {\n            ProcessRecord app = mLruProcesses.get(i);\n            if (!app.killedByAm && app.thread != null) {\n                app.procStateChanged = false;\n                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);\n\n                // If we haven't yet assigned the final cached adj\n                // to the process, do that now.\n                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {\n                    switch (app.curProcState) {\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                            // This process is a cached process holding activities...\n                            // assign it the next cached value for that type, and then\n                            // step that cached level.\n                            app.curRawAdj = curCachedAdj;\n                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning activity LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curCachedAdj=\" + curCachedAdj\n                                    + \")\");\n                            if (curCachedAdj != nextCachedAdj) {\n                                stepCached++;\n                                if (stepCached >= cachedFactor) {\n                                    stepCached = 0;\n                                    curCachedAdj = nextCachedAdj;\n                                    nextCachedAdj += 2;\n                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                        default:\n                            // For everything else, assign next empty cached process\n                            // level and bump that up.  Note that this means that\n                            // long-running services that have dropped down to the\n                            // cached level will be treated as empty (since their process\n                            // state is still as a service), which is what we want.\n                            app.curRawAdj = curEmptyAdj;\n                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning empty LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curEmptyAdj=\" + curEmptyAdj\n                                    + \")\");\n                            if (curEmptyAdj != nextEmptyAdj) {\n                                stepEmpty++;\n                                if (stepEmpty >= emptyFactor) {\n                                    stepEmpty = 0;\n                                    curEmptyAdj = nextEmptyAdj;\n                                    nextEmptyAdj += 2;\n                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                    }\n                }\n\n                applyOomAdjLocked(app, true, now);\n\n                // Count the number of process types.\n                switch (app.curProcState) {\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                        mNumCachedHiddenProcs++;\n                        numCached++;\n                        if (numCached > cachedProcessLimit) {\n                            app.kill(\"cached #\" + numCached, true);\n                        }\n                        break;\n                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:\n                        if (numEmpty > ProcessList.TRIM_EMPTY_APPS\n                                && app.lastActivityTime < oldTime) {\n                            app.kill(\"empty for \"\n                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)\n                                    / 1000) + \"s\", true);\n                        } else {\n                            numEmpty++;\n                            if (numEmpty > emptyProcessLimit) {\n                                app.kill(\"empty #\" + numEmpty, true);\n                            }\n                        }\n                        break;\n                    default:\n                        mNumNonCachedProcs++;\n                        break;\n                }\n\n                if (app.isolated && app.services.size() <= 0) {\n                    // If this is an isolated process, and there are no\n                    // services running in it, then the process is no longer\n                    // needed.  We agressively kill these because we can by\n                    // definition not re-use the same process again, and it is\n                    // good to avoid having whatever code was running in them\n                    // left sitting around after no longer needed.\n                    app.kill(\"isolated not needed\", true);\n                } else {\n                    // Keeping this process, update its uid.\n                    final UidRecord uidRec = app.uidRecord;\n                    if (uidRec != null && uidRec.curProcState > app.curProcState) {\n                        uidRec.curProcState = app.curProcState;\n                    }\n                }\n\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    numTrimming++;\n                }\n            }\n        }\n```\n\n\n上面代码的逻辑是更新进程oomadj值。\n\n* 首先通过computeOomAdjLocked计算oomadj值\n* 当进程未分配adj值是，更新adj值(if (app.curAdj >= ProcessList.UNKNOWN_ADJ))\n\t* 当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值\n\t* 不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值\n* applyOomAdjLocked,使更新生效\n* 根据进程状态，选择策略\n\t* PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程\n\t* PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程\n* 如果是孤立进程 并且没有service，直接杀掉\n\n\n```\n        final int numCachedAndEmpty = numCached + numEmpty;\n        int memFactor;\n        if (numCached <= ProcessList.TRIM_CACHED_APPS\n                && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {\n            if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n            } else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n            } else {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n            }\n        } else {\n            memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n        }\n        // We always allow the memory level to go up (better).  We only allow it to go\n        // down if we are in a state where that is allowed, *and* the total number of processes\n        // has gone down since last time.\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"oom: memFactor=\" + memFactor\n                + \" last=\" + mLastMemoryLevel + \" allowLow=\" + mAllowLowerMemLevel\n                + \" numProcs=\" + mLruProcesses.size() + \" last=\" + mLastNumProcesses);\n        if (memFactor > mLastMemoryLevel) {\n            if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {\n                memFactor = mLastMemoryLevel;\n                if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"Keeping last mem factor!\");\n            }\n        }\n        mLastMemoryLevel = memFactor;\n        mLastNumProcesses = mLruProcesses.size();\n        boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\n        final int trackerMemFactor = mProcessStats.getMemFactorLocked();\n        if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n            if (mLowRamStartTime == 0) {\n                mLowRamStartTime = now;\n            }\n            int step = 0;\n            int fgTrimLevel;\n            switch (memFactor) {\n                case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n                    break;\n                case ProcessStats.ADJ_MEM_FACTOR_LOW:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n                    break;\n                default:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n                    break;\n            }\n            int factor = numTrimming/3;\n            int minFactor = 2;\n            if (mHomeProcess != null) minFactor++;\n            if (mPreviousProcess != null) minFactor++;\n            if (factor < minFactor) factor = minFactor;\n            int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    if (app.trimMemoryLevel < curLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of \" + app.processName + \" to \" + curLevel);\n                            app.thread.scheduleTrimMemory(curLevel);\n                        } catch (RemoteException e) {\n                        }\n                        if (false) {\n                            // For now we won't do this; our memory trimming seems\n                            // to be good enough at this point that destroying\n                            // activities causes more harm than good.\n                            if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                                    && app != mHomeProcess && app != mPreviousProcess) {\n                                // Need to do this on its own message because the stack may not\n                                // be in a consistent state at this point.\n                                // For these apps we will also finish their activities\n                                // to help them free memory.\n                                mStackSupervisor.scheduleDestroyAllActivities(app, \"trim\");\n                            }\n                        }\n                    }\n                    app.trimMemoryLevel = curLevel;\n                    step++;\n                    if (step >= factor) {\n                        step = 0;\n                        switch (curLevel) {\n                            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                                break;\n                            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                                break;\n                        }\n                    }\n                } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of heavy-weight \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                } else {\n                    if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                            || app.systemNoUi) && app.pendingUiClean) {\n                        // If this application is now in the background and it\n                        // had done UI, then give it the special trim level to\n                        // have it free UI resources.\n                        final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                        if (app.trimMemoryLevel < level && app.thread != null) {\n                            try {\n                                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                        \"Trimming memory of bg-ui \" + app.processName\n                                        + \" to \" + level);\n                                app.thread.scheduleTrimMemory(level);\n                            } catch (RemoteException e) {\n                            }\n                        }\n                        app.pendingUiClean = false;\n                    }\n                    if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of fg \" + app.processName\n                                    + \" to \" + fgTrimLevel);\n                            app.thread.scheduleTrimMemory(fgTrimLevel);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = fgTrimLevel;\n                }\n            }\n        } else {\n            if (mLowRamStartTime != 0) {\n                mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n                mLowRamStartTime = 0;\n            }\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                        || app.systemNoUi) && app.pendingUiClean) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of ui hidden \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.pendingUiClean = false;\n                }\n                app.trimMemoryLevel = 0;\n            }\n        }\n```\t\n\n* 先调整内存因子memFactor\n* 如果内存因子不为0\n\t* 根据内存因子 初始化fgTrimLevel\n\t* 循环处理进程\n\t\t* curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel\n\t\t* curProcState等于9，且满足条件，进行TrimMemory\n\t\t* 其他情况下，根据条件进行TrimMemory操作\n\t \n* 内存因子为0,也是根据跳进进行TrimMemory操作\n\n整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。\n\ncomputeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。\n\n### 4.杀进程\n\n杀进程这里就略过了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\t","source":"_posts/AMS中的进程管理部分－上.md","raw":"---\ntitle: AMS中的进程管理部分－上\ndate: 2017-01-05 11:41:01\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1.前言\n\nActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 新建进程\n* 调整进程在mLruProcesses的位置\n* 调整进程OomAdj值\n* 杀进程\n\n而新建进程在前面有说到过，今天就来介绍下剩下的三个。\n\n### 2.调整位置的updateLruProcessLocked方法\n\n代码比较长，分段看。\n\n```\n        final boolean hasActivity = app.activities.size() > 0 || app.hasClientActivities\n                || app.treatLikeActivity;\n        final boolean hasService = false; // not impl yet. app.services.size() > 0;\n        if (!activityChange && hasActivity) {\n            // The process has activities, so we are only allowing activity-based adjustments\n            // to move it.  It should be kept in the front of the list with other\n            // processes that have activities, and we don't want those to change their\n            // order except due to activity operations.\n            return;\n        }\n\n        mLruSeq++;\n        final long now = SystemClock.uptimeMillis();\n        app.lastActivityTime = now;\n\n        // First a quick reject: if the app is already at the position we will\n        // put it, then there is nothing to do.\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (N > 0 && mLruProcesses.get(N-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top activity: \" + app);\n                return;\n            }\n        } else {\n            if (mLruProcessServiceStart > 0\n                    && mLruProcesses.get(mLruProcessServiceStart-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top other: \" + app);\n                return;\n            }\n        }\n\n        int lrui = mLruProcesses.lastIndexOf(app);\n\n        if (app.persistent && lrui >= 0) {\n            // We don't care about the position of persistent processes, as long as\n            // they are in the list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, persistent: \" + app);\n            return;\n        }\n```\n\n* 如果有activity，并且进程中activity没有发生变化，不需要调整\n* 如果有activity，但是当前进程就是在最后，不需要调整\n* 如果没有activity，但是在合适的位置，不需要调整\n* 如果有persistent标志，不需要调整\n* lrui 为当前进程在list中的索引(最后一个的索引)\n\n```\n        if (lrui >= 0) {\n            if (lrui < mLruProcessActivityStart) {\n                mLruProcessActivityStart--;\n            }\n            if (lrui < mLruProcessServiceStart) {\n                mLruProcessServiceStart--;\n            }\n            /*\n            if (addIndex > lrui) {\n                addIndex--;\n            }\n            if (nextIndex > lrui) {\n                nextIndex--;\n            }\n            */\n            mLruProcesses.remove(lrui);\n        }\n\n```\n\n如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。\n\n```\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (app.activities.size() == 0 && mLruProcessActivityStart < (N - 1)) {\n                // Process doesn't have activities, but has clients with\n                // activities...  move it up, but one below the top (the top\n                // should always have a real activity).\n                if (DEBUG_LRU) Slog.d(TAG_LRU,\n                        \"Adding to second-top of LRU activity list: \" + app);\n                mLruProcesses.add(N - 1, app);\n                // To keep it from spamming the LRU list (by making a bunch of clients),\n                // we will push down any other entries owned by the app.\n                final int uid = app.info.uid;\n                for (int i = N - 2; i > mLruProcessActivityStart; i--) {\n                    ProcessRecord subProc = mLruProcesses.get(i);\n                    if (subProc.info.uid == uid) {\n                        // We want to push this one down the list.  If the process after\n                        // it is for the same uid, however, don't do so, because we don't\n                        // want them internally to be re-ordered.\n                        if (mLruProcesses.get(i - 1).info.uid != uid) {\n                            if (DEBUG_LRU) Slog.d(TAG_LRU,\n                                    \"Pushing uid \" + uid + \" swapping at \" + i + \": \"\n                                    + mLruProcesses.get(i) + \" : \" + mLruProcesses.get(i - 1));\n                            ProcessRecord tmp = mLruProcesses.get(i);\n                            mLruProcesses.set(i, mLruProcesses.get(i - 1));\n                            mLruProcesses.set(i - 1, tmp);\n                            i--;\n                        }\n                    } else {\n                        // A gap, we can stop here.\n                        break;\n                    }\n                }\n            } else {\n                // Process has activities, put it at the very tipsy-top.\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU activity list: \" + app);\n                mLruProcesses.add(app);\n            }\n            nextIndex = mLruProcessServiceStart;\n        } else if (hasService) {\n            // Process has services, put it at the top of the service list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU service list: \" + app);\n            mLruProcesses.add(mLruProcessActivityStart, app);\n            nextIndex = mLruProcessServiceStart;\n            mLruProcessActivityStart++;\n        } else  {\n            // Process not otherwise of interest, it goes to the top of the non-service area.\n            int index = mLruProcessServiceStart;\n            if (client != null) {\n                // If there is a client, don't allow the process to be moved up higher\n                // in the list than that client.\n                int clientIndex = mLruProcesses.lastIndexOf(client);\n                if (DEBUG_LRU && clientIndex < 0) Slog.d(TAG_LRU, \"Unknown client \" + client\n                        + \" when updating \" + app);\n                if (clientIndex <= lrui) {\n                    // Don't allow the client index restriction to push it down farther in the\n                    // list than it already is.\n                    clientIndex = lrui;\n                }\n                if (clientIndex >= 0 && index > clientIndex) {\n                    index = clientIndex;\n                }\n            }\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding at \" + index + \" of LRU list: \" + app);\n            mLruProcesses.add(index, app);\n            nextIndex = index-1;\n            mLruProcessActivityStart++;\n            mLruProcessServiceStart++;\n        }\n\n```\n\n* hasActivity为true\n\t* 没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。\n\t* 直接添加到最后一个\n* hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置\n* 因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处\n\n\n```\n        for (int j=app.connections.size()-1; j>=0; j--) {\n            ConnectionRecord cr = app.connections.valueAt(j);\n            if (cr.binding != null && !cr.serviceDead && cr.binding.service != null\n                    && cr.binding.service.app != null\n                    && cr.binding.service.app.lruSeq != mLruSeq\n                    && !cr.binding.service.app.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,\n                        \"service connection\", cr, app);\n            }\n        }\n        for (int j=app.conProviders.size()-1; j>=0; j--) {\n            ContentProviderRecord cpr = app.conProviders.get(j).provider;\n            if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq && !cpr.proc.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,\n                        \"provider reference\", cpr, app);\n            }\n        }\n```\n\n把和这个进程关联的service和contentprovider调整到这个进程之后。\n\n### 3. 调整OomAdj值的updateOomAdjLocked方法\n\n方法较长，分段看。\n\n```\n        final ActivityRecord TOP_ACT = resumedAppLocked();\n        final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;\n        final long now = SystemClock.uptimeMillis();\n        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;\n        final int N = mLruProcesses.size();\n\n        if (false) {\n            RuntimeException e = new RuntimeException();\n            e.fillInStackTrace();\n            Slog.i(TAG, \"updateOomAdj: top=\" + TOP_ACT, e);\n        }\n\n        // Reset state in all uid records.\n        for (int i=mActiveUids.size()-1; i>=0; i--) {\n            final UidRecord uidRec = mActiveUids.valueAt(i);\n            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,\n                    \"Starting update of \" + uidRec);\n            uidRec.reset();\n        }\n\n        mAdjSeq++;\n        mNewNumServiceProcs = 0;\n        mNewNumAServiceProcs = 0;\n\n        final int emptyProcessLimit;\n        final int cachedProcessLimit;\n        if (mProcessLimit <= 0) {\n            emptyProcessLimit = cachedProcessLimit = 0;\n        } else if (mProcessLimit == 1) {\n            emptyProcessLimit = 1;\n            cachedProcessLimit = 0;\n        } else {\n            emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);\n            cachedProcessLimit = mProcessLimit - emptyProcessLimit;\n        }\n\n        // Let's determine how many processes we have running vs.\n        // how many slots we have for background processes; we may want\n        // to put multiple processes in a slot of there are enough of\n        // them.\n        int numSlots = (ProcessList.CACHED_APP_MAX_ADJ\n                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;\n        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;\n        if (numEmptyProcs > cachedProcessLimit) {\n            // If there are more empty processes than our limit on cached\n            // processes, then use the cached process limit for the factor.\n            // This ensures that the really old empty processes get pushed\n            // down to the bottom, so if we are running low on memory we will\n            // have a better chance at keeping around more cached processes\n            // instead of a gazillion empty processes.\n            numEmptyProcs = cachedProcessLimit;\n        }\n        int emptyFactor = numEmptyProcs/numSlots;\n        if (emptyFactor < 1) emptyFactor = 1;\n        int cachedFactor = (mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1)/numSlots;\n        if (cachedFactor < 1) cachedFactor = 1;\n        int stepCached = 0;\n        int stepEmpty = 0;\n        int numCached = 0;\n        int numEmpty = 0;\n        int numTrimming = 0;\n\n        mNumNonCachedProcs = 0;\n        mNumCachedHiddenProcs = 0;\n\n```\n\n这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。\n\n\n```\n int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextCachedAdj = curCachedAdj+1;\n        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextEmptyAdj = curEmptyAdj+2;\n        for (int i=N-1; i>=0; i--) {\n            ProcessRecord app = mLruProcesses.get(i);\n            if (!app.killedByAm && app.thread != null) {\n                app.procStateChanged = false;\n                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);\n\n                // If we haven't yet assigned the final cached adj\n                // to the process, do that now.\n                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {\n                    switch (app.curProcState) {\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                            // This process is a cached process holding activities...\n                            // assign it the next cached value for that type, and then\n                            // step that cached level.\n                            app.curRawAdj = curCachedAdj;\n                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning activity LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curCachedAdj=\" + curCachedAdj\n                                    + \")\");\n                            if (curCachedAdj != nextCachedAdj) {\n                                stepCached++;\n                                if (stepCached >= cachedFactor) {\n                                    stepCached = 0;\n                                    curCachedAdj = nextCachedAdj;\n                                    nextCachedAdj += 2;\n                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                        default:\n                            // For everything else, assign next empty cached process\n                            // level and bump that up.  Note that this means that\n                            // long-running services that have dropped down to the\n                            // cached level will be treated as empty (since their process\n                            // state is still as a service), which is what we want.\n                            app.curRawAdj = curEmptyAdj;\n                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning empty LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curEmptyAdj=\" + curEmptyAdj\n                                    + \")\");\n                            if (curEmptyAdj != nextEmptyAdj) {\n                                stepEmpty++;\n                                if (stepEmpty >= emptyFactor) {\n                                    stepEmpty = 0;\n                                    curEmptyAdj = nextEmptyAdj;\n                                    nextEmptyAdj += 2;\n                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                    }\n                }\n\n                applyOomAdjLocked(app, true, now);\n\n                // Count the number of process types.\n                switch (app.curProcState) {\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                        mNumCachedHiddenProcs++;\n                        numCached++;\n                        if (numCached > cachedProcessLimit) {\n                            app.kill(\"cached #\" + numCached, true);\n                        }\n                        break;\n                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:\n                        if (numEmpty > ProcessList.TRIM_EMPTY_APPS\n                                && app.lastActivityTime < oldTime) {\n                            app.kill(\"empty for \"\n                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)\n                                    / 1000) + \"s\", true);\n                        } else {\n                            numEmpty++;\n                            if (numEmpty > emptyProcessLimit) {\n                                app.kill(\"empty #\" + numEmpty, true);\n                            }\n                        }\n                        break;\n                    default:\n                        mNumNonCachedProcs++;\n                        break;\n                }\n\n                if (app.isolated && app.services.size() <= 0) {\n                    // If this is an isolated process, and there are no\n                    // services running in it, then the process is no longer\n                    // needed.  We agressively kill these because we can by\n                    // definition not re-use the same process again, and it is\n                    // good to avoid having whatever code was running in them\n                    // left sitting around after no longer needed.\n                    app.kill(\"isolated not needed\", true);\n                } else {\n                    // Keeping this process, update its uid.\n                    final UidRecord uidRec = app.uidRecord;\n                    if (uidRec != null && uidRec.curProcState > app.curProcState) {\n                        uidRec.curProcState = app.curProcState;\n                    }\n                }\n\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    numTrimming++;\n                }\n            }\n        }\n```\n\n\n上面代码的逻辑是更新进程oomadj值。\n\n* 首先通过computeOomAdjLocked计算oomadj值\n* 当进程未分配adj值是，更新adj值(if (app.curAdj >= ProcessList.UNKNOWN_ADJ))\n\t* 当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值\n\t* 不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值\n* applyOomAdjLocked,使更新生效\n* 根据进程状态，选择策略\n\t* PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程\n\t* PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程\n* 如果是孤立进程 并且没有service，直接杀掉\n\n\n```\n        final int numCachedAndEmpty = numCached + numEmpty;\n        int memFactor;\n        if (numCached <= ProcessList.TRIM_CACHED_APPS\n                && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {\n            if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n            } else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n            } else {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n            }\n        } else {\n            memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n        }\n        // We always allow the memory level to go up (better).  We only allow it to go\n        // down if we are in a state where that is allowed, *and* the total number of processes\n        // has gone down since last time.\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"oom: memFactor=\" + memFactor\n                + \" last=\" + mLastMemoryLevel + \" allowLow=\" + mAllowLowerMemLevel\n                + \" numProcs=\" + mLruProcesses.size() + \" last=\" + mLastNumProcesses);\n        if (memFactor > mLastMemoryLevel) {\n            if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {\n                memFactor = mLastMemoryLevel;\n                if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"Keeping last mem factor!\");\n            }\n        }\n        mLastMemoryLevel = memFactor;\n        mLastNumProcesses = mLruProcesses.size();\n        boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\n        final int trackerMemFactor = mProcessStats.getMemFactorLocked();\n        if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n            if (mLowRamStartTime == 0) {\n                mLowRamStartTime = now;\n            }\n            int step = 0;\n            int fgTrimLevel;\n            switch (memFactor) {\n                case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n                    break;\n                case ProcessStats.ADJ_MEM_FACTOR_LOW:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n                    break;\n                default:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n                    break;\n            }\n            int factor = numTrimming/3;\n            int minFactor = 2;\n            if (mHomeProcess != null) minFactor++;\n            if (mPreviousProcess != null) minFactor++;\n            if (factor < minFactor) factor = minFactor;\n            int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    if (app.trimMemoryLevel < curLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of \" + app.processName + \" to \" + curLevel);\n                            app.thread.scheduleTrimMemory(curLevel);\n                        } catch (RemoteException e) {\n                        }\n                        if (false) {\n                            // For now we won't do this; our memory trimming seems\n                            // to be good enough at this point that destroying\n                            // activities causes more harm than good.\n                            if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                                    && app != mHomeProcess && app != mPreviousProcess) {\n                                // Need to do this on its own message because the stack may not\n                                // be in a consistent state at this point.\n                                // For these apps we will also finish their activities\n                                // to help them free memory.\n                                mStackSupervisor.scheduleDestroyAllActivities(app, \"trim\");\n                            }\n                        }\n                    }\n                    app.trimMemoryLevel = curLevel;\n                    step++;\n                    if (step >= factor) {\n                        step = 0;\n                        switch (curLevel) {\n                            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                                break;\n                            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                                break;\n                        }\n                    }\n                } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of heavy-weight \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                } else {\n                    if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                            || app.systemNoUi) && app.pendingUiClean) {\n                        // If this application is now in the background and it\n                        // had done UI, then give it the special trim level to\n                        // have it free UI resources.\n                        final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                        if (app.trimMemoryLevel < level && app.thread != null) {\n                            try {\n                                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                        \"Trimming memory of bg-ui \" + app.processName\n                                        + \" to \" + level);\n                                app.thread.scheduleTrimMemory(level);\n                            } catch (RemoteException e) {\n                            }\n                        }\n                        app.pendingUiClean = false;\n                    }\n                    if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of fg \" + app.processName\n                                    + \" to \" + fgTrimLevel);\n                            app.thread.scheduleTrimMemory(fgTrimLevel);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = fgTrimLevel;\n                }\n            }\n        } else {\n            if (mLowRamStartTime != 0) {\n                mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n                mLowRamStartTime = 0;\n            }\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                        || app.systemNoUi) && app.pendingUiClean) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of ui hidden \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.pendingUiClean = false;\n                }\n                app.trimMemoryLevel = 0;\n            }\n        }\n```\t\n\n* 先调整内存因子memFactor\n* 如果内存因子不为0\n\t* 根据内存因子 初始化fgTrimLevel\n\t* 循环处理进程\n\t\t* curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel\n\t\t* curProcState等于9，且满足条件，进行TrimMemory\n\t\t* 其他情况下，根据条件进行TrimMemory操作\n\t \n* 内存因子为0,也是根据跳进进行TrimMemory操作\n\n整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。\n\ncomputeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。\n\n### 4.杀进程\n\n杀进程这里就略过了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\t","slug":"AMS中的进程管理部分－上","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslx0000a19fy749me5ts","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>ActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<ul>\n<li>新建进程</li>\n<li>调整进程在mLruProcesses的位置</li>\n<li>调整进程OomAdj值</li>\n<li>杀进程</li>\n</ul>\n<p>而新建进程在前面有说到过，今天就来介绍下剩下的三个。</p>\n<h3 id=\"2-调整位置的updateLruProcessLocked方法\"><a href=\"#2-调整位置的updateLruProcessLocked方法\" class=\"headerlink\" title=\"2.调整位置的updateLruProcessLocked方法\"></a>2.调整位置的updateLruProcessLocked方法</h3><p>代码比较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean hasActivity = app.activities.size() &gt; 0 || app.hasClientActivities</div><div class=\"line\">        || app.treatLikeActivity;</div><div class=\"line\">final boolean hasService = false; // not impl yet. app.services.size() &gt; 0;</div><div class=\"line\">if (!activityChange &amp;&amp; hasActivity) &#123;</div><div class=\"line\">    // The process has activities, so we are only allowing activity-based adjustments</div><div class=\"line\">    // to move it.  It should be kept in the front of the list with other</div><div class=\"line\">    // processes that have activities, and we don&apos;t want those to change their</div><div class=\"line\">    // order except due to activity operations.</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mLruSeq++;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">app.lastActivityTime = now;</div><div class=\"line\"></div><div class=\"line\">// First a quick reject: if the app is already at the position we will</div><div class=\"line\">// put it, then there is nothing to do.</div><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (N &gt; 0 &amp;&amp; mLruProcesses.get(N-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top activity: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    if (mLruProcessServiceStart &gt; 0</div><div class=\"line\">            &amp;&amp; mLruProcesses.get(mLruProcessServiceStart-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top other: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int lrui = mLruProcesses.lastIndexOf(app);</div><div class=\"line\"></div><div class=\"line\">if (app.persistent &amp;&amp; lrui &gt;= 0) &#123;</div><div class=\"line\">    // We don&apos;t care about the position of persistent processes, as long as</div><div class=\"line\">    // they are in the list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, persistent: &quot; + app);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果有activity，并且进程中activity没有发生变化，不需要调整</li>\n<li>如果有activity，但是当前进程就是在最后，不需要调整</li>\n<li>如果没有activity，但是在合适的位置，不需要调整</li>\n<li>如果有persistent标志，不需要调整</li>\n<li>lrui 为当前进程在list中的索引(最后一个的索引)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (lrui &gt;= 0) &#123;</div><div class=\"line\">    if (lrui &lt; mLruProcessActivityStart) &#123;</div><div class=\"line\">        mLruProcessActivityStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (lrui &lt; mLruProcessServiceStart) &#123;</div><div class=\"line\">        mLruProcessServiceStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">    if (addIndex &gt; lrui) &#123;</div><div class=\"line\">        addIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (nextIndex &gt; lrui) &#123;</div><div class=\"line\">        nextIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    */</div><div class=\"line\">    mLruProcesses.remove(lrui);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (app.activities.size() == 0 &amp;&amp; mLruProcessActivityStart &lt; (N - 1)) &#123;</div><div class=\"line\">        // Process doesn&apos;t have activities, but has clients with</div><div class=\"line\">        // activities...  move it up, but one below the top (the top</div><div class=\"line\">        // should always have a real activity).</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                &quot;Adding to second-top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(N - 1, app);</div><div class=\"line\">        // To keep it from spamming the LRU list (by making a bunch of clients),</div><div class=\"line\">        // we will push down any other entries owned by the app.</div><div class=\"line\">        final int uid = app.info.uid;</div><div class=\"line\">        for (int i = N - 2; i &gt; mLruProcessActivityStart; i--) &#123;</div><div class=\"line\">            ProcessRecord subProc = mLruProcesses.get(i);</div><div class=\"line\">            if (subProc.info.uid == uid) &#123;</div><div class=\"line\">                // We want to push this one down the list.  If the process after</div><div class=\"line\">                // it is for the same uid, however, don&apos;t do so, because we don&apos;t</div><div class=\"line\">                // want them internally to be re-ordered.</div><div class=\"line\">                if (mLruProcesses.get(i - 1).info.uid != uid) &#123;</div><div class=\"line\">                    if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                            &quot;Pushing uid &quot; + uid + &quot; swapping at &quot; + i + &quot;: &quot;</div><div class=\"line\">                            + mLruProcesses.get(i) + &quot; : &quot; + mLruProcesses.get(i - 1));</div><div class=\"line\">                    ProcessRecord tmp = mLruProcesses.get(i);</div><div class=\"line\">                    mLruProcesses.set(i, mLruProcesses.get(i - 1));</div><div class=\"line\">                    mLruProcesses.set(i - 1, tmp);</div><div class=\"line\">                    i--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // A gap, we can stop here.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Process has activities, put it at the very tipsy-top.</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(app);</div><div class=\"line\">    &#125;</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">&#125; else if (hasService) &#123;</div><div class=\"line\">    // Process has services, put it at the top of the service list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU service list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(mLruProcessActivityStart, app);</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">&#125; else  &#123;</div><div class=\"line\">    // Process not otherwise of interest, it goes to the top of the non-service area.</div><div class=\"line\">    int index = mLruProcessServiceStart;</div><div class=\"line\">    if (client != null) &#123;</div><div class=\"line\">        // If there is a client, don&apos;t allow the process to be moved up higher</div><div class=\"line\">        // in the list than that client.</div><div class=\"line\">        int clientIndex = mLruProcesses.lastIndexOf(client);</div><div class=\"line\">        if (DEBUG_LRU &amp;&amp; clientIndex &lt; 0) Slog.d(TAG_LRU, &quot;Unknown client &quot; + client</div><div class=\"line\">                + &quot; when updating &quot; + app);</div><div class=\"line\">        if (clientIndex &lt;= lrui) &#123;</div><div class=\"line\">            // Don&apos;t allow the client index restriction to push it down farther in the</div><div class=\"line\">            // list than it already is.</div><div class=\"line\">            clientIndex = lrui;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (clientIndex &gt;= 0 &amp;&amp; index &gt; clientIndex) &#123;</div><div class=\"line\">            index = clientIndex;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding at &quot; + index + &quot; of LRU list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(index, app);</div><div class=\"line\">    nextIndex = index-1;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">    mLruProcessServiceStart++;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>hasActivity为true<ul>\n<li>没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。</li>\n<li>直接添加到最后一个</li>\n</ul>\n</li>\n<li>hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置</li>\n<li>因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j=app.connections.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ConnectionRecord cr = app.connections.valueAt(j);</div><div class=\"line\">    if (cr.binding != null &amp;&amp; !cr.serviceDead &amp;&amp; cr.binding.service != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app.lruSeq != mLruSeq</div><div class=\"line\">            &amp;&amp; !cr.binding.service.app.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,</div><div class=\"line\">                &quot;service connection&quot;, cr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">for (int j=app.conProviders.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ContentProviderRecord cpr = app.conProviders.get(j).provider;</div><div class=\"line\">    if (cpr.proc != null &amp;&amp; cpr.proc.lruSeq != mLruSeq &amp;&amp; !cpr.proc.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,</div><div class=\"line\">                &quot;provider reference&quot;, cpr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>把和这个进程关联的service和contentprovider调整到这个进程之后。</p>\n<h3 id=\"3-调整OomAdj值的updateOomAdjLocked方法\"><a href=\"#3-调整OomAdj值的updateOomAdjLocked方法\" class=\"headerlink\" title=\"3. 调整OomAdj值的updateOomAdjLocked方法\"></a>3. 调整OomAdj值的updateOomAdjLocked方法</h3><p>方法较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ActivityRecord TOP_ACT = resumedAppLocked();</div><div class=\"line\">final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">final long oldTime = now - ProcessList.MAX_EMPTY_TIME;</div><div class=\"line\">final int N = mLruProcesses.size();</div><div class=\"line\"></div><div class=\"line\">if (false) &#123;</div><div class=\"line\">    RuntimeException e = new RuntimeException();</div><div class=\"line\">    e.fillInStackTrace();</div><div class=\"line\">    Slog.i(TAG, &quot;updateOomAdj: top=&quot; + TOP_ACT, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Reset state in all uid records.</div><div class=\"line\">for (int i=mActiveUids.size()-1; i&gt;=0; i--) &#123;</div><div class=\"line\">    final UidRecord uidRec = mActiveUids.valueAt(i);</div><div class=\"line\">    if (false &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</div><div class=\"line\">            &quot;Starting update of &quot; + uidRec);</div><div class=\"line\">    uidRec.reset();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mAdjSeq++;</div><div class=\"line\">mNewNumServiceProcs = 0;</div><div class=\"line\">mNewNumAServiceProcs = 0;</div><div class=\"line\"></div><div class=\"line\">final int emptyProcessLimit;</div><div class=\"line\">final int cachedProcessLimit;</div><div class=\"line\">if (mProcessLimit &lt;= 0) &#123;</div><div class=\"line\">    emptyProcessLimit = cachedProcessLimit = 0;</div><div class=\"line\">&#125; else if (mProcessLimit == 1) &#123;</div><div class=\"line\">    emptyProcessLimit = 1;</div><div class=\"line\">    cachedProcessLimit = 0;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);</div><div class=\"line\">    cachedProcessLimit = mProcessLimit - emptyProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Let&apos;s determine how many processes we have running vs.</div><div class=\"line\">// how many slots we have for background processes; we may want</div><div class=\"line\">// to put multiple processes in a slot of there are enough of</div><div class=\"line\">// them.</div><div class=\"line\">int numSlots = (ProcessList.CACHED_APP_MAX_ADJ</div><div class=\"line\">        - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;</div><div class=\"line\">int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</div><div class=\"line\">if (numEmptyProcs &gt; cachedProcessLimit) &#123;</div><div class=\"line\">    // If there are more empty processes than our limit on cached</div><div class=\"line\">    // processes, then use the cached process limit for the factor.</div><div class=\"line\">    // This ensures that the really old empty processes get pushed</div><div class=\"line\">    // down to the bottom, so if we are running low on memory we will</div><div class=\"line\">    // have a better chance at keeping around more cached processes</div><div class=\"line\">    // instead of a gazillion empty processes.</div><div class=\"line\">    numEmptyProcs = cachedProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\">int emptyFactor = numEmptyProcs/numSlots;</div><div class=\"line\">if (emptyFactor &lt; 1) emptyFactor = 1;</div><div class=\"line\">int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1)/numSlots;</div><div class=\"line\">if (cachedFactor &lt; 1) cachedFactor = 1;</div><div class=\"line\">int stepCached = 0;</div><div class=\"line\">int stepEmpty = 0;</div><div class=\"line\">int numCached = 0;</div><div class=\"line\">int numEmpty = 0;</div><div class=\"line\">int numTrimming = 0;</div><div class=\"line\"></div><div class=\"line\">mNumNonCachedProcs = 0;</div><div class=\"line\">mNumCachedHiddenProcs = 0;</div></pre></td></tr></table></figure>\n<p>这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextCachedAdj = curCachedAdj+1;</div><div class=\"line\">       int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextEmptyAdj = curEmptyAdj+2;</div><div class=\"line\">       for (int i=N-1; i&gt;=0; i--) &#123;</div><div class=\"line\">           ProcessRecord app = mLruProcesses.get(i);</div><div class=\"line\">           if (!app.killedByAm &amp;&amp; app.thread != null) &#123;</div><div class=\"line\">               app.procStateChanged = false;</div><div class=\"line\">               computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);</div><div class=\"line\"></div><div class=\"line\">               // If we haven&apos;t yet assigned the final cached adj</div><div class=\"line\">               // to the process, do that now.</div><div class=\"line\">               if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</div><div class=\"line\">                   switch (app.curProcState) &#123;</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                           // This process is a cached process holding activities...</div><div class=\"line\">                           // assign it the next cached value for that type, and then</div><div class=\"line\">                           // step that cached level.</div><div class=\"line\">                           app.curRawAdj = curCachedAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curCachedAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning activity LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curCachedAdj=&quot; + curCachedAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curCachedAdj != nextCachedAdj) &#123;</div><div class=\"line\">                               stepCached++;</div><div class=\"line\">                               if (stepCached &gt;= cachedFactor) &#123;</div><div class=\"line\">                                   stepCached = 0;</div><div class=\"line\">                                   curCachedAdj = nextCachedAdj;</div><div class=\"line\">                                   nextCachedAdj += 2;</div><div class=\"line\">                                   if (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                       default:</div><div class=\"line\">                           // For everything else, assign next empty cached process</div><div class=\"line\">                           // level and bump that up.  Note that this means that</div><div class=\"line\">                           // long-running services that have dropped down to the</div><div class=\"line\">                           // cached level will be treated as empty (since their process</div><div class=\"line\">                           // state is still as a service), which is what we want.</div><div class=\"line\">                           app.curRawAdj = curEmptyAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning empty LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curEmptyAdj=&quot; + curEmptyAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curEmptyAdj != nextEmptyAdj) &#123;</div><div class=\"line\">                               stepEmpty++;</div><div class=\"line\">                               if (stepEmpty &gt;= emptyFactor) &#123;</div><div class=\"line\">                                   stepEmpty = 0;</div><div class=\"line\">                                   curEmptyAdj = nextEmptyAdj;</div><div class=\"line\">                                   nextEmptyAdj += 2;</div><div class=\"line\">                                   if (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               applyOomAdjLocked(app, true, now);</div><div class=\"line\"></div><div class=\"line\">               // Count the number of process types.</div><div class=\"line\">               switch (app.curProcState) &#123;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                       mNumCachedHiddenProcs++;</div><div class=\"line\">                       numCached++;</div><div class=\"line\">                       if (numCached &gt; cachedProcessLimit) &#123;</div><div class=\"line\">                           app.kill(&quot;cached #&quot; + numCached, true);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_EMPTY:</div><div class=\"line\">                       if (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS</div><div class=\"line\">                               &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</div><div class=\"line\">                           app.kill(&quot;empty for &quot;</div><div class=\"line\">                                   + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)</div><div class=\"line\">                                   / 1000) + &quot;s&quot;, true);</div><div class=\"line\">                       &#125; else &#123;</div><div class=\"line\">                           numEmpty++;</div><div class=\"line\">                           if (numEmpty &gt; emptyProcessLimit) &#123;</div><div class=\"line\">                               app.kill(&quot;empty #&quot; + numEmpty, true);</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   default:</div><div class=\"line\">                       mNumNonCachedProcs++;</div><div class=\"line\">                       break;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.isolated &amp;&amp; app.services.size() &lt;= 0) &#123;</div><div class=\"line\">                   // If this is an isolated process, and there are no</div><div class=\"line\">                   // services running in it, then the process is no longer</div><div class=\"line\">                   // needed.  We agressively kill these because we can by</div><div class=\"line\">                   // definition not re-use the same process again, and it is</div><div class=\"line\">                   // good to avoid having whatever code was running in them</div><div class=\"line\">                   // left sitting around after no longer needed.</div><div class=\"line\">                   app.kill(&quot;isolated not needed&quot;, true);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Keeping this process, update its uid.</div><div class=\"line\">                   final UidRecord uidRec = app.uidRecord;</div><div class=\"line\">                   if (uidRec != null &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123;</div><div class=\"line\">                       uidRec.curProcState = app.curProcState;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</div><div class=\"line\">                       &amp;&amp; !app.killedByAm) &#123;</div><div class=\"line\">                   numTrimming++;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>上面代码的逻辑是更新进程oomadj值。</p>\n<ul>\n<li>首先通过computeOomAdjLocked计算oomadj值</li>\n<li>当进程未分配adj值是，更新adj值(if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ))<ul>\n<li>当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值</li>\n<li>不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值</li>\n</ul>\n</li>\n<li>applyOomAdjLocked,使更新生效</li>\n<li>根据进程状态，选择策略<ul>\n<li>PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程</li>\n<li>PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程</li>\n</ul>\n</li>\n<li>如果是孤立进程 并且没有service，直接杀掉</li>\n</ul>\n<pre><code>final int numCachedAndEmpty = numCached + numEmpty;\nint memFactor;\nif (numCached &lt;= ProcessList.TRIM_CACHED_APPS\n        &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) {\n    if (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n    } else if (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n    } else {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n    }\n} else {\n    memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n}\n// We always allow the memory level to go up (better).  We only allow it to go\n// down if we are in a state where that is allowed, *and* the total number of processes\n// has gone down since last time.\nif (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;oom: memFactor=&quot; + memFactor\n        + &quot; last=&quot; + mLastMemoryLevel + &quot; allowLow=&quot; + mAllowLowerMemLevel\n        + &quot; numProcs=&quot; + mLruProcesses.size() + &quot; last=&quot; + mLastNumProcesses);\nif (memFactor &gt; mLastMemoryLevel) {\n    if (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) {\n        memFactor = mLastMemoryLevel;\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;Keeping last mem factor!&quot;);\n    }\n}\nmLastMemoryLevel = memFactor;\nmLastNumProcesses = mLruProcesses.size();\nboolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\nfinal int trackerMemFactor = mProcessStats.getMemFactorLocked();\nif (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n    if (mLowRamStartTime == 0) {\n        mLowRamStartTime = now;\n    }\n    int step = 0;\n    int fgTrimLevel;\n    switch (memFactor) {\n        case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n            break;\n        case ProcessStats.ADJ_MEM_FACTOR_LOW:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n            break;\n        default:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n            break;\n    }\n    int factor = numTrimming/3;\n    int minFactor = 2;\n    if (mHomeProcess != null) minFactor++;\n    if (mPreviousProcess != null) minFactor++;\n    if (factor &lt; minFactor) factor = minFactor;\n    int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME\n                &amp;&amp; !app.killedByAm) {\n            if (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of &quot; + app.processName + &quot; to &quot; + curLevel);\n                    app.thread.scheduleTrimMemory(curLevel);\n                } catch (RemoteException e) {\n                }\n                if (false) {\n                    // For now we won&apos;t do this; our memory trimming seems\n                    // to be good enough at this point that destroying\n                    // activities causes more harm than good.\n                    if (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                            &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) {\n                        // Need to do this on its own message because the stack may not\n                        // be in a consistent state at this point.\n                        // For these apps we will also finish their activities\n                        // to help them free memory.\n                        mStackSupervisor.scheduleDestroyAllActivities(app, &quot;trim&quot;);\n                    }\n                }\n            }\n            app.trimMemoryLevel = curLevel;\n            step++;\n            if (step &gt;= factor) {\n                step = 0;\n                switch (curLevel) {\n                    case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                        break;\n                    case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                        break;\n                }\n            }\n        } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of heavy-weight &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n        } else {\n            if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                    || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n                // If this application is now in the background and it\n                // had done UI, then give it the special trim level to\n                // have it free UI resources.\n                final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                if (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != null) {\n                    try {\n                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                &quot;Trimming memory of bg-ui &quot; + app.processName\n                                + &quot; to &quot; + level);\n                        app.thread.scheduleTrimMemory(level);\n                    } catch (RemoteException e) {\n                    }\n                }\n                app.pendingUiClean = false;\n            }\n            if (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of fg &quot; + app.processName\n                            + &quot; to &quot; + fgTrimLevel);\n                    app.thread.scheduleTrimMemory(fgTrimLevel);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = fgTrimLevel;\n        }\n    }\n} else {\n    if (mLowRamStartTime != 0) {\n        mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n        mLowRamStartTime = 0;\n    }\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of ui hidden &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                } catch (RemoteException e) {\n                }\n            }\n            app.pendingUiClean = false;\n        }\n        app.trimMemoryLevel = 0;\n    }\n}\n</code></pre><ul>\n<li>先调整内存因子memFactor</li>\n<li><p>如果内存因子不为0</p>\n<ul>\n<li>根据内存因子 初始化fgTrimLevel</li>\n<li>循环处理进程<ul>\n<li>curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel</li>\n<li>curProcState等于9，且满足条件，进行TrimMemory</li>\n<li>其他情况下，根据条件进行TrimMemory操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内存因子为0,也是根据跳进进行TrimMemory操作</p>\n</li>\n</ul>\n<p>整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。</p>\n<p>computeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。</p>\n<h3 id=\"4-杀进程\"><a href=\"#4-杀进程\" class=\"headerlink\" title=\"4.杀进程\"></a>4.杀进程</h3><p>杀进程这里就略过了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>ActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:</p>","more":"<The rest of contents | 余下全文>\n\n\n<ul>\n<li>新建进程</li>\n<li>调整进程在mLruProcesses的位置</li>\n<li>调整进程OomAdj值</li>\n<li>杀进程</li>\n</ul>\n<p>而新建进程在前面有说到过，今天就来介绍下剩下的三个。</p>\n<h3 id=\"2-调整位置的updateLruProcessLocked方法\"><a href=\"#2-调整位置的updateLruProcessLocked方法\" class=\"headerlink\" title=\"2.调整位置的updateLruProcessLocked方法\"></a>2.调整位置的updateLruProcessLocked方法</h3><p>代码比较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean hasActivity = app.activities.size() &gt; 0 || app.hasClientActivities</div><div class=\"line\">        || app.treatLikeActivity;</div><div class=\"line\">final boolean hasService = false; // not impl yet. app.services.size() &gt; 0;</div><div class=\"line\">if (!activityChange &amp;&amp; hasActivity) &#123;</div><div class=\"line\">    // The process has activities, so we are only allowing activity-based adjustments</div><div class=\"line\">    // to move it.  It should be kept in the front of the list with other</div><div class=\"line\">    // processes that have activities, and we don&apos;t want those to change their</div><div class=\"line\">    // order except due to activity operations.</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mLruSeq++;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">app.lastActivityTime = now;</div><div class=\"line\"></div><div class=\"line\">// First a quick reject: if the app is already at the position we will</div><div class=\"line\">// put it, then there is nothing to do.</div><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (N &gt; 0 &amp;&amp; mLruProcesses.get(N-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top activity: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    if (mLruProcessServiceStart &gt; 0</div><div class=\"line\">            &amp;&amp; mLruProcesses.get(mLruProcessServiceStart-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top other: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int lrui = mLruProcesses.lastIndexOf(app);</div><div class=\"line\"></div><div class=\"line\">if (app.persistent &amp;&amp; lrui &gt;= 0) &#123;</div><div class=\"line\">    // We don&apos;t care about the position of persistent processes, as long as</div><div class=\"line\">    // they are in the list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, persistent: &quot; + app);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果有activity，并且进程中activity没有发生变化，不需要调整</li>\n<li>如果有activity，但是当前进程就是在最后，不需要调整</li>\n<li>如果没有activity，但是在合适的位置，不需要调整</li>\n<li>如果有persistent标志，不需要调整</li>\n<li>lrui 为当前进程在list中的索引(最后一个的索引)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (lrui &gt;= 0) &#123;</div><div class=\"line\">    if (lrui &lt; mLruProcessActivityStart) &#123;</div><div class=\"line\">        mLruProcessActivityStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (lrui &lt; mLruProcessServiceStart) &#123;</div><div class=\"line\">        mLruProcessServiceStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">    if (addIndex &gt; lrui) &#123;</div><div class=\"line\">        addIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (nextIndex &gt; lrui) &#123;</div><div class=\"line\">        nextIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    */</div><div class=\"line\">    mLruProcesses.remove(lrui);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (app.activities.size() == 0 &amp;&amp; mLruProcessActivityStart &lt; (N - 1)) &#123;</div><div class=\"line\">        // Process doesn&apos;t have activities, but has clients with</div><div class=\"line\">        // activities...  move it up, but one below the top (the top</div><div class=\"line\">        // should always have a real activity).</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                &quot;Adding to second-top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(N - 1, app);</div><div class=\"line\">        // To keep it from spamming the LRU list (by making a bunch of clients),</div><div class=\"line\">        // we will push down any other entries owned by the app.</div><div class=\"line\">        final int uid = app.info.uid;</div><div class=\"line\">        for (int i = N - 2; i &gt; mLruProcessActivityStart; i--) &#123;</div><div class=\"line\">            ProcessRecord subProc = mLruProcesses.get(i);</div><div class=\"line\">            if (subProc.info.uid == uid) &#123;</div><div class=\"line\">                // We want to push this one down the list.  If the process after</div><div class=\"line\">                // it is for the same uid, however, don&apos;t do so, because we don&apos;t</div><div class=\"line\">                // want them internally to be re-ordered.</div><div class=\"line\">                if (mLruProcesses.get(i - 1).info.uid != uid) &#123;</div><div class=\"line\">                    if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                            &quot;Pushing uid &quot; + uid + &quot; swapping at &quot; + i + &quot;: &quot;</div><div class=\"line\">                            + mLruProcesses.get(i) + &quot; : &quot; + mLruProcesses.get(i - 1));</div><div class=\"line\">                    ProcessRecord tmp = mLruProcesses.get(i);</div><div class=\"line\">                    mLruProcesses.set(i, mLruProcesses.get(i - 1));</div><div class=\"line\">                    mLruProcesses.set(i - 1, tmp);</div><div class=\"line\">                    i--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // A gap, we can stop here.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Process has activities, put it at the very tipsy-top.</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(app);</div><div class=\"line\">    &#125;</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">&#125; else if (hasService) &#123;</div><div class=\"line\">    // Process has services, put it at the top of the service list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU service list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(mLruProcessActivityStart, app);</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">&#125; else  &#123;</div><div class=\"line\">    // Process not otherwise of interest, it goes to the top of the non-service area.</div><div class=\"line\">    int index = mLruProcessServiceStart;</div><div class=\"line\">    if (client != null) &#123;</div><div class=\"line\">        // If there is a client, don&apos;t allow the process to be moved up higher</div><div class=\"line\">        // in the list than that client.</div><div class=\"line\">        int clientIndex = mLruProcesses.lastIndexOf(client);</div><div class=\"line\">        if (DEBUG_LRU &amp;&amp; clientIndex &lt; 0) Slog.d(TAG_LRU, &quot;Unknown client &quot; + client</div><div class=\"line\">                + &quot; when updating &quot; + app);</div><div class=\"line\">        if (clientIndex &lt;= lrui) &#123;</div><div class=\"line\">            // Don&apos;t allow the client index restriction to push it down farther in the</div><div class=\"line\">            // list than it already is.</div><div class=\"line\">            clientIndex = lrui;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (clientIndex &gt;= 0 &amp;&amp; index &gt; clientIndex) &#123;</div><div class=\"line\">            index = clientIndex;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding at &quot; + index + &quot; of LRU list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(index, app);</div><div class=\"line\">    nextIndex = index-1;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">    mLruProcessServiceStart++;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>hasActivity为true<ul>\n<li>没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。</li>\n<li>直接添加到最后一个</li>\n</ul>\n</li>\n<li>hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置</li>\n<li>因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j=app.connections.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ConnectionRecord cr = app.connections.valueAt(j);</div><div class=\"line\">    if (cr.binding != null &amp;&amp; !cr.serviceDead &amp;&amp; cr.binding.service != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app.lruSeq != mLruSeq</div><div class=\"line\">            &amp;&amp; !cr.binding.service.app.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,</div><div class=\"line\">                &quot;service connection&quot;, cr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">for (int j=app.conProviders.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ContentProviderRecord cpr = app.conProviders.get(j).provider;</div><div class=\"line\">    if (cpr.proc != null &amp;&amp; cpr.proc.lruSeq != mLruSeq &amp;&amp; !cpr.proc.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,</div><div class=\"line\">                &quot;provider reference&quot;, cpr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>把和这个进程关联的service和contentprovider调整到这个进程之后。</p>\n<h3 id=\"3-调整OomAdj值的updateOomAdjLocked方法\"><a href=\"#3-调整OomAdj值的updateOomAdjLocked方法\" class=\"headerlink\" title=\"3. 调整OomAdj值的updateOomAdjLocked方法\"></a>3. 调整OomAdj值的updateOomAdjLocked方法</h3><p>方法较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ActivityRecord TOP_ACT = resumedAppLocked();</div><div class=\"line\">final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">final long oldTime = now - ProcessList.MAX_EMPTY_TIME;</div><div class=\"line\">final int N = mLruProcesses.size();</div><div class=\"line\"></div><div class=\"line\">if (false) &#123;</div><div class=\"line\">    RuntimeException e = new RuntimeException();</div><div class=\"line\">    e.fillInStackTrace();</div><div class=\"line\">    Slog.i(TAG, &quot;updateOomAdj: top=&quot; + TOP_ACT, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Reset state in all uid records.</div><div class=\"line\">for (int i=mActiveUids.size()-1; i&gt;=0; i--) &#123;</div><div class=\"line\">    final UidRecord uidRec = mActiveUids.valueAt(i);</div><div class=\"line\">    if (false &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</div><div class=\"line\">            &quot;Starting update of &quot; + uidRec);</div><div class=\"line\">    uidRec.reset();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mAdjSeq++;</div><div class=\"line\">mNewNumServiceProcs = 0;</div><div class=\"line\">mNewNumAServiceProcs = 0;</div><div class=\"line\"></div><div class=\"line\">final int emptyProcessLimit;</div><div class=\"line\">final int cachedProcessLimit;</div><div class=\"line\">if (mProcessLimit &lt;= 0) &#123;</div><div class=\"line\">    emptyProcessLimit = cachedProcessLimit = 0;</div><div class=\"line\">&#125; else if (mProcessLimit == 1) &#123;</div><div class=\"line\">    emptyProcessLimit = 1;</div><div class=\"line\">    cachedProcessLimit = 0;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);</div><div class=\"line\">    cachedProcessLimit = mProcessLimit - emptyProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Let&apos;s determine how many processes we have running vs.</div><div class=\"line\">// how many slots we have for background processes; we may want</div><div class=\"line\">// to put multiple processes in a slot of there are enough of</div><div class=\"line\">// them.</div><div class=\"line\">int numSlots = (ProcessList.CACHED_APP_MAX_ADJ</div><div class=\"line\">        - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;</div><div class=\"line\">int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</div><div class=\"line\">if (numEmptyProcs &gt; cachedProcessLimit) &#123;</div><div class=\"line\">    // If there are more empty processes than our limit on cached</div><div class=\"line\">    // processes, then use the cached process limit for the factor.</div><div class=\"line\">    // This ensures that the really old empty processes get pushed</div><div class=\"line\">    // down to the bottom, so if we are running low on memory we will</div><div class=\"line\">    // have a better chance at keeping around more cached processes</div><div class=\"line\">    // instead of a gazillion empty processes.</div><div class=\"line\">    numEmptyProcs = cachedProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\">int emptyFactor = numEmptyProcs/numSlots;</div><div class=\"line\">if (emptyFactor &lt; 1) emptyFactor = 1;</div><div class=\"line\">int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1)/numSlots;</div><div class=\"line\">if (cachedFactor &lt; 1) cachedFactor = 1;</div><div class=\"line\">int stepCached = 0;</div><div class=\"line\">int stepEmpty = 0;</div><div class=\"line\">int numCached = 0;</div><div class=\"line\">int numEmpty = 0;</div><div class=\"line\">int numTrimming = 0;</div><div class=\"line\"></div><div class=\"line\">mNumNonCachedProcs = 0;</div><div class=\"line\">mNumCachedHiddenProcs = 0;</div></pre></td></tr></table></figure>\n<p>这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextCachedAdj = curCachedAdj+1;</div><div class=\"line\">       int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextEmptyAdj = curEmptyAdj+2;</div><div class=\"line\">       for (int i=N-1; i&gt;=0; i--) &#123;</div><div class=\"line\">           ProcessRecord app = mLruProcesses.get(i);</div><div class=\"line\">           if (!app.killedByAm &amp;&amp; app.thread != null) &#123;</div><div class=\"line\">               app.procStateChanged = false;</div><div class=\"line\">               computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);</div><div class=\"line\"></div><div class=\"line\">               // If we haven&apos;t yet assigned the final cached adj</div><div class=\"line\">               // to the process, do that now.</div><div class=\"line\">               if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</div><div class=\"line\">                   switch (app.curProcState) &#123;</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                           // This process is a cached process holding activities...</div><div class=\"line\">                           // assign it the next cached value for that type, and then</div><div class=\"line\">                           // step that cached level.</div><div class=\"line\">                           app.curRawAdj = curCachedAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curCachedAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning activity LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curCachedAdj=&quot; + curCachedAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curCachedAdj != nextCachedAdj) &#123;</div><div class=\"line\">                               stepCached++;</div><div class=\"line\">                               if (stepCached &gt;= cachedFactor) &#123;</div><div class=\"line\">                                   stepCached = 0;</div><div class=\"line\">                                   curCachedAdj = nextCachedAdj;</div><div class=\"line\">                                   nextCachedAdj += 2;</div><div class=\"line\">                                   if (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                       default:</div><div class=\"line\">                           // For everything else, assign next empty cached process</div><div class=\"line\">                           // level and bump that up.  Note that this means that</div><div class=\"line\">                           // long-running services that have dropped down to the</div><div class=\"line\">                           // cached level will be treated as empty (since their process</div><div class=\"line\">                           // state is still as a service), which is what we want.</div><div class=\"line\">                           app.curRawAdj = curEmptyAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning empty LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curEmptyAdj=&quot; + curEmptyAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curEmptyAdj != nextEmptyAdj) &#123;</div><div class=\"line\">                               stepEmpty++;</div><div class=\"line\">                               if (stepEmpty &gt;= emptyFactor) &#123;</div><div class=\"line\">                                   stepEmpty = 0;</div><div class=\"line\">                                   curEmptyAdj = nextEmptyAdj;</div><div class=\"line\">                                   nextEmptyAdj += 2;</div><div class=\"line\">                                   if (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               applyOomAdjLocked(app, true, now);</div><div class=\"line\"></div><div class=\"line\">               // Count the number of process types.</div><div class=\"line\">               switch (app.curProcState) &#123;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                       mNumCachedHiddenProcs++;</div><div class=\"line\">                       numCached++;</div><div class=\"line\">                       if (numCached &gt; cachedProcessLimit) &#123;</div><div class=\"line\">                           app.kill(&quot;cached #&quot; + numCached, true);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_EMPTY:</div><div class=\"line\">                       if (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS</div><div class=\"line\">                               &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</div><div class=\"line\">                           app.kill(&quot;empty for &quot;</div><div class=\"line\">                                   + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)</div><div class=\"line\">                                   / 1000) + &quot;s&quot;, true);</div><div class=\"line\">                       &#125; else &#123;</div><div class=\"line\">                           numEmpty++;</div><div class=\"line\">                           if (numEmpty &gt; emptyProcessLimit) &#123;</div><div class=\"line\">                               app.kill(&quot;empty #&quot; + numEmpty, true);</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   default:</div><div class=\"line\">                       mNumNonCachedProcs++;</div><div class=\"line\">                       break;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.isolated &amp;&amp; app.services.size() &lt;= 0) &#123;</div><div class=\"line\">                   // If this is an isolated process, and there are no</div><div class=\"line\">                   // services running in it, then the process is no longer</div><div class=\"line\">                   // needed.  We agressively kill these because we can by</div><div class=\"line\">                   // definition not re-use the same process again, and it is</div><div class=\"line\">                   // good to avoid having whatever code was running in them</div><div class=\"line\">                   // left sitting around after no longer needed.</div><div class=\"line\">                   app.kill(&quot;isolated not needed&quot;, true);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Keeping this process, update its uid.</div><div class=\"line\">                   final UidRecord uidRec = app.uidRecord;</div><div class=\"line\">                   if (uidRec != null &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123;</div><div class=\"line\">                       uidRec.curProcState = app.curProcState;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</div><div class=\"line\">                       &amp;&amp; !app.killedByAm) &#123;</div><div class=\"line\">                   numTrimming++;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>上面代码的逻辑是更新进程oomadj值。</p>\n<ul>\n<li>首先通过computeOomAdjLocked计算oomadj值</li>\n<li>当进程未分配adj值是，更新adj值(if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ))<ul>\n<li>当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值</li>\n<li>不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值</li>\n</ul>\n</li>\n<li>applyOomAdjLocked,使更新生效</li>\n<li>根据进程状态，选择策略<ul>\n<li>PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程</li>\n<li>PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程</li>\n</ul>\n</li>\n<li>如果是孤立进程 并且没有service，直接杀掉</li>\n</ul>\n<pre><code>final int numCachedAndEmpty = numCached + numEmpty;\nint memFactor;\nif (numCached &lt;= ProcessList.TRIM_CACHED_APPS\n        &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) {\n    if (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n    } else if (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n    } else {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n    }\n} else {\n    memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n}\n// We always allow the memory level to go up (better).  We only allow it to go\n// down if we are in a state where that is allowed, *and* the total number of processes\n// has gone down since last time.\nif (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;oom: memFactor=&quot; + memFactor\n        + &quot; last=&quot; + mLastMemoryLevel + &quot; allowLow=&quot; + mAllowLowerMemLevel\n        + &quot; numProcs=&quot; + mLruProcesses.size() + &quot; last=&quot; + mLastNumProcesses);\nif (memFactor &gt; mLastMemoryLevel) {\n    if (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) {\n        memFactor = mLastMemoryLevel;\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;Keeping last mem factor!&quot;);\n    }\n}\nmLastMemoryLevel = memFactor;\nmLastNumProcesses = mLruProcesses.size();\nboolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\nfinal int trackerMemFactor = mProcessStats.getMemFactorLocked();\nif (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n    if (mLowRamStartTime == 0) {\n        mLowRamStartTime = now;\n    }\n    int step = 0;\n    int fgTrimLevel;\n    switch (memFactor) {\n        case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n            break;\n        case ProcessStats.ADJ_MEM_FACTOR_LOW:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n            break;\n        default:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n            break;\n    }\n    int factor = numTrimming/3;\n    int minFactor = 2;\n    if (mHomeProcess != null) minFactor++;\n    if (mPreviousProcess != null) minFactor++;\n    if (factor &lt; minFactor) factor = minFactor;\n    int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME\n                &amp;&amp; !app.killedByAm) {\n            if (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of &quot; + app.processName + &quot; to &quot; + curLevel);\n                    app.thread.scheduleTrimMemory(curLevel);\n                } catch (RemoteException e) {\n                }\n                if (false) {\n                    // For now we won&apos;t do this; our memory trimming seems\n                    // to be good enough at this point that destroying\n                    // activities causes more harm than good.\n                    if (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                            &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) {\n                        // Need to do this on its own message because the stack may not\n                        // be in a consistent state at this point.\n                        // For these apps we will also finish their activities\n                        // to help them free memory.\n                        mStackSupervisor.scheduleDestroyAllActivities(app, &quot;trim&quot;);\n                    }\n                }\n            }\n            app.trimMemoryLevel = curLevel;\n            step++;\n            if (step &gt;= factor) {\n                step = 0;\n                switch (curLevel) {\n                    case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                        break;\n                    case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                        break;\n                }\n            }\n        } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of heavy-weight &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n        } else {\n            if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                    || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n                // If this application is now in the background and it\n                // had done UI, then give it the special trim level to\n                // have it free UI resources.\n                final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                if (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != null) {\n                    try {\n                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                &quot;Trimming memory of bg-ui &quot; + app.processName\n                                + &quot; to &quot; + level);\n                        app.thread.scheduleTrimMemory(level);\n                    } catch (RemoteException e) {\n                    }\n                }\n                app.pendingUiClean = false;\n            }\n            if (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of fg &quot; + app.processName\n                            + &quot; to &quot; + fgTrimLevel);\n                    app.thread.scheduleTrimMemory(fgTrimLevel);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = fgTrimLevel;\n        }\n    }\n} else {\n    if (mLowRamStartTime != 0) {\n        mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n        mLowRamStartTime = 0;\n    }\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of ui hidden &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                } catch (RemoteException e) {\n                }\n            }\n            app.pendingUiClean = false;\n        }\n        app.trimMemoryLevel = 0;\n    }\n}\n</code></pre><ul>\n<li>先调整内存因子memFactor</li>\n<li><p>如果内存因子不为0</p>\n<ul>\n<li>根据内存因子 初始化fgTrimLevel</li>\n<li>循环处理进程<ul>\n<li>curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel</li>\n<li>curProcState等于9，且满足条件，进行TrimMemory</li>\n<li>其他情况下，根据条件进行TrimMemory操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内存因子为0,也是根据跳进进行TrimMemory操作</p>\n</li>\n</ul>\n<p>整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。</p>\n<p>computeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。</p>\n<h3 id=\"4-杀进程\"><a href=\"#4-杀进程\" class=\"headerlink\" title=\"4.杀进程\"></a>4.杀进程</h3><p>杀进程这里就略过了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android","date":"2018-01-18T12:29:36.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 前言\n\n很久没写博客了，也感觉有很长时间没学习了。正好今天遇见两个适配问题，记录一下。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### Android O 应用内安装问题\n\n在8.0版本的手机上，应用内下载安装的时候，后闪一下，然后退回到应用。这是因为，我们缺少一个权限，看一下官方文档的说明。[链接地址](https://developer.android.google.cn/reference/android/Manifest.permission.html#REQUEST_INSTALL_PACKAGES)\n\n\n![](http://7xsy89.com1.z0.glb.clouddn.com/QQ20180118-202532@2x.png)\n\n可以看到，这里说明了，大于25版本，要注册这个权限。\n\n\n### Android 0通知栏适配问题\n\n在8.0版本，我们必须要设置ChannelId，否则，显示不出来通知。demo如下。\n\n```\n        final NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {\n            NotificationChannel chan = new NotificationChannel(getPackageName(),\"demo\", NotificationManager.IMPORTANCE_HIGH);\n            manager.createNotificationChannel(chan);\n        }\n        findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Notification notification = new NotificationCompat.Builder(MainActivity.this)\n                        .setContentTitle(\"111\")\n                        .setContentText(\"222\")\n                        .setSmallIcon(R.drawable.ic_launcher_background)\n                        .setChannelId(getPackageName())\n                        .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher_background))\n                        .build();\n                manager.notify(111,notification);\n            }\n        });\n```\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Android8的一点适配问题.md","raw":"---\ntitle: Android\ndate: 2018-01-18 20:29:36\ntags: Android\n\n---\n<Excerpt in index | 首页摘要>\n\n### 前言\n\n很久没写博客了，也感觉有很长时间没学习了。正好今天遇见两个适配问题，记录一下。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### Android O 应用内安装问题\n\n在8.0版本的手机上，应用内下载安装的时候，后闪一下，然后退回到应用。这是因为，我们缺少一个权限，看一下官方文档的说明。[链接地址](https://developer.android.google.cn/reference/android/Manifest.permission.html#REQUEST_INSTALL_PACKAGES)\n\n\n![](http://7xsy89.com1.z0.glb.clouddn.com/QQ20180118-202532@2x.png)\n\n可以看到，这里说明了，大于25版本，要注册这个权限。\n\n\n### Android 0通知栏适配问题\n\n在8.0版本，我们必须要设置ChannelId，否则，显示不出来通知。demo如下。\n\n```\n        final NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {\n            NotificationChannel chan = new NotificationChannel(getPackageName(),\"demo\", NotificationManager.IMPORTANCE_HIGH);\n            manager.createNotificationChannel(chan);\n        }\n        findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Notification notification = new NotificationCompat.Builder(MainActivity.this)\n                        .setContentTitle(\"111\")\n                        .setContentText(\"222\")\n                        .setSmallIcon(R.drawable.ic_launcher_background)\n                        .setChannelId(getPackageName())\n                        .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher_background))\n                        .build();\n                manager.notify(111,notification);\n            }\n        });\n```\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Android8的一点适配问题","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslx3000d19fyl3g8tzeo","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>很久没写博客了，也感觉有很长时间没学习了。正好今天遇见两个适配问题，记录一下。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"Android-O-应用内安装问题\"><a href=\"#Android-O-应用内安装问题\" class=\"headerlink\" title=\"Android O 应用内安装问题\"></a>Android O 应用内安装问题</h3><p>在8.0版本的手机上，应用内下载安装的时候，后闪一下，然后退回到应用。这是因为，我们缺少一个权限，看一下官方文档的说明。<a href=\"https://developer.android.google.cn/reference/android/Manifest.permission.html#REQUEST_INSTALL_PACKAGES\" target=\"_blank\" rel=\"external\">链接地址</a></p>\n<p><img src=\"http://7xsy89.com1.z0.glb.clouddn.com/QQ20180118-202532@2x.png\" alt=\"\"></p>\n<p>可以看到，这里说明了，大于25版本，要注册这个权限。</p>\n<h3 id=\"Android-0通知栏适配问题\"><a href=\"#Android-0通知栏适配问题\" class=\"headerlink\" title=\"Android 0通知栏适配问题\"></a>Android 0通知栏适配问题</h3><p>在8.0版本，我们必须要设置ChannelId，否则，显示不出来通知。demo如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">final NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</div><div class=\"line\">if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</div><div class=\"line\">    NotificationChannel chan = new NotificationChannel(getPackageName(),&quot;demo&quot;, NotificationManager.IMPORTANCE_HIGH);</div><div class=\"line\">    manager.createNotificationChannel(chan);</div><div class=\"line\">&#125;</div><div class=\"line\">findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onClick(View view) &#123;</div><div class=\"line\">        Notification notification = new NotificationCompat.Builder(MainActivity.this)</div><div class=\"line\">                .setContentTitle(&quot;111&quot;)</div><div class=\"line\">                .setContentText(&quot;222&quot;)</div><div class=\"line\">                .setSmallIcon(R.drawable.ic_launcher_background)</div><div class=\"line\">                .setChannelId(getPackageName())</div><div class=\"line\">                .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher_background))</div><div class=\"line\">                .build();</div><div class=\"line\">        manager.notify(111,notification);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>很久没写博客了，也感觉有很长时间没学习了。正好今天遇见两个适配问题，记录一下。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"Android-O-应用内安装问题\"><a href=\"#Android-O-应用内安装问题\" class=\"headerlink\" title=\"Android O 应用内安装问题\"></a>Android O 应用内安装问题</h3><p>在8.0版本的手机上，应用内下载安装的时候，后闪一下，然后退回到应用。这是因为，我们缺少一个权限，看一下官方文档的说明。<a href=\"https://developer.android.google.cn/reference/android/Manifest.permission.html#REQUEST_INSTALL_PACKAGES\">链接地址</a></p>\n<p><img src=\"http://7xsy89.com1.z0.glb.clouddn.com/QQ20180118-202532@2x.png\" alt=\"\"></p>\n<p>可以看到，这里说明了，大于25版本，要注册这个权限。</p>\n<h3 id=\"Android-0通知栏适配问题\"><a href=\"#Android-0通知栏适配问题\" class=\"headerlink\" title=\"Android 0通知栏适配问题\"></a>Android 0通知栏适配问题</h3><p>在8.0版本，我们必须要设置ChannelId，否则，显示不出来通知。demo如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">final NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</div><div class=\"line\">if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</div><div class=\"line\">    NotificationChannel chan = new NotificationChannel(getPackageName(),&quot;demo&quot;, NotificationManager.IMPORTANCE_HIGH);</div><div class=\"line\">    manager.createNotificationChannel(chan);</div><div class=\"line\">&#125;</div><div class=\"line\">findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onClick(View view) &#123;</div><div class=\"line\">        Notification notification = new NotificationCompat.Builder(MainActivity.this)</div><div class=\"line\">                .setContentTitle(&quot;111&quot;)</div><div class=\"line\">                .setContentText(&quot;222&quot;)</div><div class=\"line\">                .setSmallIcon(R.drawable.ic_launcher_background)</div><div class=\"line\">                .setChannelId(getPackageName())</div><div class=\"line\">                .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher_background))</div><div class=\"line\">                .build();</div><div class=\"line\">        manager.notify(111,notification);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"AndroidJNI学习笔记（四）－数据类型映射以及native调用java","date":"2016-11-29T16:05:36.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 2. 数据类型映射 \n\n首先是我们的基本数据类型，其关系如下表描述这样。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225511135)\n\n上面关系的相关代码在jni.h的44－51行，如下\n\n```\ntypedef unsigned char   jboolean;       /* unsigned 8 bits */\ntypedef signed char     jbyte;          /* signed 8 bits */\ntypedef unsigned short  jchar;          /* unsigned 16 bits */\ntypedef short           jshort;         /* signed 16 bits */\ntypedef int             jint;           /* signed 32 bits */\ntypedef long long       jlong;          /* signed 64 bits */\ntypedef float           jfloat;         /* 32-bit IEEE 754 */\ntypedef double          jdouble;        /* 64-bit IEEE 754 */\n```\n\n\n而jni层的引用类型则是下面这个样子。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225901230)\n\n对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。\n\n```\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n```\n\n### 3. native 如何调用c\n\n我们这里的调用包括许多方面，如：\n\n* 调用静态方法\n* 调用实例方法\n* 获取字段值\n* 修改字段值\n* 构造对象\n* 等等\n\n而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：\n\n*  根据全限定名在jvm中找到想要的类\n* 从jclass中获取到method、或者field\n* 执行获取值、修改值、调用方法或者其他的操作\n* 释放局部引用\n\n举个调用静态方法的例子看看。\n\n```\nvoid callJavaStatic(JNIEnv *env,jobject jobj){\n  char* str = \"call from c++\";\n\n  jclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n  if (clazz == NULL) {\n    LOGE(\"class is null\");\n    return;\n  }\n\n  jmethodID method = env->GetStaticMethodID(clazz,\"javaStaticMethod\",\"(Ljava/lang/String;)V\");\n  if (method == NULL) {\n    LOGE(\"not find method\");\n  }\n\n  jstring  jstr = env->NewStringUTF(str);\n  env->CallStaticVoidMethod(clazz,method,jstr);\n  env->DeleteLocalRef(clazz);\n  env->DeleteLocalRef(jstr);\n}\n```\n\n\n#### 3.1 如何找到类\n\n很简单，我们可以通过FindClass方法去查找类。\n\n```\njclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n```\n\n#### 3.2  如何获取方法、或者字段\n大致为以下四种方法\n\n```\n env->GetxxxField()\n env->GetStaticxxxField()\n env->GetMethodID()\n env->GetxxxMethodID()\n```\n\n上面没有列出参数，但是仍然很明白，这里就不多说了。\n\n\n#### 3.3 如何调用方法\n\n这里呢。大致分为以下四种：\n\n```\n  env->CallXXXMethod();\n  env->CallxxxMethodA();\n  env->CallxxxMethodV();\n  env->CallNonvirtualBooleanMethod()\n```\n\n同样，我这里没给出方法的参数，同学们自己看jni.h吧\n\n* 调用方法（这里的方法可能使静态的、也可能是非静态的）\n* 和上面的区别就在于对应的java层参数，在这里以数组的形式传进入\n* 和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。\n* 调用构造函数初始化一个对象，这个，马上说道。\n\n#### 3.4 如何修改字段的值\n\n相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。\n\n\n#### 3.5 如何构造一个对象出来\n\n有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。\n\n*  NewObject方法 \n*  CallNonvirtualxxMethod\n\n先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是< init >（md语法的原因，注意尖括号之间没有空格），别问为什么。\n\n在来说说第二种，第二中使用时这样的\n\n```\n  jobject  jo = env->AllocObject(clazz);\n  env->CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )\n```\n\n* 第一行代码 创建未初始化的对象，并分配内存\n* 第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。\n\n\n### 4. 总结\n\n现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/AndroidJNI学习笔记（四）－数据类型映射以及native调用java.md","raw":"---\ntitle: AndroidJNI学习笔记（四）－数据类型映射以及native调用java\ndate: 2016-11-30 00:05:36\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 2. 数据类型映射 \n\n首先是我们的基本数据类型，其关系如下表描述这样。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225511135)\n\n上面关系的相关代码在jni.h的44－51行，如下\n\n```\ntypedef unsigned char   jboolean;       /* unsigned 8 bits */\ntypedef signed char     jbyte;          /* signed 8 bits */\ntypedef unsigned short  jchar;          /* unsigned 16 bits */\ntypedef short           jshort;         /* signed 16 bits */\ntypedef int             jint;           /* signed 32 bits */\ntypedef long long       jlong;          /* signed 64 bits */\ntypedef float           jfloat;         /* 32-bit IEEE 754 */\ntypedef double          jdouble;        /* 64-bit IEEE 754 */\n```\n\n\n而jni层的引用类型则是下面这个样子。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225901230)\n\n对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。\n\n```\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n```\n\n### 3. native 如何调用c\n\n我们这里的调用包括许多方面，如：\n\n* 调用静态方法\n* 调用实例方法\n* 获取字段值\n* 修改字段值\n* 构造对象\n* 等等\n\n而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：\n\n*  根据全限定名在jvm中找到想要的类\n* 从jclass中获取到method、或者field\n* 执行获取值、修改值、调用方法或者其他的操作\n* 释放局部引用\n\n举个调用静态方法的例子看看。\n\n```\nvoid callJavaStatic(JNIEnv *env,jobject jobj){\n  char* str = \"call from c++\";\n\n  jclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n  if (clazz == NULL) {\n    LOGE(\"class is null\");\n    return;\n  }\n\n  jmethodID method = env->GetStaticMethodID(clazz,\"javaStaticMethod\",\"(Ljava/lang/String;)V\");\n  if (method == NULL) {\n    LOGE(\"not find method\");\n  }\n\n  jstring  jstr = env->NewStringUTF(str);\n  env->CallStaticVoidMethod(clazz,method,jstr);\n  env->DeleteLocalRef(clazz);\n  env->DeleteLocalRef(jstr);\n}\n```\n\n\n#### 3.1 如何找到类\n\n很简单，我们可以通过FindClass方法去查找类。\n\n```\njclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n```\n\n#### 3.2  如何获取方法、或者字段\n大致为以下四种方法\n\n```\n env->GetxxxField()\n env->GetStaticxxxField()\n env->GetMethodID()\n env->GetxxxMethodID()\n```\n\n上面没有列出参数，但是仍然很明白，这里就不多说了。\n\n\n#### 3.3 如何调用方法\n\n这里呢。大致分为以下四种：\n\n```\n  env->CallXXXMethod();\n  env->CallxxxMethodA();\n  env->CallxxxMethodV();\n  env->CallNonvirtualBooleanMethod()\n```\n\n同样，我这里没给出方法的参数，同学们自己看jni.h吧\n\n* 调用方法（这里的方法可能使静态的、也可能是非静态的）\n* 和上面的区别就在于对应的java层参数，在这里以数组的形式传进入\n* 和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。\n* 调用构造函数初始化一个对象，这个，马上说道。\n\n#### 3.4 如何修改字段的值\n\n相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。\n\n\n#### 3.5 如何构造一个对象出来\n\n有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。\n\n*  NewObject方法 \n*  CallNonvirtualxxMethod\n\n先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是< init >（md语法的原因，注意尖括号之间没有空格），别问为什么。\n\n在来说说第二种，第二中使用时这样的\n\n```\n  jobject  jo = env->AllocObject(clazz);\n  env->CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )\n```\n\n* 第一行代码 创建未初始化的对象，并分配内存\n* 第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。\n\n\n### 4. 总结\n\n现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"AndroidJNI学习笔记（四）－数据类型映射以及native调用java","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslx4000f19fy01ygixdy","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"2-数据类型映射\"><a href=\"#2-数据类型映射\" class=\"headerlink\" title=\"2. 数据类型映射\"></a>2. 数据类型映射</h3><p>首先是我们的基本数据类型，其关系如下表描述这样。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225511135\" alt=\"这里写图片描述\"></p>\n<p>上面关系的相关代码在jni.h的44－51行，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char   jboolean;       /* unsigned 8 bits */</div><div class=\"line\">typedef signed char     jbyte;          /* signed 8 bits */</div><div class=\"line\">typedef unsigned short  jchar;          /* unsigned 16 bits */</div><div class=\"line\">typedef short           jshort;         /* signed 16 bits */</div><div class=\"line\">typedef int             jint;           /* signed 32 bits */</div><div class=\"line\">typedef long long       jlong;          /* signed 64 bits */</div><div class=\"line\">typedef float           jfloat;         /* 32-bit IEEE 754 */</div><div class=\"line\">typedef double          jdouble;        /* 64-bit IEEE 754 */</div></pre></td></tr></table></figure>\n<p>而jni层的引用类型则是下面这个样子。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225901230\" alt=\"这里写图片描述\"></p>\n<p>对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class _jobject &#123;&#125;;</div><div class=\"line\">class _jclass : public _jobject &#123;&#125;;</div><div class=\"line\">class _jstring : public _jobject &#123;&#125;;</div><div class=\"line\">class _jarray : public _jobject &#123;&#125;;</div><div class=\"line\">class _jobjectArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbooleanArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbyteArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jcharArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jshortArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jintArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jlongArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jfloatArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jdoubleArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jthrowable : public _jobject &#123;&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-native-如何调用c\"><a href=\"#3-native-如何调用c\" class=\"headerlink\" title=\"3. native 如何调用c\"></a>3. native 如何调用c</h3><p>我们这里的调用包括许多方面，如：</p>\n<ul>\n<li>调用静态方法</li>\n<li>调用实例方法</li>\n<li>获取字段值</li>\n<li>修改字段值</li>\n<li>构造对象</li>\n<li>等等</li>\n</ul>\n<p>而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：</p>\n<ul>\n<li>根据全限定名在jvm中找到想要的类</li>\n<li>从jclass中获取到method、或者field</li>\n<li>执行获取值、修改值、调用方法或者其他的操作</li>\n<li>释放局部引用</li>\n</ul>\n<p>举个调用静态方法的例子看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void callJavaStatic(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;call from c++&quot;;</div><div class=\"line\"></div><div class=\"line\">  jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div><div class=\"line\">  if (clazz == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;class is null&quot;);</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jmethodID method = env-&gt;GetStaticMethodID(clazz,&quot;javaStaticMethod&quot;,&quot;(Ljava/lang/String;)V&quot;);</div><div class=\"line\">  if (method == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;not find method&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jstring  jstr = env-&gt;NewStringUTF(str);</div><div class=\"line\">  env-&gt;CallStaticVoidMethod(clazz,method,jstr);</div><div class=\"line\">  env-&gt;DeleteLocalRef(clazz);</div><div class=\"line\">  env-&gt;DeleteLocalRef(jstr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-如何找到类\"><a href=\"#3-1-如何找到类\" class=\"headerlink\" title=\"3.1 如何找到类\"></a>3.1 如何找到类</h4><p>很简单，我们可以通过FindClass方法去查找类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div></pre></td></tr></table></figure>\n<h4 id=\"3-2-如何获取方法、或者字段\"><a href=\"#3-2-如何获取方法、或者字段\" class=\"headerlink\" title=\"3.2  如何获取方法、或者字段\"></a>3.2  如何获取方法、或者字段</h4><p>大致为以下四种方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;GetxxxField()</div><div class=\"line\">env-&gt;GetStaticxxxField()</div><div class=\"line\">env-&gt;GetMethodID()</div><div class=\"line\">env-&gt;GetxxxMethodID()</div></pre></td></tr></table></figure>\n<p>上面没有列出参数，但是仍然很明白，这里就不多说了。</p>\n<h4 id=\"3-3-如何调用方法\"><a href=\"#3-3-如何调用方法\" class=\"headerlink\" title=\"3.3 如何调用方法\"></a>3.3 如何调用方法</h4><p>这里呢。大致分为以下四种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;CallXXXMethod();</div><div class=\"line\">env-&gt;CallxxxMethodA();</div><div class=\"line\">env-&gt;CallxxxMethodV();</div><div class=\"line\">env-&gt;CallNonvirtualBooleanMethod()</div></pre></td></tr></table></figure>\n<p>同样，我这里没给出方法的参数，同学们自己看jni.h吧</p>\n<ul>\n<li>调用方法（这里的方法可能使静态的、也可能是非静态的）</li>\n<li>和上面的区别就在于对应的java层参数，在这里以数组的形式传进入</li>\n<li>和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。</li>\n<li>调用构造函数初始化一个对象，这个，马上说道。</li>\n</ul>\n<h4 id=\"3-4-如何修改字段的值\"><a href=\"#3-4-如何修改字段的值\" class=\"headerlink\" title=\"3.4 如何修改字段的值\"></a>3.4 如何修改字段的值</h4><p>相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。</p>\n<h4 id=\"3-5-如何构造一个对象出来\"><a href=\"#3-5-如何构造一个对象出来\" class=\"headerlink\" title=\"3.5 如何构造一个对象出来\"></a>3.5 如何构造一个对象出来</h4><p>有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。</p>\n<ul>\n<li>NewObject方法 </li>\n<li>CallNonvirtualxxMethod</li>\n</ul>\n<p>先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是&lt; init &gt;（md语法的原因，注意尖括号之间没有空格），别问为什么。</p>\n<p>在来说说第二种，第二中使用时这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jobject  jo = env-&gt;AllocObject(clazz);</div><div class=\"line\">env-&gt;CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )</div></pre></td></tr></table></figure>\n<ul>\n<li>第一行代码 创建未初始化的对象，并分配内存</li>\n<li>第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"2-数据类型映射\"><a href=\"#2-数据类型映射\" class=\"headerlink\" title=\"2. 数据类型映射\"></a>2. 数据类型映射</h3><p>首先是我们的基本数据类型，其关系如下表描述这样。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225511135\" alt=\"这里写图片描述\"></p>\n<p>上面关系的相关代码在jni.h的44－51行，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char   jboolean;       /* unsigned 8 bits */</div><div class=\"line\">typedef signed char     jbyte;          /* signed 8 bits */</div><div class=\"line\">typedef unsigned short  jchar;          /* unsigned 16 bits */</div><div class=\"line\">typedef short           jshort;         /* signed 16 bits */</div><div class=\"line\">typedef int             jint;           /* signed 32 bits */</div><div class=\"line\">typedef long long       jlong;          /* signed 64 bits */</div><div class=\"line\">typedef float           jfloat;         /* 32-bit IEEE 754 */</div><div class=\"line\">typedef double          jdouble;        /* 64-bit IEEE 754 */</div></pre></td></tr></table></figure>\n<p>而jni层的引用类型则是下面这个样子。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225901230\" alt=\"这里写图片描述\"></p>\n<p>对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class _jobject &#123;&#125;;</div><div class=\"line\">class _jclass : public _jobject &#123;&#125;;</div><div class=\"line\">class _jstring : public _jobject &#123;&#125;;</div><div class=\"line\">class _jarray : public _jobject &#123;&#125;;</div><div class=\"line\">class _jobjectArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbooleanArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbyteArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jcharArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jshortArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jintArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jlongArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jfloatArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jdoubleArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jthrowable : public _jobject &#123;&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-native-如何调用c\"><a href=\"#3-native-如何调用c\" class=\"headerlink\" title=\"3. native 如何调用c\"></a>3. native 如何调用c</h3><p>我们这里的调用包括许多方面，如：</p>\n<ul>\n<li>调用静态方法</li>\n<li>调用实例方法</li>\n<li>获取字段值</li>\n<li>修改字段值</li>\n<li>构造对象</li>\n<li>等等</li>\n</ul>\n<p>而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：</p>\n<ul>\n<li>根据全限定名在jvm中找到想要的类</li>\n<li>从jclass中获取到method、或者field</li>\n<li>执行获取值、修改值、调用方法或者其他的操作</li>\n<li>释放局部引用</li>\n</ul>\n<p>举个调用静态方法的例子看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void callJavaStatic(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;call from c++&quot;;</div><div class=\"line\"></div><div class=\"line\">  jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div><div class=\"line\">  if (clazz == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;class is null&quot;);</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jmethodID method = env-&gt;GetStaticMethodID(clazz,&quot;javaStaticMethod&quot;,&quot;(Ljava/lang/String;)V&quot;);</div><div class=\"line\">  if (method == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;not find method&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jstring  jstr = env-&gt;NewStringUTF(str);</div><div class=\"line\">  env-&gt;CallStaticVoidMethod(clazz,method,jstr);</div><div class=\"line\">  env-&gt;DeleteLocalRef(clazz);</div><div class=\"line\">  env-&gt;DeleteLocalRef(jstr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-如何找到类\"><a href=\"#3-1-如何找到类\" class=\"headerlink\" title=\"3.1 如何找到类\"></a>3.1 如何找到类</h4><p>很简单，我们可以通过FindClass方法去查找类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div></pre></td></tr></table></figure>\n<h4 id=\"3-2-如何获取方法、或者字段\"><a href=\"#3-2-如何获取方法、或者字段\" class=\"headerlink\" title=\"3.2  如何获取方法、或者字段\"></a>3.2  如何获取方法、或者字段</h4><p>大致为以下四种方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;GetxxxField()</div><div class=\"line\">env-&gt;GetStaticxxxField()</div><div class=\"line\">env-&gt;GetMethodID()</div><div class=\"line\">env-&gt;GetxxxMethodID()</div></pre></td></tr></table></figure>\n<p>上面没有列出参数，但是仍然很明白，这里就不多说了。</p>\n<h4 id=\"3-3-如何调用方法\"><a href=\"#3-3-如何调用方法\" class=\"headerlink\" title=\"3.3 如何调用方法\"></a>3.3 如何调用方法</h4><p>这里呢。大致分为以下四种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;CallXXXMethod();</div><div class=\"line\">env-&gt;CallxxxMethodA();</div><div class=\"line\">env-&gt;CallxxxMethodV();</div><div class=\"line\">env-&gt;CallNonvirtualBooleanMethod()</div></pre></td></tr></table></figure>\n<p>同样，我这里没给出方法的参数，同学们自己看jni.h吧</p>\n<ul>\n<li>调用方法（这里的方法可能使静态的、也可能是非静态的）</li>\n<li>和上面的区别就在于对应的java层参数，在这里以数组的形式传进入</li>\n<li>和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。</li>\n<li>调用构造函数初始化一个对象，这个，马上说道。</li>\n</ul>\n<h4 id=\"3-4-如何修改字段的值\"><a href=\"#3-4-如何修改字段的值\" class=\"headerlink\" title=\"3.4 如何修改字段的值\"></a>3.4 如何修改字段的值</h4><p>相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。</p>\n<h4 id=\"3-5-如何构造一个对象出来\"><a href=\"#3-5-如何构造一个对象出来\" class=\"headerlink\" title=\"3.5 如何构造一个对象出来\"></a>3.5 如何构造一个对象出来</h4><p>有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。</p>\n<ul>\n<li>NewObject方法 </li>\n<li>CallNonvirtualxxMethod</li>\n</ul>\n<p>先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是&lt; init &gt;（md语法的原因，注意尖括号之间没有空格），别问为什么。</p>\n<p>在来说说第二种，第二中使用时这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jobject  jo = env-&gt;AllocObject(clazz);</div><div class=\"line\">env-&gt;CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )</div></pre></td></tr></table></figure>\n<ul>\n<li>第一行代码 创建未初始化的对象，并分配内存</li>\n<li>第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android也需要防止SQL注入","date":"2018-03-25T02:59:03.000Z","_content":"<Excerpt in index | 首页摘要>\n### 为什么要写下这篇\n\n最近，在移动端发现一个用户无法登陆的bug，经过排查，发现是不规范的Sql语句以及没做SQL攻击的防止导致的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 移动端也防止关注SQL攻击\n\n大多数情况下，我们是不需要考虑的，Android SDK给我们提供的query/insert/update/delete等API是安全的,但是**execSql这个API却不是,尽量别使用这个API**\n\n由于我们的代码，原先的数据存储是靠C++的sqlite，而没借助Android的Sdk来做的。因此，原先一些SQL可能存在问题。\n\n### 例子\n\n```\nString userName = \"\";\nint age = 24;\nmDBHelper.getWritableDatabase().execSQL(String.format(Locale.getDefault(),\"insert into \" + \t\tUserDBHelper.TABLE_NAME+ \" (UserName,Age) values(%s,%d)\",userName,age));\n```\n\n类似上面的代码，我想 大家的项目里或许也有。看上去，这个没有任何问题，但是却存在sql攻击，当我把userName这个字符串的内容换成，带特殊字符的，如 guolei' 的时候，这个拼接出来的sql语句就有问题了，回报如下错误。\n\n```\nProcess: com.guolei.sqlinsert, PID: 22520\n                                                                      android.database.sqlite.SQLiteException: unrecognized token: \"',24)\" (code 1): , while compiling: insert into user (UserName,Age) values(error',24)\n                                                                          at android.database.sqlite.SQLiteConnection.nativePrepareStatement(Native Method)\n```\n\n这是因为单引号 ' 使sql语句发生了截断，在sql语句中，要用连续两个单引号去表达一个单引号字符。这仅仅是一个例子。有兴趣的，大家去了解SQL攻击相关的东西吧。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Android也需要防止SQL注入.md","raw":"---\ntitle: Android也需要防止SQL注入\ndate: 2018-03-25 10:59:03\ntags: 安全\ncategories: Android\n\n---\n<Excerpt in index | 首页摘要>\n### 为什么要写下这篇\n\n最近，在移动端发现一个用户无法登陆的bug，经过排查，发现是不规范的Sql语句以及没做SQL攻击的防止导致的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 移动端也防止关注SQL攻击\n\n大多数情况下，我们是不需要考虑的，Android SDK给我们提供的query/insert/update/delete等API是安全的,但是**execSql这个API却不是,尽量别使用这个API**\n\n由于我们的代码，原先的数据存储是靠C++的sqlite，而没借助Android的Sdk来做的。因此，原先一些SQL可能存在问题。\n\n### 例子\n\n```\nString userName = \"\";\nint age = 24;\nmDBHelper.getWritableDatabase().execSQL(String.format(Locale.getDefault(),\"insert into \" + \t\tUserDBHelper.TABLE_NAME+ \" (UserName,Age) values(%s,%d)\",userName,age));\n```\n\n类似上面的代码，我想 大家的项目里或许也有。看上去，这个没有任何问题，但是却存在sql攻击，当我把userName这个字符串的内容换成，带特殊字符的，如 guolei' 的时候，这个拼接出来的sql语句就有问题了，回报如下错误。\n\n```\nProcess: com.guolei.sqlinsert, PID: 22520\n                                                                      android.database.sqlite.SQLiteException: unrecognized token: \"',24)\" (code 1): , while compiling: insert into user (UserName,Age) values(error',24)\n                                                                          at android.database.sqlite.SQLiteConnection.nativePrepareStatement(Native Method)\n```\n\n这是因为单引号 ' 使sql语句发生了截断，在sql语句中，要用连续两个单引号去表达一个单引号字符。这仅仅是一个例子。有兴趣的，大家去了解SQL攻击相关的东西吧。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Android也需要防止SQL注入","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslx6000i19fy6y3usx68","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"为什么要写下这篇\"><a href=\"#为什么要写下这篇\" class=\"headerlink\" title=\"为什么要写下这篇\"></a>为什么要写下这篇</h3><p>最近，在移动端发现一个用户无法登陆的bug，经过排查，发现是不规范的Sql语句以及没做SQL攻击的防止导致的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"移动端也防止关注SQL攻击\"><a href=\"#移动端也防止关注SQL攻击\" class=\"headerlink\" title=\"移动端也防止关注SQL攻击\"></a>移动端也防止关注SQL攻击</h3><p>大多数情况下，我们是不需要考虑的，Android SDK给我们提供的query/insert/update/delete等API是安全的,但是<strong>execSql这个API却不是,尽量别使用这个API</strong></p>\n<p>由于我们的代码，原先的数据存储是靠C++的sqlite，而没借助Android的Sdk来做的。因此，原先一些SQL可能存在问题。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String userName = &quot;&quot;;</div><div class=\"line\">int age = 24;</div><div class=\"line\">mDBHelper.getWritableDatabase().execSQL(String.format(Locale.getDefault(),&quot;insert into &quot; + \t\tUserDBHelper.TABLE_NAME+ &quot; (UserName,Age) values(%s,%d)&quot;,userName,age));</div></pre></td></tr></table></figure>\n<p>类似上面的代码，我想 大家的项目里或许也有。看上去，这个没有任何问题，但是却存在sql攻击，当我把userName这个字符串的内容换成，带特殊字符的，如 guolei’ 的时候，这个拼接出来的sql语句就有问题了，回报如下错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process: com.guolei.sqlinsert, PID: 22520</div><div class=\"line\">                                                                      android.database.sqlite.SQLiteException: unrecognized token: &quot;&apos;,24)&quot; (code 1): , while compiling: insert into user (UserName,Age) values(error&apos;,24)</div><div class=\"line\">                                                                          at android.database.sqlite.SQLiteConnection.nativePrepareStatement(Native Method)</div></pre></td></tr></table></figure>\n<p>这是因为单引号 ‘ 使sql语句发生了截断，在sql语句中，要用连续两个单引号去表达一个单引号字符。这仅仅是一个例子。有兴趣的，大家去了解SQL攻击相关的东西吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"为什么要写下这篇\"><a href=\"#为什么要写下这篇\" class=\"headerlink\" title=\"为什么要写下这篇\"></a>为什么要写下这篇</h3><p>最近，在移动端发现一个用户无法登陆的bug，经过排查，发现是不规范的Sql语句以及没做SQL攻击的防止导致的。</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"移动端也防止关注SQL攻击\"><a href=\"#移动端也防止关注SQL攻击\" class=\"headerlink\" title=\"移动端也防止关注SQL攻击\"></a>移动端也防止关注SQL攻击</h3><p>大多数情况下，我们是不需要考虑的，Android SDK给我们提供的query/insert/update/delete等API是安全的,但是<strong>execSql这个API却不是,尽量别使用这个API</strong></p>\n<p>由于我们的代码，原先的数据存储是靠C++的sqlite，而没借助Android的Sdk来做的。因此，原先一些SQL可能存在问题。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String userName = &quot;&quot;;</div><div class=\"line\">int age = 24;</div><div class=\"line\">mDBHelper.getWritableDatabase().execSQL(String.format(Locale.getDefault(),&quot;insert into &quot; + \t\tUserDBHelper.TABLE_NAME+ &quot; (UserName,Age) values(%s,%d)&quot;,userName,age));</div></pre></td></tr></table></figure>\n<p>类似上面的代码，我想 大家的项目里或许也有。看上去，这个没有任何问题，但是却存在sql攻击，当我把userName这个字符串的内容换成，带特殊字符的，如 guolei’ 的时候，这个拼接出来的sql语句就有问题了，回报如下错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Process: com.guolei.sqlinsert, PID: 22520</div><div class=\"line\">                                                                      android.database.sqlite.SQLiteException: unrecognized token: &quot;&apos;,24)&quot; (code 1): , while compiling: insert into user (UserName,Age) values(error&apos;,24)</div><div class=\"line\">                                                                          at android.database.sqlite.SQLiteConnection.nativePrepareStatement(Native Method)</div></pre></td></tr></table></figure>\n<p>这是因为单引号 ‘ 使sql语句发生了截断，在sql语句中，要用连续两个单引号去表达一个单引号字符。这仅仅是一个例子。有兴趣的，大家去了解SQL攻击相关的东西吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android属性动画源码浅析","date":"2017-01-19T08:32:38.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n日常开发离不开动画，属性动画更为强大，我们不仅要知道如何使用，更要知道他的原理。这样，才能得心应手。那么，今天，就从最简单的来说，了解下属性动画的原理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n        ObjectAnimator\n                .ofInt(mView,\"width\",100,500)\n                .setDuration(1000)\n                .start();\n```\n\n### ObjectAnimator#ofInt\n\n以这个为例，代码如下。\n\n```\n    public static ObjectAnimator ofInt(Object target, String propertyName, int... values) {\n        ObjectAnimator anim = new ObjectAnimator(target, propertyName);\n        anim.setIntValues(values);\n        return anim;\n    }\n```\n\n在这个方法中，首先会new一个ObjectAnimator对象，然后通过setIntValues方法将值设置进去，然后返回。在ObjectAnimator的构造方法中，会通过setTarget方法设置当前动画的对象，通过setPropertyName设置当前的属性名。我们重点说下setIntValues方法。\n\n```\n    public void setIntValues(int... values) {\n        if (mValues == null || mValues.length == 0) {\n            // No values yet - this animator is being constructed piecemeal. Init the values with\n            // whatever the current propertyName is\n            if (mProperty != null) {\n                setValues(PropertyValuesHolder.ofInt(mProperty, values));\n            } else {\n                setValues(PropertyValuesHolder.ofInt(mPropertyName, values));\n            }\n        } else {\n            super.setIntValues(values);\n        }\n    }\n```\n\n首先会判断，mValues是不是null，我们这里是null，并且mProperty也是null，所以会调用\nsetValues(PropertyValuesHolder.ofInt(mPropertyName, values));方法。先看PropertyValuesHolder.ofInt方法，PropertyValuesHolder这个类是holds属性和值的，在这个方法会构造一个IntPropertyValuesHolder对象并返回。\n\n```\n    public static PropertyValuesHolder ofInt(String propertyName, int... values) {\n        return new IntPropertyValuesHolder(propertyName, values);\n    }\n\n```\n\nIntPropertyValuesHolder的构造方法如下：\n\n```\n        public IntPropertyValuesHolder(String propertyName, int... values) {\n            super(propertyName);\n            setIntValues(values);\n        }\n```\n\n在这里，首先会调用他的分类的构造方法，然后调用setIntValues方法，在他父类的构造方法中，只是设置了下propertyName。setIntValues内容如下：\n\n```\n        public void setIntValues(int... values) {\n            super.setIntValues(values);\n            mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;\n        }\n```\n\n在父类的setIntValues方法中，初始化了mValueType为int.class，mKeyframes为KeyframeSet.ofInt(values)。其中KeyframeSet为关键帧集合。然后将mKeyframes赋值给mIntKeyframes。\n\n#### KeyframeSet\n\n这个类是记录关键帧的。我们看下他的ofInt方法。\n\n```\n    public static KeyframeSet ofInt(int... values) {\n        int numKeyframes = values.length;\n        IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes,2)];\n        if (numKeyframes == 1) {\n            keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f);\n            keyframes[1] = (IntKeyframe) Keyframe.ofInt(1f, values[0]);\n        } else {\n            keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f, values[0]);\n            for (int i = 1; i < numKeyframes; ++i) {\n                keyframes[i] =\n                        (IntKeyframe) Keyframe.ofInt((float) i / (numKeyframes - 1), values[i]);\n            }\n        }\n        return new IntKeyframeSet(keyframes);\n    }\n```\n\n在这里呢？根据传入的values来计算关键帧，最后返回IntKeyframeSet。\n\n回到ObjectAnimator里面，这里的setValues用的是父类ValueAnimator的\n\n#### ValueAnimator#setValues\n\n```\n    public void setValues(PropertyValuesHolder... values) {\n        int numValues = values.length;\n        mValues = values;\n        mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);\n        for (int i = 0; i < numValues; ++i) {\n            PropertyValuesHolder valuesHolder = values[i];\n            mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);\n        }\n        // New property/values/target should cause re-initialization prior to starting\n        mInitialized = false;\n    }\n\n```\n\n这里的操作就简单了，就是把PropertyValuesHolder放入到mValuesMap中。\n\n### ObjectAnimator#start \n\n这个方法就是动画开始的地方。\n\n```\n    public void start() {\n        // See if any of the current active/pending animators need to be canceled\n        AnimationHandler handler = sAnimationHandler.get();\n        if (handler != null) {\n            int numAnims = handler.mAnimations.size();\n            for (int i = numAnims - 1; i >= 0; i--) {\n                if (handler.mAnimations.get(i) instanceof ObjectAnimator) {\n                    ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i);\n                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {\n                        anim.cancel();\n                    }\n                }\n            }\n            numAnims = handler.mPendingAnimations.size();\n            for (int i = numAnims - 1; i >= 0; i--) {\n                if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) {\n                    ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i);\n                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {\n                        anim.cancel();\n                    }\n                }\n            }\n            numAnims = handler.mDelayedAnims.size();\n            for (int i = numAnims - 1; i >= 0; i--) {\n                if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) {\n                    ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i);\n                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {\n                        anim.cancel();\n                    }\n                }\n            }\n        }\n        if (DBG) {\n            Log.d(LOG_TAG, \"Anim target, duration: \" + getTarget() + \", \" + getDuration());\n            for (int i = 0; i < mValues.length; ++i) {\n                PropertyValuesHolder pvh = mValues[i];\n                Log.d(LOG_TAG, \"   Values[\" + i + \"]: \" +\n                    pvh.getPropertyName() + \", \" + pvh.mKeyframes.getValue(0) + \", \" +\n                    pvh.mKeyframes.getValue(1));\n            }\n        }\n        super.start();\n    }\n```\n\n首先呢，会获取AnimationHandler对象，如果不为空的话，就会判断是mAnimations、mPendingAnimations、mDelayedAnims中的动画，并且取消。最后调用父类的start方法。\n\n\n### ValueAnimator#start\n\n```\n    private void start(boolean playBackwards) {\n        if (Looper.myLooper() == null) {\n            throw new AndroidRuntimeException(\"Animators may only be run on Looper threads\");\n        }\n        mReversing = playBackwards;\n        mPlayingBackwards = playBackwards;\n        if (playBackwards && mSeekFraction != -1) {\n            if (mSeekFraction == 0 && mCurrentIteration == 0) {\n                // special case: reversing from seek-to-0 should act as if not seeked at all\n                mSeekFraction = 0;\n            } else if (mRepeatCount == INFINITE) {\n                mSeekFraction = 1 - (mSeekFraction % 1);\n            } else {\n                mSeekFraction = 1 + mRepeatCount - (mCurrentIteration + mSeekFraction);\n            }\n            mCurrentIteration = (int) mSeekFraction;\n            mSeekFraction = mSeekFraction % 1;\n        }\n        if (mCurrentIteration > 0 && mRepeatMode == REVERSE &&\n                (mCurrentIteration < (mRepeatCount + 1) || mRepeatCount == INFINITE)) {\n            // if we were seeked to some other iteration in a reversing animator,\n            // figure out the correct direction to start playing based on the iteration\n            if (playBackwards) {\n                mPlayingBackwards = (mCurrentIteration % 2) == 0;\n            } else {\n                mPlayingBackwards = (mCurrentIteration % 2) != 0;\n            }\n        }\n        int prevPlayingState = mPlayingState;\n        mPlayingState = STOPPED;\n        mStarted = true;\n        mStartedDelay = false;\n        mPaused = false;\n        updateScaledDuration(); // in case the scale factor has changed since creation time\n        AnimationHandler animationHandler = getOrCreateAnimationHandler();\n        animationHandler.mPendingAnimations.add(this);\n        if (mStartDelay == 0) {\n            // This sets the initial value of the animation, prior to actually starting it running\n            if (prevPlayingState != SEEKED) {\n                setCurrentPlayTime(0);\n            }\n            mPlayingState = STOPPED;\n            mRunning = true;\n            notifyStartListeners();\n        }\n        animationHandler.start();\n    }\n```\n\n* 先初始化一些值\n* updateScaledDuration 缩放时间，默认为1.0f\n* 获取或者创建AnimationHandler，将动画加入到mPendingAnimations列表中，\n* 如果没延迟，通知监听器\n* animationHandler.start\n\n\n\n在animationHandler.start中，会调用scheduleAnimation方法，在这个种，会用mChoreographerpost一个callback，最终会执行mAnimate的run方法。mChoreographerpost涉及到VSYNC，这里不多介绍。\n\n### mAnimate#run\n\n```\ndoAnimationFrame(mChoreographer.getFrameTime());\n```\n\n在这里会用过doAnimationFrame设置动画帧，我们看下这个方法的代码。\n\n```\n        void doAnimationFrame(long frameTime) {\n            mLastFrameTime = frameTime;\n\n            // mPendingAnimations holds any animations that have requested to be started\n            // We're going to clear mPendingAnimations, but starting animation may\n            // cause more to be added to the pending list (for example, if one animation\n            // starting triggers another starting). So we loop until mPendingAnimations\n            // is empty.\n            while (mPendingAnimations.size() > 0) {\n                ArrayList<ValueAnimator> pendingCopy =\n                        (ArrayList<ValueAnimator>) mPendingAnimations.clone();\n                mPendingAnimations.clear();\n                int count = pendingCopy.size();\n                for (int i = 0; i < count; ++i) {\n                    ValueAnimator anim = pendingCopy.get(i);\n                    // If the animation has a startDelay, place it on the delayed list\n                    if (anim.mStartDelay == 0) {\n                        anim.startAnimation(this);\n                    } else {\n                        mDelayedAnims.add(anim);\n                    }\n                }\n            }\n\n            // Next, process animations currently sitting on the delayed queue, adding\n            // them to the active animations if they are ready\n            int numDelayedAnims = mDelayedAnims.size();\n            for (int i = 0; i < numDelayedAnims; ++i) {\n                ValueAnimator anim = mDelayedAnims.get(i);\n                if (anim.delayedAnimationFrame(frameTime)) {\n                    mReadyAnims.add(anim);\n                }\n            }\n            int numReadyAnims = mReadyAnims.size();\n            if (numReadyAnims > 0) {\n                for (int i = 0; i < numReadyAnims; ++i) {\n                    ValueAnimator anim = mReadyAnims.get(i);\n                    anim.startAnimation(this);\n                    anim.mRunning = true;\n                    mDelayedAnims.remove(anim);\n                }\n                mReadyAnims.clear();\n            }\n\n            // Now process all active animations. The return value from animationFrame()\n            // tells the handler whether it should now be ended\n            int numAnims = mAnimations.size();\n            for (int i = 0; i < numAnims; ++i) {\n                mTmpAnimations.add(mAnimations.get(i));\n            }\n            for (int i = 0; i < numAnims; ++i) {\n                ValueAnimator anim = mTmpAnimations.get(i);\n                if (mAnimations.contains(anim) && anim.doAnimationFrame(frameTime)) {\n                    mEndingAnims.add(anim);\n                }\n            }\n            mTmpAnimations.clear();\n            if (mEndingAnims.size() > 0) {\n                for (int i = 0; i < mEndingAnims.size(); ++i) {\n                    mEndingAnims.get(i).endAnimation(this);\n                }\n                mEndingAnims.clear();\n            }\n\n            // Schedule final commit for the frame.\n            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, mCommit, null);\n\n            // If there are still active or delayed animations, schedule a future call to\n            // onAnimate to process the next frame of the animations.\n            if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) {\n                scheduleAnimation();\n            }\n        }\n```\n\n方法较长，逻辑如下：\n\n* 从mPendingAnimations中取出动画，根据事先选择startAnimation还是加入到mDelayedAnims列表。\n* 如果mDelayedAnims列表中的动画准备好了，就加入到mReadyAnims列表中\n* 从mAnimations列表中取出要执行的动画，加入到mTmpAnimations列表\n* 通过doAnimationFrame方法执行动画帧\n* 继续执行scheduleAnimation\n\n从上面我们能看出，执行动画的关键是doAnimationFrame方法。在这个方法中，会调用animationFrame方法。\n\n### ValueAniator#animationFrame\n\n```\n   boolean animationFrame(long currentTime) {\n        boolean done = false;\n        switch (mPlayingState) {\n        case RUNNING:\n        case SEEKED:\n            float fraction = mDuration > 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;\n            if (mDuration == 0 && mRepeatCount != INFINITE) {\n                // Skip to the end\n                mCurrentIteration = mRepeatCount;\n                if (!mReversing) {\n                    mPlayingBackwards = false;\n                }\n            }\n            if (fraction >= 1f) {\n                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {\n                    // Time to repeat\n                    if (mListeners != null) {\n                        int numListeners = mListeners.size();\n                        for (int i = 0; i < numListeners; ++i) {\n                            mListeners.get(i).onAnimationRepeat(this);\n                        }\n                    }\n                    if (mRepeatMode == REVERSE) {\n                        mPlayingBackwards = !mPlayingBackwards;\n                    }\n                    mCurrentIteration += (int) fraction;\n                    fraction = fraction % 1f;\n                    mStartTime += mDuration;\n                    // Note: We do not need to update the value of mStartTimeCommitted here\n                    // since we just added a duration offset.\n                } else {\n                    done = true;\n                    fraction = Math.min(fraction, 1.0f);\n                }\n            }\n            if (mPlayingBackwards) {\n                fraction = 1f - fraction;\n            }\n            animateValue(fraction);\n            break;\n        }\n\n        return done;\n    }\n```\n\n* 计算fraction\n* 调用animateValue方法\n\n<span style=\"color:red\">根据虚拟机执行引擎动态分派原则，这里会调用ObjectAnimator的animateValue方法。<span>\n\n### ObjectAnimator#animateValue\n\n\n```\n    void animateValue(float fraction) {\n        final Object target = getTarget();\n        if (mTarget != null && target == null) {\n            // We lost the target reference, cancel and clean up.\n            cancel();\n            return;\n        }\n\n        super.animateValue(fraction);\n        int numValues = mValues.length;\n        for (int i = 0; i < numValues; ++i) {\n            mValues[i].setAnimatedValue(target);\n        }\n    }\n\n```\n\n这里主要干了两件事，\n\n* 调用父类的animateValue方法\n* 通过setAnimatedValue设置属性\n\n其父类的方法如下：\n\n```\n    void animateValue(float fraction) {\n        fraction = mInterpolator.getInterpolation(fraction);\n        mCurrentFraction = fraction;\n        int numValues = mValues.length;\n        for (int i = 0; i < numValues; ++i) {\n            mValues[i].calculateValue(fraction);\n        }\n        if (mUpdateListeners != null) {\n            int numListeners = mUpdateListeners.size();\n            for (int i = 0; i < numListeners; ++i) {\n                mUpdateListeners.get(i).onAnimationUpdate(this);\n            }\n        }\n    }\n```\n\n在这个方法中，会通过Interpolator得到出当前的fraction，并通过calculateValue来计算当前应该的值，这里会调用IntPropertyValuesHolder的calculateValue\n\n```\n        void calculateValue(float fraction) {\n            mIntAnimatedValue = mIntKeyframes.getIntValue(fraction);\n        }\n```\n\n我们知道，mIntKeyframes对应的是IntKeyframeSet。在这个类的getIntValue中，会通过TypeEvaluator来计算当前对应的值。不多说了。\n\n最后，回到animateValue。计算了值之后，会调用setAnimatedValue来设置值。我们看看他的实现。\n\n### IntPropertyValuesHolder#setAnimatedValue\n\n```\n        void setAnimatedValue(Object target) {\n            if (mIntProperty != null) {\n                mIntProperty.setValue(target, mIntAnimatedValue);\n                return;\n            }\n            if (mProperty != null) {\n                mProperty.set(target, mIntAnimatedValue);\n                return;\n            }\n            if (mJniSetter != 0) {\n                nCallIntMethod(target, mJniSetter, mIntAnimatedValue);\n                return;\n            }\n            if (mSetter != null) {\n                try {\n                    mTmpValueArray[0] = mIntAnimatedValue;\n                    mSetter.invoke(target, mTmpValueArray);\n                } catch (InvocationTargetException e) {\n                    Log.e(\"PropertyValuesHolder\", e.toString());\n                } catch (IllegalAccessException e) {\n                    Log.e(\"PropertyValuesHolder\", e.toString());\n                }\n            }\n        }\n```\n\n恩，到这里就能看到修改属性值得痕迹了，有以下四种情况\n\n* mIntProperty不为null\n* mProperty不为null\n* mJniSetter不为null\n* mSetter不为null\n\n首先，我们通过String propertyName, int... values参数构造的对象，mIntProperty为null，并且mProperty也为null。那其他两个是怎么来的呢？似乎漏了什么？\n\n还节的，在doAnimationFrame中，直接调用startAnimation么?没错，就是这里。\n\n### startAnimation\n\n在这个方法中调用了initAnimation方法。还是根据动态分派规则，这里调用ObjectAnimator的initAnimation方法。在这里调用PropertyValuesHolder的setupSetterAndGetter方法，在这里对mSetter等进行了初始化，这里就不多说了，大家自己看代码吧。\n\n\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Android属性动画源码浅析.md","raw":"---\ntitle: Android属性动画源码浅析\ndate: 2017-01-19 16:32:38\ncategories: Android\ntags: 源码\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n日常开发离不开动画，属性动画更为强大，我们不仅要知道如何使用，更要知道他的原理。这样，才能得心应手。那么，今天，就从最简单的来说，了解下属性动画的原理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n        ObjectAnimator\n                .ofInt(mView,\"width\",100,500)\n                .setDuration(1000)\n                .start();\n```\n\n### ObjectAnimator#ofInt\n\n以这个为例，代码如下。\n\n```\n    public static ObjectAnimator ofInt(Object target, String propertyName, int... values) {\n        ObjectAnimator anim = new ObjectAnimator(target, propertyName);\n        anim.setIntValues(values);\n        return anim;\n    }\n```\n\n在这个方法中，首先会new一个ObjectAnimator对象，然后通过setIntValues方法将值设置进去，然后返回。在ObjectAnimator的构造方法中，会通过setTarget方法设置当前动画的对象，通过setPropertyName设置当前的属性名。我们重点说下setIntValues方法。\n\n```\n    public void setIntValues(int... values) {\n        if (mValues == null || mValues.length == 0) {\n            // No values yet - this animator is being constructed piecemeal. Init the values with\n            // whatever the current propertyName is\n            if (mProperty != null) {\n                setValues(PropertyValuesHolder.ofInt(mProperty, values));\n            } else {\n                setValues(PropertyValuesHolder.ofInt(mPropertyName, values));\n            }\n        } else {\n            super.setIntValues(values);\n        }\n    }\n```\n\n首先会判断，mValues是不是null，我们这里是null，并且mProperty也是null，所以会调用\nsetValues(PropertyValuesHolder.ofInt(mPropertyName, values));方法。先看PropertyValuesHolder.ofInt方法，PropertyValuesHolder这个类是holds属性和值的，在这个方法会构造一个IntPropertyValuesHolder对象并返回。\n\n```\n    public static PropertyValuesHolder ofInt(String propertyName, int... values) {\n        return new IntPropertyValuesHolder(propertyName, values);\n    }\n\n```\n\nIntPropertyValuesHolder的构造方法如下：\n\n```\n        public IntPropertyValuesHolder(String propertyName, int... values) {\n            super(propertyName);\n            setIntValues(values);\n        }\n```\n\n在这里，首先会调用他的分类的构造方法，然后调用setIntValues方法，在他父类的构造方法中，只是设置了下propertyName。setIntValues内容如下：\n\n```\n        public void setIntValues(int... values) {\n            super.setIntValues(values);\n            mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;\n        }\n```\n\n在父类的setIntValues方法中，初始化了mValueType为int.class，mKeyframes为KeyframeSet.ofInt(values)。其中KeyframeSet为关键帧集合。然后将mKeyframes赋值给mIntKeyframes。\n\n#### KeyframeSet\n\n这个类是记录关键帧的。我们看下他的ofInt方法。\n\n```\n    public static KeyframeSet ofInt(int... values) {\n        int numKeyframes = values.length;\n        IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes,2)];\n        if (numKeyframes == 1) {\n            keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f);\n            keyframes[1] = (IntKeyframe) Keyframe.ofInt(1f, values[0]);\n        } else {\n            keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f, values[0]);\n            for (int i = 1; i < numKeyframes; ++i) {\n                keyframes[i] =\n                        (IntKeyframe) Keyframe.ofInt((float) i / (numKeyframes - 1), values[i]);\n            }\n        }\n        return new IntKeyframeSet(keyframes);\n    }\n```\n\n在这里呢？根据传入的values来计算关键帧，最后返回IntKeyframeSet。\n\n回到ObjectAnimator里面，这里的setValues用的是父类ValueAnimator的\n\n#### ValueAnimator#setValues\n\n```\n    public void setValues(PropertyValuesHolder... values) {\n        int numValues = values.length;\n        mValues = values;\n        mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);\n        for (int i = 0; i < numValues; ++i) {\n            PropertyValuesHolder valuesHolder = values[i];\n            mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);\n        }\n        // New property/values/target should cause re-initialization prior to starting\n        mInitialized = false;\n    }\n\n```\n\n这里的操作就简单了，就是把PropertyValuesHolder放入到mValuesMap中。\n\n### ObjectAnimator#start \n\n这个方法就是动画开始的地方。\n\n```\n    public void start() {\n        // See if any of the current active/pending animators need to be canceled\n        AnimationHandler handler = sAnimationHandler.get();\n        if (handler != null) {\n            int numAnims = handler.mAnimations.size();\n            for (int i = numAnims - 1; i >= 0; i--) {\n                if (handler.mAnimations.get(i) instanceof ObjectAnimator) {\n                    ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i);\n                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {\n                        anim.cancel();\n                    }\n                }\n            }\n            numAnims = handler.mPendingAnimations.size();\n            for (int i = numAnims - 1; i >= 0; i--) {\n                if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) {\n                    ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i);\n                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {\n                        anim.cancel();\n                    }\n                }\n            }\n            numAnims = handler.mDelayedAnims.size();\n            for (int i = numAnims - 1; i >= 0; i--) {\n                if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) {\n                    ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i);\n                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {\n                        anim.cancel();\n                    }\n                }\n            }\n        }\n        if (DBG) {\n            Log.d(LOG_TAG, \"Anim target, duration: \" + getTarget() + \", \" + getDuration());\n            for (int i = 0; i < mValues.length; ++i) {\n                PropertyValuesHolder pvh = mValues[i];\n                Log.d(LOG_TAG, \"   Values[\" + i + \"]: \" +\n                    pvh.getPropertyName() + \", \" + pvh.mKeyframes.getValue(0) + \", \" +\n                    pvh.mKeyframes.getValue(1));\n            }\n        }\n        super.start();\n    }\n```\n\n首先呢，会获取AnimationHandler对象，如果不为空的话，就会判断是mAnimations、mPendingAnimations、mDelayedAnims中的动画，并且取消。最后调用父类的start方法。\n\n\n### ValueAnimator#start\n\n```\n    private void start(boolean playBackwards) {\n        if (Looper.myLooper() == null) {\n            throw new AndroidRuntimeException(\"Animators may only be run on Looper threads\");\n        }\n        mReversing = playBackwards;\n        mPlayingBackwards = playBackwards;\n        if (playBackwards && mSeekFraction != -1) {\n            if (mSeekFraction == 0 && mCurrentIteration == 0) {\n                // special case: reversing from seek-to-0 should act as if not seeked at all\n                mSeekFraction = 0;\n            } else if (mRepeatCount == INFINITE) {\n                mSeekFraction = 1 - (mSeekFraction % 1);\n            } else {\n                mSeekFraction = 1 + mRepeatCount - (mCurrentIteration + mSeekFraction);\n            }\n            mCurrentIteration = (int) mSeekFraction;\n            mSeekFraction = mSeekFraction % 1;\n        }\n        if (mCurrentIteration > 0 && mRepeatMode == REVERSE &&\n                (mCurrentIteration < (mRepeatCount + 1) || mRepeatCount == INFINITE)) {\n            // if we were seeked to some other iteration in a reversing animator,\n            // figure out the correct direction to start playing based on the iteration\n            if (playBackwards) {\n                mPlayingBackwards = (mCurrentIteration % 2) == 0;\n            } else {\n                mPlayingBackwards = (mCurrentIteration % 2) != 0;\n            }\n        }\n        int prevPlayingState = mPlayingState;\n        mPlayingState = STOPPED;\n        mStarted = true;\n        mStartedDelay = false;\n        mPaused = false;\n        updateScaledDuration(); // in case the scale factor has changed since creation time\n        AnimationHandler animationHandler = getOrCreateAnimationHandler();\n        animationHandler.mPendingAnimations.add(this);\n        if (mStartDelay == 0) {\n            // This sets the initial value of the animation, prior to actually starting it running\n            if (prevPlayingState != SEEKED) {\n                setCurrentPlayTime(0);\n            }\n            mPlayingState = STOPPED;\n            mRunning = true;\n            notifyStartListeners();\n        }\n        animationHandler.start();\n    }\n```\n\n* 先初始化一些值\n* updateScaledDuration 缩放时间，默认为1.0f\n* 获取或者创建AnimationHandler，将动画加入到mPendingAnimations列表中，\n* 如果没延迟，通知监听器\n* animationHandler.start\n\n\n\n在animationHandler.start中，会调用scheduleAnimation方法，在这个种，会用mChoreographerpost一个callback，最终会执行mAnimate的run方法。mChoreographerpost涉及到VSYNC，这里不多介绍。\n\n### mAnimate#run\n\n```\ndoAnimationFrame(mChoreographer.getFrameTime());\n```\n\n在这里会用过doAnimationFrame设置动画帧，我们看下这个方法的代码。\n\n```\n        void doAnimationFrame(long frameTime) {\n            mLastFrameTime = frameTime;\n\n            // mPendingAnimations holds any animations that have requested to be started\n            // We're going to clear mPendingAnimations, but starting animation may\n            // cause more to be added to the pending list (for example, if one animation\n            // starting triggers another starting). So we loop until mPendingAnimations\n            // is empty.\n            while (mPendingAnimations.size() > 0) {\n                ArrayList<ValueAnimator> pendingCopy =\n                        (ArrayList<ValueAnimator>) mPendingAnimations.clone();\n                mPendingAnimations.clear();\n                int count = pendingCopy.size();\n                for (int i = 0; i < count; ++i) {\n                    ValueAnimator anim = pendingCopy.get(i);\n                    // If the animation has a startDelay, place it on the delayed list\n                    if (anim.mStartDelay == 0) {\n                        anim.startAnimation(this);\n                    } else {\n                        mDelayedAnims.add(anim);\n                    }\n                }\n            }\n\n            // Next, process animations currently sitting on the delayed queue, adding\n            // them to the active animations if they are ready\n            int numDelayedAnims = mDelayedAnims.size();\n            for (int i = 0; i < numDelayedAnims; ++i) {\n                ValueAnimator anim = mDelayedAnims.get(i);\n                if (anim.delayedAnimationFrame(frameTime)) {\n                    mReadyAnims.add(anim);\n                }\n            }\n            int numReadyAnims = mReadyAnims.size();\n            if (numReadyAnims > 0) {\n                for (int i = 0; i < numReadyAnims; ++i) {\n                    ValueAnimator anim = mReadyAnims.get(i);\n                    anim.startAnimation(this);\n                    anim.mRunning = true;\n                    mDelayedAnims.remove(anim);\n                }\n                mReadyAnims.clear();\n            }\n\n            // Now process all active animations. The return value from animationFrame()\n            // tells the handler whether it should now be ended\n            int numAnims = mAnimations.size();\n            for (int i = 0; i < numAnims; ++i) {\n                mTmpAnimations.add(mAnimations.get(i));\n            }\n            for (int i = 0; i < numAnims; ++i) {\n                ValueAnimator anim = mTmpAnimations.get(i);\n                if (mAnimations.contains(anim) && anim.doAnimationFrame(frameTime)) {\n                    mEndingAnims.add(anim);\n                }\n            }\n            mTmpAnimations.clear();\n            if (mEndingAnims.size() > 0) {\n                for (int i = 0; i < mEndingAnims.size(); ++i) {\n                    mEndingAnims.get(i).endAnimation(this);\n                }\n                mEndingAnims.clear();\n            }\n\n            // Schedule final commit for the frame.\n            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, mCommit, null);\n\n            // If there are still active or delayed animations, schedule a future call to\n            // onAnimate to process the next frame of the animations.\n            if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) {\n                scheduleAnimation();\n            }\n        }\n```\n\n方法较长，逻辑如下：\n\n* 从mPendingAnimations中取出动画，根据事先选择startAnimation还是加入到mDelayedAnims列表。\n* 如果mDelayedAnims列表中的动画准备好了，就加入到mReadyAnims列表中\n* 从mAnimations列表中取出要执行的动画，加入到mTmpAnimations列表\n* 通过doAnimationFrame方法执行动画帧\n* 继续执行scheduleAnimation\n\n从上面我们能看出，执行动画的关键是doAnimationFrame方法。在这个方法中，会调用animationFrame方法。\n\n### ValueAniator#animationFrame\n\n```\n   boolean animationFrame(long currentTime) {\n        boolean done = false;\n        switch (mPlayingState) {\n        case RUNNING:\n        case SEEKED:\n            float fraction = mDuration > 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;\n            if (mDuration == 0 && mRepeatCount != INFINITE) {\n                // Skip to the end\n                mCurrentIteration = mRepeatCount;\n                if (!mReversing) {\n                    mPlayingBackwards = false;\n                }\n            }\n            if (fraction >= 1f) {\n                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {\n                    // Time to repeat\n                    if (mListeners != null) {\n                        int numListeners = mListeners.size();\n                        for (int i = 0; i < numListeners; ++i) {\n                            mListeners.get(i).onAnimationRepeat(this);\n                        }\n                    }\n                    if (mRepeatMode == REVERSE) {\n                        mPlayingBackwards = !mPlayingBackwards;\n                    }\n                    mCurrentIteration += (int) fraction;\n                    fraction = fraction % 1f;\n                    mStartTime += mDuration;\n                    // Note: We do not need to update the value of mStartTimeCommitted here\n                    // since we just added a duration offset.\n                } else {\n                    done = true;\n                    fraction = Math.min(fraction, 1.0f);\n                }\n            }\n            if (mPlayingBackwards) {\n                fraction = 1f - fraction;\n            }\n            animateValue(fraction);\n            break;\n        }\n\n        return done;\n    }\n```\n\n* 计算fraction\n* 调用animateValue方法\n\n<span style=\"color:red\">根据虚拟机执行引擎动态分派原则，这里会调用ObjectAnimator的animateValue方法。<span>\n\n### ObjectAnimator#animateValue\n\n\n```\n    void animateValue(float fraction) {\n        final Object target = getTarget();\n        if (mTarget != null && target == null) {\n            // We lost the target reference, cancel and clean up.\n            cancel();\n            return;\n        }\n\n        super.animateValue(fraction);\n        int numValues = mValues.length;\n        for (int i = 0; i < numValues; ++i) {\n            mValues[i].setAnimatedValue(target);\n        }\n    }\n\n```\n\n这里主要干了两件事，\n\n* 调用父类的animateValue方法\n* 通过setAnimatedValue设置属性\n\n其父类的方法如下：\n\n```\n    void animateValue(float fraction) {\n        fraction = mInterpolator.getInterpolation(fraction);\n        mCurrentFraction = fraction;\n        int numValues = mValues.length;\n        for (int i = 0; i < numValues; ++i) {\n            mValues[i].calculateValue(fraction);\n        }\n        if (mUpdateListeners != null) {\n            int numListeners = mUpdateListeners.size();\n            for (int i = 0; i < numListeners; ++i) {\n                mUpdateListeners.get(i).onAnimationUpdate(this);\n            }\n        }\n    }\n```\n\n在这个方法中，会通过Interpolator得到出当前的fraction，并通过calculateValue来计算当前应该的值，这里会调用IntPropertyValuesHolder的calculateValue\n\n```\n        void calculateValue(float fraction) {\n            mIntAnimatedValue = mIntKeyframes.getIntValue(fraction);\n        }\n```\n\n我们知道，mIntKeyframes对应的是IntKeyframeSet。在这个类的getIntValue中，会通过TypeEvaluator来计算当前对应的值。不多说了。\n\n最后，回到animateValue。计算了值之后，会调用setAnimatedValue来设置值。我们看看他的实现。\n\n### IntPropertyValuesHolder#setAnimatedValue\n\n```\n        void setAnimatedValue(Object target) {\n            if (mIntProperty != null) {\n                mIntProperty.setValue(target, mIntAnimatedValue);\n                return;\n            }\n            if (mProperty != null) {\n                mProperty.set(target, mIntAnimatedValue);\n                return;\n            }\n            if (mJniSetter != 0) {\n                nCallIntMethod(target, mJniSetter, mIntAnimatedValue);\n                return;\n            }\n            if (mSetter != null) {\n                try {\n                    mTmpValueArray[0] = mIntAnimatedValue;\n                    mSetter.invoke(target, mTmpValueArray);\n                } catch (InvocationTargetException e) {\n                    Log.e(\"PropertyValuesHolder\", e.toString());\n                } catch (IllegalAccessException e) {\n                    Log.e(\"PropertyValuesHolder\", e.toString());\n                }\n            }\n        }\n```\n\n恩，到这里就能看到修改属性值得痕迹了，有以下四种情况\n\n* mIntProperty不为null\n* mProperty不为null\n* mJniSetter不为null\n* mSetter不为null\n\n首先，我们通过String propertyName, int... values参数构造的对象，mIntProperty为null，并且mProperty也为null。那其他两个是怎么来的呢？似乎漏了什么？\n\n还节的，在doAnimationFrame中，直接调用startAnimation么?没错，就是这里。\n\n### startAnimation\n\n在这个方法中调用了initAnimation方法。还是根据动态分派规则，这里调用ObjectAnimator的initAnimation方法。在这里调用PropertyValuesHolder的setupSetterAndGetter方法，在这里对mSetter等进行了初始化，这里就不多说了，大家自己看代码吧。\n\n\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Android属性动画源码浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxc000l19fykwjch8gf","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>日常开发离不开动画，属性动画更为强大，我们不仅要知道如何使用，更要知道他的原理。这样，才能得心应手。那么，今天，就从最简单的来说，了解下属性动画的原理。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ObjectAnimator</div><div class=\"line\">        .ofInt(mView,&quot;width&quot;,100,500)</div><div class=\"line\">        .setDuration(1000)</div><div class=\"line\">        .start();</div></pre></td></tr></table></figure>\n<h3 id=\"ObjectAnimator-ofInt\"><a href=\"#ObjectAnimator-ofInt\" class=\"headerlink\" title=\"ObjectAnimator#ofInt\"></a>ObjectAnimator#ofInt</h3><p>以这个为例，代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ObjectAnimator ofInt(Object target, String propertyName, int... values) &#123;</div><div class=\"line\">    ObjectAnimator anim = new ObjectAnimator(target, propertyName);</div><div class=\"line\">    anim.setIntValues(values);</div><div class=\"line\">    return anim;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，首先会new一个ObjectAnimator对象，然后通过setIntValues方法将值设置进去，然后返回。在ObjectAnimator的构造方法中，会通过setTarget方法设置当前动画的对象，通过setPropertyName设置当前的属性名。我们重点说下setIntValues方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setIntValues(int... values) &#123;</div><div class=\"line\">    if (mValues == null || mValues.length == 0) &#123;</div><div class=\"line\">        // No values yet - this animator is being constructed piecemeal. Init the values with</div><div class=\"line\">        // whatever the current propertyName is</div><div class=\"line\">        if (mProperty != null) &#123;</div><div class=\"line\">            setValues(PropertyValuesHolder.ofInt(mProperty, values));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            setValues(PropertyValuesHolder.ofInt(mPropertyName, values));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        super.setIntValues(values);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先会判断，mValues是不是null，我们这里是null，并且mProperty也是null，所以会调用<br>setValues(PropertyValuesHolder.ofInt(mPropertyName, values));方法。先看PropertyValuesHolder.ofInt方法，PropertyValuesHolder这个类是holds属性和值的，在这个方法会构造一个IntPropertyValuesHolder对象并返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static PropertyValuesHolder ofInt(String propertyName, int... values) &#123;</div><div class=\"line\">    return new IntPropertyValuesHolder(propertyName, values);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>IntPropertyValuesHolder的构造方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public IntPropertyValuesHolder(String propertyName, int... values) &#123;</div><div class=\"line\">    super(propertyName);</div><div class=\"line\">    setIntValues(values);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，首先会调用他的分类的构造方法，然后调用setIntValues方法，在他父类的构造方法中，只是设置了下propertyName。setIntValues内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setIntValues(int... values) &#123;</div><div class=\"line\">    super.setIntValues(values);</div><div class=\"line\">    mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在父类的setIntValues方法中，初始化了mValueType为int.class，mKeyframes为KeyframeSet.ofInt(values)。其中KeyframeSet为关键帧集合。然后将mKeyframes赋值给mIntKeyframes。</p>\n<h4 id=\"KeyframeSet\"><a href=\"#KeyframeSet\" class=\"headerlink\" title=\"KeyframeSet\"></a>KeyframeSet</h4><p>这个类是记录关键帧的。我们看下他的ofInt方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static KeyframeSet ofInt(int... values) &#123;</div><div class=\"line\">    int numKeyframes = values.length;</div><div class=\"line\">    IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes,2)];</div><div class=\"line\">    if (numKeyframes == 1) &#123;</div><div class=\"line\">        keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f);</div><div class=\"line\">        keyframes[1] = (IntKeyframe) Keyframe.ofInt(1f, values[0]);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f, values[0]);</div><div class=\"line\">        for (int i = 1; i &lt; numKeyframes; ++i) &#123;</div><div class=\"line\">            keyframes[i] =</div><div class=\"line\">                    (IntKeyframe) Keyframe.ofInt((float) i / (numKeyframes - 1), values[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return new IntKeyframeSet(keyframes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里呢？根据传入的values来计算关键帧，最后返回IntKeyframeSet。</p>\n<p>回到ObjectAnimator里面，这里的setValues用的是父类ValueAnimator的</p>\n<h4 id=\"ValueAnimator-setValues\"><a href=\"#ValueAnimator-setValues\" class=\"headerlink\" title=\"ValueAnimator#setValues\"></a>ValueAnimator#setValues</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setValues(PropertyValuesHolder... values) &#123;</div><div class=\"line\">    int numValues = values.length;</div><div class=\"line\">    mValues = values;</div><div class=\"line\">    mValuesMap = new HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</div><div class=\"line\">    for (int i = 0; i &lt; numValues; ++i) &#123;</div><div class=\"line\">        PropertyValuesHolder valuesHolder = values[i];</div><div class=\"line\">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // New property/values/target should cause re-initialization prior to starting</div><div class=\"line\">    mInitialized = false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的操作就简单了，就是把PropertyValuesHolder放入到mValuesMap中。</p>\n<h3 id=\"ObjectAnimator-start\"><a href=\"#ObjectAnimator-start\" class=\"headerlink\" title=\"ObjectAnimator#start\"></a>ObjectAnimator#start</h3><p>这个方法就是动画开始的地方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void start() &#123;</div><div class=\"line\">    // See if any of the current active/pending animators need to be canceled</div><div class=\"line\">    AnimationHandler handler = sAnimationHandler.get();</div><div class=\"line\">    if (handler != null) &#123;</div><div class=\"line\">        int numAnims = handler.mAnimations.size();</div><div class=\"line\">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">            if (handler.mAnimations.get(i) instanceof ObjectAnimator) &#123;</div><div class=\"line\">                ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i);</div><div class=\"line\">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class=\"line\">                    anim.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        numAnims = handler.mPendingAnimations.size();</div><div class=\"line\">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">            if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) &#123;</div><div class=\"line\">                ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i);</div><div class=\"line\">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class=\"line\">                    anim.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        numAnims = handler.mDelayedAnims.size();</div><div class=\"line\">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">            if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) &#123;</div><div class=\"line\">                ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i);</div><div class=\"line\">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class=\"line\">                    anim.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (DBG) &#123;</div><div class=\"line\">        Log.d(LOG_TAG, &quot;Anim target, duration: &quot; + getTarget() + &quot;, &quot; + getDuration());</div><div class=\"line\">        for (int i = 0; i &lt; mValues.length; ++i) &#123;</div><div class=\"line\">            PropertyValuesHolder pvh = mValues[i];</div><div class=\"line\">            Log.d(LOG_TAG, &quot;   Values[&quot; + i + &quot;]: &quot; +</div><div class=\"line\">                pvh.getPropertyName() + &quot;, &quot; + pvh.mKeyframes.getValue(0) + &quot;, &quot; +</div><div class=\"line\">                pvh.mKeyframes.getValue(1));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    super.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先呢，会获取AnimationHandler对象，如果不为空的话，就会判断是mAnimations、mPendingAnimations、mDelayedAnims中的动画，并且取消。最后调用父类的start方法。</p>\n<h3 id=\"ValueAnimator-start\"><a href=\"#ValueAnimator-start\" class=\"headerlink\" title=\"ValueAnimator#start\"></a>ValueAnimator#start</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void start(boolean playBackwards) &#123;</div><div class=\"line\">    if (Looper.myLooper() == null) &#123;</div><div class=\"line\">        throw new AndroidRuntimeException(&quot;Animators may only be run on Looper threads&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    mReversing = playBackwards;</div><div class=\"line\">    mPlayingBackwards = playBackwards;</div><div class=\"line\">    if (playBackwards &amp;&amp; mSeekFraction != -1) &#123;</div><div class=\"line\">        if (mSeekFraction == 0 &amp;&amp; mCurrentIteration == 0) &#123;</div><div class=\"line\">            // special case: reversing from seek-to-0 should act as if not seeked at all</div><div class=\"line\">            mSeekFraction = 0;</div><div class=\"line\">        &#125; else if (mRepeatCount == INFINITE) &#123;</div><div class=\"line\">            mSeekFraction = 1 - (mSeekFraction % 1);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mSeekFraction = 1 + mRepeatCount - (mCurrentIteration + mSeekFraction);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mCurrentIteration = (int) mSeekFraction;</div><div class=\"line\">        mSeekFraction = mSeekFraction % 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mCurrentIteration &gt; 0 &amp;&amp; mRepeatMode == REVERSE &amp;&amp;</div><div class=\"line\">            (mCurrentIteration &lt; (mRepeatCount + 1) || mRepeatCount == INFINITE)) &#123;</div><div class=\"line\">        // if we were seeked to some other iteration in a reversing animator,</div><div class=\"line\">        // figure out the correct direction to start playing based on the iteration</div><div class=\"line\">        if (playBackwards) &#123;</div><div class=\"line\">            mPlayingBackwards = (mCurrentIteration % 2) == 0;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mPlayingBackwards = (mCurrentIteration % 2) != 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int prevPlayingState = mPlayingState;</div><div class=\"line\">    mPlayingState = STOPPED;</div><div class=\"line\">    mStarted = true;</div><div class=\"line\">    mStartedDelay = false;</div><div class=\"line\">    mPaused = false;</div><div class=\"line\">    updateScaledDuration(); // in case the scale factor has changed since creation time</div><div class=\"line\">    AnimationHandler animationHandler = getOrCreateAnimationHandler();</div><div class=\"line\">    animationHandler.mPendingAnimations.add(this);</div><div class=\"line\">    if (mStartDelay == 0) &#123;</div><div class=\"line\">        // This sets the initial value of the animation, prior to actually starting it running</div><div class=\"line\">        if (prevPlayingState != SEEKED) &#123;</div><div class=\"line\">            setCurrentPlayTime(0);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mPlayingState = STOPPED;</div><div class=\"line\">        mRunning = true;</div><div class=\"line\">        notifyStartListeners();</div><div class=\"line\">    &#125;</div><div class=\"line\">    animationHandler.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先初始化一些值</li>\n<li>updateScaledDuration 缩放时间，默认为1.0f</li>\n<li>获取或者创建AnimationHandler，将动画加入到mPendingAnimations列表中，</li>\n<li>如果没延迟，通知监听器</li>\n<li>animationHandler.start</li>\n</ul>\n<p>在animationHandler.start中，会调用scheduleAnimation方法，在这个种，会用mChoreographerpost一个callback，最终会执行mAnimate的run方法。mChoreographerpost涉及到VSYNC，这里不多介绍。</p>\n<h3 id=\"mAnimate-run\"><a href=\"#mAnimate-run\" class=\"headerlink\" title=\"mAnimate#run\"></a>mAnimate#run</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">doAnimationFrame(mChoreographer.getFrameTime());</div></pre></td></tr></table></figure>\n<p>在这里会用过doAnimationFrame设置动画帧，我们看下这个方法的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">void doAnimationFrame(long frameTime) &#123;</div><div class=\"line\">    mLastFrameTime = frameTime;</div><div class=\"line\"></div><div class=\"line\">    // mPendingAnimations holds any animations that have requested to be started</div><div class=\"line\">    // We&apos;re going to clear mPendingAnimations, but starting animation may</div><div class=\"line\">    // cause more to be added to the pending list (for example, if one animation</div><div class=\"line\">    // starting triggers another starting). So we loop until mPendingAnimations</div><div class=\"line\">    // is empty.</div><div class=\"line\">    while (mPendingAnimations.size() &gt; 0) &#123;</div><div class=\"line\">        ArrayList&lt;ValueAnimator&gt; pendingCopy =</div><div class=\"line\">                (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone();</div><div class=\"line\">        mPendingAnimations.clear();</div><div class=\"line\">        int count = pendingCopy.size();</div><div class=\"line\">        for (int i = 0; i &lt; count; ++i) &#123;</div><div class=\"line\">            ValueAnimator anim = pendingCopy.get(i);</div><div class=\"line\">            // If the animation has a startDelay, place it on the delayed list</div><div class=\"line\">            if (anim.mStartDelay == 0) &#123;</div><div class=\"line\">                anim.startAnimation(this);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                mDelayedAnims.add(anim);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Next, process animations currently sitting on the delayed queue, adding</div><div class=\"line\">    // them to the active animations if they are ready</div><div class=\"line\">    int numDelayedAnims = mDelayedAnims.size();</div><div class=\"line\">    for (int i = 0; i &lt; numDelayedAnims; ++i) &#123;</div><div class=\"line\">        ValueAnimator anim = mDelayedAnims.get(i);</div><div class=\"line\">        if (anim.delayedAnimationFrame(frameTime)) &#123;</div><div class=\"line\">            mReadyAnims.add(anim);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int numReadyAnims = mReadyAnims.size();</div><div class=\"line\">    if (numReadyAnims &gt; 0) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; numReadyAnims; ++i) &#123;</div><div class=\"line\">            ValueAnimator anim = mReadyAnims.get(i);</div><div class=\"line\">            anim.startAnimation(this);</div><div class=\"line\">            anim.mRunning = true;</div><div class=\"line\">            mDelayedAnims.remove(anim);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mReadyAnims.clear();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Now process all active animations. The return value from animationFrame()</div><div class=\"line\">    // tells the handler whether it should now be ended</div><div class=\"line\">    int numAnims = mAnimations.size();</div><div class=\"line\">    for (int i = 0; i &lt; numAnims; ++i) &#123;</div><div class=\"line\">        mTmpAnimations.add(mAnimations.get(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (int i = 0; i &lt; numAnims; ++i) &#123;</div><div class=\"line\">        ValueAnimator anim = mTmpAnimations.get(i);</div><div class=\"line\">        if (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</div><div class=\"line\">            mEndingAnims.add(anim);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mTmpAnimations.clear();</div><div class=\"line\">    if (mEndingAnims.size() &gt; 0) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; mEndingAnims.size(); ++i) &#123;</div><div class=\"line\">            mEndingAnims.get(i).endAnimation(this);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mEndingAnims.clear();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Schedule final commit for the frame.</div><div class=\"line\">    mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, mCommit, null);</div><div class=\"line\"></div><div class=\"line\">    // If there are still active or delayed animations, schedule a future call to</div><div class=\"line\">    // onAnimate to process the next frame of the animations.</div><div class=\"line\">    if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</div><div class=\"line\">        scheduleAnimation();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法较长，逻辑如下：</p>\n<ul>\n<li>从mPendingAnimations中取出动画，根据事先选择startAnimation还是加入到mDelayedAnims列表。</li>\n<li>如果mDelayedAnims列表中的动画准备好了，就加入到mReadyAnims列表中</li>\n<li>从mAnimations列表中取出要执行的动画，加入到mTmpAnimations列表</li>\n<li>通过doAnimationFrame方法执行动画帧</li>\n<li>继续执行scheduleAnimation</li>\n</ul>\n<p>从上面我们能看出，执行动画的关键是doAnimationFrame方法。在这个方法中，会调用animationFrame方法。</p>\n<h3 id=\"ValueAniator-animationFrame\"><a href=\"#ValueAniator-animationFrame\" class=\"headerlink\" title=\"ValueAniator#animationFrame\"></a>ValueAniator#animationFrame</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean animationFrame(long currentTime) &#123;</div><div class=\"line\">     boolean done = false;</div><div class=\"line\">     switch (mPlayingState) &#123;</div><div class=\"line\">     case RUNNING:</div><div class=\"line\">     case SEEKED:</div><div class=\"line\">         float fraction = mDuration &gt; 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;</div><div class=\"line\">         if (mDuration == 0 &amp;&amp; mRepeatCount != INFINITE) &#123;</div><div class=\"line\">             // Skip to the end</div><div class=\"line\">             mCurrentIteration = mRepeatCount;</div><div class=\"line\">             if (!mReversing) &#123;</div><div class=\"line\">                 mPlayingBackwards = false;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">         if (fraction &gt;= 1f) &#123;</div><div class=\"line\">             if (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</div><div class=\"line\">                 // Time to repeat</div><div class=\"line\">                 if (mListeners != null) &#123;</div><div class=\"line\">                     int numListeners = mListeners.size();</div><div class=\"line\">                     for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class=\"line\">                         mListeners.get(i).onAnimationRepeat(this);</div><div class=\"line\">                     &#125;</div><div class=\"line\">                 &#125;</div><div class=\"line\">                 if (mRepeatMode == REVERSE) &#123;</div><div class=\"line\">                     mPlayingBackwards = !mPlayingBackwards;</div><div class=\"line\">                 &#125;</div><div class=\"line\">                 mCurrentIteration += (int) fraction;</div><div class=\"line\">                 fraction = fraction % 1f;</div><div class=\"line\">                 mStartTime += mDuration;</div><div class=\"line\">                 // Note: We do not need to update the value of mStartTimeCommitted here</div><div class=\"line\">                 // since we just added a duration offset.</div><div class=\"line\">             &#125; else &#123;</div><div class=\"line\">                 done = true;</div><div class=\"line\">                 fraction = Math.min(fraction, 1.0f);</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">         if (mPlayingBackwards) &#123;</div><div class=\"line\">             fraction = 1f - fraction;</div><div class=\"line\">         &#125;</div><div class=\"line\">         animateValue(fraction);</div><div class=\"line\">         break;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     return done;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>计算fraction</li>\n<li>调用animateValue方法</li>\n</ul>\n<p><span style=\"color:red\">根据虚拟机执行引擎动态分派原则，这里会调用ObjectAnimator的animateValue方法。<span></span></span></p>\n<h3 id=\"ObjectAnimator-animateValue\"><a href=\"#ObjectAnimator-animateValue\" class=\"headerlink\" title=\"ObjectAnimator#animateValue\"></a>ObjectAnimator#animateValue</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">void animateValue(float fraction) &#123;</div><div class=\"line\">    final Object target = getTarget();</div><div class=\"line\">    if (mTarget != null &amp;&amp; target == null) &#123;</div><div class=\"line\">        // We lost the target reference, cancel and clean up.</div><div class=\"line\">        cancel();</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    super.animateValue(fraction);</div><div class=\"line\">    int numValues = mValues.length;</div><div class=\"line\">    for (int i = 0; i &lt; numValues; ++i) &#123;</div><div class=\"line\">        mValues[i].setAnimatedValue(target);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里主要干了两件事，</p>\n<ul>\n<li>调用父类的animateValue方法</li>\n<li>通过setAnimatedValue设置属性</li>\n</ul>\n<p>其父类的方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">void animateValue(float fraction) &#123;</div><div class=\"line\">    fraction = mInterpolator.getInterpolation(fraction);</div><div class=\"line\">    mCurrentFraction = fraction;</div><div class=\"line\">    int numValues = mValues.length;</div><div class=\"line\">    for (int i = 0; i &lt; numValues; ++i) &#123;</div><div class=\"line\">        mValues[i].calculateValue(fraction);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mUpdateListeners != null) &#123;</div><div class=\"line\">        int numListeners = mUpdateListeners.size();</div><div class=\"line\">        for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class=\"line\">            mUpdateListeners.get(i).onAnimationUpdate(this);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，会通过Interpolator得到出当前的fraction，并通过calculateValue来计算当前应该的值，这里会调用IntPropertyValuesHolder的calculateValue</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">void calculateValue(float fraction) &#123;</div><div class=\"line\">    mIntAnimatedValue = mIntKeyframes.getIntValue(fraction);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们知道，mIntKeyframes对应的是IntKeyframeSet。在这个类的getIntValue中，会通过TypeEvaluator来计算当前对应的值。不多说了。</p>\n<p>最后，回到animateValue。计算了值之后，会调用setAnimatedValue来设置值。我们看看他的实现。</p>\n<h3 id=\"IntPropertyValuesHolder-setAnimatedValue\"><a href=\"#IntPropertyValuesHolder-setAnimatedValue\" class=\"headerlink\" title=\"IntPropertyValuesHolder#setAnimatedValue\"></a>IntPropertyValuesHolder#setAnimatedValue</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">void setAnimatedValue(Object target) &#123;</div><div class=\"line\">    if (mIntProperty != null) &#123;</div><div class=\"line\">        mIntProperty.setValue(target, mIntAnimatedValue);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mProperty != null) &#123;</div><div class=\"line\">        mProperty.set(target, mIntAnimatedValue);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mJniSetter != 0) &#123;</div><div class=\"line\">        nCallIntMethod(target, mJniSetter, mIntAnimatedValue);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mSetter != null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            mTmpValueArray[0] = mIntAnimatedValue;</div><div class=\"line\">            mSetter.invoke(target, mTmpValueArray);</div><div class=\"line\">        &#125; catch (InvocationTargetException e) &#123;</div><div class=\"line\">            Log.e(&quot;PropertyValuesHolder&quot;, e.toString());</div><div class=\"line\">        &#125; catch (IllegalAccessException e) &#123;</div><div class=\"line\">            Log.e(&quot;PropertyValuesHolder&quot;, e.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>恩，到这里就能看到修改属性值得痕迹了，有以下四种情况</p>\n<ul>\n<li>mIntProperty不为null</li>\n<li>mProperty不为null</li>\n<li>mJniSetter不为null</li>\n<li>mSetter不为null</li>\n</ul>\n<p>首先，我们通过String propertyName, int… values参数构造的对象，mIntProperty为null，并且mProperty也为null。那其他两个是怎么来的呢？似乎漏了什么？</p>\n<p>还节的，在doAnimationFrame中，直接调用startAnimation么?没错，就是这里。</p>\n<h3 id=\"startAnimation\"><a href=\"#startAnimation\" class=\"headerlink\" title=\"startAnimation\"></a>startAnimation</h3><p>在这个方法中调用了initAnimation方法。还是根据动态分派规则，这里调用ObjectAnimator的initAnimation方法。在这里调用PropertyValuesHolder的setupSetterAndGetter方法，在这里对mSetter等进行了初始化，这里就不多说了，大家自己看代码吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>日常开发离不开动画，属性动画更为强大，我们不仅要知道如何使用，更要知道他的原理。这样，才能得心应手。那么，今天，就从最简单的来说，了解下属性动画的原理。</p>","more":"<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ObjectAnimator</div><div class=\"line\">        .ofInt(mView,&quot;width&quot;,100,500)</div><div class=\"line\">        .setDuration(1000)</div><div class=\"line\">        .start();</div></pre></td></tr></table></figure>\n<h3 id=\"ObjectAnimator-ofInt\"><a href=\"#ObjectAnimator-ofInt\" class=\"headerlink\" title=\"ObjectAnimator#ofInt\"></a>ObjectAnimator#ofInt</h3><p>以这个为例，代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ObjectAnimator ofInt(Object target, String propertyName, int... values) &#123;</div><div class=\"line\">    ObjectAnimator anim = new ObjectAnimator(target, propertyName);</div><div class=\"line\">    anim.setIntValues(values);</div><div class=\"line\">    return anim;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，首先会new一个ObjectAnimator对象，然后通过setIntValues方法将值设置进去，然后返回。在ObjectAnimator的构造方法中，会通过setTarget方法设置当前动画的对象，通过setPropertyName设置当前的属性名。我们重点说下setIntValues方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setIntValues(int... values) &#123;</div><div class=\"line\">    if (mValues == null || mValues.length == 0) &#123;</div><div class=\"line\">        // No values yet - this animator is being constructed piecemeal. Init the values with</div><div class=\"line\">        // whatever the current propertyName is</div><div class=\"line\">        if (mProperty != null) &#123;</div><div class=\"line\">            setValues(PropertyValuesHolder.ofInt(mProperty, values));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            setValues(PropertyValuesHolder.ofInt(mPropertyName, values));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        super.setIntValues(values);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先会判断，mValues是不是null，我们这里是null，并且mProperty也是null，所以会调用<br>setValues(PropertyValuesHolder.ofInt(mPropertyName, values));方法。先看PropertyValuesHolder.ofInt方法，PropertyValuesHolder这个类是holds属性和值的，在这个方法会构造一个IntPropertyValuesHolder对象并返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static PropertyValuesHolder ofInt(String propertyName, int... values) &#123;</div><div class=\"line\">    return new IntPropertyValuesHolder(propertyName, values);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>IntPropertyValuesHolder的构造方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public IntPropertyValuesHolder(String propertyName, int... values) &#123;</div><div class=\"line\">    super(propertyName);</div><div class=\"line\">    setIntValues(values);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，首先会调用他的分类的构造方法，然后调用setIntValues方法，在他父类的构造方法中，只是设置了下propertyName。setIntValues内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setIntValues(int... values) &#123;</div><div class=\"line\">    super.setIntValues(values);</div><div class=\"line\">    mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在父类的setIntValues方法中，初始化了mValueType为int.class，mKeyframes为KeyframeSet.ofInt(values)。其中KeyframeSet为关键帧集合。然后将mKeyframes赋值给mIntKeyframes。</p>\n<h4 id=\"KeyframeSet\"><a href=\"#KeyframeSet\" class=\"headerlink\" title=\"KeyframeSet\"></a>KeyframeSet</h4><p>这个类是记录关键帧的。我们看下他的ofInt方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static KeyframeSet ofInt(int... values) &#123;</div><div class=\"line\">    int numKeyframes = values.length;</div><div class=\"line\">    IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes,2)];</div><div class=\"line\">    if (numKeyframes == 1) &#123;</div><div class=\"line\">        keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f);</div><div class=\"line\">        keyframes[1] = (IntKeyframe) Keyframe.ofInt(1f, values[0]);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f, values[0]);</div><div class=\"line\">        for (int i = 1; i &lt; numKeyframes; ++i) &#123;</div><div class=\"line\">            keyframes[i] =</div><div class=\"line\">                    (IntKeyframe) Keyframe.ofInt((float) i / (numKeyframes - 1), values[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return new IntKeyframeSet(keyframes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里呢？根据传入的values来计算关键帧，最后返回IntKeyframeSet。</p>\n<p>回到ObjectAnimator里面，这里的setValues用的是父类ValueAnimator的</p>\n<h4 id=\"ValueAnimator-setValues\"><a href=\"#ValueAnimator-setValues\" class=\"headerlink\" title=\"ValueAnimator#setValues\"></a>ValueAnimator#setValues</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setValues(PropertyValuesHolder... values) &#123;</div><div class=\"line\">    int numValues = values.length;</div><div class=\"line\">    mValues = values;</div><div class=\"line\">    mValuesMap = new HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</div><div class=\"line\">    for (int i = 0; i &lt; numValues; ++i) &#123;</div><div class=\"line\">        PropertyValuesHolder valuesHolder = values[i];</div><div class=\"line\">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // New property/values/target should cause re-initialization prior to starting</div><div class=\"line\">    mInitialized = false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的操作就简单了，就是把PropertyValuesHolder放入到mValuesMap中。</p>\n<h3 id=\"ObjectAnimator-start\"><a href=\"#ObjectAnimator-start\" class=\"headerlink\" title=\"ObjectAnimator#start\"></a>ObjectAnimator#start</h3><p>这个方法就是动画开始的地方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void start() &#123;</div><div class=\"line\">    // See if any of the current active/pending animators need to be canceled</div><div class=\"line\">    AnimationHandler handler = sAnimationHandler.get();</div><div class=\"line\">    if (handler != null) &#123;</div><div class=\"line\">        int numAnims = handler.mAnimations.size();</div><div class=\"line\">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">            if (handler.mAnimations.get(i) instanceof ObjectAnimator) &#123;</div><div class=\"line\">                ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i);</div><div class=\"line\">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class=\"line\">                    anim.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        numAnims = handler.mPendingAnimations.size();</div><div class=\"line\">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">            if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) &#123;</div><div class=\"line\">                ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i);</div><div class=\"line\">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class=\"line\">                    anim.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        numAnims = handler.mDelayedAnims.size();</div><div class=\"line\">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">            if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) &#123;</div><div class=\"line\">                ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i);</div><div class=\"line\">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class=\"line\">                    anim.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (DBG) &#123;</div><div class=\"line\">        Log.d(LOG_TAG, &quot;Anim target, duration: &quot; + getTarget() + &quot;, &quot; + getDuration());</div><div class=\"line\">        for (int i = 0; i &lt; mValues.length; ++i) &#123;</div><div class=\"line\">            PropertyValuesHolder pvh = mValues[i];</div><div class=\"line\">            Log.d(LOG_TAG, &quot;   Values[&quot; + i + &quot;]: &quot; +</div><div class=\"line\">                pvh.getPropertyName() + &quot;, &quot; + pvh.mKeyframes.getValue(0) + &quot;, &quot; +</div><div class=\"line\">                pvh.mKeyframes.getValue(1));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    super.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先呢，会获取AnimationHandler对象，如果不为空的话，就会判断是mAnimations、mPendingAnimations、mDelayedAnims中的动画，并且取消。最后调用父类的start方法。</p>\n<h3 id=\"ValueAnimator-start\"><a href=\"#ValueAnimator-start\" class=\"headerlink\" title=\"ValueAnimator#start\"></a>ValueAnimator#start</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void start(boolean playBackwards) &#123;</div><div class=\"line\">    if (Looper.myLooper() == null) &#123;</div><div class=\"line\">        throw new AndroidRuntimeException(&quot;Animators may only be run on Looper threads&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    mReversing = playBackwards;</div><div class=\"line\">    mPlayingBackwards = playBackwards;</div><div class=\"line\">    if (playBackwards &amp;&amp; mSeekFraction != -1) &#123;</div><div class=\"line\">        if (mSeekFraction == 0 &amp;&amp; mCurrentIteration == 0) &#123;</div><div class=\"line\">            // special case: reversing from seek-to-0 should act as if not seeked at all</div><div class=\"line\">            mSeekFraction = 0;</div><div class=\"line\">        &#125; else if (mRepeatCount == INFINITE) &#123;</div><div class=\"line\">            mSeekFraction = 1 - (mSeekFraction % 1);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mSeekFraction = 1 + mRepeatCount - (mCurrentIteration + mSeekFraction);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mCurrentIteration = (int) mSeekFraction;</div><div class=\"line\">        mSeekFraction = mSeekFraction % 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mCurrentIteration &gt; 0 &amp;&amp; mRepeatMode == REVERSE &amp;&amp;</div><div class=\"line\">            (mCurrentIteration &lt; (mRepeatCount + 1) || mRepeatCount == INFINITE)) &#123;</div><div class=\"line\">        // if we were seeked to some other iteration in a reversing animator,</div><div class=\"line\">        // figure out the correct direction to start playing based on the iteration</div><div class=\"line\">        if (playBackwards) &#123;</div><div class=\"line\">            mPlayingBackwards = (mCurrentIteration % 2) == 0;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mPlayingBackwards = (mCurrentIteration % 2) != 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int prevPlayingState = mPlayingState;</div><div class=\"line\">    mPlayingState = STOPPED;</div><div class=\"line\">    mStarted = true;</div><div class=\"line\">    mStartedDelay = false;</div><div class=\"line\">    mPaused = false;</div><div class=\"line\">    updateScaledDuration(); // in case the scale factor has changed since creation time</div><div class=\"line\">    AnimationHandler animationHandler = getOrCreateAnimationHandler();</div><div class=\"line\">    animationHandler.mPendingAnimations.add(this);</div><div class=\"line\">    if (mStartDelay == 0) &#123;</div><div class=\"line\">        // This sets the initial value of the animation, prior to actually starting it running</div><div class=\"line\">        if (prevPlayingState != SEEKED) &#123;</div><div class=\"line\">            setCurrentPlayTime(0);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mPlayingState = STOPPED;</div><div class=\"line\">        mRunning = true;</div><div class=\"line\">        notifyStartListeners();</div><div class=\"line\">    &#125;</div><div class=\"line\">    animationHandler.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先初始化一些值</li>\n<li>updateScaledDuration 缩放时间，默认为1.0f</li>\n<li>获取或者创建AnimationHandler，将动画加入到mPendingAnimations列表中，</li>\n<li>如果没延迟，通知监听器</li>\n<li>animationHandler.start</li>\n</ul>\n<p>在animationHandler.start中，会调用scheduleAnimation方法，在这个种，会用mChoreographerpost一个callback，最终会执行mAnimate的run方法。mChoreographerpost涉及到VSYNC，这里不多介绍。</p>\n<h3 id=\"mAnimate-run\"><a href=\"#mAnimate-run\" class=\"headerlink\" title=\"mAnimate#run\"></a>mAnimate#run</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">doAnimationFrame(mChoreographer.getFrameTime());</div></pre></td></tr></table></figure>\n<p>在这里会用过doAnimationFrame设置动画帧，我们看下这个方法的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">void doAnimationFrame(long frameTime) &#123;</div><div class=\"line\">    mLastFrameTime = frameTime;</div><div class=\"line\"></div><div class=\"line\">    // mPendingAnimations holds any animations that have requested to be started</div><div class=\"line\">    // We&apos;re going to clear mPendingAnimations, but starting animation may</div><div class=\"line\">    // cause more to be added to the pending list (for example, if one animation</div><div class=\"line\">    // starting triggers another starting). So we loop until mPendingAnimations</div><div class=\"line\">    // is empty.</div><div class=\"line\">    while (mPendingAnimations.size() &gt; 0) &#123;</div><div class=\"line\">        ArrayList&lt;ValueAnimator&gt; pendingCopy =</div><div class=\"line\">                (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone();</div><div class=\"line\">        mPendingAnimations.clear();</div><div class=\"line\">        int count = pendingCopy.size();</div><div class=\"line\">        for (int i = 0; i &lt; count; ++i) &#123;</div><div class=\"line\">            ValueAnimator anim = pendingCopy.get(i);</div><div class=\"line\">            // If the animation has a startDelay, place it on the delayed list</div><div class=\"line\">            if (anim.mStartDelay == 0) &#123;</div><div class=\"line\">                anim.startAnimation(this);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                mDelayedAnims.add(anim);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Next, process animations currently sitting on the delayed queue, adding</div><div class=\"line\">    // them to the active animations if they are ready</div><div class=\"line\">    int numDelayedAnims = mDelayedAnims.size();</div><div class=\"line\">    for (int i = 0; i &lt; numDelayedAnims; ++i) &#123;</div><div class=\"line\">        ValueAnimator anim = mDelayedAnims.get(i);</div><div class=\"line\">        if (anim.delayedAnimationFrame(frameTime)) &#123;</div><div class=\"line\">            mReadyAnims.add(anim);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int numReadyAnims = mReadyAnims.size();</div><div class=\"line\">    if (numReadyAnims &gt; 0) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; numReadyAnims; ++i) &#123;</div><div class=\"line\">            ValueAnimator anim = mReadyAnims.get(i);</div><div class=\"line\">            anim.startAnimation(this);</div><div class=\"line\">            anim.mRunning = true;</div><div class=\"line\">            mDelayedAnims.remove(anim);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mReadyAnims.clear();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Now process all active animations. The return value from animationFrame()</div><div class=\"line\">    // tells the handler whether it should now be ended</div><div class=\"line\">    int numAnims = mAnimations.size();</div><div class=\"line\">    for (int i = 0; i &lt; numAnims; ++i) &#123;</div><div class=\"line\">        mTmpAnimations.add(mAnimations.get(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (int i = 0; i &lt; numAnims; ++i) &#123;</div><div class=\"line\">        ValueAnimator anim = mTmpAnimations.get(i);</div><div class=\"line\">        if (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</div><div class=\"line\">            mEndingAnims.add(anim);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mTmpAnimations.clear();</div><div class=\"line\">    if (mEndingAnims.size() &gt; 0) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; mEndingAnims.size(); ++i) &#123;</div><div class=\"line\">            mEndingAnims.get(i).endAnimation(this);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mEndingAnims.clear();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Schedule final commit for the frame.</div><div class=\"line\">    mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, mCommit, null);</div><div class=\"line\"></div><div class=\"line\">    // If there are still active or delayed animations, schedule a future call to</div><div class=\"line\">    // onAnimate to process the next frame of the animations.</div><div class=\"line\">    if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</div><div class=\"line\">        scheduleAnimation();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法较长，逻辑如下：</p>\n<ul>\n<li>从mPendingAnimations中取出动画，根据事先选择startAnimation还是加入到mDelayedAnims列表。</li>\n<li>如果mDelayedAnims列表中的动画准备好了，就加入到mReadyAnims列表中</li>\n<li>从mAnimations列表中取出要执行的动画，加入到mTmpAnimations列表</li>\n<li>通过doAnimationFrame方法执行动画帧</li>\n<li>继续执行scheduleAnimation</li>\n</ul>\n<p>从上面我们能看出，执行动画的关键是doAnimationFrame方法。在这个方法中，会调用animationFrame方法。</p>\n<h3 id=\"ValueAniator-animationFrame\"><a href=\"#ValueAniator-animationFrame\" class=\"headerlink\" title=\"ValueAniator#animationFrame\"></a>ValueAniator#animationFrame</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean animationFrame(long currentTime) &#123;</div><div class=\"line\">     boolean done = false;</div><div class=\"line\">     switch (mPlayingState) &#123;</div><div class=\"line\">     case RUNNING:</div><div class=\"line\">     case SEEKED:</div><div class=\"line\">         float fraction = mDuration &gt; 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;</div><div class=\"line\">         if (mDuration == 0 &amp;&amp; mRepeatCount != INFINITE) &#123;</div><div class=\"line\">             // Skip to the end</div><div class=\"line\">             mCurrentIteration = mRepeatCount;</div><div class=\"line\">             if (!mReversing) &#123;</div><div class=\"line\">                 mPlayingBackwards = false;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">         if (fraction &gt;= 1f) &#123;</div><div class=\"line\">             if (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</div><div class=\"line\">                 // Time to repeat</div><div class=\"line\">                 if (mListeners != null) &#123;</div><div class=\"line\">                     int numListeners = mListeners.size();</div><div class=\"line\">                     for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class=\"line\">                         mListeners.get(i).onAnimationRepeat(this);</div><div class=\"line\">                     &#125;</div><div class=\"line\">                 &#125;</div><div class=\"line\">                 if (mRepeatMode == REVERSE) &#123;</div><div class=\"line\">                     mPlayingBackwards = !mPlayingBackwards;</div><div class=\"line\">                 &#125;</div><div class=\"line\">                 mCurrentIteration += (int) fraction;</div><div class=\"line\">                 fraction = fraction % 1f;</div><div class=\"line\">                 mStartTime += mDuration;</div><div class=\"line\">                 // Note: We do not need to update the value of mStartTimeCommitted here</div><div class=\"line\">                 // since we just added a duration offset.</div><div class=\"line\">             &#125; else &#123;</div><div class=\"line\">                 done = true;</div><div class=\"line\">                 fraction = Math.min(fraction, 1.0f);</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">         if (mPlayingBackwards) &#123;</div><div class=\"line\">             fraction = 1f - fraction;</div><div class=\"line\">         &#125;</div><div class=\"line\">         animateValue(fraction);</div><div class=\"line\">         break;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     return done;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>计算fraction</li>\n<li>调用animateValue方法</li>\n</ul>\n<p><span style=\"color:red\">根据虚拟机执行引擎动态分派原则，这里会调用ObjectAnimator的animateValue方法。<span></p>\n<h3 id=\"ObjectAnimator-animateValue\"><a href=\"#ObjectAnimator-animateValue\" class=\"headerlink\" title=\"ObjectAnimator#animateValue\"></a>ObjectAnimator#animateValue</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">void animateValue(float fraction) &#123;</div><div class=\"line\">    final Object target = getTarget();</div><div class=\"line\">    if (mTarget != null &amp;&amp; target == null) &#123;</div><div class=\"line\">        // We lost the target reference, cancel and clean up.</div><div class=\"line\">        cancel();</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    super.animateValue(fraction);</div><div class=\"line\">    int numValues = mValues.length;</div><div class=\"line\">    for (int i = 0; i &lt; numValues; ++i) &#123;</div><div class=\"line\">        mValues[i].setAnimatedValue(target);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里主要干了两件事，</p>\n<ul>\n<li>调用父类的animateValue方法</li>\n<li>通过setAnimatedValue设置属性</li>\n</ul>\n<p>其父类的方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">void animateValue(float fraction) &#123;</div><div class=\"line\">    fraction = mInterpolator.getInterpolation(fraction);</div><div class=\"line\">    mCurrentFraction = fraction;</div><div class=\"line\">    int numValues = mValues.length;</div><div class=\"line\">    for (int i = 0; i &lt; numValues; ++i) &#123;</div><div class=\"line\">        mValues[i].calculateValue(fraction);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mUpdateListeners != null) &#123;</div><div class=\"line\">        int numListeners = mUpdateListeners.size();</div><div class=\"line\">        for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class=\"line\">            mUpdateListeners.get(i).onAnimationUpdate(this);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，会通过Interpolator得到出当前的fraction，并通过calculateValue来计算当前应该的值，这里会调用IntPropertyValuesHolder的calculateValue</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">void calculateValue(float fraction) &#123;</div><div class=\"line\">    mIntAnimatedValue = mIntKeyframes.getIntValue(fraction);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们知道，mIntKeyframes对应的是IntKeyframeSet。在这个类的getIntValue中，会通过TypeEvaluator来计算当前对应的值。不多说了。</p>\n<p>最后，回到animateValue。计算了值之后，会调用setAnimatedValue来设置值。我们看看他的实现。</p>\n<h3 id=\"IntPropertyValuesHolder-setAnimatedValue\"><a href=\"#IntPropertyValuesHolder-setAnimatedValue\" class=\"headerlink\" title=\"IntPropertyValuesHolder#setAnimatedValue\"></a>IntPropertyValuesHolder#setAnimatedValue</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">void setAnimatedValue(Object target) &#123;</div><div class=\"line\">    if (mIntProperty != null) &#123;</div><div class=\"line\">        mIntProperty.setValue(target, mIntAnimatedValue);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mProperty != null) &#123;</div><div class=\"line\">        mProperty.set(target, mIntAnimatedValue);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mJniSetter != 0) &#123;</div><div class=\"line\">        nCallIntMethod(target, mJniSetter, mIntAnimatedValue);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mSetter != null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            mTmpValueArray[0] = mIntAnimatedValue;</div><div class=\"line\">            mSetter.invoke(target, mTmpValueArray);</div><div class=\"line\">        &#125; catch (InvocationTargetException e) &#123;</div><div class=\"line\">            Log.e(&quot;PropertyValuesHolder&quot;, e.toString());</div><div class=\"line\">        &#125; catch (IllegalAccessException e) &#123;</div><div class=\"line\">            Log.e(&quot;PropertyValuesHolder&quot;, e.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>恩，到这里就能看到修改属性值得痕迹了，有以下四种情况</p>\n<ul>\n<li>mIntProperty不为null</li>\n<li>mProperty不为null</li>\n<li>mJniSetter不为null</li>\n<li>mSetter不为null</li>\n</ul>\n<p>首先，我们通过String propertyName, int… values参数构造的对象，mIntProperty为null，并且mProperty也为null。那其他两个是怎么来的呢？似乎漏了什么？</p>\n<p>还节的，在doAnimationFrame中，直接调用startAnimation么?没错，就是这里。</p>\n<h3 id=\"startAnimation\"><a href=\"#startAnimation\" class=\"headerlink\" title=\"startAnimation\"></a>startAnimation</h3><p>在这个方法中调用了initAnimation方法。还是根据动态分派规则，这里调用ObjectAnimator的initAnimation方法。在这里调用PropertyValuesHolder的setupSetterAndGetter方法，在这里对mSetter等进行了初始化，这里就不多说了，大家自己看代码吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android应用的破解与保护","date":"2018-01-27T04:35:08.000Z","_content":"<Excerpt in index | 首页摘要>\n\n[Android应用的破解与保护](https://github.com/Guolei1130/blog_resource/blob/master/art/Android%E5%BA%94%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%A0%B4%E8%A7%A3.pdf)\n\n<!-- more -->\n\n\n\n本来是想写篇博客的，但是太赖了。直接转成pdf算求，喜欢的朋友点个星星吧。\n\n[Android应用的破解与保护](https://github.com/Guolei1130/blog_resource/blob/master/art/Android%E5%BA%94%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%A0%B4%E8%A7%A3.pdf)\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Android应用的破解与保护.md","raw":"---\ntitle: Android应用的破解与保护\ndate: 2018-01-27 12:35:08\ntags: Andrid\ncategories: 安全\n\n---\n<Excerpt in index | 首页摘要>\n\n[Android应用的破解与保护](https://github.com/Guolei1130/blog_resource/blob/master/art/Android%E5%BA%94%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%A0%B4%E8%A7%A3.pdf)\n\n<!-- more -->\n\n\n\n本来是想写篇博客的，但是太赖了。直接转成pdf算求，喜欢的朋友点个星星吧。\n\n[Android应用的破解与保护](https://github.com/Guolei1130/blog_resource/blob/master/art/Android%E5%BA%94%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%A0%B4%E8%A7%A3.pdf)\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Android应用的破解与保护","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxe000o19fyhxrwc89a","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<p><a href=\"https://github.com/Guolei1130/blog_resource/blob/master/art/Android%E5%BA%94%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%A0%B4%E8%A7%A3.pdf\" target=\"_blank\" rel=\"external\">Android应用的破解与保护</a></p>\n<a id=\"more\"></a>\n<p>本来是想写篇博客的，但是太赖了。直接转成pdf算求，喜欢的朋友点个星星吧。</p>\n<p><a href=\"https://github.com/Guolei1130/blog_resource/blob/master/art/Android%E5%BA%94%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%A0%B4%E8%A7%A3.pdf\" target=\"_blank\" rel=\"external\">Android应用的破解与保护</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<p><a href=\"https://github.com/Guolei1130/blog_resource/blob/master/art/Android%E5%BA%94%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%A0%B4%E8%A7%A3.pdf\">Android应用的破解与保护</a></p>","more":"<p>本来是想写篇博客的，但是太赖了。直接转成pdf算求，喜欢的朋友点个星星吧。</p>\n<p><a href=\"https://github.com/Guolei1130/blog_resource/blob/master/art/Android%E5%BA%94%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%A0%B4%E8%A7%A3.pdf\">Android应用的破解与保护</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android应用程序是如何安装的","date":"2017-01-04T12:24:27.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，\n\n### 2.安装器\n\n显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。\n\n```\n        if (v == mOk) {\n            if (mOkCanInstall || mScrollView == null) {\n                mInstallFlowAnalytics.setInstallButtonClicked();\n                if (mSessionId != -1) {\n                    mInstaller.setPermissionsResult(mSessionId, true);\n\n                    // We're only confirming permissions, so we don't really know how the\n                    // story ends; assume success.\n                    mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(\n                            PackageManager.INSTALL_SUCCEEDED);\n                    finish();\n                } else {\n                    startInstall();\n                }\n            } else {\n                mScrollView.pageScroll(View.FOCUS_DOWN);\n            }\n        }\n```\n\n虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。\n\n```\n        if (\"package\".equals(mPackageURI.getScheme())) {\n            try {\n                pm.installExistingPackage(mAppInfo.packageName);\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_SUCCEEDED);\n            } catch (PackageManager.NameNotFoundException e) {\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_FAILED_INVALID_APK);\n            }\n        } else {\n            pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,\n                    installerPackageName, verificationParams, null);\n        }\n```\n\n* mPackageURI，安装应用的话，应该是file\n* pm 为ApplicationPackageManager\n\n因此，我们看installPackageWithVerificationAndEncryption方法。\n\n### 3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\n\n\n在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。\n\n```\n    public static IPackageManager getPackageManager() {\n        if (sPackageManager != null) {\n            //Slog.v(\"PackageManager\", \"returning cur default = \" + sPackageManager);\n            return sPackageManager;\n        }\n        IBinder b = ServiceManager.getService(\"package\");\n        //Slog.v(\"PackageManager\", \"default service binder = \" + b);\n        sPackageManager = IPackageManager.Stub.asInterface(b);\n        //Slog.v(\"PackageManager\", \"default service = \" + sPackageManager);\n        return sPackageManager;\n    }\n```\n\n从中可以看出，其binder服务端为PackageManagerService.\n\n### 4.PackageManagerService#installPackage\n\n在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy\n\n```\n        final Message msg = mHandler.obtainMessage(INIT_COPY);\n        msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,\n                null, verificationParams, user, packageAbiOverride, null);\n        mHandler.sendMessage(msg);\n```\n\n这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？\n\n```\n                case INIT_COPY: {\n                    HandlerParams params = (HandlerParams) msg.obj;\n                    int idx = mPendingInstalls.size();\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy idx=\" + idx + \": \" + params);\n                    // If a bind was already initiated we dont really\n                    // need to do anything. The pending install\n                    // will be processed later on.\n                    if (!mBound) {\n                        // If this is the only one pending we might\n                        // have to bind to the service again.\n                        if (!connectToService()) {\n                            Slog.e(TAG, \"Failed to bind to media container service\");\n                            params.serviceError();\n                            return;\n                        } else {\n                            // Once we bind to the service, the first\n                            // pending request will be processed.\n                            mPendingInstalls.add(idx, params);\n                        }\n                    } else {\n                        mPendingInstalls.add(idx, params);\n                        // Already bound to the service. Just make\n                        // sure we trigger off processing the first request.\n                        if (idx == 0) {\n                            mHandler.sendEmptyMessage(MCS_BOUND);\n                        }\n                    }\n                    break;\n                }\n```\n\n如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。\n在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，\n\n```\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_bound\");\n                    if (msg.obj != null) {\n                        mContainerService = (IMediaContainerService) msg.obj;\n                    }\n                    if (mContainerService == null) {\n                        if (!mBound) {\n                            // Something seriously wrong since we are not bound and we are not\n                            // waiting for connection. Bail out.\n                            Slog.e(TAG, \"Cannot bind to media container service\");\n                            for (HandlerParams params : mPendingInstalls) {\n                                // Indicate service bind error\n                                params.serviceError();\n                            }\n                            mPendingInstalls.clear();\n                        } else {\n                            Slog.w(TAG, \"Waiting to connect to media container service\");\n                        }\n                    } else if (mPendingInstalls.size() > 0) {\n                        HandlerParams params = mPendingInstalls.get(0);\n                        if (params != null) {\n                            if (params.startCopy()) {\n                                // We are done...  look for more work or to\n                                // go idle.\n                                if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                        \"Checking for more work or unbind...\");\n                                // Delete pending install\n                                if (mPendingInstalls.size() > 0) {\n                                    mPendingInstalls.remove(0);\n                                }\n                                if (mPendingInstalls.size() == 0) {\n                                    if (mBound) {\n                                        if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                                \"Posting delayed MCS_UNBIND\");\n                                        removeMessages(MCS_UNBIND);\n                                        Message ubmsg = obtainMessage(MCS_UNBIND);\n                                        // Unbind after a little delay, to avoid\n                                        // continual thrashing.\n                                        sendMessageDelayed(ubmsg, 10000);\n                                    }\n                                } else {\n                                    // There are more pending requests in queue.\n                                    // Just post MCS_BOUND message to trigger processing\n                                    // of next pending install.\n                                    if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                            \"Posting MCS_BOUND for next work\");\n                                    mHandler.sendEmptyMessage(MCS_BOUND);\n                                }\n                            }\n                        }\n                    } else {\n                        // Should never happen ideally.\n                        Slog.w(TAG, \"Empty queue\");\n                    }\n                    break;\n```\n\n从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。\n\n### 5.HandlerParams#startCopy\n\n```\n        final boolean startCopy() {\n            boolean res;\n            try {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"startCopy \" + mUser + \": \" + this);\n\n                if (++mRetries > MAX_RETRIES) {\n                    Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\");\n                    mHandler.sendEmptyMessage(MCS_GIVE_UP);\n                    handleServiceError();\n                    return false;\n                } else {\n                    handleStartCopy();\n                    res = true;\n                }\n            } catch (RemoteException e) {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\");\n                mHandler.sendEmptyMessage(MCS_RECONNECT);\n                res = false;\n            }\n            handleReturnCode();\n            return res;\n        }\n```\n\n这里有重试机制。而handleStartCopy的实现在InstallParams中。\n\n### 6.InstallParams#handleStartCopy\n\n这个方法比较长，分段来看。\n\n```\n                    final StorageManager storage = StorageManager.from(mContext);\n                    final long lowThreshold = storage.getStorageLowBytes(\n                            Environment.getDataDirectory());\n\n                    final long sizeBytes = mContainerService.calculateInstalledSize(\n                            origin.resolvedPath, isForwardLocked(), packageAbiOverride);\n\n                    if (mInstaller.freeCache(null, sizeBytes + lowThreshold) >= 0) {\n                        pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,\n                                installFlags, packageAbiOverride);\n                    }\n```\n\n首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。\n\n这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。\n\n中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。\n\n```\nif (ret == PackageManager.INSTALL_SUCCEEDED) {\n                 /*\n                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by\n                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.\n                 */\n                int userIdentifier = getUser().getIdentifier();\n                if (userIdentifier == UserHandle.USER_ALL\n                        && ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0)) {\n                    userIdentifier = UserHandle.USER_OWNER;\n                }\n\n                /*\n                 * Determine if we have any installed package verifiers. If we\n                 * do, then we'll defer to them to verify the packages.\n                 */\n                final int requiredUid = mRequiredVerifierPackage == null ? -1\n                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);\n                if (!origin.existing && requiredUid != -1\n                        && isVerificationEnabled(userIdentifier, installFlags)) {\n                    final Intent verification = new Intent(\n                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);\n                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),\n                            PACKAGE_MIME_TYPE);\n                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n                    final List<ResolveInfo> receivers = queryIntentReceivers(verification,\n                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,\n                            0 /* TODO: Which userId? */);\n\n                    if (DEBUG_VERIFY) {\n                        Slog.d(TAG, \"Found \" + receivers.size() + \" verifiers for intent \"\n                                + verification.toString() + \" with \" + pkgLite.verifiers.length\n                                + \" optional verifiers\");\n                    }\n\n                    final int verificationId = mPendingVerificationToken++;\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,\n                            installerPackageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,\n                            installFlags);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,\n                            pkgLite.packageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,\n                            pkgLite.versionCode);\n\n                    if (verificationParams != null) {\n                        if (verificationParams.getVerificationURI() != null) {\n                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,\n                                 verificationParams.getVerificationURI());\n                        }\n                        if (verificationParams.getOriginatingURI() != null) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,\n                                  verificationParams.getOriginatingURI());\n                        }\n                        if (verificationParams.getReferrer() != null) {\n                            verification.putExtra(Intent.EXTRA_REFERRER,\n                                  verificationParams.getReferrer());\n                        }\n                        if (verificationParams.getOriginatingUid() >= 0) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,\n                                  verificationParams.getOriginatingUid());\n                        }\n                        if (verificationParams.getInstallerUid() >= 0) {\n                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,\n                                  verificationParams.getInstallerUid());\n                        }\n                    }\n\n                    final PackageVerificationState verificationState = new PackageVerificationState(\n                            requiredUid, args);\n\n                    mPendingVerification.append(verificationId, verificationState);\n\n                    final List<ComponentName> sufficientVerifiers = matchVerifiers(pkgLite,\n                            receivers, verificationState);\n\n                    // Apps installed for \"all\" users use the device owner to verify the app\n                    UserHandle verifierUser = getUser();\n                    if (verifierUser == UserHandle.ALL) {\n                        verifierUser = UserHandle.OWNER;\n                    }\n\n                    /*\n                     * If any sufficient verifiers were listed in the package\n                     * manifest, attempt to ask them.\n                     */\n                    if (sufficientVerifiers != null) {\n                        final int N = sufficientVerifiers.size();\n                        if (N == 0) {\n                            Slog.i(TAG, \"Additional verifiers required, but none installed.\");\n                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;\n                        } else {\n                            for (int i = 0; i < N; i++) {\n                                final ComponentName verifierComponent = sufficientVerifiers.get(i);\n\n                                final Intent sufficientIntent = new Intent(verification);\n                                sufficientIntent.setComponent(verifierComponent);\n                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);\n                            }\n                        }\n                    }\n\n                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(\n                            mRequiredVerifierPackage, receivers);\n                    if (ret == PackageManager.INSTALL_SUCCEEDED\n                            && mRequiredVerifierPackage != null) {\n                        /*\n                         * Send the intent to the required verification agent,\n                         * but only start the verification timeout after the\n                         * target BroadcastReceivers have run.\n                         */\n                        verification.setComponent(requiredVerifierComponent);\n                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,\n                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,\n                                new BroadcastReceiver() {\n                                    @Override\n                                    public void onReceive(Context context, Intent intent) {\n                                        final Message msg = mHandler\n                                                .obtainMessage(CHECK_PENDING_VERIFICATION);\n                                        msg.arg1 = verificationId;\n                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());\n                                    }\n                                }, null, 0, null, null);\n\n                        /*\n                         * We don't want the copy to proceed until verification\n                         * succeeds, so null out this field.\n                         */\n                        mArgs = null;\n                    }\n                } else {\n                    /*\n                     * No package verification is enabled, so immediately start\n                     * the remote call to initiate copy using temporary file.\n                     */\n                    ret = args.copyApk(mContainerService, true);\n                }\n            }\n\n```\n\n* 如果启动了包验证的话，就会进入验证阶段。 \n\t* 发送有序广播， \n* 否则，直接进行复制操作\n\n验证部分的逻辑很长，大部分代码都是对intent进行设置。\n\n### 7.InstallArgs#copyApk\n\n在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。\n\n```\n    private InstallArgs createInstallArgs(InstallParams params) {\n        if (params.move != null) {\n            return new MoveInstallArgs(params);\n        } else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {\n            return new AsecInstallArgs(params);\n        } else {\n            return new FileInstallArgs(params);\n        }\n    }\n```\n\n以FileInstallArgs为例，我们来看看。\n\n```\n\n       int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {\n            if (origin.staged) {\n                if (DEBUG_INSTALL) Slog.d(TAG, origin.file + \" already staged; skipping copy\");\n                codeFile = origin.file;\n                resourceFile = origin.file;\n                return PackageManager.INSTALL_SUCCEEDED;\n            }\n\n            try {\n                final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);\n                codeFile = tempDir;\n                resourceFile = tempDir;\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to create copy file: \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n\n            final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {\n                @Override\n                public ParcelFileDescriptor open(String name, int mode) throws RemoteException {\n                    if (!FileUtils.isValidExtFilename(name)) {\n                        throw new IllegalArgumentException(\"Invalid filename: \" + name);\n                    }\n                    try {\n                        final File file = new File(codeFile, name);\n                        final FileDescriptor fd = Os.open(file.getAbsolutePath(),\n                                O_RDWR | O_CREAT, 0644);\n                        Os.chmod(file.getAbsolutePath(), 0644);\n                        return new ParcelFileDescriptor(fd);\n                    } catch (ErrnoException e) {\n                        throw new RemoteException(\"Failed to open: \" + e.getMessage());\n                    }\n                }\n            };\n\n            int ret = PackageManager.INSTALL_SUCCEEDED;\n            ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);\n            if (ret != PackageManager.INSTALL_SUCCEEDED) {\n                Slog.e(TAG, \"Failed to copy package\");\n                return ret;\n            }\n\n            final File libraryRoot = new File(codeFile, LIB_DIR_NAME);\n            NativeLibraryHelper.Handle handle = null;\n            try {\n                handle = NativeLibraryHelper.Handle.create(codeFile);\n                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,\n                        abiOverride);\n            } catch (IOException e) {\n                Slog.e(TAG, \"Copying native libraries failed\", e);\n                ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;\n            } finally {\n                IoUtils.closeQuietly(handle);\n            }\n\n            return ret;\n        }\n\n```\n\n* 首先mInstallerService.allocateStageDirLegacy申请足够的存储空间\n* 得到申请的那部分空间的文件描述符，并且修改权限\n* IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，\n* NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)\n\n### 8.DefaultContainerService#copyPackage\n\n```\n        public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) {\n            if (packagePath == null || target == null) {\n                return PackageManager.INSTALL_FAILED_INVALID_URI;\n            }\n\n            PackageLite pkg = null;\n            try {\n                final File packageFile = new File(packagePath);\n                pkg = PackageParser.parsePackageLite(packageFile, 0);\n                return copyPackageInner(pkg, target);\n            } catch (PackageParserException | IOException | RemoteException e) {\n                Slog.w(TAG, \"Failed to copy package at \" + packagePath + \": \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n        }\n```\n\n* 解析apk文件\n* 将文件拷贝到指定目录\n\n### 9.NativeLibraryHelper#copyNativeBinariesWithOverride\n\n在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。\n\n到现在，copy的流程就完了。\n\n在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。\n\n### 10.InstallParams#handleReturnCode\n\n在这个方法中，会调用processPendingInstall去处理。\n\n```\n    private void processPendingInstall(final InstallArgs args, final int currentStatus) {\n        // Queue up an async operation since the package installation may take a little while.\n        mHandler.post(new Runnable() {\n            public void run() {\n                mHandler.removeCallbacks(this);\n                 // Result object to be returned\n                PackageInstalledInfo res = new PackageInstalledInfo();\n                res.returnCode = currentStatus;\n                res.uid = -1;\n                res.pkg = null;\n                res.removedInfo = new PackageRemovedInfo();\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {\n                    args.doPreInstall(res.returnCode);\n                    synchronized (mInstallLock) {\n                        installPackageLI(args, res);\n                    }\n                    args.doPostInstall(res.returnCode, res.uid);\n                }\n\n                // A restore should be performed at this point if (a) the install\n                // succeeded, (b) the operation is not an update, and (c) the new\n                // package has not opted out of backup participation.\n                final boolean update = res.removedInfo.removedPackage != null;\n                final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;\n                boolean doRestore = !update\n                        && ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);\n\n                // Set up the post-install work request bookkeeping.  This will be used\n                // and cleaned up by the post-install event handling regardless of whether\n                // there's a restore pass performed.  Token values are >= 1.\n                int token;\n                if (mNextInstallToken < 0) mNextInstallToken = 1;\n                token = mNextInstallToken++;\n\n                PostInstallData data = new PostInstallData(args, res);\n                mRunningInstalls.put(token, data);\n                if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token);\n\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {\n                    // Pass responsibility to the Backup Manager.  It will perform a\n                    // restore if appropriate, then pass responsibility back to the\n                    // Package Manager to run the post-install observer callbacks\n                    // and broadcasts.\n                    IBackupManager bm = IBackupManager.Stub.asInterface(\n                            ServiceManager.getService(Context.BACKUP_SERVICE));\n                    if (bm != null) {\n                        if (DEBUG_INSTALL) Log.v(TAG, \"token \" + token\n                                + \" to BM for possible restore\");\n                        try {\n                            if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) {\n                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);\n                            } else {\n                                doRestore = false;\n                            }\n                        } catch (RemoteException e) {\n                            // can't happen; the backup manager is local\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"Exception trying to enqueue restore\", e);\n                            doRestore = false;\n                        }\n                    } else {\n                        Slog.e(TAG, \"Backup Manager not found!\");\n                        doRestore = false;\n                    }\n                }\n\n                if (!doRestore) {\n                    // No restore possible, or the Backup Manager was mysteriously not\n                    // available -- just fire the post-install work request directly.\n                    if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token);\n                    Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);\n                    mHandler.sendMessage(msg);\n                }\n            }\n        });\n    }\n```\n\n安装过程\n\n* installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。\n* 恢复部分代码 没看明白。😭\n* 发送POST_INSTALL消息\n\n### 11.installPackageLI\n\n改方法氛围几部分。\n\n首先是解析包过程。\n\n```\n        PackageParser pp = new PackageParser();\n        pp.setSeparateProcesses(mSeparateProcesses);\n        pp.setDisplayMetrics(mMetrics);\n\n        final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(tmpPackageFile, parseFlags);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed parse during installPackageLI\", e);\n            return;\n        }\n```\n\n其次是校验签名的md5的过程\n\n```\n        try {\n            pp.collectCertificates(pkg, parseFlags);\n            pp.collectManifestDigest(pkg);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed collect during installPackageLI\", e);\n            return;\n        }\n\n        /* If the installer passed in a manifest digest, compare it now. */\n        if (args.manifestDigest != null) {\n            if (DEBUG_INSTALL) {\n                final String parsedManifest = pkg.manifestDigest == null ? \"null\"\n                        : pkg.manifestDigest.toString();\n                Slog.d(TAG, \"Comparing manifests: \" + args.manifestDigest.toString() + \" vs. \"\n                        + parsedManifest);\n            }\n\n            if (!args.manifestDigest.equals(pkg.manifestDigest)) {\n                res.setError(INSTALL_FAILED_PACKAGE_CHANGED, \"Manifest digest changed\");\n                return;\n            }\n        } else if (DEBUG_INSTALL) {\n            final String parsedManifest = pkg.manifestDigest == null\n                    ? \"null\" : pkg.manifestDigest.toString();\n            Slog.d(TAG, \"manifestDigest was not present, but parser got: \" + parsedManifest);\n        }\n```\n\n\n调用installNewPackageLI安装。\n\n### 12.installNewPackageLI\n\n在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。\n\n\n### 13.处理POST_INSTALL消息\n\n略。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n","source":"_posts/Android应用程序是如何安装的.md","raw":"---\ntitle: Android应用程序是如何安装的\ndate: 2017-01-04 20:24:27\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，\n\n### 2.安装器\n\n显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。\n\n```\n        if (v == mOk) {\n            if (mOkCanInstall || mScrollView == null) {\n                mInstallFlowAnalytics.setInstallButtonClicked();\n                if (mSessionId != -1) {\n                    mInstaller.setPermissionsResult(mSessionId, true);\n\n                    // We're only confirming permissions, so we don't really know how the\n                    // story ends; assume success.\n                    mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(\n                            PackageManager.INSTALL_SUCCEEDED);\n                    finish();\n                } else {\n                    startInstall();\n                }\n            } else {\n                mScrollView.pageScroll(View.FOCUS_DOWN);\n            }\n        }\n```\n\n虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。\n\n```\n        if (\"package\".equals(mPackageURI.getScheme())) {\n            try {\n                pm.installExistingPackage(mAppInfo.packageName);\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_SUCCEEDED);\n            } catch (PackageManager.NameNotFoundException e) {\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_FAILED_INVALID_APK);\n            }\n        } else {\n            pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,\n                    installerPackageName, verificationParams, null);\n        }\n```\n\n* mPackageURI，安装应用的话，应该是file\n* pm 为ApplicationPackageManager\n\n因此，我们看installPackageWithVerificationAndEncryption方法。\n\n### 3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\n\n\n在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。\n\n```\n    public static IPackageManager getPackageManager() {\n        if (sPackageManager != null) {\n            //Slog.v(\"PackageManager\", \"returning cur default = \" + sPackageManager);\n            return sPackageManager;\n        }\n        IBinder b = ServiceManager.getService(\"package\");\n        //Slog.v(\"PackageManager\", \"default service binder = \" + b);\n        sPackageManager = IPackageManager.Stub.asInterface(b);\n        //Slog.v(\"PackageManager\", \"default service = \" + sPackageManager);\n        return sPackageManager;\n    }\n```\n\n从中可以看出，其binder服务端为PackageManagerService.\n\n### 4.PackageManagerService#installPackage\n\n在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy\n\n```\n        final Message msg = mHandler.obtainMessage(INIT_COPY);\n        msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,\n                null, verificationParams, user, packageAbiOverride, null);\n        mHandler.sendMessage(msg);\n```\n\n这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？\n\n```\n                case INIT_COPY: {\n                    HandlerParams params = (HandlerParams) msg.obj;\n                    int idx = mPendingInstalls.size();\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy idx=\" + idx + \": \" + params);\n                    // If a bind was already initiated we dont really\n                    // need to do anything. The pending install\n                    // will be processed later on.\n                    if (!mBound) {\n                        // If this is the only one pending we might\n                        // have to bind to the service again.\n                        if (!connectToService()) {\n                            Slog.e(TAG, \"Failed to bind to media container service\");\n                            params.serviceError();\n                            return;\n                        } else {\n                            // Once we bind to the service, the first\n                            // pending request will be processed.\n                            mPendingInstalls.add(idx, params);\n                        }\n                    } else {\n                        mPendingInstalls.add(idx, params);\n                        // Already bound to the service. Just make\n                        // sure we trigger off processing the first request.\n                        if (idx == 0) {\n                            mHandler.sendEmptyMessage(MCS_BOUND);\n                        }\n                    }\n                    break;\n                }\n```\n\n如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。\n在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，\n\n```\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_bound\");\n                    if (msg.obj != null) {\n                        mContainerService = (IMediaContainerService) msg.obj;\n                    }\n                    if (mContainerService == null) {\n                        if (!mBound) {\n                            // Something seriously wrong since we are not bound and we are not\n                            // waiting for connection. Bail out.\n                            Slog.e(TAG, \"Cannot bind to media container service\");\n                            for (HandlerParams params : mPendingInstalls) {\n                                // Indicate service bind error\n                                params.serviceError();\n                            }\n                            mPendingInstalls.clear();\n                        } else {\n                            Slog.w(TAG, \"Waiting to connect to media container service\");\n                        }\n                    } else if (mPendingInstalls.size() > 0) {\n                        HandlerParams params = mPendingInstalls.get(0);\n                        if (params != null) {\n                            if (params.startCopy()) {\n                                // We are done...  look for more work or to\n                                // go idle.\n                                if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                        \"Checking for more work or unbind...\");\n                                // Delete pending install\n                                if (mPendingInstalls.size() > 0) {\n                                    mPendingInstalls.remove(0);\n                                }\n                                if (mPendingInstalls.size() == 0) {\n                                    if (mBound) {\n                                        if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                                \"Posting delayed MCS_UNBIND\");\n                                        removeMessages(MCS_UNBIND);\n                                        Message ubmsg = obtainMessage(MCS_UNBIND);\n                                        // Unbind after a little delay, to avoid\n                                        // continual thrashing.\n                                        sendMessageDelayed(ubmsg, 10000);\n                                    }\n                                } else {\n                                    // There are more pending requests in queue.\n                                    // Just post MCS_BOUND message to trigger processing\n                                    // of next pending install.\n                                    if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                            \"Posting MCS_BOUND for next work\");\n                                    mHandler.sendEmptyMessage(MCS_BOUND);\n                                }\n                            }\n                        }\n                    } else {\n                        // Should never happen ideally.\n                        Slog.w(TAG, \"Empty queue\");\n                    }\n                    break;\n```\n\n从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。\n\n### 5.HandlerParams#startCopy\n\n```\n        final boolean startCopy() {\n            boolean res;\n            try {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"startCopy \" + mUser + \": \" + this);\n\n                if (++mRetries > MAX_RETRIES) {\n                    Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\");\n                    mHandler.sendEmptyMessage(MCS_GIVE_UP);\n                    handleServiceError();\n                    return false;\n                } else {\n                    handleStartCopy();\n                    res = true;\n                }\n            } catch (RemoteException e) {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\");\n                mHandler.sendEmptyMessage(MCS_RECONNECT);\n                res = false;\n            }\n            handleReturnCode();\n            return res;\n        }\n```\n\n这里有重试机制。而handleStartCopy的实现在InstallParams中。\n\n### 6.InstallParams#handleStartCopy\n\n这个方法比较长，分段来看。\n\n```\n                    final StorageManager storage = StorageManager.from(mContext);\n                    final long lowThreshold = storage.getStorageLowBytes(\n                            Environment.getDataDirectory());\n\n                    final long sizeBytes = mContainerService.calculateInstalledSize(\n                            origin.resolvedPath, isForwardLocked(), packageAbiOverride);\n\n                    if (mInstaller.freeCache(null, sizeBytes + lowThreshold) >= 0) {\n                        pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,\n                                installFlags, packageAbiOverride);\n                    }\n```\n\n首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。\n\n这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。\n\n中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。\n\n```\nif (ret == PackageManager.INSTALL_SUCCEEDED) {\n                 /*\n                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by\n                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.\n                 */\n                int userIdentifier = getUser().getIdentifier();\n                if (userIdentifier == UserHandle.USER_ALL\n                        && ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0)) {\n                    userIdentifier = UserHandle.USER_OWNER;\n                }\n\n                /*\n                 * Determine if we have any installed package verifiers. If we\n                 * do, then we'll defer to them to verify the packages.\n                 */\n                final int requiredUid = mRequiredVerifierPackage == null ? -1\n                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);\n                if (!origin.existing && requiredUid != -1\n                        && isVerificationEnabled(userIdentifier, installFlags)) {\n                    final Intent verification = new Intent(\n                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);\n                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),\n                            PACKAGE_MIME_TYPE);\n                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n                    final List<ResolveInfo> receivers = queryIntentReceivers(verification,\n                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,\n                            0 /* TODO: Which userId? */);\n\n                    if (DEBUG_VERIFY) {\n                        Slog.d(TAG, \"Found \" + receivers.size() + \" verifiers for intent \"\n                                + verification.toString() + \" with \" + pkgLite.verifiers.length\n                                + \" optional verifiers\");\n                    }\n\n                    final int verificationId = mPendingVerificationToken++;\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,\n                            installerPackageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,\n                            installFlags);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,\n                            pkgLite.packageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,\n                            pkgLite.versionCode);\n\n                    if (verificationParams != null) {\n                        if (verificationParams.getVerificationURI() != null) {\n                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,\n                                 verificationParams.getVerificationURI());\n                        }\n                        if (verificationParams.getOriginatingURI() != null) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,\n                                  verificationParams.getOriginatingURI());\n                        }\n                        if (verificationParams.getReferrer() != null) {\n                            verification.putExtra(Intent.EXTRA_REFERRER,\n                                  verificationParams.getReferrer());\n                        }\n                        if (verificationParams.getOriginatingUid() >= 0) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,\n                                  verificationParams.getOriginatingUid());\n                        }\n                        if (verificationParams.getInstallerUid() >= 0) {\n                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,\n                                  verificationParams.getInstallerUid());\n                        }\n                    }\n\n                    final PackageVerificationState verificationState = new PackageVerificationState(\n                            requiredUid, args);\n\n                    mPendingVerification.append(verificationId, verificationState);\n\n                    final List<ComponentName> sufficientVerifiers = matchVerifiers(pkgLite,\n                            receivers, verificationState);\n\n                    // Apps installed for \"all\" users use the device owner to verify the app\n                    UserHandle verifierUser = getUser();\n                    if (verifierUser == UserHandle.ALL) {\n                        verifierUser = UserHandle.OWNER;\n                    }\n\n                    /*\n                     * If any sufficient verifiers were listed in the package\n                     * manifest, attempt to ask them.\n                     */\n                    if (sufficientVerifiers != null) {\n                        final int N = sufficientVerifiers.size();\n                        if (N == 0) {\n                            Slog.i(TAG, \"Additional verifiers required, but none installed.\");\n                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;\n                        } else {\n                            for (int i = 0; i < N; i++) {\n                                final ComponentName verifierComponent = sufficientVerifiers.get(i);\n\n                                final Intent sufficientIntent = new Intent(verification);\n                                sufficientIntent.setComponent(verifierComponent);\n                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);\n                            }\n                        }\n                    }\n\n                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(\n                            mRequiredVerifierPackage, receivers);\n                    if (ret == PackageManager.INSTALL_SUCCEEDED\n                            && mRequiredVerifierPackage != null) {\n                        /*\n                         * Send the intent to the required verification agent,\n                         * but only start the verification timeout after the\n                         * target BroadcastReceivers have run.\n                         */\n                        verification.setComponent(requiredVerifierComponent);\n                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,\n                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,\n                                new BroadcastReceiver() {\n                                    @Override\n                                    public void onReceive(Context context, Intent intent) {\n                                        final Message msg = mHandler\n                                                .obtainMessage(CHECK_PENDING_VERIFICATION);\n                                        msg.arg1 = verificationId;\n                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());\n                                    }\n                                }, null, 0, null, null);\n\n                        /*\n                         * We don't want the copy to proceed until verification\n                         * succeeds, so null out this field.\n                         */\n                        mArgs = null;\n                    }\n                } else {\n                    /*\n                     * No package verification is enabled, so immediately start\n                     * the remote call to initiate copy using temporary file.\n                     */\n                    ret = args.copyApk(mContainerService, true);\n                }\n            }\n\n```\n\n* 如果启动了包验证的话，就会进入验证阶段。 \n\t* 发送有序广播， \n* 否则，直接进行复制操作\n\n验证部分的逻辑很长，大部分代码都是对intent进行设置。\n\n### 7.InstallArgs#copyApk\n\n在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。\n\n```\n    private InstallArgs createInstallArgs(InstallParams params) {\n        if (params.move != null) {\n            return new MoveInstallArgs(params);\n        } else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {\n            return new AsecInstallArgs(params);\n        } else {\n            return new FileInstallArgs(params);\n        }\n    }\n```\n\n以FileInstallArgs为例，我们来看看。\n\n```\n\n       int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {\n            if (origin.staged) {\n                if (DEBUG_INSTALL) Slog.d(TAG, origin.file + \" already staged; skipping copy\");\n                codeFile = origin.file;\n                resourceFile = origin.file;\n                return PackageManager.INSTALL_SUCCEEDED;\n            }\n\n            try {\n                final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);\n                codeFile = tempDir;\n                resourceFile = tempDir;\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to create copy file: \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n\n            final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {\n                @Override\n                public ParcelFileDescriptor open(String name, int mode) throws RemoteException {\n                    if (!FileUtils.isValidExtFilename(name)) {\n                        throw new IllegalArgumentException(\"Invalid filename: \" + name);\n                    }\n                    try {\n                        final File file = new File(codeFile, name);\n                        final FileDescriptor fd = Os.open(file.getAbsolutePath(),\n                                O_RDWR | O_CREAT, 0644);\n                        Os.chmod(file.getAbsolutePath(), 0644);\n                        return new ParcelFileDescriptor(fd);\n                    } catch (ErrnoException e) {\n                        throw new RemoteException(\"Failed to open: \" + e.getMessage());\n                    }\n                }\n            };\n\n            int ret = PackageManager.INSTALL_SUCCEEDED;\n            ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);\n            if (ret != PackageManager.INSTALL_SUCCEEDED) {\n                Slog.e(TAG, \"Failed to copy package\");\n                return ret;\n            }\n\n            final File libraryRoot = new File(codeFile, LIB_DIR_NAME);\n            NativeLibraryHelper.Handle handle = null;\n            try {\n                handle = NativeLibraryHelper.Handle.create(codeFile);\n                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,\n                        abiOverride);\n            } catch (IOException e) {\n                Slog.e(TAG, \"Copying native libraries failed\", e);\n                ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;\n            } finally {\n                IoUtils.closeQuietly(handle);\n            }\n\n            return ret;\n        }\n\n```\n\n* 首先mInstallerService.allocateStageDirLegacy申请足够的存储空间\n* 得到申请的那部分空间的文件描述符，并且修改权限\n* IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，\n* NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)\n\n### 8.DefaultContainerService#copyPackage\n\n```\n        public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) {\n            if (packagePath == null || target == null) {\n                return PackageManager.INSTALL_FAILED_INVALID_URI;\n            }\n\n            PackageLite pkg = null;\n            try {\n                final File packageFile = new File(packagePath);\n                pkg = PackageParser.parsePackageLite(packageFile, 0);\n                return copyPackageInner(pkg, target);\n            } catch (PackageParserException | IOException | RemoteException e) {\n                Slog.w(TAG, \"Failed to copy package at \" + packagePath + \": \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n        }\n```\n\n* 解析apk文件\n* 将文件拷贝到指定目录\n\n### 9.NativeLibraryHelper#copyNativeBinariesWithOverride\n\n在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。\n\n到现在，copy的流程就完了。\n\n在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。\n\n### 10.InstallParams#handleReturnCode\n\n在这个方法中，会调用processPendingInstall去处理。\n\n```\n    private void processPendingInstall(final InstallArgs args, final int currentStatus) {\n        // Queue up an async operation since the package installation may take a little while.\n        mHandler.post(new Runnable() {\n            public void run() {\n                mHandler.removeCallbacks(this);\n                 // Result object to be returned\n                PackageInstalledInfo res = new PackageInstalledInfo();\n                res.returnCode = currentStatus;\n                res.uid = -1;\n                res.pkg = null;\n                res.removedInfo = new PackageRemovedInfo();\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {\n                    args.doPreInstall(res.returnCode);\n                    synchronized (mInstallLock) {\n                        installPackageLI(args, res);\n                    }\n                    args.doPostInstall(res.returnCode, res.uid);\n                }\n\n                // A restore should be performed at this point if (a) the install\n                // succeeded, (b) the operation is not an update, and (c) the new\n                // package has not opted out of backup participation.\n                final boolean update = res.removedInfo.removedPackage != null;\n                final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;\n                boolean doRestore = !update\n                        && ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);\n\n                // Set up the post-install work request bookkeeping.  This will be used\n                // and cleaned up by the post-install event handling regardless of whether\n                // there's a restore pass performed.  Token values are >= 1.\n                int token;\n                if (mNextInstallToken < 0) mNextInstallToken = 1;\n                token = mNextInstallToken++;\n\n                PostInstallData data = new PostInstallData(args, res);\n                mRunningInstalls.put(token, data);\n                if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token);\n\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {\n                    // Pass responsibility to the Backup Manager.  It will perform a\n                    // restore if appropriate, then pass responsibility back to the\n                    // Package Manager to run the post-install observer callbacks\n                    // and broadcasts.\n                    IBackupManager bm = IBackupManager.Stub.asInterface(\n                            ServiceManager.getService(Context.BACKUP_SERVICE));\n                    if (bm != null) {\n                        if (DEBUG_INSTALL) Log.v(TAG, \"token \" + token\n                                + \" to BM for possible restore\");\n                        try {\n                            if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) {\n                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);\n                            } else {\n                                doRestore = false;\n                            }\n                        } catch (RemoteException e) {\n                            // can't happen; the backup manager is local\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"Exception trying to enqueue restore\", e);\n                            doRestore = false;\n                        }\n                    } else {\n                        Slog.e(TAG, \"Backup Manager not found!\");\n                        doRestore = false;\n                    }\n                }\n\n                if (!doRestore) {\n                    // No restore possible, or the Backup Manager was mysteriously not\n                    // available -- just fire the post-install work request directly.\n                    if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token);\n                    Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);\n                    mHandler.sendMessage(msg);\n                }\n            }\n        });\n    }\n```\n\n安装过程\n\n* installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。\n* 恢复部分代码 没看明白。😭\n* 发送POST_INSTALL消息\n\n### 11.installPackageLI\n\n改方法氛围几部分。\n\n首先是解析包过程。\n\n```\n        PackageParser pp = new PackageParser();\n        pp.setSeparateProcesses(mSeparateProcesses);\n        pp.setDisplayMetrics(mMetrics);\n\n        final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(tmpPackageFile, parseFlags);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed parse during installPackageLI\", e);\n            return;\n        }\n```\n\n其次是校验签名的md5的过程\n\n```\n        try {\n            pp.collectCertificates(pkg, parseFlags);\n            pp.collectManifestDigest(pkg);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed collect during installPackageLI\", e);\n            return;\n        }\n\n        /* If the installer passed in a manifest digest, compare it now. */\n        if (args.manifestDigest != null) {\n            if (DEBUG_INSTALL) {\n                final String parsedManifest = pkg.manifestDigest == null ? \"null\"\n                        : pkg.manifestDigest.toString();\n                Slog.d(TAG, \"Comparing manifests: \" + args.manifestDigest.toString() + \" vs. \"\n                        + parsedManifest);\n            }\n\n            if (!args.manifestDigest.equals(pkg.manifestDigest)) {\n                res.setError(INSTALL_FAILED_PACKAGE_CHANGED, \"Manifest digest changed\");\n                return;\n            }\n        } else if (DEBUG_INSTALL) {\n            final String parsedManifest = pkg.manifestDigest == null\n                    ? \"null\" : pkg.manifestDigest.toString();\n            Slog.d(TAG, \"manifestDigest was not present, but parser got: \" + parsedManifest);\n        }\n```\n\n\n调用installNewPackageLI安装。\n\n### 12.installNewPackageLI\n\n在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。\n\n\n### 13.处理POST_INSTALL消息\n\n略。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n","slug":"Android应用程序是如何安装的","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxh000r19fy6vdfvhl0","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<p>以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，</p>\n<h3 id=\"2-安装器\"><a href=\"#2-安装器\" class=\"headerlink\" title=\"2.安装器\"></a>2.安装器</h3><p>显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (v == mOk) &#123;</div><div class=\"line\">    if (mOkCanInstall || mScrollView == null) &#123;</div><div class=\"line\">        mInstallFlowAnalytics.setInstallButtonClicked();</div><div class=\"line\">        if (mSessionId != -1) &#123;</div><div class=\"line\">            mInstaller.setPermissionsResult(mSessionId, true);</div><div class=\"line\"></div><div class=\"line\">            // We&apos;re only confirming permissions, so we don&apos;t really know how the</div><div class=\"line\">            // story ends; assume success.</div><div class=\"line\">            mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(</div><div class=\"line\">                    PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">            finish();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            startInstall();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mScrollView.pageScroll(View.FOCUS_DOWN);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        pm.installExistingPackage(mAppInfo.packageName);</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_FAILED_INVALID_APK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,</div><div class=\"line\">            installerPackageName, verificationParams, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>mPackageURI，安装应用的话，应该是file</li>\n<li>pm 为ApplicationPackageManager</li>\n</ul>\n<p>因此，我们看installPackageWithVerificationAndEncryption方法。</p>\n<h3 id=\"3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\"><a href=\"#3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\" class=\"headerlink\" title=\"3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\"></a>3.ApplicationPackageManager#installPackageWithVerificationAndEncryption</h3><p>在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static IPackageManager getPackageManager() &#123;</div><div class=\"line\">    if (sPackageManager != null) &#123;</div><div class=\"line\">        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</div><div class=\"line\">        return sPackageManager;</div><div class=\"line\">    &#125;</div><div class=\"line\">    IBinder b = ServiceManager.getService(&quot;package&quot;);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</div><div class=\"line\">    sPackageManager = IPackageManager.Stub.asInterface(b);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</div><div class=\"line\">    return sPackageManager;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从中可以看出，其binder服务端为PackageManagerService.</p>\n<h3 id=\"4-PackageManagerService-installPackage\"><a href=\"#4-PackageManagerService-installPackage\" class=\"headerlink\" title=\"4.PackageManagerService#installPackage\"></a>4.PackageManagerService#installPackage</h3><p>在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Message msg = mHandler.obtainMessage(INIT_COPY);</div><div class=\"line\">msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,</div><div class=\"line\">        null, verificationParams, user, packageAbiOverride, null);</div><div class=\"line\">mHandler.sendMessage(msg);</div></pre></td></tr></table></figure>\n<p>这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">case INIT_COPY: &#123;</div><div class=\"line\">    HandlerParams params = (HandlerParams) msg.obj;</div><div class=\"line\">    int idx = mPendingInstalls.size();</div><div class=\"line\">    if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params);</div><div class=\"line\">    // If a bind was already initiated we dont really</div><div class=\"line\">    // need to do anything. The pending install</div><div class=\"line\">    // will be processed later on.</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // If this is the only one pending we might</div><div class=\"line\">        // have to bind to the service again.</div><div class=\"line\">        if (!connectToService()) &#123;</div><div class=\"line\">            Slog.e(TAG, &quot;Failed to bind to media container service&quot;);</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Once we bind to the service, the first</div><div class=\"line\">            // pending request will be processed.</div><div class=\"line\">            mPendingInstalls.add(idx, params);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mPendingInstalls.add(idx, params);</div><div class=\"line\">        // Already bound to the service. Just make</div><div class=\"line\">        // sure we trigger off processing the first request.</div><div class=\"line\">        if (idx == 0) &#123;</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。<br>在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;);</div><div class=\"line\">if (msg.obj != null) &#123;</div><div class=\"line\">    mContainerService = (IMediaContainerService) msg.obj;</div><div class=\"line\">&#125;</div><div class=\"line\">if (mContainerService == null) &#123;</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // Something seriously wrong since we are not bound and we are not</div><div class=\"line\">        // waiting for connection. Bail out.</div><div class=\"line\">        Slog.e(TAG, &quot;Cannot bind to media container service&quot;);</div><div class=\"line\">        for (HandlerParams params : mPendingInstalls) &#123;</div><div class=\"line\">            // Indicate service bind error</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mPendingInstalls.clear();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Waiting to connect to media container service&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">    HandlerParams params = mPendingInstalls.get(0);</div><div class=\"line\">    if (params != null) &#123;</div><div class=\"line\">        if (params.startCopy()) &#123;</div><div class=\"line\">            // We are done...  look for more work or to</div><div class=\"line\">            // go idle.</div><div class=\"line\">            if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                    &quot;Checking for more work or unbind...&quot;);</div><div class=\"line\">            // Delete pending install</div><div class=\"line\">            if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">                mPendingInstalls.remove(0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (mPendingInstalls.size() == 0) &#123;</div><div class=\"line\">                if (mBound) &#123;</div><div class=\"line\">                    if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                            &quot;Posting delayed MCS_UNBIND&quot;);</div><div class=\"line\">                    removeMessages(MCS_UNBIND);</div><div class=\"line\">                    Message ubmsg = obtainMessage(MCS_UNBIND);</div><div class=\"line\">                    // Unbind after a little delay, to avoid</div><div class=\"line\">                    // continual thrashing.</div><div class=\"line\">                    sendMessageDelayed(ubmsg, 10000);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are more pending requests in queue.</div><div class=\"line\">                // Just post MCS_BOUND message to trigger processing</div><div class=\"line\">                // of next pending install.</div><div class=\"line\">                if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                        &quot;Posting MCS_BOUND for next work&quot;);</div><div class=\"line\">                mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // Should never happen ideally.</div><div class=\"line\">    Slog.w(TAG, &quot;Empty queue&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div></pre></td></tr></table></figure>\n<p>从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。</p>\n<h3 id=\"5-HandlerParams-startCopy\"><a href=\"#5-HandlerParams-startCopy\" class=\"headerlink\" title=\"5.HandlerParams#startCopy\"></a>5.HandlerParams#startCopy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean startCopy() &#123;</div><div class=\"line\">    boolean res;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);</div><div class=\"line\"></div><div class=\"line\">        if (++mRetries &gt; MAX_RETRIES) &#123;</div><div class=\"line\">            Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_GIVE_UP);</div><div class=\"line\">            handleServiceError();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            handleStartCopy();</div><div class=\"line\">            res = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);</div><div class=\"line\">        mHandler.sendEmptyMessage(MCS_RECONNECT);</div><div class=\"line\">        res = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    handleReturnCode();</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有重试机制。而handleStartCopy的实现在InstallParams中。</p>\n<h3 id=\"6-InstallParams-handleStartCopy\"><a href=\"#6-InstallParams-handleStartCopy\" class=\"headerlink\" title=\"6.InstallParams#handleStartCopy\"></a>6.InstallParams#handleStartCopy</h3><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">final StorageManager storage = StorageManager.from(mContext);</div><div class=\"line\">final long lowThreshold = storage.getStorageLowBytes(</div><div class=\"line\">        Environment.getDataDirectory());</div><div class=\"line\"></div><div class=\"line\">final long sizeBytes = mContainerService.calculateInstalledSize(</div><div class=\"line\">        origin.resolvedPath, isForwardLocked(), packageAbiOverride);</div><div class=\"line\"></div><div class=\"line\">if (mInstaller.freeCache(null, sizeBytes + lowThreshold) &gt;= 0) &#123;</div><div class=\"line\">    pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,</div><div class=\"line\">            installFlags, packageAbiOverride);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。</p>\n<p>这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。</p>\n<p>中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                 /*</div><div class=\"line\">                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by</div><div class=\"line\">                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.</div><div class=\"line\">                 */</div><div class=\"line\">                int userIdentifier = getUser().getIdentifier();</div><div class=\"line\">                if (userIdentifier == UserHandle.USER_ALL</div><div class=\"line\">                        &amp;&amp; ((installFlags &amp; PackageManager.INSTALL_FROM_ADB) != 0)) &#123;</div><div class=\"line\">                    userIdentifier = UserHandle.USER_OWNER;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /*</div><div class=\"line\">                 * Determine if we have any installed package verifiers. If we</div><div class=\"line\">                 * do, then we&apos;ll defer to them to verify the packages.</div><div class=\"line\">                 */</div><div class=\"line\">                final int requiredUid = mRequiredVerifierPackage == null ? -1</div><div class=\"line\">                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);</div><div class=\"line\">                if (!origin.existing &amp;&amp; requiredUid != -1</div><div class=\"line\">                        &amp;&amp; isVerificationEnabled(userIdentifier, installFlags)) &#123;</div><div class=\"line\">                    final Intent verification = new Intent(</div><div class=\"line\">                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</div><div class=\"line\">                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),</div><div class=\"line\">                            PACKAGE_MIME_TYPE);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ResolveInfo&gt; receivers = queryIntentReceivers(verification,</div><div class=\"line\">                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,</div><div class=\"line\">                            0 /* TODO: Which userId? */);</div><div class=\"line\"></div><div class=\"line\">                    if (DEBUG_VERIFY) &#123;</div><div class=\"line\">                        Slog.d(TAG, &quot;Found &quot; + receivers.size() + &quot; verifiers for intent &quot;</div><div class=\"line\">                                + verification.toString() + &quot; with &quot; + pkgLite.verifiers.length</div><div class=\"line\">                                + &quot; optional verifiers&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final int verificationId = mPendingVerificationToken++;</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</div><div class=\"line\">                            installerPackageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,</div><div class=\"line\">                            installFlags);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,</div><div class=\"line\">                            pkgLite.packageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,</div><div class=\"line\">                            pkgLite.versionCode);</div><div class=\"line\"></div><div class=\"line\">                    if (verificationParams != null) &#123;</div><div class=\"line\">                        if (verificationParams.getVerificationURI() != null) &#123;</div><div class=\"line\">                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</div><div class=\"line\">                                 verificationParams.getVerificationURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingURI() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,</div><div class=\"line\">                                  verificationParams.getOriginatingURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getReferrer() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_REFERRER,</div><div class=\"line\">                                  verificationParams.getReferrer());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,</div><div class=\"line\">                                  verificationParams.getOriginatingUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getInstallerUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,</div><div class=\"line\">                                  verificationParams.getInstallerUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final PackageVerificationState verificationState = new PackageVerificationState(</div><div class=\"line\">                            requiredUid, args);</div><div class=\"line\"></div><div class=\"line\">                    mPendingVerification.append(verificationId, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite,</div><div class=\"line\">                            receivers, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    // Apps installed for &quot;all&quot; users use the device owner to verify the app</div><div class=\"line\">                    UserHandle verifierUser = getUser();</div><div class=\"line\">                    if (verifierUser == UserHandle.ALL) &#123;</div><div class=\"line\">                        verifierUser = UserHandle.OWNER;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    /*</div><div class=\"line\">                     * If any sufficient verifiers were listed in the package</div><div class=\"line\">                     * manifest, attempt to ask them.</div><div class=\"line\">                     */</div><div class=\"line\">                    if (sufficientVerifiers != null) &#123;</div><div class=\"line\">                        final int N = sufficientVerifiers.size();</div><div class=\"line\">                        if (N == 0) &#123;</div><div class=\"line\">                            Slog.i(TAG, &quot;Additional verifiers required, but none installed.&quot;);</div><div class=\"line\">                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            for (int i = 0; i &lt; N; i++) &#123;</div><div class=\"line\">                                final ComponentName verifierComponent = sufficientVerifiers.get(i);</div><div class=\"line\"></div><div class=\"line\">                                final Intent sufficientIntent = new Intent(verification);</div><div class=\"line\">                                sufficientIntent.setComponent(verifierComponent);</div><div class=\"line\">                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(</div><div class=\"line\">                            mRequiredVerifierPackage, receivers);</div><div class=\"line\">                    if (ret == PackageManager.INSTALL_SUCCEEDED</div><div class=\"line\">                            &amp;&amp; mRequiredVerifierPackage != null) &#123;</div><div class=\"line\">                        /*</div><div class=\"line\">                         * Send the intent to the required verification agent,</div><div class=\"line\">                         * but only start the verification timeout after the</div><div class=\"line\">                         * target BroadcastReceivers have run.</div><div class=\"line\">                         */</div><div class=\"line\">                        verification.setComponent(requiredVerifierComponent);</div><div class=\"line\">                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,</div><div class=\"line\">                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</div><div class=\"line\">                                new BroadcastReceiver() &#123;</div><div class=\"line\">                                    @Override</div><div class=\"line\">                                    public void onReceive(Context context, Intent intent) &#123;</div><div class=\"line\">                                        final Message msg = mHandler</div><div class=\"line\">                                                .obtainMessage(CHECK_PENDING_VERIFICATION);</div><div class=\"line\">                                        msg.arg1 = verificationId;</div><div class=\"line\">                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125;, null, 0, null, null);</div><div class=\"line\"></div><div class=\"line\">                        /*</div><div class=\"line\">                         * We don&apos;t want the copy to proceed until verification</div><div class=\"line\">                         * succeeds, so null out this field.</div><div class=\"line\">                         */</div><div class=\"line\">                        mArgs = null;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    /*</div><div class=\"line\">                     * No package verification is enabled, so immediately start</div><div class=\"line\">                     * the remote call to initiate copy using temporary file.</div><div class=\"line\">                     */</div><div class=\"line\">                    ret = args.copyApk(mContainerService, true);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果启动了包验证的话，就会进入验证阶段。 <ul>\n<li>发送有序广播， </li>\n</ul>\n</li>\n<li>否则，直接进行复制操作</li>\n</ul>\n<p>验证部分的逻辑很长，大部分代码都是对intent进行设置。</p>\n<h3 id=\"7-InstallArgs-copyApk\"><a href=\"#7-InstallArgs-copyApk\" class=\"headerlink\" title=\"7.InstallArgs#copyApk\"></a>7.InstallArgs#copyApk</h3><p>在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private InstallArgs createInstallArgs(InstallParams params) &#123;</div><div class=\"line\">    if (params.move != null) &#123;</div><div class=\"line\">        return new MoveInstallArgs(params);</div><div class=\"line\">    &#125; else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) &#123;</div><div class=\"line\">        return new AsecInstallArgs(params);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return new FileInstallArgs(params);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以FileInstallArgs为例，我们来看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException &#123;</div><div class=\"line\">     if (origin.staged) &#123;</div><div class=\"line\">         if (DEBUG_INSTALL) Slog.d(TAG, origin.file + &quot; already staged; skipping copy&quot;);</div><div class=\"line\">         codeFile = origin.file;</div><div class=\"line\">         resourceFile = origin.file;</div><div class=\"line\">         return PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);</div><div class=\"line\">         codeFile = tempDir;</div><div class=\"line\">         resourceFile = tempDir;</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.w(TAG, &quot;Failed to create copy file: &quot; + e);</div><div class=\"line\">         return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() &#123;</div><div class=\"line\">         @Override</div><div class=\"line\">         public ParcelFileDescriptor open(String name, int mode) throws RemoteException &#123;</div><div class=\"line\">             if (!FileUtils.isValidExtFilename(name)) &#123;</div><div class=\"line\">                 throw new IllegalArgumentException(&quot;Invalid filename: &quot; + name);</div><div class=\"line\">             &#125;</div><div class=\"line\">             try &#123;</div><div class=\"line\">                 final File file = new File(codeFile, name);</div><div class=\"line\">                 final FileDescriptor fd = Os.open(file.getAbsolutePath(),</div><div class=\"line\">                         O_RDWR | O_CREAT, 0644);</div><div class=\"line\">                 Os.chmod(file.getAbsolutePath(), 0644);</div><div class=\"line\">                 return new ParcelFileDescriptor(fd);</div><div class=\"line\">             &#125; catch (ErrnoException e) &#123;</div><div class=\"line\">                 throw new RemoteException(&quot;Failed to open: &quot; + e.getMessage());</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\"></div><div class=\"line\">     int ret = PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);</div><div class=\"line\">     if (ret != PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Failed to copy package&quot;);</div><div class=\"line\">         return ret;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final File libraryRoot = new File(codeFile, LIB_DIR_NAME);</div><div class=\"line\">     NativeLibraryHelper.Handle handle = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         handle = NativeLibraryHelper.Handle.create(codeFile);</div><div class=\"line\">         ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,</div><div class=\"line\">                 abiOverride);</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Copying native libraries failed&quot;, e);</div><div class=\"line\">         ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(handle);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     return ret;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先mInstallerService.allocateStageDirLegacy申请足够的存储空间</li>\n<li>得到申请的那部分空间的文件描述符，并且修改权限</li>\n<li>IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，</li>\n<li>NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)</li>\n</ul>\n<h3 id=\"8-DefaultContainerService-copyPackage\"><a href=\"#8-DefaultContainerService-copyPackage\" class=\"headerlink\" title=\"8.DefaultContainerService#copyPackage\"></a>8.DefaultContainerService#copyPackage</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) &#123;</div><div class=\"line\">    if (packagePath == null || target == null) &#123;</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INVALID_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    PackageLite pkg = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        final File packageFile = new File(packagePath);</div><div class=\"line\">        pkg = PackageParser.parsePackageLite(packageFile, 0);</div><div class=\"line\">        return copyPackageInner(pkg, target);</div><div class=\"line\">    &#125; catch (PackageParserException | IOException | RemoteException e) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Failed to copy package at &quot; + packagePath + &quot;: &quot; + e);</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>解析apk文件</li>\n<li>将文件拷贝到指定目录</li>\n</ul>\n<h3 id=\"9-NativeLibraryHelper-copyNativeBinariesWithOverride\"><a href=\"#9-NativeLibraryHelper-copyNativeBinariesWithOverride\" class=\"headerlink\" title=\"9.NativeLibraryHelper#copyNativeBinariesWithOverride\"></a>9.NativeLibraryHelper#copyNativeBinariesWithOverride</h3><p>在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。</p>\n<p>到现在，copy的流程就完了。</p>\n<p>在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。</p>\n<h3 id=\"10-InstallParams-handleReturnCode\"><a href=\"#10-InstallParams-handleReturnCode\" class=\"headerlink\" title=\"10.InstallParams#handleReturnCode\"></a>10.InstallParams#handleReturnCode</h3><p>在这个方法中，会调用processPendingInstall去处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123;</div><div class=\"line\">    // Queue up an async operation since the package installation may take a little while.</div><div class=\"line\">    mHandler.post(new Runnable() &#123;</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            mHandler.removeCallbacks(this);</div><div class=\"line\">             // Result object to be returned</div><div class=\"line\">            PackageInstalledInfo res = new PackageInstalledInfo();</div><div class=\"line\">            res.returnCode = currentStatus;</div><div class=\"line\">            res.uid = -1;</div><div class=\"line\">            res.pkg = null;</div><div class=\"line\">            res.removedInfo = new PackageRemovedInfo();</div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                args.doPreInstall(res.returnCode);</div><div class=\"line\">                synchronized (mInstallLock) &#123;</div><div class=\"line\">                    installPackageLI(args, res);</div><div class=\"line\">                &#125;</div><div class=\"line\">                args.doPostInstall(res.returnCode, res.uid);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // A restore should be performed at this point if (a) the install</div><div class=\"line\">            // succeeded, (b) the operation is not an update, and (c) the new</div><div class=\"line\">            // package has not opted out of backup participation.</div><div class=\"line\">            final boolean update = res.removedInfo.removedPackage != null;</div><div class=\"line\">            final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;</div><div class=\"line\">            boolean doRestore = !update</div><div class=\"line\">                    &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);</div><div class=\"line\"></div><div class=\"line\">            // Set up the post-install work request bookkeeping.  This will be used</div><div class=\"line\">            // and cleaned up by the post-install event handling regardless of whether</div><div class=\"line\">            // there&apos;s a restore pass performed.  Token values are &gt;= 1.</div><div class=\"line\">            int token;</div><div class=\"line\">            if (mNextInstallToken &lt; 0) mNextInstallToken = 1;</div><div class=\"line\">            token = mNextInstallToken++;</div><div class=\"line\"></div><div class=\"line\">            PostInstallData data = new PostInstallData(args, res);</div><div class=\"line\">            mRunningInstalls.put(token, data);</div><div class=\"line\">            if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token);</div><div class=\"line\"></div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123;</div><div class=\"line\">                // Pass responsibility to the Backup Manager.  It will perform a</div><div class=\"line\">                // restore if appropriate, then pass responsibility back to the</div><div class=\"line\">                // Package Manager to run the post-install observer callbacks</div><div class=\"line\">                // and broadcasts.</div><div class=\"line\">                IBackupManager bm = IBackupManager.Stub.asInterface(</div><div class=\"line\">                        ServiceManager.getService(Context.BACKUP_SERVICE));</div><div class=\"line\">                if (bm != null) &#123;</div><div class=\"line\">                    if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token</div><div class=\"line\">                            + &quot; to BM for possible restore&quot;);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) &#123;</div><div class=\"line\">                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            doRestore = false;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">                        // can&apos;t happen; the backup manager is local</div><div class=\"line\">                    &#125; catch (Exception e) &#123;</div><div class=\"line\">                        Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e);</div><div class=\"line\">                        doRestore = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    Slog.e(TAG, &quot;Backup Manager not found!&quot;);</div><div class=\"line\">                    doRestore = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!doRestore) &#123;</div><div class=\"line\">                // No restore possible, or the Backup Manager was mysteriously not</div><div class=\"line\">                // available -- just fire the post-install work request directly.</div><div class=\"line\">                if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);</div><div class=\"line\">                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</div><div class=\"line\">                mHandler.sendMessage(msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装过程</p>\n<ul>\n<li>installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。</li>\n<li>恢复部分代码 没看明白。😭</li>\n<li>发送POST_INSTALL消息</li>\n</ul>\n<h3 id=\"11-installPackageLI\"><a href=\"#11-installPackageLI\" class=\"headerlink\" title=\"11.installPackageLI\"></a>11.installPackageLI</h3><p>改方法氛围几部分。</p>\n<p>首先是解析包过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">PackageParser pp = new PackageParser();</div><div class=\"line\">pp.setSeparateProcesses(mSeparateProcesses);</div><div class=\"line\">pp.setDisplayMetrics(mMetrics);</div><div class=\"line\"></div><div class=\"line\">final PackageParser.Package pkg;</div><div class=\"line\">try &#123;</div><div class=\"line\">    pkg = pp.parsePackage(tmpPackageFile, parseFlags);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed parse during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其次是校验签名的md5的过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    pp.collectCertificates(pkg, parseFlags);</div><div class=\"line\">    pp.collectManifestDigest(pkg);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed collect during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* If the installer passed in a manifest digest, compare it now. */</div><div class=\"line\">if (args.manifestDigest != null) &#123;</div><div class=\"line\">    if (DEBUG_INSTALL) &#123;</div><div class=\"line\">        final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot;</div><div class=\"line\">                : pkg.manifestDigest.toString();</div><div class=\"line\">        Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot;</div><div class=\"line\">                + parsedManifest);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!args.manifestDigest.equals(pkg.manifestDigest)) &#123;</div><div class=\"line\">        res.setError(INSTALL_FAILED_PACKAGE_CHANGED, &quot;Manifest digest changed&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (DEBUG_INSTALL) &#123;</div><div class=\"line\">    final String parsedManifest = pkg.manifestDigest == null</div><div class=\"line\">            ? &quot;null&quot; : pkg.manifestDigest.toString();</div><div class=\"line\">    Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用installNewPackageLI安装。</p>\n<h3 id=\"12-installNewPackageLI\"><a href=\"#12-installNewPackageLI\" class=\"headerlink\" title=\"12.installNewPackageLI\"></a>12.installNewPackageLI</h3><p>在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。</p>\n<h3 id=\"13-处理POST-INSTALL消息\"><a href=\"#13-处理POST-INSTALL消息\" class=\"headerlink\" title=\"13.处理POST_INSTALL消息\"></a>13.处理POST_INSTALL消息</h3><p>略。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<p>以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，</p>\n<h3 id=\"2-安装器\"><a href=\"#2-安装器\" class=\"headerlink\" title=\"2.安装器\"></a>2.安装器</h3><p>显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (v == mOk) &#123;</div><div class=\"line\">    if (mOkCanInstall || mScrollView == null) &#123;</div><div class=\"line\">        mInstallFlowAnalytics.setInstallButtonClicked();</div><div class=\"line\">        if (mSessionId != -1) &#123;</div><div class=\"line\">            mInstaller.setPermissionsResult(mSessionId, true);</div><div class=\"line\"></div><div class=\"line\">            // We&apos;re only confirming permissions, so we don&apos;t really know how the</div><div class=\"line\">            // story ends; assume success.</div><div class=\"line\">            mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(</div><div class=\"line\">                    PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">            finish();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            startInstall();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mScrollView.pageScroll(View.FOCUS_DOWN);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        pm.installExistingPackage(mAppInfo.packageName);</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_FAILED_INVALID_APK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,</div><div class=\"line\">            installerPackageName, verificationParams, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>mPackageURI，安装应用的话，应该是file</li>\n<li>pm 为ApplicationPackageManager</li>\n</ul>\n<p>因此，我们看installPackageWithVerificationAndEncryption方法。</p>\n<h3 id=\"3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\"><a href=\"#3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\" class=\"headerlink\" title=\"3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\"></a>3.ApplicationPackageManager#installPackageWithVerificationAndEncryption</h3><p>在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static IPackageManager getPackageManager() &#123;</div><div class=\"line\">    if (sPackageManager != null) &#123;</div><div class=\"line\">        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</div><div class=\"line\">        return sPackageManager;</div><div class=\"line\">    &#125;</div><div class=\"line\">    IBinder b = ServiceManager.getService(&quot;package&quot;);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</div><div class=\"line\">    sPackageManager = IPackageManager.Stub.asInterface(b);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</div><div class=\"line\">    return sPackageManager;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从中可以看出，其binder服务端为PackageManagerService.</p>\n<h3 id=\"4-PackageManagerService-installPackage\"><a href=\"#4-PackageManagerService-installPackage\" class=\"headerlink\" title=\"4.PackageManagerService#installPackage\"></a>4.PackageManagerService#installPackage</h3><p>在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Message msg = mHandler.obtainMessage(INIT_COPY);</div><div class=\"line\">msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,</div><div class=\"line\">        null, verificationParams, user, packageAbiOverride, null);</div><div class=\"line\">mHandler.sendMessage(msg);</div></pre></td></tr></table></figure>\n<p>这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">case INIT_COPY: &#123;</div><div class=\"line\">    HandlerParams params = (HandlerParams) msg.obj;</div><div class=\"line\">    int idx = mPendingInstalls.size();</div><div class=\"line\">    if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params);</div><div class=\"line\">    // If a bind was already initiated we dont really</div><div class=\"line\">    // need to do anything. The pending install</div><div class=\"line\">    // will be processed later on.</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // If this is the only one pending we might</div><div class=\"line\">        // have to bind to the service again.</div><div class=\"line\">        if (!connectToService()) &#123;</div><div class=\"line\">            Slog.e(TAG, &quot;Failed to bind to media container service&quot;);</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Once we bind to the service, the first</div><div class=\"line\">            // pending request will be processed.</div><div class=\"line\">            mPendingInstalls.add(idx, params);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mPendingInstalls.add(idx, params);</div><div class=\"line\">        // Already bound to the service. Just make</div><div class=\"line\">        // sure we trigger off processing the first request.</div><div class=\"line\">        if (idx == 0) &#123;</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。<br>在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;);</div><div class=\"line\">if (msg.obj != null) &#123;</div><div class=\"line\">    mContainerService = (IMediaContainerService) msg.obj;</div><div class=\"line\">&#125;</div><div class=\"line\">if (mContainerService == null) &#123;</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // Something seriously wrong since we are not bound and we are not</div><div class=\"line\">        // waiting for connection. Bail out.</div><div class=\"line\">        Slog.e(TAG, &quot;Cannot bind to media container service&quot;);</div><div class=\"line\">        for (HandlerParams params : mPendingInstalls) &#123;</div><div class=\"line\">            // Indicate service bind error</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mPendingInstalls.clear();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Waiting to connect to media container service&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">    HandlerParams params = mPendingInstalls.get(0);</div><div class=\"line\">    if (params != null) &#123;</div><div class=\"line\">        if (params.startCopy()) &#123;</div><div class=\"line\">            // We are done...  look for more work or to</div><div class=\"line\">            // go idle.</div><div class=\"line\">            if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                    &quot;Checking for more work or unbind...&quot;);</div><div class=\"line\">            // Delete pending install</div><div class=\"line\">            if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">                mPendingInstalls.remove(0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (mPendingInstalls.size() == 0) &#123;</div><div class=\"line\">                if (mBound) &#123;</div><div class=\"line\">                    if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                            &quot;Posting delayed MCS_UNBIND&quot;);</div><div class=\"line\">                    removeMessages(MCS_UNBIND);</div><div class=\"line\">                    Message ubmsg = obtainMessage(MCS_UNBIND);</div><div class=\"line\">                    // Unbind after a little delay, to avoid</div><div class=\"line\">                    // continual thrashing.</div><div class=\"line\">                    sendMessageDelayed(ubmsg, 10000);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are more pending requests in queue.</div><div class=\"line\">                // Just post MCS_BOUND message to trigger processing</div><div class=\"line\">                // of next pending install.</div><div class=\"line\">                if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                        &quot;Posting MCS_BOUND for next work&quot;);</div><div class=\"line\">                mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // Should never happen ideally.</div><div class=\"line\">    Slog.w(TAG, &quot;Empty queue&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div></pre></td></tr></table></figure>\n<p>从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。</p>\n<h3 id=\"5-HandlerParams-startCopy\"><a href=\"#5-HandlerParams-startCopy\" class=\"headerlink\" title=\"5.HandlerParams#startCopy\"></a>5.HandlerParams#startCopy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean startCopy() &#123;</div><div class=\"line\">    boolean res;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);</div><div class=\"line\"></div><div class=\"line\">        if (++mRetries &gt; MAX_RETRIES) &#123;</div><div class=\"line\">            Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_GIVE_UP);</div><div class=\"line\">            handleServiceError();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            handleStartCopy();</div><div class=\"line\">            res = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);</div><div class=\"line\">        mHandler.sendEmptyMessage(MCS_RECONNECT);</div><div class=\"line\">        res = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    handleReturnCode();</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有重试机制。而handleStartCopy的实现在InstallParams中。</p>\n<h3 id=\"6-InstallParams-handleStartCopy\"><a href=\"#6-InstallParams-handleStartCopy\" class=\"headerlink\" title=\"6.InstallParams#handleStartCopy\"></a>6.InstallParams#handleStartCopy</h3><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">final StorageManager storage = StorageManager.from(mContext);</div><div class=\"line\">final long lowThreshold = storage.getStorageLowBytes(</div><div class=\"line\">        Environment.getDataDirectory());</div><div class=\"line\"></div><div class=\"line\">final long sizeBytes = mContainerService.calculateInstalledSize(</div><div class=\"line\">        origin.resolvedPath, isForwardLocked(), packageAbiOverride);</div><div class=\"line\"></div><div class=\"line\">if (mInstaller.freeCache(null, sizeBytes + lowThreshold) &gt;= 0) &#123;</div><div class=\"line\">    pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,</div><div class=\"line\">            installFlags, packageAbiOverride);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。</p>\n<p>这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。</p>\n<p>中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                 /*</div><div class=\"line\">                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by</div><div class=\"line\">                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.</div><div class=\"line\">                 */</div><div class=\"line\">                int userIdentifier = getUser().getIdentifier();</div><div class=\"line\">                if (userIdentifier == UserHandle.USER_ALL</div><div class=\"line\">                        &amp;&amp; ((installFlags &amp; PackageManager.INSTALL_FROM_ADB) != 0)) &#123;</div><div class=\"line\">                    userIdentifier = UserHandle.USER_OWNER;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /*</div><div class=\"line\">                 * Determine if we have any installed package verifiers. If we</div><div class=\"line\">                 * do, then we&apos;ll defer to them to verify the packages.</div><div class=\"line\">                 */</div><div class=\"line\">                final int requiredUid = mRequiredVerifierPackage == null ? -1</div><div class=\"line\">                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);</div><div class=\"line\">                if (!origin.existing &amp;&amp; requiredUid != -1</div><div class=\"line\">                        &amp;&amp; isVerificationEnabled(userIdentifier, installFlags)) &#123;</div><div class=\"line\">                    final Intent verification = new Intent(</div><div class=\"line\">                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</div><div class=\"line\">                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),</div><div class=\"line\">                            PACKAGE_MIME_TYPE);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ResolveInfo&gt; receivers = queryIntentReceivers(verification,</div><div class=\"line\">                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,</div><div class=\"line\">                            0 /* TODO: Which userId? */);</div><div class=\"line\"></div><div class=\"line\">                    if (DEBUG_VERIFY) &#123;</div><div class=\"line\">                        Slog.d(TAG, &quot;Found &quot; + receivers.size() + &quot; verifiers for intent &quot;</div><div class=\"line\">                                + verification.toString() + &quot; with &quot; + pkgLite.verifiers.length</div><div class=\"line\">                                + &quot; optional verifiers&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final int verificationId = mPendingVerificationToken++;</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</div><div class=\"line\">                            installerPackageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,</div><div class=\"line\">                            installFlags);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,</div><div class=\"line\">                            pkgLite.packageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,</div><div class=\"line\">                            pkgLite.versionCode);</div><div class=\"line\"></div><div class=\"line\">                    if (verificationParams != null) &#123;</div><div class=\"line\">                        if (verificationParams.getVerificationURI() != null) &#123;</div><div class=\"line\">                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</div><div class=\"line\">                                 verificationParams.getVerificationURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingURI() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,</div><div class=\"line\">                                  verificationParams.getOriginatingURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getReferrer() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_REFERRER,</div><div class=\"line\">                                  verificationParams.getReferrer());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,</div><div class=\"line\">                                  verificationParams.getOriginatingUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getInstallerUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,</div><div class=\"line\">                                  verificationParams.getInstallerUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final PackageVerificationState verificationState = new PackageVerificationState(</div><div class=\"line\">                            requiredUid, args);</div><div class=\"line\"></div><div class=\"line\">                    mPendingVerification.append(verificationId, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite,</div><div class=\"line\">                            receivers, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    // Apps installed for &quot;all&quot; users use the device owner to verify the app</div><div class=\"line\">                    UserHandle verifierUser = getUser();</div><div class=\"line\">                    if (verifierUser == UserHandle.ALL) &#123;</div><div class=\"line\">                        verifierUser = UserHandle.OWNER;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    /*</div><div class=\"line\">                     * If any sufficient verifiers were listed in the package</div><div class=\"line\">                     * manifest, attempt to ask them.</div><div class=\"line\">                     */</div><div class=\"line\">                    if (sufficientVerifiers != null) &#123;</div><div class=\"line\">                        final int N = sufficientVerifiers.size();</div><div class=\"line\">                        if (N == 0) &#123;</div><div class=\"line\">                            Slog.i(TAG, &quot;Additional verifiers required, but none installed.&quot;);</div><div class=\"line\">                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            for (int i = 0; i &lt; N; i++) &#123;</div><div class=\"line\">                                final ComponentName verifierComponent = sufficientVerifiers.get(i);</div><div class=\"line\"></div><div class=\"line\">                                final Intent sufficientIntent = new Intent(verification);</div><div class=\"line\">                                sufficientIntent.setComponent(verifierComponent);</div><div class=\"line\">                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(</div><div class=\"line\">                            mRequiredVerifierPackage, receivers);</div><div class=\"line\">                    if (ret == PackageManager.INSTALL_SUCCEEDED</div><div class=\"line\">                            &amp;&amp; mRequiredVerifierPackage != null) &#123;</div><div class=\"line\">                        /*</div><div class=\"line\">                         * Send the intent to the required verification agent,</div><div class=\"line\">                         * but only start the verification timeout after the</div><div class=\"line\">                         * target BroadcastReceivers have run.</div><div class=\"line\">                         */</div><div class=\"line\">                        verification.setComponent(requiredVerifierComponent);</div><div class=\"line\">                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,</div><div class=\"line\">                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</div><div class=\"line\">                                new BroadcastReceiver() &#123;</div><div class=\"line\">                                    @Override</div><div class=\"line\">                                    public void onReceive(Context context, Intent intent) &#123;</div><div class=\"line\">                                        final Message msg = mHandler</div><div class=\"line\">                                                .obtainMessage(CHECK_PENDING_VERIFICATION);</div><div class=\"line\">                                        msg.arg1 = verificationId;</div><div class=\"line\">                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125;, null, 0, null, null);</div><div class=\"line\"></div><div class=\"line\">                        /*</div><div class=\"line\">                         * We don&apos;t want the copy to proceed until verification</div><div class=\"line\">                         * succeeds, so null out this field.</div><div class=\"line\">                         */</div><div class=\"line\">                        mArgs = null;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    /*</div><div class=\"line\">                     * No package verification is enabled, so immediately start</div><div class=\"line\">                     * the remote call to initiate copy using temporary file.</div><div class=\"line\">                     */</div><div class=\"line\">                    ret = args.copyApk(mContainerService, true);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果启动了包验证的话，就会进入验证阶段。 <ul>\n<li>发送有序广播， </li>\n</ul>\n</li>\n<li>否则，直接进行复制操作</li>\n</ul>\n<p>验证部分的逻辑很长，大部分代码都是对intent进行设置。</p>\n<h3 id=\"7-InstallArgs-copyApk\"><a href=\"#7-InstallArgs-copyApk\" class=\"headerlink\" title=\"7.InstallArgs#copyApk\"></a>7.InstallArgs#copyApk</h3><p>在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private InstallArgs createInstallArgs(InstallParams params) &#123;</div><div class=\"line\">    if (params.move != null) &#123;</div><div class=\"line\">        return new MoveInstallArgs(params);</div><div class=\"line\">    &#125; else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) &#123;</div><div class=\"line\">        return new AsecInstallArgs(params);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return new FileInstallArgs(params);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以FileInstallArgs为例，我们来看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException &#123;</div><div class=\"line\">     if (origin.staged) &#123;</div><div class=\"line\">         if (DEBUG_INSTALL) Slog.d(TAG, origin.file + &quot; already staged; skipping copy&quot;);</div><div class=\"line\">         codeFile = origin.file;</div><div class=\"line\">         resourceFile = origin.file;</div><div class=\"line\">         return PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);</div><div class=\"line\">         codeFile = tempDir;</div><div class=\"line\">         resourceFile = tempDir;</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.w(TAG, &quot;Failed to create copy file: &quot; + e);</div><div class=\"line\">         return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() &#123;</div><div class=\"line\">         @Override</div><div class=\"line\">         public ParcelFileDescriptor open(String name, int mode) throws RemoteException &#123;</div><div class=\"line\">             if (!FileUtils.isValidExtFilename(name)) &#123;</div><div class=\"line\">                 throw new IllegalArgumentException(&quot;Invalid filename: &quot; + name);</div><div class=\"line\">             &#125;</div><div class=\"line\">             try &#123;</div><div class=\"line\">                 final File file = new File(codeFile, name);</div><div class=\"line\">                 final FileDescriptor fd = Os.open(file.getAbsolutePath(),</div><div class=\"line\">                         O_RDWR | O_CREAT, 0644);</div><div class=\"line\">                 Os.chmod(file.getAbsolutePath(), 0644);</div><div class=\"line\">                 return new ParcelFileDescriptor(fd);</div><div class=\"line\">             &#125; catch (ErrnoException e) &#123;</div><div class=\"line\">                 throw new RemoteException(&quot;Failed to open: &quot; + e.getMessage());</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\"></div><div class=\"line\">     int ret = PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);</div><div class=\"line\">     if (ret != PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Failed to copy package&quot;);</div><div class=\"line\">         return ret;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final File libraryRoot = new File(codeFile, LIB_DIR_NAME);</div><div class=\"line\">     NativeLibraryHelper.Handle handle = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         handle = NativeLibraryHelper.Handle.create(codeFile);</div><div class=\"line\">         ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,</div><div class=\"line\">                 abiOverride);</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Copying native libraries failed&quot;, e);</div><div class=\"line\">         ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(handle);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     return ret;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先mInstallerService.allocateStageDirLegacy申请足够的存储空间</li>\n<li>得到申请的那部分空间的文件描述符，并且修改权限</li>\n<li>IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，</li>\n<li>NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)</li>\n</ul>\n<h3 id=\"8-DefaultContainerService-copyPackage\"><a href=\"#8-DefaultContainerService-copyPackage\" class=\"headerlink\" title=\"8.DefaultContainerService#copyPackage\"></a>8.DefaultContainerService#copyPackage</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) &#123;</div><div class=\"line\">    if (packagePath == null || target == null) &#123;</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INVALID_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    PackageLite pkg = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        final File packageFile = new File(packagePath);</div><div class=\"line\">        pkg = PackageParser.parsePackageLite(packageFile, 0);</div><div class=\"line\">        return copyPackageInner(pkg, target);</div><div class=\"line\">    &#125; catch (PackageParserException | IOException | RemoteException e) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Failed to copy package at &quot; + packagePath + &quot;: &quot; + e);</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>解析apk文件</li>\n<li>将文件拷贝到指定目录</li>\n</ul>\n<h3 id=\"9-NativeLibraryHelper-copyNativeBinariesWithOverride\"><a href=\"#9-NativeLibraryHelper-copyNativeBinariesWithOverride\" class=\"headerlink\" title=\"9.NativeLibraryHelper#copyNativeBinariesWithOverride\"></a>9.NativeLibraryHelper#copyNativeBinariesWithOverride</h3><p>在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。</p>\n<p>到现在，copy的流程就完了。</p>\n<p>在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。</p>\n<h3 id=\"10-InstallParams-handleReturnCode\"><a href=\"#10-InstallParams-handleReturnCode\" class=\"headerlink\" title=\"10.InstallParams#handleReturnCode\"></a>10.InstallParams#handleReturnCode</h3><p>在这个方法中，会调用processPendingInstall去处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123;</div><div class=\"line\">    // Queue up an async operation since the package installation may take a little while.</div><div class=\"line\">    mHandler.post(new Runnable() &#123;</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            mHandler.removeCallbacks(this);</div><div class=\"line\">             // Result object to be returned</div><div class=\"line\">            PackageInstalledInfo res = new PackageInstalledInfo();</div><div class=\"line\">            res.returnCode = currentStatus;</div><div class=\"line\">            res.uid = -1;</div><div class=\"line\">            res.pkg = null;</div><div class=\"line\">            res.removedInfo = new PackageRemovedInfo();</div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                args.doPreInstall(res.returnCode);</div><div class=\"line\">                synchronized (mInstallLock) &#123;</div><div class=\"line\">                    installPackageLI(args, res);</div><div class=\"line\">                &#125;</div><div class=\"line\">                args.doPostInstall(res.returnCode, res.uid);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // A restore should be performed at this point if (a) the install</div><div class=\"line\">            // succeeded, (b) the operation is not an update, and (c) the new</div><div class=\"line\">            // package has not opted out of backup participation.</div><div class=\"line\">            final boolean update = res.removedInfo.removedPackage != null;</div><div class=\"line\">            final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;</div><div class=\"line\">            boolean doRestore = !update</div><div class=\"line\">                    &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);</div><div class=\"line\"></div><div class=\"line\">            // Set up the post-install work request bookkeeping.  This will be used</div><div class=\"line\">            // and cleaned up by the post-install event handling regardless of whether</div><div class=\"line\">            // there&apos;s a restore pass performed.  Token values are &gt;= 1.</div><div class=\"line\">            int token;</div><div class=\"line\">            if (mNextInstallToken &lt; 0) mNextInstallToken = 1;</div><div class=\"line\">            token = mNextInstallToken++;</div><div class=\"line\"></div><div class=\"line\">            PostInstallData data = new PostInstallData(args, res);</div><div class=\"line\">            mRunningInstalls.put(token, data);</div><div class=\"line\">            if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token);</div><div class=\"line\"></div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123;</div><div class=\"line\">                // Pass responsibility to the Backup Manager.  It will perform a</div><div class=\"line\">                // restore if appropriate, then pass responsibility back to the</div><div class=\"line\">                // Package Manager to run the post-install observer callbacks</div><div class=\"line\">                // and broadcasts.</div><div class=\"line\">                IBackupManager bm = IBackupManager.Stub.asInterface(</div><div class=\"line\">                        ServiceManager.getService(Context.BACKUP_SERVICE));</div><div class=\"line\">                if (bm != null) &#123;</div><div class=\"line\">                    if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token</div><div class=\"line\">                            + &quot; to BM for possible restore&quot;);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) &#123;</div><div class=\"line\">                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            doRestore = false;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">                        // can&apos;t happen; the backup manager is local</div><div class=\"line\">                    &#125; catch (Exception e) &#123;</div><div class=\"line\">                        Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e);</div><div class=\"line\">                        doRestore = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    Slog.e(TAG, &quot;Backup Manager not found!&quot;);</div><div class=\"line\">                    doRestore = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!doRestore) &#123;</div><div class=\"line\">                // No restore possible, or the Backup Manager was mysteriously not</div><div class=\"line\">                // available -- just fire the post-install work request directly.</div><div class=\"line\">                if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);</div><div class=\"line\">                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</div><div class=\"line\">                mHandler.sendMessage(msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装过程</p>\n<ul>\n<li>installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。</li>\n<li>恢复部分代码 没看明白。😭</li>\n<li>发送POST_INSTALL消息</li>\n</ul>\n<h3 id=\"11-installPackageLI\"><a href=\"#11-installPackageLI\" class=\"headerlink\" title=\"11.installPackageLI\"></a>11.installPackageLI</h3><p>改方法氛围几部分。</p>\n<p>首先是解析包过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">PackageParser pp = new PackageParser();</div><div class=\"line\">pp.setSeparateProcesses(mSeparateProcesses);</div><div class=\"line\">pp.setDisplayMetrics(mMetrics);</div><div class=\"line\"></div><div class=\"line\">final PackageParser.Package pkg;</div><div class=\"line\">try &#123;</div><div class=\"line\">    pkg = pp.parsePackage(tmpPackageFile, parseFlags);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed parse during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其次是校验签名的md5的过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    pp.collectCertificates(pkg, parseFlags);</div><div class=\"line\">    pp.collectManifestDigest(pkg);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed collect during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* If the installer passed in a manifest digest, compare it now. */</div><div class=\"line\">if (args.manifestDigest != null) &#123;</div><div class=\"line\">    if (DEBUG_INSTALL) &#123;</div><div class=\"line\">        final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot;</div><div class=\"line\">                : pkg.manifestDigest.toString();</div><div class=\"line\">        Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot;</div><div class=\"line\">                + parsedManifest);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!args.manifestDigest.equals(pkg.manifestDigest)) &#123;</div><div class=\"line\">        res.setError(INSTALL_FAILED_PACKAGE_CHANGED, &quot;Manifest digest changed&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (DEBUG_INSTALL) &#123;</div><div class=\"line\">    final String parsedManifest = pkg.manifestDigest == null</div><div class=\"line\">            ? &quot;null&quot; : pkg.manifestDigest.toString();</div><div class=\"line\">    Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用installNewPackageLI安装。</p>\n<h3 id=\"12-installNewPackageLI\"><a href=\"#12-installNewPackageLI\" class=\"headerlink\" title=\"12.installNewPackageLI\"></a>12.installNewPackageLI</h3><p>在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。</p>\n<h3 id=\"13-处理POST-INSTALL消息\"><a href=\"#13-处理POST-INSTALL消息\" class=\"headerlink\" title=\"13.处理POST_INSTALL消息\"></a>13.处理POST_INSTALL消息</h3><p>略。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android消息机制浅析","date":"2016-12-21T15:32:56.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.Looper、Handler、MessageQueue的关系\n* Looper 用于线程的消息循环,一个线程只能有一个Looper对象\n* Handler\n * 执行任务调度和发生一些操作（在未来某时刻）\n * 执行其他线程中的队列消息\n* MessageQueue 消息队列\n\n>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.Looper\n以主线程为例。Looper的初始化过程是这样的。\n代码地址： \n/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)\n```\nLooper.prepareMainLooper();\nxxxx\nLooper.loop();\n```\n而非UI线程的初始化过程\n```\nLooper.prepare()\nxxx\nLooper.loop();\n```\n不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。\n```\n\tprivate static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n接下来看Looper的构造方法\n```\n\tprivate Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。\n那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法\n```\nfinal Looper me = myLooper();\n```\n```\n\tpublic static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n```\n取出和当前线程对应的Looper对象\n```\n\tfor (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            msg.recycleUnchecked();\n        }\n    }\n```\n上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。\n\n### 3.Handler\n既然知道了Looper，那么我们需要知道消息是怎么来的。\n```\nMessage msg = new Message();\nmsg.what = xxx;\nmsg.obj = xxx;\nhandler.sendMessage(msg);\n```\n我们通常都是通过上面的步骤去发送的，所以，追踪下代码。\n\nsendMessage->sendMessageDelayed->sendMessageAtTime->enqueueMessage\n到这里就来到了一个关键点了，我们看下代码。\n```\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n   msg.target = this;\n   if (mAsynchronous) {\n        msg.setAsynchronous(true);\n   }\n   return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。\n```\nHandler target\n```\n好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。\n```\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n调用关系和初始化的关系有关。\n\n  *  Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法\n  * 初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法\n  * 否则，调用handlerMessage(msg)方法。\n\n回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。\n### 4.MessageQueue\n消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：\n```\n    boolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n上面的步骤是这样子的。\n\n* 判断是否关联了handler\n* 判断是否用过(已经插入到链表中的)\n* 当前队列是否处在退出状态\n * 退出状态  回收资源，插入链表失败\n * 不是退出状态\n \t * 改变Message的状态为已经use，并获取message的when时间\n \t * 在链表中找到合适的位置插入\n \t \t* 和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点\n \t \t* 死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾\n\n在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。\n```\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\n```\n * 假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message\n * 如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis\n * 不小于的话\n \t* 假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息\n \t* 否则，将mMessages(表头)指向msg.next(也是移除了该消息) \n\n * 下面的代码忽略(ps:我看不懂...)\n\n### 5.总结\n当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。\nAndroid中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n","source":"_posts/Android消息机制浅析.md","raw":"---\ntitle: Android消息机制浅析\ndate: 2016-12-21 23:32:56\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.Looper、Handler、MessageQueue的关系\n* Looper 用于线程的消息循环,一个线程只能有一个Looper对象\n* Handler\n * 执行任务调度和发生一些操作（在未来某时刻）\n * 执行其他线程中的队列消息\n* MessageQueue 消息队列\n\n>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.Looper\n以主线程为例。Looper的初始化过程是这样的。\n代码地址： \n/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)\n```\nLooper.prepareMainLooper();\nxxxx\nLooper.loop();\n```\n而非UI线程的初始化过程\n```\nLooper.prepare()\nxxx\nLooper.loop();\n```\n不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。\n```\n\tprivate static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n接下来看Looper的构造方法\n```\n\tprivate Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。\n那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法\n```\nfinal Looper me = myLooper();\n```\n```\n\tpublic static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n```\n取出和当前线程对应的Looper对象\n```\n\tfor (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            msg.recycleUnchecked();\n        }\n    }\n```\n上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。\n\n### 3.Handler\n既然知道了Looper，那么我们需要知道消息是怎么来的。\n```\nMessage msg = new Message();\nmsg.what = xxx;\nmsg.obj = xxx;\nhandler.sendMessage(msg);\n```\n我们通常都是通过上面的步骤去发送的，所以，追踪下代码。\n\nsendMessage->sendMessageDelayed->sendMessageAtTime->enqueueMessage\n到这里就来到了一个关键点了，我们看下代码。\n```\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n   msg.target = this;\n   if (mAsynchronous) {\n        msg.setAsynchronous(true);\n   }\n   return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。\n```\nHandler target\n```\n好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。\n```\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n调用关系和初始化的关系有关。\n\n  *  Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法\n  * 初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法\n  * 否则，调用handlerMessage(msg)方法。\n\n回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。\n### 4.MessageQueue\n消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：\n```\n    boolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n上面的步骤是这样子的。\n\n* 判断是否关联了handler\n* 判断是否用过(已经插入到链表中的)\n* 当前队列是否处在退出状态\n * 退出状态  回收资源，插入链表失败\n * 不是退出状态\n \t * 改变Message的状态为已经use，并获取message的when时间\n \t * 在链表中找到合适的位置插入\n \t \t* 和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点\n \t \t* 死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾\n\n在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。\n```\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\n```\n * 假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message\n * 如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis\n * 不小于的话\n \t* 假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息\n \t* 否则，将mMessages(表头)指向msg.next(也是移除了该消息) \n\n * 下面的代码忽略(ps:我看不懂...)\n\n### 5.总结\n当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。\nAndroid中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n","slug":"Android消息机制浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxj000v19fyx9gi6z2q","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-Looper、Handler、MessageQueue的关系\"><a href=\"#1-Looper、Handler、MessageQueue的关系\" class=\"headerlink\" title=\"1.Looper、Handler、MessageQueue的关系\"></a>1.Looper、Handler、MessageQueue的关系</h3><ul>\n<li>Looper 用于线程的消息循环,一个线程只能有一个Looper对象</li>\n<li>Handler<ul>\n<li>执行任务调度和发生一些操作（在未来某时刻）</li>\n<li>执行其他线程中的队列消息</li>\n</ul>\n</li>\n<li>MessageQueue 消息队列</li>\n</ul>\n<blockquote>\n<p>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。</p>\n</blockquote>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"2-Looper\"><a href=\"#2-Looper\" class=\"headerlink\" title=\"2.Looper\"></a>2.Looper</h3><p>以主线程为例。Looper的初始化过程是这样的。<br>代码地址：<br>/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepareMainLooper();</div><div class=\"line\">xxxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>而非UI线程的初始化过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepare()</div><div class=\"line\">xxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void prepare(boolean quitAllowed) &#123;</div><div class=\"line\">       if (sThreadLocal.get() != null) &#123;</div><div class=\"line\">           throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       sThreadLocal.set(new Looper(quitAllowed));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>接下来看Looper的构造方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Looper(boolean quitAllowed) &#123;</div><div class=\"line\">       mQueue = new MessageQueue(quitAllowed);</div><div class=\"line\">       mThread = Thread.currentThread();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。<br>那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Looper me = myLooper();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static @Nullable Looper myLooper() &#123;</div><div class=\"line\">       return sThreadLocal.get();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>取出和当前线程对应的Looper对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">           Message msg = queue.next(); // might block</div><div class=\"line\">           if (msg == null) &#123;</div><div class=\"line\">               // No message indicates that the message queue is quitting.</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">           if (logging != null) &#123;</div><div class=\"line\">               logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Make sure that during the course of dispatching the</div><div class=\"line\">           // identity of the thread wasn&apos;t corrupted.</div><div class=\"line\">           final long newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">           msg.recycleUnchecked();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。</p>\n<h3 id=\"3-Handler\"><a href=\"#3-Handler\" class=\"headerlink\" title=\"3.Handler\"></a>3.Handler</h3><p>既然知道了Looper，那么我们需要知道消息是怎么来的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Message msg = new Message();</div><div class=\"line\">msg.what = xxx;</div><div class=\"line\">msg.obj = xxx;</div><div class=\"line\">handler.sendMessage(msg);</div></pre></td></tr></table></figure></p>\n<p>我们通常都是通过上面的步骤去发送的，所以，追踪下代码。</p>\n<p>sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage<br>到这里就来到了一个关键点了，我们看下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class=\"line\">   msg.target = this;</div><div class=\"line\">   if (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(true);</div><div class=\"line\">   &#125;</div><div class=\"line\">   return queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Handler target</div></pre></td></tr></table></figure></p>\n<p>好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void dispatchMessage(Message msg) &#123;</div><div class=\"line\">    if (msg.callback != null) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (mCallback != null) &#123;</div><div class=\"line\">            if (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用关系和初始化的关系有关。</p>\n<ul>\n<li>Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法</li>\n<li>初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法</li>\n<li>否则，调用handlerMessage(msg)方法。</li>\n</ul>\n<p>回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。</p>\n<h3 id=\"4-MessageQueue\"><a href=\"#4-MessageQueue\" class=\"headerlink\" title=\"4.MessageQueue\"></a>4.MessageQueue</h3><p>消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean enqueueMessage(Message msg, long when) &#123;</div><div class=\"line\">    if (msg.target == null) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg.isInUse()) &#123;</div><div class=\"line\">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        if (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = new IllegalStateException(</div><div class=\"line\">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class=\"line\">            Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        boolean needWake;</div><div class=\"line\">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class=\"line\">            // New head, wake up the event queue if blocked.</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class=\"line\">            // up the event queue unless there is a barrier at the head of the queue</div><div class=\"line\">            // and the message is the earliest asynchronous message in the queue.</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">            for (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">                if (p == null || when &lt; p.when) &#123;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = p; // invariant: p == prev.next</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We can assume mPtr != 0 because mQuitting is false.</div><div class=\"line\">        if (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的步骤是这样子的。</p>\n<ul>\n<li>判断是否关联了handler</li>\n<li>判断是否用过(已经插入到链表中的)</li>\n<li>当前队列是否处在退出状态<ul>\n<li>退出状态  回收资源，插入链表失败</li>\n<li>不是退出状态<ul>\n<li>改变Message的状态为已经use，并获取message的when时间</li>\n<li>在链表中找到合适的位置插入<ul>\n<li>和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点</li>\n<li>死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">Message prevMsg = null;</div><div class=\"line\">Message msg = mMessages;</div><div class=\"line\">if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class=\"line\">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class=\"line\">    do &#123;</div><div class=\"line\">        prevMsg = msg;</div><div class=\"line\">        msg = msg.next;</div><div class=\"line\">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg != null) &#123;</div><div class=\"line\">    if (now &lt; msg.when) &#123;</div><div class=\"line\">        // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class=\"line\">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Got a message.</div><div class=\"line\">        mBlocked = false;</div><div class=\"line\">        if (prevMsg != null) &#123;</div><div class=\"line\">            prevMsg.next = msg.next;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mMessages = msg.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg.next = null;</div><div class=\"line\">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        return msg;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // No more messages.</div><div class=\"line\">    nextPollTimeoutMillis = -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message</li>\n<li>如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis</li>\n<li><p>不小于的话</p>\n<ul>\n<li>假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息</li>\n<li>否则，将mMessages(表头)指向msg.next(也是移除了该消息) </li>\n</ul>\n</li>\n<li><p>下面的代码忽略(ps:我看不懂…)</p>\n</li>\n</ul>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><p>当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。<br>Android中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-Looper、Handler、MessageQueue的关系\"><a href=\"#1-Looper、Handler、MessageQueue的关系\" class=\"headerlink\" title=\"1.Looper、Handler、MessageQueue的关系\"></a>1.Looper、Handler、MessageQueue的关系</h3><ul>\n<li>Looper 用于线程的消息循环,一个线程只能有一个Looper对象</li>\n<li>Handler<ul>\n<li>执行任务调度和发生一些操作（在未来某时刻）</li>\n<li>执行其他线程中的队列消息</li>\n</ul>\n</li>\n<li>MessageQueue 消息队列</li>\n</ul>\n<blockquote>\n<p>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。</p>\n</blockquote>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"2-Looper\"><a href=\"#2-Looper\" class=\"headerlink\" title=\"2.Looper\"></a>2.Looper</h3><p>以主线程为例。Looper的初始化过程是这样的。<br>代码地址：<br>/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepareMainLooper();</div><div class=\"line\">xxxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>而非UI线程的初始化过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepare()</div><div class=\"line\">xxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void prepare(boolean quitAllowed) &#123;</div><div class=\"line\">       if (sThreadLocal.get() != null) &#123;</div><div class=\"line\">           throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       sThreadLocal.set(new Looper(quitAllowed));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>接下来看Looper的构造方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Looper(boolean quitAllowed) &#123;</div><div class=\"line\">       mQueue = new MessageQueue(quitAllowed);</div><div class=\"line\">       mThread = Thread.currentThread();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。<br>那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Looper me = myLooper();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static @Nullable Looper myLooper() &#123;</div><div class=\"line\">       return sThreadLocal.get();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>取出和当前线程对应的Looper对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">           Message msg = queue.next(); // might block</div><div class=\"line\">           if (msg == null) &#123;</div><div class=\"line\">               // No message indicates that the message queue is quitting.</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">           if (logging != null) &#123;</div><div class=\"line\">               logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Make sure that during the course of dispatching the</div><div class=\"line\">           // identity of the thread wasn&apos;t corrupted.</div><div class=\"line\">           final long newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">           msg.recycleUnchecked();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。</p>\n<h3 id=\"3-Handler\"><a href=\"#3-Handler\" class=\"headerlink\" title=\"3.Handler\"></a>3.Handler</h3><p>既然知道了Looper，那么我们需要知道消息是怎么来的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Message msg = new Message();</div><div class=\"line\">msg.what = xxx;</div><div class=\"line\">msg.obj = xxx;</div><div class=\"line\">handler.sendMessage(msg);</div></pre></td></tr></table></figure></p>\n<p>我们通常都是通过上面的步骤去发送的，所以，追踪下代码。</p>\n<p>sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage<br>到这里就来到了一个关键点了，我们看下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class=\"line\">   msg.target = this;</div><div class=\"line\">   if (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(true);</div><div class=\"line\">   &#125;</div><div class=\"line\">   return queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Handler target</div></pre></td></tr></table></figure></p>\n<p>好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void dispatchMessage(Message msg) &#123;</div><div class=\"line\">    if (msg.callback != null) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (mCallback != null) &#123;</div><div class=\"line\">            if (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用关系和初始化的关系有关。</p>\n<ul>\n<li>Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法</li>\n<li>初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法</li>\n<li>否则，调用handlerMessage(msg)方法。</li>\n</ul>\n<p>回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。</p>\n<h3 id=\"4-MessageQueue\"><a href=\"#4-MessageQueue\" class=\"headerlink\" title=\"4.MessageQueue\"></a>4.MessageQueue</h3><p>消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean enqueueMessage(Message msg, long when) &#123;</div><div class=\"line\">    if (msg.target == null) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg.isInUse()) &#123;</div><div class=\"line\">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        if (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = new IllegalStateException(</div><div class=\"line\">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class=\"line\">            Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        boolean needWake;</div><div class=\"line\">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class=\"line\">            // New head, wake up the event queue if blocked.</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class=\"line\">            // up the event queue unless there is a barrier at the head of the queue</div><div class=\"line\">            // and the message is the earliest asynchronous message in the queue.</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">            for (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">                if (p == null || when &lt; p.when) &#123;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = p; // invariant: p == prev.next</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We can assume mPtr != 0 because mQuitting is false.</div><div class=\"line\">        if (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的步骤是这样子的。</p>\n<ul>\n<li>判断是否关联了handler</li>\n<li>判断是否用过(已经插入到链表中的)</li>\n<li>当前队列是否处在退出状态<ul>\n<li>退出状态  回收资源，插入链表失败</li>\n<li>不是退出状态<ul>\n<li>改变Message的状态为已经use，并获取message的when时间</li>\n<li>在链表中找到合适的位置插入<ul>\n<li>和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点</li>\n<li>死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">Message prevMsg = null;</div><div class=\"line\">Message msg = mMessages;</div><div class=\"line\">if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class=\"line\">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class=\"line\">    do &#123;</div><div class=\"line\">        prevMsg = msg;</div><div class=\"line\">        msg = msg.next;</div><div class=\"line\">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg != null) &#123;</div><div class=\"line\">    if (now &lt; msg.when) &#123;</div><div class=\"line\">        // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class=\"line\">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Got a message.</div><div class=\"line\">        mBlocked = false;</div><div class=\"line\">        if (prevMsg != null) &#123;</div><div class=\"line\">            prevMsg.next = msg.next;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mMessages = msg.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg.next = null;</div><div class=\"line\">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        return msg;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // No more messages.</div><div class=\"line\">    nextPollTimeoutMillis = -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message</li>\n<li>如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis</li>\n<li><p>不小于的话</p>\n<ul>\n<li>假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息</li>\n<li>否则，将mMessages(表头)指向msg.next(也是移除了该消息) </li>\n</ul>\n</li>\n<li><p>下面的代码忽略(ps:我看不懂…)</p>\n</li>\n</ul>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><p>当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。<br>Android中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android消息机制－native层","date":"2016-12-24T08:25:04.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2.初始化\n\n在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。\n\n首先，我们先看下方法表：\n\n```\nstatic JNINativeMethod gMessageQueueMethods[] = {\n    /* name, signature, funcPtr */\n    { \"nativeInit\", \"()J\", (void*)android_os_MessageQueue_nativeInit },\n    { \"nativeDestroy\", \"(J)V\", (void*)android_os_MessageQueue_nativeDestroy },\n    { \"nativePollOnce\", \"(JI)V\", (void*)android_os_MessageQueue_nativePollOnce },\n    { \"nativeWake\", \"(J)V\", (void*)android_os_MessageQueue_nativeWake },\n    { \"nativeIsPolling\", \"(J)Z\", (void*)android_os_MessageQueue_nativeIsPolling },\n    { \"nativeSetFileDescriptorEvents\", \"(JII)V\",\n            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },\n};\n```\n\n\n因为前面有介绍jni的相关知识，这里就不多说了。\n\n从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.\n\n```\nstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n    if (!nativeMessageQueue) {\n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");\n        return 0;\n    }\n\n    nativeMessageQueue->incStrong(env);\n    return reinterpret_cast<jlong>(nativeMessageQueue);\n}\n```\n\n\n* 初始化NativeMessageQueue\n* 并且返回给java层，也就是java层的mPtr\n\n那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。\n\n```\nNativeMessageQueue::NativeMessageQueue() :\n        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n        mLooper = new Looper(false);\n        Looper::setForThread(mLooper);\n    }\n}\n```\n\n* 构造native层的looper，注意，这个和java层的没有任何关系\n* 保存在类似ThreadLocal一样的结构里。\n\nLooper的构造函数在Looper.cpp中。\n\n```\nLooper::Looper(bool allowNonCallbacks) :\n        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),\n        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),\n        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {\n    mWakeEventFd = eventfd(0, EFD_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(mWakeEventFd < 0, \"Could not make wake event fd.  errno=%d\", errno);\n\n    AutoMutex _l(mLock);\n    rebuildEpollLocked();\n}\n```\n\n* eventfd构造欢迎时间的fd\n* rebuildEpollLocked 重建epoll\n\nepoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：\n\n* 监视的描述符数量不受限制\n* IO效率不会随着监视fd的数量增长而下降\n\n关于epoll的更多内容，这里就不介绍了。\n\n那么，在我们native的looper里面，是如何重建的呢？\n\n```\nvoid Looper::rebuildEpollLocked() {\n    // Close old epoll instance if we have one.\n    if (mEpollFd >= 0) {\n#if DEBUG_CALLBACKS\n        ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);\n#endif\n        close(mEpollFd);\n    }\n\n    // Allocate the new epoll instance and register the wake pipe.\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance.  errno=%d\", errno);\n\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;\n    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance.  errno=%d\",\n            errno);\n\n    for (size_t i = 0; i < mRequests.size(); i++) {\n        const Request& request = mRequests.valueAt(i);\n        struct epoll_event eventItem;\n        request.initEventItem(&eventItem);\n\n        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, & eventItem);\n        if (epollResult < 0) {\n            ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d\",\n                    request.fd, errno);\n        }\n    }\n}\n```\n\n* epoll_create，创建epoll句柄\n* memset 将数据区域至0\n* eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。\n* epoll_ctl添加唤醒事件\n* 循环将mRequests中的事件都添加进去。\n\n### 3. nativePollOnce\n\n在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。\n\nandroid_os_MessageQueue_nativePollOnce->pollOnce->Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)\n\n\n\n```\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != NULL) *outFd = fd;\n                if (outEvents != NULL) *outEvents = events;\n                if (outData != NULL) *outData = data;\n                return ident;\n            }\n        }\n\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != NULL) *outFd = 0;\n            if (outEvents != NULL) *outEvents = 0;\n            if (outData != NULL) *outData = NULL;\n            return result;\n        }\n\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n这个方法的参数含义：\n\n* timeoutMillis 超时等待时间，-1无限等待，0立即返回\n* outFd 发生事件的文件描述符\n* outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,\n* outData 存储上下文数据\n\n返回值的含义如下：\n\n* ALOOPER_POLL_WAKE 表示由wake触发\n* ALOOPER_POLL_TIMEOUT 等待超时\n* ALOOPER_POLL_ERROR 等待过程中发生错误\n* ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发\n\n这个方法的处理逻辑如下：\n\n* 先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)\n* pollInner 处理内部轮询\n\n\npollInner方法很长，\n\n* toMillisecondTimeoutDelay 重新计算超时时间\n* epoll_wait 等待\n* 如果需要，重建epoll\n* epoll_wait函数返回，三种情况\n\t* eventCount<0 发生错误，goto Done\n\t* eventCount=0 连接超时 goto Done\n\t* 监听到有事件发生，\n* 如果有事件发生，则循环处理\n\t* 如果是mWakeEventFd，则进行awoken唤醒\n\t* pushResponse，根据request构建response，并添加到response数组中\n* Done 标志，事件处理\n\t* handleMessage 先处理native的message\n\t* handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。 \t\n\t\n\n### 4.nativeWake\n\n同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。\n\n在native层通过层层调用，会调用到looper的wake方法中。\n\n```\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(\"Could not write wake signal, errno=%d\", errno);\n        }\n    }\n}\n``` \n\n* 向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。\n\n### 补充\n\n\n当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/Android消息机制－native层.md","raw":"---\ntitle: Android消息机制－native层\ndate: 2016-12-24 16:25:04\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2.初始化\n\n在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。\n\n首先，我们先看下方法表：\n\n```\nstatic JNINativeMethod gMessageQueueMethods[] = {\n    /* name, signature, funcPtr */\n    { \"nativeInit\", \"()J\", (void*)android_os_MessageQueue_nativeInit },\n    { \"nativeDestroy\", \"(J)V\", (void*)android_os_MessageQueue_nativeDestroy },\n    { \"nativePollOnce\", \"(JI)V\", (void*)android_os_MessageQueue_nativePollOnce },\n    { \"nativeWake\", \"(J)V\", (void*)android_os_MessageQueue_nativeWake },\n    { \"nativeIsPolling\", \"(J)Z\", (void*)android_os_MessageQueue_nativeIsPolling },\n    { \"nativeSetFileDescriptorEvents\", \"(JII)V\",\n            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },\n};\n```\n\n\n因为前面有介绍jni的相关知识，这里就不多说了。\n\n从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.\n\n```\nstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n    if (!nativeMessageQueue) {\n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");\n        return 0;\n    }\n\n    nativeMessageQueue->incStrong(env);\n    return reinterpret_cast<jlong>(nativeMessageQueue);\n}\n```\n\n\n* 初始化NativeMessageQueue\n* 并且返回给java层，也就是java层的mPtr\n\n那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。\n\n```\nNativeMessageQueue::NativeMessageQueue() :\n        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n        mLooper = new Looper(false);\n        Looper::setForThread(mLooper);\n    }\n}\n```\n\n* 构造native层的looper，注意，这个和java层的没有任何关系\n* 保存在类似ThreadLocal一样的结构里。\n\nLooper的构造函数在Looper.cpp中。\n\n```\nLooper::Looper(bool allowNonCallbacks) :\n        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),\n        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),\n        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {\n    mWakeEventFd = eventfd(0, EFD_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(mWakeEventFd < 0, \"Could not make wake event fd.  errno=%d\", errno);\n\n    AutoMutex _l(mLock);\n    rebuildEpollLocked();\n}\n```\n\n* eventfd构造欢迎时间的fd\n* rebuildEpollLocked 重建epoll\n\nepoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：\n\n* 监视的描述符数量不受限制\n* IO效率不会随着监视fd的数量增长而下降\n\n关于epoll的更多内容，这里就不介绍了。\n\n那么，在我们native的looper里面，是如何重建的呢？\n\n```\nvoid Looper::rebuildEpollLocked() {\n    // Close old epoll instance if we have one.\n    if (mEpollFd >= 0) {\n#if DEBUG_CALLBACKS\n        ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);\n#endif\n        close(mEpollFd);\n    }\n\n    // Allocate the new epoll instance and register the wake pipe.\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance.  errno=%d\", errno);\n\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;\n    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance.  errno=%d\",\n            errno);\n\n    for (size_t i = 0; i < mRequests.size(); i++) {\n        const Request& request = mRequests.valueAt(i);\n        struct epoll_event eventItem;\n        request.initEventItem(&eventItem);\n\n        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, & eventItem);\n        if (epollResult < 0) {\n            ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d\",\n                    request.fd, errno);\n        }\n    }\n}\n```\n\n* epoll_create，创建epoll句柄\n* memset 将数据区域至0\n* eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。\n* epoll_ctl添加唤醒事件\n* 循环将mRequests中的事件都添加进去。\n\n### 3. nativePollOnce\n\n在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。\n\nandroid_os_MessageQueue_nativePollOnce->pollOnce->Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)\n\n\n\n```\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != NULL) *outFd = fd;\n                if (outEvents != NULL) *outEvents = events;\n                if (outData != NULL) *outData = data;\n                return ident;\n            }\n        }\n\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != NULL) *outFd = 0;\n            if (outEvents != NULL) *outEvents = 0;\n            if (outData != NULL) *outData = NULL;\n            return result;\n        }\n\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n这个方法的参数含义：\n\n* timeoutMillis 超时等待时间，-1无限等待，0立即返回\n* outFd 发生事件的文件描述符\n* outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,\n* outData 存储上下文数据\n\n返回值的含义如下：\n\n* ALOOPER_POLL_WAKE 表示由wake触发\n* ALOOPER_POLL_TIMEOUT 等待超时\n* ALOOPER_POLL_ERROR 等待过程中发生错误\n* ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发\n\n这个方法的处理逻辑如下：\n\n* 先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)\n* pollInner 处理内部轮询\n\n\npollInner方法很长，\n\n* toMillisecondTimeoutDelay 重新计算超时时间\n* epoll_wait 等待\n* 如果需要，重建epoll\n* epoll_wait函数返回，三种情况\n\t* eventCount<0 发生错误，goto Done\n\t* eventCount=0 连接超时 goto Done\n\t* 监听到有事件发生，\n* 如果有事件发生，则循环处理\n\t* 如果是mWakeEventFd，则进行awoken唤醒\n\t* pushResponse，根据request构建response，并添加到response数组中\n* Done 标志，事件处理\n\t* handleMessage 先处理native的message\n\t* handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。 \t\n\t\n\n### 4.nativeWake\n\n同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。\n\n在native层通过层层调用，会调用到looper的wake方法中。\n\n```\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(\"Could not write wake signal, errno=%d\", errno);\n        }\n    }\n}\n``` \n\n* 向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。\n\n### 补充\n\n\n当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"Android消息机制－native层","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxk000y19fy7ktk6vus","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><p>在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。</p>\n<p>首先，我们先看下方法表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class=\"line\">    /* name, signature, funcPtr */</div><div class=\"line\">    &#123; &quot;nativeInit&quot;, &quot;()J&quot;, (void*)android_os_MessageQueue_nativeInit &#125;,</div><div class=\"line\">    &#123; &quot;nativeDestroy&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class=\"line\">    &#123; &quot;nativePollOnce&quot;, &quot;(JI)V&quot;, (void*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class=\"line\">    &#123; &quot;nativeWake&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeWake &#125;,</div><div class=\"line\">    &#123; &quot;nativeIsPolling&quot;, &quot;(J)Z&quot;, (void*)android_os_MessageQueue_nativeIsPolling &#125;,</div><div class=\"line\">    &#123; &quot;nativeSetFileDescriptorEvents&quot;, &quot;(JII)V&quot;,</div><div class=\"line\">            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>因为前面有介绍jni的相关知识，这里就不多说了。</p>\n<p>从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</div><div class=\"line\">    if (!nativeMessageQueue) &#123;</div><div class=\"line\">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    nativeMessageQueue-&gt;incStrong(env);</div><div class=\"line\">    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化NativeMessageQueue</li>\n<li>并且返回给java层，也就是java层的mPtr</li>\n</ul>\n<p>那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMessageQueue::NativeMessageQueue() :</div><div class=\"line\">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</div><div class=\"line\">    mLooper = Looper::getForThread();</div><div class=\"line\">    if (mLooper == NULL) &#123;</div><div class=\"line\">        mLooper = new Looper(false);</div><div class=\"line\">        Looper::setForThread(mLooper);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造native层的looper，注意，这个和java层的没有任何关系</li>\n<li>保存在类似ThreadLocal一样的结构里。</li>\n</ul>\n<p>Looper的构造函数在Looper.cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper::Looper(bool allowNonCallbacks) :</div><div class=\"line\">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</div><div class=\"line\">        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),</div><div class=\"line\">        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</div><div class=\"line\">    mWakeEventFd = eventfd(0, EFD_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, &quot;Could not make wake event fd.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\">    rebuildEpollLocked();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>eventfd构造欢迎时间的fd</li>\n<li>rebuildEpollLocked 重建epoll</li>\n</ul>\n<p>epoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：</p>\n<ul>\n<li>监视的描述符数量不受限制</li>\n<li>IO效率不会随着监视fd的数量增长而下降</li>\n</ul>\n<p>关于epoll的更多内容，这里就不介绍了。</p>\n<p>那么，在我们native的looper里面，是如何重建的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Looper::rebuildEpollLocked() &#123;</div><div class=\"line\">    // Close old epoll instance if we have one.</div><div class=\"line\">    if (mEpollFd &gt;= 0) &#123;</div><div class=\"line\">#if DEBUG_CALLBACKS</div><div class=\"line\">        ALOGD(&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;, this);</div><div class=\"line\">#endif</div><div class=\"line\">        close(mEpollFd);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Allocate the new epoll instance and register the wake pipe.</div><div class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    struct epoll_event eventItem;</div><div class=\"line\">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</div><div class=\"line\">    eventItem.events = EPOLLIN;</div><div class=\"line\">    eventItem.data.fd = mWakeEventFd;</div><div class=\"line\">    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; mRequests.size(); i++) &#123;</div><div class=\"line\">        const Request&amp; request = mRequests.valueAt(i);</div><div class=\"line\">        struct epoll_event eventItem;</div><div class=\"line\">        request.initEventItem(&amp;eventItem);</div><div class=\"line\"></div><div class=\"line\">        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</div><div class=\"line\">        if (epollResult &lt; 0) &#123;</div><div class=\"line\">            ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set, errno=%d&quot;,</div><div class=\"line\">                    request.fd, errno);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>epoll_create，创建epoll句柄</li>\n<li>memset 将数据区域至0</li>\n<li>eventItem.events = EPOLLIN;<br>  eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。</li>\n<li>epoll_ctl添加唤醒事件</li>\n<li>循环将mRequests中的事件都添加进去。</li>\n</ul>\n<h3 id=\"3-nativePollOnce\"><a href=\"#3-nativePollOnce\" class=\"headerlink\" title=\"3. nativePollOnce\"></a>3. nativePollOnce</h3><p>在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。</p>\n<p>android_os_MessageQueue_nativePollOnce-&gt;pollOnce-&gt;Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class=\"line\">    int result = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class=\"line\">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class=\"line\">            int ident = response.request.ident;</div><div class=\"line\">            if (ident &gt;= 0) &#123;</div><div class=\"line\">                int fd = response.request.fd;</div><div class=\"line\">                int events = response.events;</div><div class=\"line\">                void* data = response.request.data;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class=\"line\">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class=\"line\">                        this, ident, fd, events, data);</div><div class=\"line\">#endif</div><div class=\"line\">                if (outFd != NULL) *outFd = fd;</div><div class=\"line\">                if (outEvents != NULL) *outEvents = events;</div><div class=\"line\">                if (outData != NULL) *outData = data;</div><div class=\"line\">                return ident;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (result != 0) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class=\"line\">#endif</div><div class=\"line\">            if (outFd != NULL) *outFd = 0;</div><div class=\"line\">            if (outEvents != NULL) *outEvents = 0;</div><div class=\"line\">            if (outData != NULL) *outData = NULL;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        result = pollInner(timeoutMillis);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的参数含义：</p>\n<ul>\n<li>timeoutMillis 超时等待时间，-1无限等待，0立即返回</li>\n<li>outFd 发生事件的文件描述符</li>\n<li>outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,</li>\n<li>outData 存储上下文数据</li>\n</ul>\n<p>返回值的含义如下：</p>\n<ul>\n<li>ALOOPER_POLL_WAKE 表示由wake触发</li>\n<li>ALOOPER_POLL_TIMEOUT 等待超时</li>\n<li>ALOOPER_POLL_ERROR 等待过程中发生错误</li>\n<li>ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发</li>\n</ul>\n<p>这个方法的处理逻辑如下：</p>\n<ul>\n<li>先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)</li>\n<li>pollInner 处理内部轮询</li>\n</ul>\n<p>pollInner方法很长，</p>\n<ul>\n<li>toMillisecondTimeoutDelay 重新计算超时时间</li>\n<li>epoll_wait 等待</li>\n<li>如果需要，重建epoll</li>\n<li>epoll_wait函数返回，三种情况<ul>\n<li>eventCount&lt;0 发生错误，goto Done</li>\n<li>eventCount=0 连接超时 goto Done</li>\n<li>监听到有事件发生，</li>\n</ul>\n</li>\n<li>如果有事件发生，则循环处理<ul>\n<li>如果是mWakeEventFd，则进行awoken唤醒</li>\n<li>pushResponse，根据request构建response，并添加到response数组中</li>\n</ul>\n</li>\n<li>Done 标志，事件处理<ul>\n<li>handleMessage 先处理native的message</li>\n<li>handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-nativeWake\"><a href=\"#4-nativeWake\" class=\"headerlink\" title=\"4.nativeWake\"></a>4.nativeWake</h3><p>同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。</p>\n<p>在native层通过层层调用，会调用到looper的wake方法中。</p>\n<pre><code>void Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(&quot;%p ~ wake&quot;, this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);\n        }\n    }\n}\n</code></pre><ul>\n<li>向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。</li>\n</ul>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><p>在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。</p>\n<p>首先，我们先看下方法表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class=\"line\">    /* name, signature, funcPtr */</div><div class=\"line\">    &#123; &quot;nativeInit&quot;, &quot;()J&quot;, (void*)android_os_MessageQueue_nativeInit &#125;,</div><div class=\"line\">    &#123; &quot;nativeDestroy&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class=\"line\">    &#123; &quot;nativePollOnce&quot;, &quot;(JI)V&quot;, (void*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class=\"line\">    &#123; &quot;nativeWake&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeWake &#125;,</div><div class=\"line\">    &#123; &quot;nativeIsPolling&quot;, &quot;(J)Z&quot;, (void*)android_os_MessageQueue_nativeIsPolling &#125;,</div><div class=\"line\">    &#123; &quot;nativeSetFileDescriptorEvents&quot;, &quot;(JII)V&quot;,</div><div class=\"line\">            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>因为前面有介绍jni的相关知识，这里就不多说了。</p>\n<p>从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</div><div class=\"line\">    if (!nativeMessageQueue) &#123;</div><div class=\"line\">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    nativeMessageQueue-&gt;incStrong(env);</div><div class=\"line\">    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化NativeMessageQueue</li>\n<li>并且返回给java层，也就是java层的mPtr</li>\n</ul>\n<p>那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMessageQueue::NativeMessageQueue() :</div><div class=\"line\">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</div><div class=\"line\">    mLooper = Looper::getForThread();</div><div class=\"line\">    if (mLooper == NULL) &#123;</div><div class=\"line\">        mLooper = new Looper(false);</div><div class=\"line\">        Looper::setForThread(mLooper);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造native层的looper，注意，这个和java层的没有任何关系</li>\n<li>保存在类似ThreadLocal一样的结构里。</li>\n</ul>\n<p>Looper的构造函数在Looper.cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper::Looper(bool allowNonCallbacks) :</div><div class=\"line\">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</div><div class=\"line\">        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),</div><div class=\"line\">        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</div><div class=\"line\">    mWakeEventFd = eventfd(0, EFD_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, &quot;Could not make wake event fd.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\">    rebuildEpollLocked();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>eventfd构造欢迎时间的fd</li>\n<li>rebuildEpollLocked 重建epoll</li>\n</ul>\n<p>epoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：</p>\n<ul>\n<li>监视的描述符数量不受限制</li>\n<li>IO效率不会随着监视fd的数量增长而下降</li>\n</ul>\n<p>关于epoll的更多内容，这里就不介绍了。</p>\n<p>那么，在我们native的looper里面，是如何重建的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Looper::rebuildEpollLocked() &#123;</div><div class=\"line\">    // Close old epoll instance if we have one.</div><div class=\"line\">    if (mEpollFd &gt;= 0) &#123;</div><div class=\"line\">#if DEBUG_CALLBACKS</div><div class=\"line\">        ALOGD(&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;, this);</div><div class=\"line\">#endif</div><div class=\"line\">        close(mEpollFd);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Allocate the new epoll instance and register the wake pipe.</div><div class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    struct epoll_event eventItem;</div><div class=\"line\">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</div><div class=\"line\">    eventItem.events = EPOLLIN;</div><div class=\"line\">    eventItem.data.fd = mWakeEventFd;</div><div class=\"line\">    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; mRequests.size(); i++) &#123;</div><div class=\"line\">        const Request&amp; request = mRequests.valueAt(i);</div><div class=\"line\">        struct epoll_event eventItem;</div><div class=\"line\">        request.initEventItem(&amp;eventItem);</div><div class=\"line\"></div><div class=\"line\">        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</div><div class=\"line\">        if (epollResult &lt; 0) &#123;</div><div class=\"line\">            ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set, errno=%d&quot;,</div><div class=\"line\">                    request.fd, errno);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>epoll_create，创建epoll句柄</li>\n<li>memset 将数据区域至0</li>\n<li>eventItem.events = EPOLLIN;<br>  eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。</li>\n<li>epoll_ctl添加唤醒事件</li>\n<li>循环将mRequests中的事件都添加进去。</li>\n</ul>\n<h3 id=\"3-nativePollOnce\"><a href=\"#3-nativePollOnce\" class=\"headerlink\" title=\"3. nativePollOnce\"></a>3. nativePollOnce</h3><p>在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。</p>\n<p>android_os_MessageQueue_nativePollOnce-&gt;pollOnce-&gt;Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class=\"line\">    int result = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class=\"line\">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class=\"line\">            int ident = response.request.ident;</div><div class=\"line\">            if (ident &gt;= 0) &#123;</div><div class=\"line\">                int fd = response.request.fd;</div><div class=\"line\">                int events = response.events;</div><div class=\"line\">                void* data = response.request.data;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class=\"line\">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class=\"line\">                        this, ident, fd, events, data);</div><div class=\"line\">#endif</div><div class=\"line\">                if (outFd != NULL) *outFd = fd;</div><div class=\"line\">                if (outEvents != NULL) *outEvents = events;</div><div class=\"line\">                if (outData != NULL) *outData = data;</div><div class=\"line\">                return ident;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (result != 0) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class=\"line\">#endif</div><div class=\"line\">            if (outFd != NULL) *outFd = 0;</div><div class=\"line\">            if (outEvents != NULL) *outEvents = 0;</div><div class=\"line\">            if (outData != NULL) *outData = NULL;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        result = pollInner(timeoutMillis);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的参数含义：</p>\n<ul>\n<li>timeoutMillis 超时等待时间，-1无限等待，0立即返回</li>\n<li>outFd 发生事件的文件描述符</li>\n<li>outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,</li>\n<li>outData 存储上下文数据</li>\n</ul>\n<p>返回值的含义如下：</p>\n<ul>\n<li>ALOOPER_POLL_WAKE 表示由wake触发</li>\n<li>ALOOPER_POLL_TIMEOUT 等待超时</li>\n<li>ALOOPER_POLL_ERROR 等待过程中发生错误</li>\n<li>ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发</li>\n</ul>\n<p>这个方法的处理逻辑如下：</p>\n<ul>\n<li>先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)</li>\n<li>pollInner 处理内部轮询</li>\n</ul>\n<p>pollInner方法很长，</p>\n<ul>\n<li>toMillisecondTimeoutDelay 重新计算超时时间</li>\n<li>epoll_wait 等待</li>\n<li>如果需要，重建epoll</li>\n<li>epoll_wait函数返回，三种情况<ul>\n<li>eventCount&lt;0 发生错误，goto Done</li>\n<li>eventCount=0 连接超时 goto Done</li>\n<li>监听到有事件发生，</li>\n</ul>\n</li>\n<li>如果有事件发生，则循环处理<ul>\n<li>如果是mWakeEventFd，则进行awoken唤醒</li>\n<li>pushResponse，根据request构建response，并添加到response数组中</li>\n</ul>\n</li>\n<li>Done 标志，事件处理<ul>\n<li>handleMessage 先处理native的message</li>\n<li>handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-nativeWake\"><a href=\"#4-nativeWake\" class=\"headerlink\" title=\"4.nativeWake\"></a>4.nativeWake</h3><p>同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。</p>\n<p>在native层通过层层调用，会调用到looper的wake方法中。</p>\n<pre><code>void Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(&quot;%p ~ wake&quot;, this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);\n        }\n    }\n}\n</code></pre><ul>\n<li>向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。</li>\n</ul>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"ContentProvider凑数文","date":"2016-12-29T10:33:56.000Z","_content":"<Excerpt in index | 首页摘要>\n这一篇，没营养，凑数用的。\n\n### 1. ActivityThread的main方法\n\n* 我们知道android应用程序的入口是ActivityThread的main方法。\n* ContentProvid是何时、何流程，调用的onCreate方法呢？\n\nActivityThread的main方法说起。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n```\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n```\n\n在main方法中，我们能发现如上代码，attach什么？我们跟进去看。\n\n```\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n            final IActivityManager mgr = ActivityManagerNative.getDefault();\n            try {\n                mgr.attachApplication(mAppThread);\n            } catch (RemoteException ex) {\n                // Ignore\n            }\n```\n\n我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现\n\n```\nList<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;\n```\n\n* app ProcessRecord, 进程相关信息\n* ProviderInfo contentprovider信息\n\n再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：\n\n```\n            if (!data.restrictedBackupMode) {\n                List<ProviderInfo> providers = data.providers;\n                if (providers != null) {\n                    installContentProviders(app, providers);\n                    // For process that contains content providers, we want to\n                    // ensure that the JIT is enabled \"at some point\".\n                    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);\n                }\n            }\n```\n\n找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。\n\n```\n    private void installContentProviders(\n            Context context, List<ProviderInfo> providers) {\n        final ArrayList<IActivityManager.ContentProviderHolder> results =\n            new ArrayList<IActivityManager.ContentProviderHolder>();\n\n        for (ProviderInfo cpi : providers) {\n            if (DEBUG_PROVIDER) {\n                StringBuilder buf = new StringBuilder(128);\n                buf.append(\"Pub \");\n                buf.append(cpi.authority);\n                buf.append(\": \");\n                buf.append(cpi.name);\n                Log.i(TAG, buf.toString());\n            }\n            IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,\n                    false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);\n            if (cph != null) {\n                cph.noReleaseNeeded = true;\n                results.add(cph);\n            }\n        }\n\n        try {\n            ActivityManagerNative.getDefault().publishContentProviders(\n                getApplicationThread(), results);\n        } catch (RemoteException ex) {\n        }\n    }\n```\n\n总体分为两步，\n\n* installProvider 生成ContentProviderHolder对象\n* publishContentProviders 发布出去\n\n### 2.installProvider\n\n\n```\n                final java.lang.ClassLoader cl = c.getClassLoader();\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n                if (provider == null) {\n                    Slog.e(TAG, \"Failed to instantiate class \" +\n                          info.name + \" from sourceDir \" +\n                          info.applicationInfo.sourceDir);\n                    return null;\n                }\n                if (DEBUG_PROVIDER) Slog.v(\n                    TAG, \"Instantiating local provider \" + info.name);\n                // XXX Need to create the correct context for this provider.\n                localProvider.attachInfo(c, info);\n```\n\n在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现\n\n```\nContentProvider.this.onCreate();\n```\n\n### 3.query操作\n\nContext的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。\n\nquery方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个[理解ContentProvider原理](http://gityuan.com/2016/07/30/content-provider/) \n\n* 获取IContentProvider对象\n* IContentProvider的query方法\n\n\nIContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。\n\n```\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n```\ncp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/ContentProvider水文(凑四大组件).md","raw":"---\ntitle: ContentProvider凑数文\ndate: 2016-12-29 18:33:56\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n这一篇，没营养，凑数用的。\n\n### 1. ActivityThread的main方法\n\n* 我们知道android应用程序的入口是ActivityThread的main方法。\n* ContentProvid是何时、何流程，调用的onCreate方法呢？\n\nActivityThread的main方法说起。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n```\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n```\n\n在main方法中，我们能发现如上代码，attach什么？我们跟进去看。\n\n```\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n            final IActivityManager mgr = ActivityManagerNative.getDefault();\n            try {\n                mgr.attachApplication(mAppThread);\n            } catch (RemoteException ex) {\n                // Ignore\n            }\n```\n\n我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现\n\n```\nList<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;\n```\n\n* app ProcessRecord, 进程相关信息\n* ProviderInfo contentprovider信息\n\n再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：\n\n```\n            if (!data.restrictedBackupMode) {\n                List<ProviderInfo> providers = data.providers;\n                if (providers != null) {\n                    installContentProviders(app, providers);\n                    // For process that contains content providers, we want to\n                    // ensure that the JIT is enabled \"at some point\".\n                    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);\n                }\n            }\n```\n\n找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。\n\n```\n    private void installContentProviders(\n            Context context, List<ProviderInfo> providers) {\n        final ArrayList<IActivityManager.ContentProviderHolder> results =\n            new ArrayList<IActivityManager.ContentProviderHolder>();\n\n        for (ProviderInfo cpi : providers) {\n            if (DEBUG_PROVIDER) {\n                StringBuilder buf = new StringBuilder(128);\n                buf.append(\"Pub \");\n                buf.append(cpi.authority);\n                buf.append(\": \");\n                buf.append(cpi.name);\n                Log.i(TAG, buf.toString());\n            }\n            IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,\n                    false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);\n            if (cph != null) {\n                cph.noReleaseNeeded = true;\n                results.add(cph);\n            }\n        }\n\n        try {\n            ActivityManagerNative.getDefault().publishContentProviders(\n                getApplicationThread(), results);\n        } catch (RemoteException ex) {\n        }\n    }\n```\n\n总体分为两步，\n\n* installProvider 生成ContentProviderHolder对象\n* publishContentProviders 发布出去\n\n### 2.installProvider\n\n\n```\n                final java.lang.ClassLoader cl = c.getClassLoader();\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n                if (provider == null) {\n                    Slog.e(TAG, \"Failed to instantiate class \" +\n                          info.name + \" from sourceDir \" +\n                          info.applicationInfo.sourceDir);\n                    return null;\n                }\n                if (DEBUG_PROVIDER) Slog.v(\n                    TAG, \"Instantiating local provider \" + info.name);\n                // XXX Need to create the correct context for this provider.\n                localProvider.attachInfo(c, info);\n```\n\n在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现\n\n```\nContentProvider.this.onCreate();\n```\n\n### 3.query操作\n\nContext的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。\n\nquery方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个[理解ContentProvider原理](http://gityuan.com/2016/07/30/content-provider/) \n\n* 获取IContentProvider对象\n* IContentProvider的query方法\n\n\nIContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。\n\n```\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n```\ncp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"ContentProvider水文(凑四大组件)","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxl001219fyr8cfd1km","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br>这一篇，没营养，凑数用的。</excerpt></p>\n<h3 id=\"1-ActivityThread的main方法\"><a href=\"#1-ActivityThread的main方法\" class=\"headerlink\" title=\"1. ActivityThread的main方法\"></a>1. ActivityThread的main方法</h3><ul>\n<li>我们知道android应用程序的入口是ActivityThread的main方法。</li>\n<li>ContentProvid是何时、何流程，调用的onCreate方法呢？</li>\n</ul>\n<p>ActivityThread的main方法说起。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityThread thread = new ActivityThread();</div><div class=\"line\">thread.attach(false);</div></pre></td></tr></table></figure>\n<p>在main方法中，我们能发现如上代码，attach什么？我们跟进去看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class=\"line\">final IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class=\"line\">try &#123;</div><div class=\"line\">    mgr.attachApplication(mAppThread);</div><div class=\"line\">&#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    // Ignore</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null;</div></pre></td></tr></table></figure>\n<ul>\n<li>app ProcessRecord, 进程相关信息</li>\n<li>ProviderInfo contentprovider信息</li>\n</ul>\n<p>再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!data.restrictedBackupMode) &#123;</div><div class=\"line\">    List&lt;ProviderInfo&gt; providers = data.providers;</div><div class=\"line\">    if (providers != null) &#123;</div><div class=\"line\">        installContentProviders(app, providers);</div><div class=\"line\">        // For process that contains content providers, we want to</div><div class=\"line\">        // ensure that the JIT is enabled &quot;at some point&quot;.</div><div class=\"line\">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void installContentProviders(</div><div class=\"line\">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class=\"line\">    final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</div><div class=\"line\">        new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</div><div class=\"line\"></div><div class=\"line\">    for (ProviderInfo cpi : providers) &#123;</div><div class=\"line\">        if (DEBUG_PROVIDER) &#123;</div><div class=\"line\">            StringBuilder buf = new StringBuilder(128);</div><div class=\"line\">            buf.append(&quot;Pub &quot;);</div><div class=\"line\">            buf.append(cpi.authority);</div><div class=\"line\">            buf.append(&quot;: &quot;);</div><div class=\"line\">            buf.append(cpi.name);</div><div class=\"line\">            Log.i(TAG, buf.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">        IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class=\"line\">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class=\"line\">        if (cph != null) &#123;</div><div class=\"line\">            cph.noReleaseNeeded = true;</div><div class=\"line\">            results.add(cph);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        ActivityManagerNative.getDefault().publishContentProviders(</div><div class=\"line\">            getApplicationThread(), results);</div><div class=\"line\">    &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总体分为两步，</p>\n<ul>\n<li>installProvider 生成ContentProviderHolder对象</li>\n<li>publishContentProviders 发布出去</li>\n</ul>\n<h3 id=\"2-installProvider\"><a href=\"#2-installProvider\" class=\"headerlink\" title=\"2.installProvider\"></a>2.installProvider</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">final java.lang.ClassLoader cl = c.getClassLoader();</div><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div><div class=\"line\">if (provider == null) &#123;</div><div class=\"line\">    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</div><div class=\"line\">          info.name + &quot; from sourceDir &quot; +</div><div class=\"line\">          info.applicationInfo.sourceDir);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div><div class=\"line\">if (DEBUG_PROVIDER) Slog.v(</div><div class=\"line\">    TAG, &quot;Instantiating local provider &quot; + info.name);</div><div class=\"line\">// XXX Need to create the correct context for this provider.</div><div class=\"line\">localProvider.attachInfo(c, info);</div></pre></td></tr></table></figure>\n<p>在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentProvider.this.onCreate();</div></pre></td></tr></table></figure>\n<h3 id=\"3-query操作\"><a href=\"#3-query操作\" class=\"headerlink\" title=\"3.query操作\"></a>3.query操作</h3><p>Context的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。</p>\n<p>query方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个<a href=\"http://gityuan.com/2016/07/30/content-provider/\" target=\"_blank\" rel=\"external\">理解ContentProvider原理</a> </p>\n<ul>\n<li>获取IContentProvider对象</li>\n<li>IContentProvider的query方法</li>\n</ul>\n<p>IContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div></pre></td></tr></table></figure>\n<p>cp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要><br>这一篇，没营养，凑数用的。</p>\n<h3 id=\"1-ActivityThread的main方法\"><a href=\"#1-ActivityThread的main方法\" class=\"headerlink\" title=\"1. ActivityThread的main方法\"></a>1. ActivityThread的main方法</h3><ul>\n<li>我们知道android应用程序的入口是ActivityThread的main方法。</li>\n<li>ContentProvid是何时、何流程，调用的onCreate方法呢？</li>\n</ul>\n<p>ActivityThread的main方法说起。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityThread thread = new ActivityThread();</div><div class=\"line\">thread.attach(false);</div></pre></td></tr></table></figure>\n<p>在main方法中，我们能发现如上代码，attach什么？我们跟进去看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class=\"line\">final IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class=\"line\">try &#123;</div><div class=\"line\">    mgr.attachApplication(mAppThread);</div><div class=\"line\">&#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    // Ignore</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null;</div></pre></td></tr></table></figure>\n<ul>\n<li>app ProcessRecord, 进程相关信息</li>\n<li>ProviderInfo contentprovider信息</li>\n</ul>\n<p>再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!data.restrictedBackupMode) &#123;</div><div class=\"line\">    List&lt;ProviderInfo&gt; providers = data.providers;</div><div class=\"line\">    if (providers != null) &#123;</div><div class=\"line\">        installContentProviders(app, providers);</div><div class=\"line\">        // For process that contains content providers, we want to</div><div class=\"line\">        // ensure that the JIT is enabled &quot;at some point&quot;.</div><div class=\"line\">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void installContentProviders(</div><div class=\"line\">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class=\"line\">    final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</div><div class=\"line\">        new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</div><div class=\"line\"></div><div class=\"line\">    for (ProviderInfo cpi : providers) &#123;</div><div class=\"line\">        if (DEBUG_PROVIDER) &#123;</div><div class=\"line\">            StringBuilder buf = new StringBuilder(128);</div><div class=\"line\">            buf.append(&quot;Pub &quot;);</div><div class=\"line\">            buf.append(cpi.authority);</div><div class=\"line\">            buf.append(&quot;: &quot;);</div><div class=\"line\">            buf.append(cpi.name);</div><div class=\"line\">            Log.i(TAG, buf.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">        IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class=\"line\">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class=\"line\">        if (cph != null) &#123;</div><div class=\"line\">            cph.noReleaseNeeded = true;</div><div class=\"line\">            results.add(cph);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        ActivityManagerNative.getDefault().publishContentProviders(</div><div class=\"line\">            getApplicationThread(), results);</div><div class=\"line\">    &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总体分为两步，</p>\n<ul>\n<li>installProvider 生成ContentProviderHolder对象</li>\n<li>publishContentProviders 发布出去</li>\n</ul>\n<h3 id=\"2-installProvider\"><a href=\"#2-installProvider\" class=\"headerlink\" title=\"2.installProvider\"></a>2.installProvider</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">final java.lang.ClassLoader cl = c.getClassLoader();</div><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div><div class=\"line\">if (provider == null) &#123;</div><div class=\"line\">    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</div><div class=\"line\">          info.name + &quot; from sourceDir &quot; +</div><div class=\"line\">          info.applicationInfo.sourceDir);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div><div class=\"line\">if (DEBUG_PROVIDER) Slog.v(</div><div class=\"line\">    TAG, &quot;Instantiating local provider &quot; + info.name);</div><div class=\"line\">// XXX Need to create the correct context for this provider.</div><div class=\"line\">localProvider.attachInfo(c, info);</div></pre></td></tr></table></figure>\n<p>在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentProvider.this.onCreate();</div></pre></td></tr></table></figure>\n<h3 id=\"3-query操作\"><a href=\"#3-query操作\" class=\"headerlink\" title=\"3.query操作\"></a>3.query操作</h3><p>Context的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。</p>\n<p>query方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个<a href=\"http://gityuan.com/2016/07/30/content-provider/\">理解ContentProvider原理</a> </p>\n<ul>\n<li>获取IContentProvider对象</li>\n<li>IContentProvider的query方法</li>\n</ul>\n<p>IContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div></pre></td></tr></table></figure>\n<p>cp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"AsyncTask浅析","date":"2017-02-21T13:15:28.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\nAsyncTask，或许大家在平常开发中经常用，或许不用，虽然说AsyncTask有自己的一些缺点，但是，这并不阻碍我们对他的学习。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 怎么用\n\n用法很简单，我们只需要继承AsyncTask，并实现一些方法就可以了。\n\n```\n    public class CustomAsyncTask extends AsyncTask<String,Integer,Integer>{\n\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n        }\n\n        @Override\n        protected Integer doInBackground(String... params) {\n            //注意 更新进度要用publishProgress\n            publishProgress(1);\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(Integer... values) {\n            super.onProgressUpdate(values);\n        }\n\n        @Override\n        protected void onPostExecute(Integer integer) {\n            super.onPostExecute(integer);\n        }\n    }\n```\n\n一般来说，我们实现这几个方法就可以了。\n\n* 而其中三个泛型参数分别表示，参数、进度值类型、返回值类型\n* onPreExecute 会在执行之前调用，运行在主线程\n* doInBackground运行在后台线程，需要注意，当我们更新进度的时候，需要使用publishProgress方法。\n* onProgressUpdate表示，当进度值更新的时候，回调，运行在主线程\n* onPostExecute耗时任务，执行完毕的时候回调，运行在主线程\n\n然后，我们通过如下代码执行即可。\n\n```\n        CustomAsyncTask asyncTask = new CustomAsyncTask();\n        asyncTask.execute(\"xxx\");\n```\n\n接下来，我们就来看看它内部的实现原理。\n\n### 构造方法\n\n```\n    public AsyncTask() {\n        mWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                //noinspection unchecked\n                Result result = doInBackground(mParams);\n                Binder.flushPendingCommands();\n                return postResult(result);\n            }\n        };\n\n        mFuture = new FutureTask<Result>(mWorker) {\n            @Override\n            protected void done() {\n                try {\n                    postResultIfNotInvoked(get());\n                } catch (InterruptedException e) {\n                    android.util.Log.w(LOG_TAG, e);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(\"An error occurred while executing doInBackground()\",\n                            e.getCause());\n                } catch (CancellationException e) {\n                    postResultIfNotInvoked(null);\n                }\n            }\n        };\n    }\n```\n\n初始化方法也很简单，在其中初始化了两个对象，其中一个是WorkerRunnable，这个类implements了Callable接口，这个接口是个声明类型的接口。还有一个是FutureTask，这是一个带返回值的task。\n\n### execute方法\n\n在execute方法中，直接调用了executeOnExecutor方法。\n\n```\n    public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n```\n\n其中第一个参数是默认的线程池。这里是SerialExecutor，从名字上就看得出，这是串行的。\n\n```\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n            Params... params) {\n        if (mStatus != Status.PENDING) {\n            switch (mStatus) {\n                case RUNNING:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task is already running.\");\n                case FINISHED:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task has already been executed \"\n                            + \"(a task can be executed only once)\");\n            }\n        }\n\n        mStatus = Status.RUNNING;\n\n        onPreExecute();\n\n        mWorker.mParams = params;\n        exec.execute(mFuture);\n\n        return this;\n    }\n```\n\n在这个方法中，会判断任务的状态，从这里的能看出，一次智能执行一个。随后会调用onPreExecute在执行之前的操作。接着，便是线程池execute任务，然后，便会调用mFuture的run方法。我们接着看。\n\n### FutureTask#run\n\n```\n    public void run() {\n        if (state != NEW ||\n            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\n从上面的代码，我们能看出这里，会先执行，Callback的call方法，也就是我们传入的WorkerRunnable的call方法，接着，在执行完毕之后，调用set方法去设置结果。这个方法中，调用finishCompletion方法。在这个方法中，则会调用自身的done方法，多的不说。我们回到AsyncTask，看WorkerRunnable的call和FutureTask的done吧。\n\n### WorkerRunnable#call和FutureTask#done\n\n我们先看call方法，\n\n```\n                mTaskInvoked.set(true);\n\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                //noinspection unchecked\n                Result result = doInBackground(mParams);\n                Binder.flushPendingCommands();\n                return postResult(result);\n```\n\n* 首先设置 task已被调用\n* 然后设置线程优先级为后台线程\n* 调用doInBackground方法执行耗时任务\n* 执行完毕之后调用postResult去发送执行结果\n\n最后，来看下FutureTask的done方法。\n\n```\n            protected void done() {\n                try {\n                    postResultIfNotInvoked(get());\n                } catch (InterruptedException e) {\n                    android.util.Log.w(LOG_TAG, e);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(\"An error occurred while executing doInBackground()\",\n                            e.getCause());\n                } catch (CancellationException e) {\n                    postResultIfNotInvoked(null);\n                }\n            }\n```\n\n在这里，会调用postResultIfNotInvoked方法，如果postResult没被调用过，就是结果没发送过，就会发送结果，这里是发送一条消息，然后根据类型去判断是更新进度还是结束任务。\n\n```\n    private static class InternalHandler extends Handler {\n        public InternalHandler() {\n            super(Looper.getMainLooper());\n        }\n\n        @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})\n        @Override\n        public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT:\n                    // There is only one result\n                    result.mTask.finish(result.mData[0]);\n                    break;\n                case MESSAGE_POST_PROGRESS:\n                    result.mTask.onProgressUpdate(result.mData);\n                    break;\n            }\n        }\n    }\n```\n\n### SerialExecutor\n\n```\n    private static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n```\n\n这里我们就不细说了。\n\n### 总结\n\nAsyncTask的源码其实蛮简单的，但是我们能否从简单的源码中学到一个东西呢？这是个问题。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/AsyncTask浅析.md","raw":"---\ntitle: AsyncTask浅析\ndate: 2017-02-21 21:15:28\ncategories: Android\ntags: 源码\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\nAsyncTask，或许大家在平常开发中经常用，或许不用，虽然说AsyncTask有自己的一些缺点，但是，这并不阻碍我们对他的学习。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 怎么用\n\n用法很简单，我们只需要继承AsyncTask，并实现一些方法就可以了。\n\n```\n    public class CustomAsyncTask extends AsyncTask<String,Integer,Integer>{\n\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n        }\n\n        @Override\n        protected Integer doInBackground(String... params) {\n            //注意 更新进度要用publishProgress\n            publishProgress(1);\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(Integer... values) {\n            super.onProgressUpdate(values);\n        }\n\n        @Override\n        protected void onPostExecute(Integer integer) {\n            super.onPostExecute(integer);\n        }\n    }\n```\n\n一般来说，我们实现这几个方法就可以了。\n\n* 而其中三个泛型参数分别表示，参数、进度值类型、返回值类型\n* onPreExecute 会在执行之前调用，运行在主线程\n* doInBackground运行在后台线程，需要注意，当我们更新进度的时候，需要使用publishProgress方法。\n* onProgressUpdate表示，当进度值更新的时候，回调，运行在主线程\n* onPostExecute耗时任务，执行完毕的时候回调，运行在主线程\n\n然后，我们通过如下代码执行即可。\n\n```\n        CustomAsyncTask asyncTask = new CustomAsyncTask();\n        asyncTask.execute(\"xxx\");\n```\n\n接下来，我们就来看看它内部的实现原理。\n\n### 构造方法\n\n```\n    public AsyncTask() {\n        mWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                //noinspection unchecked\n                Result result = doInBackground(mParams);\n                Binder.flushPendingCommands();\n                return postResult(result);\n            }\n        };\n\n        mFuture = new FutureTask<Result>(mWorker) {\n            @Override\n            protected void done() {\n                try {\n                    postResultIfNotInvoked(get());\n                } catch (InterruptedException e) {\n                    android.util.Log.w(LOG_TAG, e);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(\"An error occurred while executing doInBackground()\",\n                            e.getCause());\n                } catch (CancellationException e) {\n                    postResultIfNotInvoked(null);\n                }\n            }\n        };\n    }\n```\n\n初始化方法也很简单，在其中初始化了两个对象，其中一个是WorkerRunnable，这个类implements了Callable接口，这个接口是个声明类型的接口。还有一个是FutureTask，这是一个带返回值的task。\n\n### execute方法\n\n在execute方法中，直接调用了executeOnExecutor方法。\n\n```\n    public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n```\n\n其中第一个参数是默认的线程池。这里是SerialExecutor，从名字上就看得出，这是串行的。\n\n```\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n            Params... params) {\n        if (mStatus != Status.PENDING) {\n            switch (mStatus) {\n                case RUNNING:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task is already running.\");\n                case FINISHED:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task has already been executed \"\n                            + \"(a task can be executed only once)\");\n            }\n        }\n\n        mStatus = Status.RUNNING;\n\n        onPreExecute();\n\n        mWorker.mParams = params;\n        exec.execute(mFuture);\n\n        return this;\n    }\n```\n\n在这个方法中，会判断任务的状态，从这里的能看出，一次智能执行一个。随后会调用onPreExecute在执行之前的操作。接着，便是线程池execute任务，然后，便会调用mFuture的run方法。我们接着看。\n\n### FutureTask#run\n\n```\n    public void run() {\n        if (state != NEW ||\n            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\n从上面的代码，我们能看出这里，会先执行，Callback的call方法，也就是我们传入的WorkerRunnable的call方法，接着，在执行完毕之后，调用set方法去设置结果。这个方法中，调用finishCompletion方法。在这个方法中，则会调用自身的done方法，多的不说。我们回到AsyncTask，看WorkerRunnable的call和FutureTask的done吧。\n\n### WorkerRunnable#call和FutureTask#done\n\n我们先看call方法，\n\n```\n                mTaskInvoked.set(true);\n\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                //noinspection unchecked\n                Result result = doInBackground(mParams);\n                Binder.flushPendingCommands();\n                return postResult(result);\n```\n\n* 首先设置 task已被调用\n* 然后设置线程优先级为后台线程\n* 调用doInBackground方法执行耗时任务\n* 执行完毕之后调用postResult去发送执行结果\n\n最后，来看下FutureTask的done方法。\n\n```\n            protected void done() {\n                try {\n                    postResultIfNotInvoked(get());\n                } catch (InterruptedException e) {\n                    android.util.Log.w(LOG_TAG, e);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(\"An error occurred while executing doInBackground()\",\n                            e.getCause());\n                } catch (CancellationException e) {\n                    postResultIfNotInvoked(null);\n                }\n            }\n```\n\n在这里，会调用postResultIfNotInvoked方法，如果postResult没被调用过，就是结果没发送过，就会发送结果，这里是发送一条消息，然后根据类型去判断是更新进度还是结束任务。\n\n```\n    private static class InternalHandler extends Handler {\n        public InternalHandler() {\n            super(Looper.getMainLooper());\n        }\n\n        @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})\n        @Override\n        public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT:\n                    // There is only one result\n                    result.mTask.finish(result.mData[0]);\n                    break;\n                case MESSAGE_POST_PROGRESS:\n                    result.mTask.onProgressUpdate(result.mData);\n                    break;\n            }\n        }\n    }\n```\n\n### SerialExecutor\n\n```\n    private static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n```\n\n这里我们就不细说了。\n\n### 总结\n\nAsyncTask的源码其实蛮简单的，但是我们能否从简单的源码中学到一个东西呢？这是个问题。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"AsyncTask浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxm001519fypujie73t","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>AsyncTask，或许大家在平常开发中经常用，或许不用，虽然说AsyncTask有自己的一些缺点，但是，这并不阻碍我们对他的学习。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h3><p>用法很简单，我们只需要继承AsyncTask，并实现一些方法就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CustomAsyncTask extends AsyncTask&lt;String,Integer,Integer&gt;&#123;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onPreExecute() &#123;</div><div class=\"line\">        super.onPreExecute();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected Integer doInBackground(String... params) &#123;</div><div class=\"line\">        //注意 更新进度要用publishProgress</div><div class=\"line\">        publishProgress(1);</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onProgressUpdate(Integer... values) &#123;</div><div class=\"line\">        super.onProgressUpdate(values);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onPostExecute(Integer integer) &#123;</div><div class=\"line\">        super.onPostExecute(integer);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一般来说，我们实现这几个方法就可以了。</p>\n<ul>\n<li>而其中三个泛型参数分别表示，参数、进度值类型、返回值类型</li>\n<li>onPreExecute 会在执行之前调用，运行在主线程</li>\n<li>doInBackground运行在后台线程，需要注意，当我们更新进度的时候，需要使用publishProgress方法。</li>\n<li>onProgressUpdate表示，当进度值更新的时候，回调，运行在主线程</li>\n<li>onPostExecute耗时任务，执行完毕的时候回调，运行在主线程</li>\n</ul>\n<p>然后，我们通过如下代码执行即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CustomAsyncTask asyncTask = new CustomAsyncTask();</div><div class=\"line\">asyncTask.execute(&quot;xxx&quot;);</div></pre></td></tr></table></figure>\n<p>接下来，我们就来看看它内部的实现原理。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public AsyncTask() &#123;</div><div class=\"line\">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class=\"line\">        public Result call() throws Exception &#123;</div><div class=\"line\">            mTaskInvoked.set(true);</div><div class=\"line\"></div><div class=\"line\">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">            //noinspection unchecked</div><div class=\"line\">            Result result = doInBackground(mParams);</div><div class=\"line\">            Binder.flushPendingCommands();</div><div class=\"line\">            return postResult(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        protected void done() &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                postResultIfNotInvoked(get());</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                android.util.Log.w(LOG_TAG, e);</div><div class=\"line\">            &#125; catch (ExecutionException e) &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</div><div class=\"line\">                        e.getCause());</div><div class=\"line\">            &#125; catch (CancellationException e) &#123;</div><div class=\"line\">                postResultIfNotInvoked(null);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>初始化方法也很简单，在其中初始化了两个对象，其中一个是WorkerRunnable，这个类implements了Callable接口，这个接口是个声明类型的接口。还有一个是FutureTask，这是一个带返回值的task。</p>\n<h3 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"execute方法\"></a>execute方法</h3><p>在execute方法中，直接调用了executeOnExecutor方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class=\"line\">    return executeOnExecutor(sDefaultExecutor, params);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中第一个参数是默认的线程池。这里是SerialExecutor，从名字上就看得出，这是串行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</div><div class=\"line\">        Params... params) &#123;</div><div class=\"line\">    if (mStatus != Status.PENDING) &#123;</div><div class=\"line\">        switch (mStatus) &#123;</div><div class=\"line\">            case RUNNING:</div><div class=\"line\">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class=\"line\">                        + &quot; the task is already running.&quot;);</div><div class=\"line\">            case FINISHED:</div><div class=\"line\">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class=\"line\">                        + &quot; the task has already been executed &quot;</div><div class=\"line\">                        + &quot;(a task can be executed only once)&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mStatus = Status.RUNNING;</div><div class=\"line\"></div><div class=\"line\">    onPreExecute();</div><div class=\"line\"></div><div class=\"line\">    mWorker.mParams = params;</div><div class=\"line\">    exec.execute(mFuture);</div><div class=\"line\"></div><div class=\"line\">    return this;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，会判断任务的状态，从这里的能看出，一次智能执行一个。随后会调用onPreExecute在执行之前的操作。接着，便是线程池execute任务，然后，便会调用mFuture的run方法。我们接着看。</p>\n<h3 id=\"FutureTask-run\"><a href=\"#FutureTask-run\" class=\"headerlink\" title=\"FutureTask#run\"></a>FutureTask#run</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    if (state != NEW ||</div><div class=\"line\">        !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</div><div class=\"line\">        return;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Callable&lt;V&gt; c = callable;</div><div class=\"line\">        if (c != null &amp;&amp; state == NEW) &#123;</div><div class=\"line\">            V result;</div><div class=\"line\">            boolean ran;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                result = c.call();</div><div class=\"line\">                ran = true;</div><div class=\"line\">            &#125; catch (Throwable ex) &#123;</div><div class=\"line\">                result = null;</div><div class=\"line\">                ran = false;</div><div class=\"line\">                setException(ex);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (ran)</div><div class=\"line\">                set(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        // runner must be non-null until state is settled to</div><div class=\"line\">        // prevent concurrent calls to run()</div><div class=\"line\">        runner = null;</div><div class=\"line\">        // state must be re-read after nulling runner to prevent</div><div class=\"line\">        // leaked interrupts</div><div class=\"line\">        int s = state;</div><div class=\"line\">        if (s &gt;= INTERRUPTING)</div><div class=\"line\">            handlePossibleCancellationInterrupt(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码，我们能看出这里，会先执行，Callback的call方法，也就是我们传入的WorkerRunnable的call方法，接着，在执行完毕之后，调用set方法去设置结果。这个方法中，调用finishCompletion方法。在这个方法中，则会调用自身的done方法，多的不说。我们回到AsyncTask，看WorkerRunnable的call和FutureTask的done吧。</p>\n<h3 id=\"WorkerRunnable-call和FutureTask-done\"><a href=\"#WorkerRunnable-call和FutureTask-done\" class=\"headerlink\" title=\"WorkerRunnable#call和FutureTask#done\"></a>WorkerRunnable#call和FutureTask#done</h3><p>我们先看call方法，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">mTaskInvoked.set(true);</div><div class=\"line\"></div><div class=\"line\">Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">//noinspection unchecked</div><div class=\"line\">Result result = doInBackground(mParams);</div><div class=\"line\">Binder.flushPendingCommands();</div><div class=\"line\">return postResult(result);</div></pre></td></tr></table></figure>\n<ul>\n<li>首先设置 task已被调用</li>\n<li>然后设置线程优先级为后台线程</li>\n<li>调用doInBackground方法执行耗时任务</li>\n<li>执行完毕之后调用postResult去发送执行结果</li>\n</ul>\n<p>最后，来看下FutureTask的done方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void done() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        postResultIfNotInvoked(get());</div><div class=\"line\">    &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">        android.util.Log.w(LOG_TAG, e);</div><div class=\"line\">    &#125; catch (ExecutionException e) &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</div><div class=\"line\">                e.getCause());</div><div class=\"line\">    &#125; catch (CancellationException e) &#123;</div><div class=\"line\">        postResultIfNotInvoked(null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，会调用postResultIfNotInvoked方法，如果postResult没被调用过，就是结果没发送过，就会发送结果，这里是发送一条消息，然后根据类型去判断是更新进度还是结束任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static class InternalHandler extends Handler &#123;</div><div class=\"line\">    public InternalHandler() &#123;</div><div class=\"line\">        super(Looper.getMainLooper());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</div><div class=\"line\">    @Override</div><div class=\"line\">    public void handleMessage(Message msg) &#123;</div><div class=\"line\">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class=\"line\">        switch (msg.what) &#123;</div><div class=\"line\">            case MESSAGE_POST_RESULT:</div><div class=\"line\">                // There is only one result</div><div class=\"line\">                result.mTask.finish(result.mData[0]);</div><div class=\"line\">                break;</div><div class=\"line\">            case MESSAGE_POST_PROGRESS:</div><div class=\"line\">                result.mTask.onProgressUpdate(result.mData);</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"SerialExecutor\"><a href=\"#SerialExecutor\" class=\"headerlink\" title=\"SerialExecutor\"></a>SerialExecutor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static class SerialExecutor implements Executor &#123;</div><div class=\"line\">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</div><div class=\"line\">    Runnable mActive;</div><div class=\"line\"></div><div class=\"line\">    public synchronized void execute(final Runnable r) &#123;</div><div class=\"line\">        mTasks.offer(new Runnable() &#123;</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    r.run();</div><div class=\"line\">                &#125; finally &#123;</div><div class=\"line\">                    scheduleNext();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        if (mActive == null) &#123;</div><div class=\"line\">            scheduleNext();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    protected synchronized void scheduleNext() &#123;</div><div class=\"line\">        if ((mActive = mTasks.poll()) != null) &#123;</div><div class=\"line\">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里我们就不细说了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AsyncTask的源码其实蛮简单的，但是我们能否从简单的源码中学到一个东西呢？这是个问题。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>AsyncTask，或许大家在平常开发中经常用，或许不用，虽然说AsyncTask有自己的一些缺点，但是，这并不阻碍我们对他的学习。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h3><p>用法很简单，我们只需要继承AsyncTask，并实现一些方法就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class CustomAsyncTask extends AsyncTask&lt;String,Integer,Integer&gt;&#123;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onPreExecute() &#123;</div><div class=\"line\">        super.onPreExecute();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected Integer doInBackground(String... params) &#123;</div><div class=\"line\">        //注意 更新进度要用publishProgress</div><div class=\"line\">        publishProgress(1);</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onProgressUpdate(Integer... values) &#123;</div><div class=\"line\">        super.onProgressUpdate(values);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onPostExecute(Integer integer) &#123;</div><div class=\"line\">        super.onPostExecute(integer);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一般来说，我们实现这几个方法就可以了。</p>\n<ul>\n<li>而其中三个泛型参数分别表示，参数、进度值类型、返回值类型</li>\n<li>onPreExecute 会在执行之前调用，运行在主线程</li>\n<li>doInBackground运行在后台线程，需要注意，当我们更新进度的时候，需要使用publishProgress方法。</li>\n<li>onProgressUpdate表示，当进度值更新的时候，回调，运行在主线程</li>\n<li>onPostExecute耗时任务，执行完毕的时候回调，运行在主线程</li>\n</ul>\n<p>然后，我们通过如下代码执行即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CustomAsyncTask asyncTask = new CustomAsyncTask();</div><div class=\"line\">asyncTask.execute(&quot;xxx&quot;);</div></pre></td></tr></table></figure>\n<p>接下来，我们就来看看它内部的实现原理。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public AsyncTask() &#123;</div><div class=\"line\">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class=\"line\">        public Result call() throws Exception &#123;</div><div class=\"line\">            mTaskInvoked.set(true);</div><div class=\"line\"></div><div class=\"line\">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">            //noinspection unchecked</div><div class=\"line\">            Result result = doInBackground(mParams);</div><div class=\"line\">            Binder.flushPendingCommands();</div><div class=\"line\">            return postResult(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        protected void done() &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                postResultIfNotInvoked(get());</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                android.util.Log.w(LOG_TAG, e);</div><div class=\"line\">            &#125; catch (ExecutionException e) &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</div><div class=\"line\">                        e.getCause());</div><div class=\"line\">            &#125; catch (CancellationException e) &#123;</div><div class=\"line\">                postResultIfNotInvoked(null);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>初始化方法也很简单，在其中初始化了两个对象，其中一个是WorkerRunnable，这个类implements了Callable接口，这个接口是个声明类型的接口。还有一个是FutureTask，这是一个带返回值的task。</p>\n<h3 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"execute方法\"></a>execute方法</h3><p>在execute方法中，直接调用了executeOnExecutor方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class=\"line\">    return executeOnExecutor(sDefaultExecutor, params);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中第一个参数是默认的线程池。这里是SerialExecutor，从名字上就看得出，这是串行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</div><div class=\"line\">        Params... params) &#123;</div><div class=\"line\">    if (mStatus != Status.PENDING) &#123;</div><div class=\"line\">        switch (mStatus) &#123;</div><div class=\"line\">            case RUNNING:</div><div class=\"line\">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class=\"line\">                        + &quot; the task is already running.&quot;);</div><div class=\"line\">            case FINISHED:</div><div class=\"line\">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class=\"line\">                        + &quot; the task has already been executed &quot;</div><div class=\"line\">                        + &quot;(a task can be executed only once)&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mStatus = Status.RUNNING;</div><div class=\"line\"></div><div class=\"line\">    onPreExecute();</div><div class=\"line\"></div><div class=\"line\">    mWorker.mParams = params;</div><div class=\"line\">    exec.execute(mFuture);</div><div class=\"line\"></div><div class=\"line\">    return this;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，会判断任务的状态，从这里的能看出，一次智能执行一个。随后会调用onPreExecute在执行之前的操作。接着，便是线程池execute任务，然后，便会调用mFuture的run方法。我们接着看。</p>\n<h3 id=\"FutureTask-run\"><a href=\"#FutureTask-run\" class=\"headerlink\" title=\"FutureTask#run\"></a>FutureTask#run</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    if (state != NEW ||</div><div class=\"line\">        !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</div><div class=\"line\">        return;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Callable&lt;V&gt; c = callable;</div><div class=\"line\">        if (c != null &amp;&amp; state == NEW) &#123;</div><div class=\"line\">            V result;</div><div class=\"line\">            boolean ran;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                result = c.call();</div><div class=\"line\">                ran = true;</div><div class=\"line\">            &#125; catch (Throwable ex) &#123;</div><div class=\"line\">                result = null;</div><div class=\"line\">                ran = false;</div><div class=\"line\">                setException(ex);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (ran)</div><div class=\"line\">                set(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        // runner must be non-null until state is settled to</div><div class=\"line\">        // prevent concurrent calls to run()</div><div class=\"line\">        runner = null;</div><div class=\"line\">        // state must be re-read after nulling runner to prevent</div><div class=\"line\">        // leaked interrupts</div><div class=\"line\">        int s = state;</div><div class=\"line\">        if (s &gt;= INTERRUPTING)</div><div class=\"line\">            handlePossibleCancellationInterrupt(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码，我们能看出这里，会先执行，Callback的call方法，也就是我们传入的WorkerRunnable的call方法，接着，在执行完毕之后，调用set方法去设置结果。这个方法中，调用finishCompletion方法。在这个方法中，则会调用自身的done方法，多的不说。我们回到AsyncTask，看WorkerRunnable的call和FutureTask的done吧。</p>\n<h3 id=\"WorkerRunnable-call和FutureTask-done\"><a href=\"#WorkerRunnable-call和FutureTask-done\" class=\"headerlink\" title=\"WorkerRunnable#call和FutureTask#done\"></a>WorkerRunnable#call和FutureTask#done</h3><p>我们先看call方法，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">mTaskInvoked.set(true);</div><div class=\"line\"></div><div class=\"line\">Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">//noinspection unchecked</div><div class=\"line\">Result result = doInBackground(mParams);</div><div class=\"line\">Binder.flushPendingCommands();</div><div class=\"line\">return postResult(result);</div></pre></td></tr></table></figure>\n<ul>\n<li>首先设置 task已被调用</li>\n<li>然后设置线程优先级为后台线程</li>\n<li>调用doInBackground方法执行耗时任务</li>\n<li>执行完毕之后调用postResult去发送执行结果</li>\n</ul>\n<p>最后，来看下FutureTask的done方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void done() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        postResultIfNotInvoked(get());</div><div class=\"line\">    &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">        android.util.Log.w(LOG_TAG, e);</div><div class=\"line\">    &#125; catch (ExecutionException e) &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</div><div class=\"line\">                e.getCause());</div><div class=\"line\">    &#125; catch (CancellationException e) &#123;</div><div class=\"line\">        postResultIfNotInvoked(null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，会调用postResultIfNotInvoked方法，如果postResult没被调用过，就是结果没发送过，就会发送结果，这里是发送一条消息，然后根据类型去判断是更新进度还是结束任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static class InternalHandler extends Handler &#123;</div><div class=\"line\">    public InternalHandler() &#123;</div><div class=\"line\">        super(Looper.getMainLooper());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</div><div class=\"line\">    @Override</div><div class=\"line\">    public void handleMessage(Message msg) &#123;</div><div class=\"line\">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class=\"line\">        switch (msg.what) &#123;</div><div class=\"line\">            case MESSAGE_POST_RESULT:</div><div class=\"line\">                // There is only one result</div><div class=\"line\">                result.mTask.finish(result.mData[0]);</div><div class=\"line\">                break;</div><div class=\"line\">            case MESSAGE_POST_PROGRESS:</div><div class=\"line\">                result.mTask.onProgressUpdate(result.mData);</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"SerialExecutor\"><a href=\"#SerialExecutor\" class=\"headerlink\" title=\"SerialExecutor\"></a>SerialExecutor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static class SerialExecutor implements Executor &#123;</div><div class=\"line\">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</div><div class=\"line\">    Runnable mActive;</div><div class=\"line\"></div><div class=\"line\">    public synchronized void execute(final Runnable r) &#123;</div><div class=\"line\">        mTasks.offer(new Runnable() &#123;</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    r.run();</div><div class=\"line\">                &#125; finally &#123;</div><div class=\"line\">                    scheduleNext();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        if (mActive == null) &#123;</div><div class=\"line\">            scheduleNext();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    protected synchronized void scheduleNext() &#123;</div><div class=\"line\">        if ((mActive = mTasks.poll()) != null) &#123;</div><div class=\"line\">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里我们就不细说了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AsyncTask的源码其实蛮简单的，但是我们能否从简单的源码中学到一个东西呢？这是个问题。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"JNI学习笔记（三）－编译文件makefile以及cmake","date":"2016-11-29T10:38:27.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. Android.mk\n\nAndroid.mk在jni目录下，用于描述构建系统的源文件以及\nshared libraries 。文件格式如下：\n\n* 以LOCAL_PATH变量开始 \n\n\n\n\t```\nLOCAL_PATH := $(call my-dir)\n```\n* 紧接着是CLEAR_VARS变量 \n\n\t```\n\tinclude $(CLEAR_VARS) \n\t```\n* 接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。\n* 接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如\n\n\t```\n\tLOCAL_SRC_FILES := hello-jni.c \n\t```\n* 最后一行是帮助构建系统联系在一起的。\n\n\t```\ninclude $(BUILD_SHARED_LIBRARY) \n```\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := hello-jni\n\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。\n\n构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：\n\n* 以LOCAL_开始，如LOCAL_MODULE\n* 以PRIVATE_, NDK_, or APP \n* 小写字母，如 my-di\n\n如果要自定义的话，建议MY_开头。\n\n#### 2.1 NDK 默认的变量\n\n* CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 \n\n\t```\ninclude $(CLEAR_VARS) \n```\n* BUILD_SHARED_LIBRARY,告诉构建系统去收集声明的LOCAL_变量的值，然后输出成so \n\n\t```\ninclude $(BUILD_SHARED_LIBRARY)\n```\n* BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a \n\n\t```\ninclude $(BUILD_STATIC_LIBRARY) \n```\n* PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 \n\n\t```\n\tinclude $(PREBUILT_SHARED_LIBRARY) \n\t```\n* PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似\n* TARGET_ARCH 略，重点看TARGET_ARCH_ABI\n* TARGET_PLATFORM 指定当前编译的android api版本 \n\n\t```\nTARGET_PLATFORM := android-22\n```\n* TARGET_ARCH_ABI 指定cpu架构，\n\n\t```\nTARGET_ARCH_ABI := arm64-v8a\n```\n* TARGET_ABI，指定android api版本鱼abi架构\n* \n\t```\n\tTARGET_ABI := android-22-arm64-v8a\n\t```\n\n#### 2.2 Module-Description Variables 描述model的变量\n\n*  LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 \n\n\n\t\n\t```\n\tLOCAL_PATH := $(call my-dir)\n\t\n\t```\n\t注意CLEAR_VARS，并不会清除这个的值\n* LOCAL_MODULE \n* LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字\n* LOCAL_SRC_FILES 指定这个model对应的原文件\n* LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他\n* LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),\n\n\t```\n\tLOCAL_CPP_FEATURES := rtti\n\t```\n* LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径\n* LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项\n* LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries\n* LOCAL_WHOLE_STATIC_LIBRARIES  整个。\n* LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so \n\n\t```\n\tLOCAL_LDLIBS := -lz \n\t```\n* LOCAL_LDFLAGS 略，没看明白\n* LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。\n* 剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。\n\n### 3. Application.mk\n\n用于描述app需要的native model。\n\n#### 3.1 变量\n\n* APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。\n* APP_OPTIM 配置release和debug\n* APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件\n* APP_CPPFLAGS 和 APP_CFLAGS类似\n* APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效\n* APP_BUILD_SCRIPT 指定Android.mk文件\n* APP_ABI 指定abi\n* APP_PLATFORM 指定android api版本\n* APP_STL 链接其他的c＋＋支持\n* NDK_TOOLCHAIN_VERSION  gcc编译版本\n* APP_PIE \n* APP_THIN_ARCHIVE\n\n\n### 4.在Android Studio中使用 \n\n要求 Android Studio 2.2 以上。\n\n在gradle中，\n\n```\nandroid {\n  defaultConfig {  \n    externalNativeBuild {\n      cmake {\n        // 设置cmake参数 \"-DVAR_NAME=VALUE\"\n        arguments \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_TOOLCHAIN=clang\"\n      }\n    }\n    // 设置 abi\n    ndk {\n            abiFilters \"armeabi\",\"x86\",\"armeabi-v7a\"\n        }\n  }\n  buildTypes {...}\n  \n  externalNativeBuild {\n    cmake {\n    \t// CMakeLists.txt 文件路径\n    \tpath 'src/main/jni/CMakeLists.txt' \n    }\n  }\n}\n```\n\n我们需要编写的就是上面三处有注释的地方。\n\n* cmake参数 格式为 -D + Variable name ＝ Arguments 的形势\n\t* ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种\n\t* ANDROID_PLATFORM target Android platform\n\t* ANDROID_STL  cmake编译时用哪个stl，有以下种类[Helper Runtimes](https://developer.android.com/ndk/guides/cpp-support.html#hr)\n\t* ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。\n\t* ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions\n\t* ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。\n\t* ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb\n\t* NDROID_ARM_NEON build native lib 是否NONE支持\n\t* ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过\n\t* ANDROID_DISABLE_RELRO 是否只读\n\t* ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。\n* ndk abifilters\n* cmake path\n\n关于cmake 参数，[官方文档](https://developer.android.com/ndk/guides/cmake.html)\n\n### 5. CMakeLists.txt 编写\n\n\n* cmake 最小版本 ```\n\tcmake_minimum_required(VERSION 3.4.1)\t\n\t``` \n\t\t\n* \n\t```\nadd_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)\n```\n* 指定头文件路径 \n\n\t```\ninclude_directories(src/main/cpp/include/)\n``` \n\n#### 5.1 添加native api\n\n```\nfind_library( # Defines the name of the path variable that stores the\n              # location of the NDK library.\n              log-lib\n\n              # Specifies the name of the NDK library that\n              # CMake needs to locate.\n              log )\n```\n\n按照我个人的理解，\n\n* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。\n* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name\n\n然后使用target_link_libraries(native-lib,${log-lib}) 去链接咱们的本地库和ndk中带的本地库，\n\n_ _ _\n\n也可以将源代码添加进来，\n\n```\nadd_library( app-glue\n             STATIC\n             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )\n```\n* lib name\n* 类型\n* 文件路径\n\n\n#### 5.2 添加其他预先构建的libraries\n\n因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project\n\n```\nadd_library( imported-lib\n             SHARED\n             IMPORTED )\n```\n\n然后需要用set_target_properties去指定路径。\n\n```\nset_target_properties( # Specifies the target library.\n                       imported-lib\n\n                       # Specifies the parameter you want to define.\n                       PROPERTIES IMPORTED_LOCATION\n\n                       # Provides the path to the library you want to import.\n                       imported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n```\n\n* lib name\n* 指定参数\n* 指定so的路径\n\n这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。\n\n\n### 6. 总结\n有理解的不对的，大家指出，共同学习共同进步。\n\n\n\n\n\n\n\n\n\n\n\n\n_ _ _\n\n参考资料：\n\n* [Android.mk、文档](https://developer.android.com/ndk/guides/android_mk.html)\n* [Application.mk 文档](https://developer.android.com/ndk/guides/application_mk.html)\n* [Android 文档cmake 文档](https://developer.android.com/ndk/guides/cmake.html)\n* [Android studio 中介绍](https://developer.android.com/studio/projects/add-native-code.html#existing-project)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/JNI学习笔记（三）－编译文件makefile以及cmake.md","raw":"---\ntitle: JNI学习笔记（三）－编译文件makefile以及cmake\ndate: 2016-11-29 18:38:27\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. Android.mk\n\nAndroid.mk在jni目录下，用于描述构建系统的源文件以及\nshared libraries 。文件格式如下：\n\n* 以LOCAL_PATH变量开始 \n\n\n\n\t```\nLOCAL_PATH := $(call my-dir)\n```\n* 紧接着是CLEAR_VARS变量 \n\n\t```\n\tinclude $(CLEAR_VARS) \n\t```\n* 接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。\n* 接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如\n\n\t```\n\tLOCAL_SRC_FILES := hello-jni.c \n\t```\n* 最后一行是帮助构建系统联系在一起的。\n\n\t```\ninclude $(BUILD_SHARED_LIBRARY) \n```\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := hello-jni\n\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。\n\n构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：\n\n* 以LOCAL_开始，如LOCAL_MODULE\n* 以PRIVATE_, NDK_, or APP \n* 小写字母，如 my-di\n\n如果要自定义的话，建议MY_开头。\n\n#### 2.1 NDK 默认的变量\n\n* CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 \n\n\t```\ninclude $(CLEAR_VARS) \n```\n* BUILD_SHARED_LIBRARY,告诉构建系统去收集声明的LOCAL_变量的值，然后输出成so \n\n\t```\ninclude $(BUILD_SHARED_LIBRARY)\n```\n* BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a \n\n\t```\ninclude $(BUILD_STATIC_LIBRARY) \n```\n* PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 \n\n\t```\n\tinclude $(PREBUILT_SHARED_LIBRARY) \n\t```\n* PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似\n* TARGET_ARCH 略，重点看TARGET_ARCH_ABI\n* TARGET_PLATFORM 指定当前编译的android api版本 \n\n\t```\nTARGET_PLATFORM := android-22\n```\n* TARGET_ARCH_ABI 指定cpu架构，\n\n\t```\nTARGET_ARCH_ABI := arm64-v8a\n```\n* TARGET_ABI，指定android api版本鱼abi架构\n* \n\t```\n\tTARGET_ABI := android-22-arm64-v8a\n\t```\n\n#### 2.2 Module-Description Variables 描述model的变量\n\n*  LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 \n\n\n\t\n\t```\n\tLOCAL_PATH := $(call my-dir)\n\t\n\t```\n\t注意CLEAR_VARS，并不会清除这个的值\n* LOCAL_MODULE \n* LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字\n* LOCAL_SRC_FILES 指定这个model对应的原文件\n* LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他\n* LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),\n\n\t```\n\tLOCAL_CPP_FEATURES := rtti\n\t```\n* LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径\n* LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项\n* LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries\n* LOCAL_WHOLE_STATIC_LIBRARIES  整个。\n* LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so \n\n\t```\n\tLOCAL_LDLIBS := -lz \n\t```\n* LOCAL_LDFLAGS 略，没看明白\n* LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。\n* 剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。\n\n### 3. Application.mk\n\n用于描述app需要的native model。\n\n#### 3.1 变量\n\n* APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。\n* APP_OPTIM 配置release和debug\n* APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件\n* APP_CPPFLAGS 和 APP_CFLAGS类似\n* APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效\n* APP_BUILD_SCRIPT 指定Android.mk文件\n* APP_ABI 指定abi\n* APP_PLATFORM 指定android api版本\n* APP_STL 链接其他的c＋＋支持\n* NDK_TOOLCHAIN_VERSION  gcc编译版本\n* APP_PIE \n* APP_THIN_ARCHIVE\n\n\n### 4.在Android Studio中使用 \n\n要求 Android Studio 2.2 以上。\n\n在gradle中，\n\n```\nandroid {\n  defaultConfig {  \n    externalNativeBuild {\n      cmake {\n        // 设置cmake参数 \"-DVAR_NAME=VALUE\"\n        arguments \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_TOOLCHAIN=clang\"\n      }\n    }\n    // 设置 abi\n    ndk {\n            abiFilters \"armeabi\",\"x86\",\"armeabi-v7a\"\n        }\n  }\n  buildTypes {...}\n  \n  externalNativeBuild {\n    cmake {\n    \t// CMakeLists.txt 文件路径\n    \tpath 'src/main/jni/CMakeLists.txt' \n    }\n  }\n}\n```\n\n我们需要编写的就是上面三处有注释的地方。\n\n* cmake参数 格式为 -D + Variable name ＝ Arguments 的形势\n\t* ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种\n\t* ANDROID_PLATFORM target Android platform\n\t* ANDROID_STL  cmake编译时用哪个stl，有以下种类[Helper Runtimes](https://developer.android.com/ndk/guides/cpp-support.html#hr)\n\t* ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。\n\t* ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions\n\t* ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。\n\t* ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb\n\t* NDROID_ARM_NEON build native lib 是否NONE支持\n\t* ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过\n\t* ANDROID_DISABLE_RELRO 是否只读\n\t* ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。\n* ndk abifilters\n* cmake path\n\n关于cmake 参数，[官方文档](https://developer.android.com/ndk/guides/cmake.html)\n\n### 5. CMakeLists.txt 编写\n\n\n* cmake 最小版本 ```\n\tcmake_minimum_required(VERSION 3.4.1)\t\n\t``` \n\t\t\n* \n\t```\nadd_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)\n```\n* 指定头文件路径 \n\n\t```\ninclude_directories(src/main/cpp/include/)\n``` \n\n#### 5.1 添加native api\n\n```\nfind_library( # Defines the name of the path variable that stores the\n              # location of the NDK library.\n              log-lib\n\n              # Specifies the name of the NDK library that\n              # CMake needs to locate.\n              log )\n```\n\n按照我个人的理解，\n\n* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。\n* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name\n\n然后使用target_link_libraries(native-lib,${log-lib}) 去链接咱们的本地库和ndk中带的本地库，\n\n_ _ _\n\n也可以将源代码添加进来，\n\n```\nadd_library( app-glue\n             STATIC\n             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )\n```\n* lib name\n* 类型\n* 文件路径\n\n\n#### 5.2 添加其他预先构建的libraries\n\n因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project\n\n```\nadd_library( imported-lib\n             SHARED\n             IMPORTED )\n```\n\n然后需要用set_target_properties去指定路径。\n\n```\nset_target_properties( # Specifies the target library.\n                       imported-lib\n\n                       # Specifies the parameter you want to define.\n                       PROPERTIES IMPORTED_LOCATION\n\n                       # Provides the path to the library you want to import.\n                       imported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n```\n\n* lib name\n* 指定参数\n* 指定so的路径\n\n这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。\n\n\n### 6. 总结\n有理解的不对的，大家指出，共同学习共同进步。\n\n\n\n\n\n\n\n\n\n\n\n\n_ _ _\n\n参考资料：\n\n* [Android.mk、文档](https://developer.android.com/ndk/guides/android_mk.html)\n* [Application.mk 文档](https://developer.android.com/ndk/guides/application_mk.html)\n* [Android 文档cmake 文档](https://developer.android.com/ndk/guides/cmake.html)\n* [Android studio 中介绍](https://developer.android.com/studio/projects/add-native-code.html#existing-project)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"JNI学习笔记（三）－编译文件makefile以及cmake","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxo001919fyx47eqgif","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。<br><a id=\"more\"></a></p>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"2-Android-mk\"><a href=\"#2-Android-mk\" class=\"headerlink\" title=\"2. Android.mk\"></a>2. Android.mk</h3><p>Android.mk在jni目录下，用于描述构建系统的源文件以及<br>shared libraries 。文件格式如下：</p>\n<ul>\n<li>以LOCAL_PATH变量开始 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><p>紧接着是CLEAR_VARS变量 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。</p>\n</li>\n<li><p>接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div></pre></td></tr></table></figure>\n</li>\n<li><p>最后一行是帮助构建系统联系在一起的。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。</p>\n<p>构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：</p>\n<ul>\n<li>以LOCAL_开始，如LOCAL_MODULE</li>\n<li>以PRIVATE<em>, NDK</em>, or APP </li>\n<li>小写字母，如 my-di</li>\n</ul>\n<p>如果要自定义的话，建议MY_开头。</p>\n<h4 id=\"2-1-NDK-默认的变量\"><a href=\"#2-1-NDK-默认的变量\" class=\"headerlink\" title=\"2.1 NDK 默认的变量\"></a>2.1 NDK 默认的变量</h4><ul>\n<li><p>CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_SHARED<em>LIBRARY,告诉构建系统去收集声明的LOCAL</em>变量的值，然后输出成so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_STATIC_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(PREBUILT_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似</p>\n</li>\n<li>TARGET_ARCH 略，重点看TARGET_ARCH_ABI</li>\n<li><p>TARGET_PLATFORM 指定当前编译的android api版本 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_PLATFORM := android-22</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ARCH_ABI 指定cpu架构，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ARCH_ABI := arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ABI，指定android api版本鱼abi架构</p>\n</li>\n<li>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ABI := android-22-arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-2-Module-Description-Variables-描述model的变量\"><a href=\"#2-2-Module-Description-Variables-描述model的变量\" class=\"headerlink\" title=\"2.2 Module-Description Variables 描述model的变量\"></a>2.2 Module-Description Variables 描述model的变量</h4><ul>\n<li>LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n\n注意CLEAR_VARS，并不会清除这个的值\n</code></pre><ul>\n<li>LOCAL_MODULE </li>\n<li>LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字</li>\n<li>LOCAL_SRC_FILES 指定这个model对应的原文件</li>\n<li>LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他</li>\n<li><p>LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_CPP_FEATURES := rtti</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径</p>\n</li>\n<li>LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项</li>\n<li>LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries</li>\n<li>LOCAL_WHOLE_STATIC_LIBRARIES  整个。</li>\n<li><p>LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_LDLIBS := -lz</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_LDFLAGS 略，没看明白</p>\n</li>\n<li>LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。</li>\n<li>剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。</li>\n</ul>\n<h3 id=\"3-Application-mk\"><a href=\"#3-Application-mk\" class=\"headerlink\" title=\"3. Application.mk\"></a>3. Application.mk</h3><p>用于描述app需要的native model。</p>\n<h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><ul>\n<li>APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。</li>\n<li>APP_OPTIM 配置release和debug</li>\n<li>APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件</li>\n<li>APP_CPPFLAGS 和 APP_CFLAGS类似</li>\n<li>APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效</li>\n<li>APP_BUILD_SCRIPT 指定Android.mk文件</li>\n<li>APP_ABI 指定abi</li>\n<li>APP_PLATFORM 指定android api版本</li>\n<li>APP_STL 链接其他的c＋＋支持</li>\n<li>NDK_TOOLCHAIN_VERSION  gcc编译版本</li>\n<li>APP_PIE </li>\n<li>APP_THIN_ARCHIVE</li>\n</ul>\n<h3 id=\"4-在Android-Studio中使用\"><a href=\"#4-在Android-Studio中使用\" class=\"headerlink\" title=\"4.在Android Studio中使用\"></a>4.在Android Studio中使用</h3><p>要求 Android Studio 2.2 以上。</p>\n<p>在gradle中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">  defaultConfig &#123;  </div><div class=\"line\">    externalNativeBuild &#123;</div><div class=\"line\">      cmake &#123;</div><div class=\"line\">        // 设置cmake参数 &quot;-DVAR_NAME=VALUE&quot;</div><div class=\"line\">        arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DANDROID_TOOLCHAIN=clang&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 设置 abi</div><div class=\"line\">    ndk &#123;</div><div class=\"line\">            abiFilters &quot;armeabi&quot;,&quot;x86&quot;,&quot;armeabi-v7a&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  buildTypes &#123;...&#125;</div><div class=\"line\">  </div><div class=\"line\">  externalNativeBuild &#123;</div><div class=\"line\">    cmake &#123;</div><div class=\"line\">    \t// CMakeLists.txt 文件路径</div><div class=\"line\">    \tpath &apos;src/main/jni/CMakeLists.txt&apos; </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要编写的就是上面三处有注释的地方。</p>\n<ul>\n<li>cmake参数 格式为 -D + Variable name ＝ Arguments 的形势<ul>\n<li>ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种</li>\n<li>ANDROID_PLATFORM target Android platform</li>\n<li>ANDROID_STL  cmake编译时用哪个stl，有以下种类<a href=\"https://developer.android.com/ndk/guides/cpp-support.html#hr\" target=\"_blank\" rel=\"external\">Helper Runtimes</a></li>\n<li>ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。</li>\n<li>ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions</li>\n<li>ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。</li>\n<li>ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb</li>\n<li>NDROID_ARM_NEON build native lib 是否NONE支持</li>\n<li>ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过</li>\n<li>ANDROID_DISABLE_RELRO 是否只读</li>\n<li>ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。</li>\n</ul>\n</li>\n<li>ndk abifilters</li>\n<li>cmake path</li>\n</ul>\n<p>关于cmake 参数，<a href=\"https://developer.android.com/ndk/guides/cmake.html\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<h3 id=\"5-CMakeLists-txt-编写\"><a href=\"#5-CMakeLists-txt-编写\" class=\"headerlink\" title=\"5. CMakeLists.txt 编写\"></a>5. CMakeLists.txt 编写</h3><ul>\n<li>cmake 最小版本 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tcmake_minimum_required(VERSION 3.4.1)\t</div><div class=\"line\">\t``` </div><div class=\"line\">\t\t</div><div class=\"line\">*</div></pre></td></tr></table></figure></li>\n</ul>\n<p>add_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* 指定头文件路径</div></pre></td></tr></table></figure></p>\n<p>include_directories(src/main/cpp/include/)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 5.1 添加native api</div></pre></td></tr></table></figure></p>\n<p>find_library( # Defines the name of the path variable that stores the</p>\n<pre><code># location of the NDK library.\nlog-lib\n\n# Specifies the name of the NDK library that\n# CMake needs to locate.\nlog )\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">按照我个人的理解，</div><div class=\"line\"></div><div class=\"line\">* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。</div><div class=\"line\">* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name</div><div class=\"line\"></div><div class=\"line\">然后使用target_link_libraries(native-lib,$&#123;log-lib&#125;) 去链接咱们的本地库和ndk中带的本地库，</div><div class=\"line\"></div><div class=\"line\">_ _ _</div><div class=\"line\"></div><div class=\"line\">也可以将源代码添加进来，</div></pre></td></tr></table></figure>\n<p>add_library( app-glue<br>             STATIC<br>             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">* lib name</div><div class=\"line\">* 类型</div><div class=\"line\">* 文件路径</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 5.2 添加其他预先构建的libraries</div><div class=\"line\"></div><div class=\"line\">因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project</div></pre></td></tr></table></figure></p>\n<p>add_library( imported-lib<br>             SHARED<br>             IMPORTED )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后需要用set_target_properties去指定路径。</div></pre></td></tr></table></figure></p>\n<p>set_target_properties( # Specifies the target library.<br>                       imported-lib</p>\n<pre><code># Specifies the parameter you want to define.\nPROPERTIES IMPORTED_LOCATION\n\n# Provides the path to the library you want to import.\nimported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n</code></pre><p>```</p>\n<ul>\n<li>lib name</li>\n<li>指定参数</li>\n<li>指定so的路径</li>\n</ul>\n<p>这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>有理解的不对的，大家指出，共同学习共同进步。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/ndk/guides/android_mk.html\" target=\"_blank\" rel=\"external\">Android.mk、文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/application_mk.html\" target=\"_blank\" rel=\"external\">Application.mk 文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/cmake.html\" target=\"_blank\" rel=\"external\">Android 文档cmake 文档</a></li>\n<li><a href=\"https://developer.android.com/studio/projects/add-native-code.html#existing-project\" target=\"_blank\" rel=\"external\">Android studio 中介绍</a></li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。<br>","more":"</p>\n<The rest of contents | 余下全文>\n\n<h3 id=\"2-Android-mk\"><a href=\"#2-Android-mk\" class=\"headerlink\" title=\"2. Android.mk\"></a>2. Android.mk</h3><p>Android.mk在jni目录下，用于描述构建系统的源文件以及<br>shared libraries 。文件格式如下：</p>\n<ul>\n<li>以LOCAL_PATH变量开始 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><p>紧接着是CLEAR_VARS变量 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。</p>\n</li>\n<li><p>接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div></pre></td></tr></table></figure>\n</li>\n<li><p>最后一行是帮助构建系统联系在一起的。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。</p>\n<p>构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：</p>\n<ul>\n<li>以LOCAL_开始，如LOCAL_MODULE</li>\n<li>以PRIVATE<em>, NDK</em>, or APP </li>\n<li>小写字母，如 my-di</li>\n</ul>\n<p>如果要自定义的话，建议MY_开头。</p>\n<h4 id=\"2-1-NDK-默认的变量\"><a href=\"#2-1-NDK-默认的变量\" class=\"headerlink\" title=\"2.1 NDK 默认的变量\"></a>2.1 NDK 默认的变量</h4><ul>\n<li><p>CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_SHARED<em>LIBRARY,告诉构建系统去收集声明的LOCAL</em>变量的值，然后输出成so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_STATIC_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(PREBUILT_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似</p>\n</li>\n<li>TARGET_ARCH 略，重点看TARGET_ARCH_ABI</li>\n<li><p>TARGET_PLATFORM 指定当前编译的android api版本 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_PLATFORM := android-22</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ARCH_ABI 指定cpu架构，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ARCH_ABI := arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ABI，指定android api版本鱼abi架构</p>\n</li>\n<li>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ABI := android-22-arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-2-Module-Description-Variables-描述model的变量\"><a href=\"#2-2-Module-Description-Variables-描述model的变量\" class=\"headerlink\" title=\"2.2 Module-Description Variables 描述model的变量\"></a>2.2 Module-Description Variables 描述model的变量</h4><ul>\n<li>LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n\n注意CLEAR_VARS，并不会清除这个的值\n</code></pre><ul>\n<li>LOCAL_MODULE </li>\n<li>LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字</li>\n<li>LOCAL_SRC_FILES 指定这个model对应的原文件</li>\n<li>LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他</li>\n<li><p>LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_CPP_FEATURES := rtti</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径</p>\n</li>\n<li>LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项</li>\n<li>LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries</li>\n<li>LOCAL_WHOLE_STATIC_LIBRARIES  整个。</li>\n<li><p>LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_LDLIBS := -lz</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_LDFLAGS 略，没看明白</p>\n</li>\n<li>LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。</li>\n<li>剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。</li>\n</ul>\n<h3 id=\"3-Application-mk\"><a href=\"#3-Application-mk\" class=\"headerlink\" title=\"3. Application.mk\"></a>3. Application.mk</h3><p>用于描述app需要的native model。</p>\n<h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><ul>\n<li>APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。</li>\n<li>APP_OPTIM 配置release和debug</li>\n<li>APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件</li>\n<li>APP_CPPFLAGS 和 APP_CFLAGS类似</li>\n<li>APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效</li>\n<li>APP_BUILD_SCRIPT 指定Android.mk文件</li>\n<li>APP_ABI 指定abi</li>\n<li>APP_PLATFORM 指定android api版本</li>\n<li>APP_STL 链接其他的c＋＋支持</li>\n<li>NDK_TOOLCHAIN_VERSION  gcc编译版本</li>\n<li>APP_PIE </li>\n<li>APP_THIN_ARCHIVE</li>\n</ul>\n<h3 id=\"4-在Android-Studio中使用\"><a href=\"#4-在Android-Studio中使用\" class=\"headerlink\" title=\"4.在Android Studio中使用\"></a>4.在Android Studio中使用</h3><p>要求 Android Studio 2.2 以上。</p>\n<p>在gradle中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">  defaultConfig &#123;  </div><div class=\"line\">    externalNativeBuild &#123;</div><div class=\"line\">      cmake &#123;</div><div class=\"line\">        // 设置cmake参数 &quot;-DVAR_NAME=VALUE&quot;</div><div class=\"line\">        arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DANDROID_TOOLCHAIN=clang&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 设置 abi</div><div class=\"line\">    ndk &#123;</div><div class=\"line\">            abiFilters &quot;armeabi&quot;,&quot;x86&quot;,&quot;armeabi-v7a&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  buildTypes &#123;...&#125;</div><div class=\"line\">  </div><div class=\"line\">  externalNativeBuild &#123;</div><div class=\"line\">    cmake &#123;</div><div class=\"line\">    \t// CMakeLists.txt 文件路径</div><div class=\"line\">    \tpath &apos;src/main/jni/CMakeLists.txt&apos; </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要编写的就是上面三处有注释的地方。</p>\n<ul>\n<li>cmake参数 格式为 -D + Variable name ＝ Arguments 的形势<ul>\n<li>ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种</li>\n<li>ANDROID_PLATFORM target Android platform</li>\n<li>ANDROID_STL  cmake编译时用哪个stl，有以下种类<a href=\"https://developer.android.com/ndk/guides/cpp-support.html#hr\">Helper Runtimes</a></li>\n<li>ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。</li>\n<li>ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions</li>\n<li>ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。</li>\n<li>ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb</li>\n<li>NDROID_ARM_NEON build native lib 是否NONE支持</li>\n<li>ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过</li>\n<li>ANDROID_DISABLE_RELRO 是否只读</li>\n<li>ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。</li>\n</ul>\n</li>\n<li>ndk abifilters</li>\n<li>cmake path</li>\n</ul>\n<p>关于cmake 参数，<a href=\"https://developer.android.com/ndk/guides/cmake.html\">官方文档</a></p>\n<h3 id=\"5-CMakeLists-txt-编写\"><a href=\"#5-CMakeLists-txt-编写\" class=\"headerlink\" title=\"5. CMakeLists.txt 编写\"></a>5. CMakeLists.txt 编写</h3><ul>\n<li>cmake 最小版本 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tcmake_minimum_required(VERSION 3.4.1)\t</div><div class=\"line\">\t``` </div><div class=\"line\">\t\t</div><div class=\"line\">*</div></pre></td></tr></table></figure></li>\n</ul>\n<p>add_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* 指定头文件路径</div></pre></td></tr></table></figure></p>\n<p>include_directories(src/main/cpp/include/)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 5.1 添加native api</div></pre></td></tr></table></figure></p>\n<p>find_library( # Defines the name of the path variable that stores the</p>\n<pre><code># location of the NDK library.\nlog-lib\n\n# Specifies the name of the NDK library that\n# CMake needs to locate.\nlog )\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">按照我个人的理解，</div><div class=\"line\"></div><div class=\"line\">* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。</div><div class=\"line\">* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name</div><div class=\"line\"></div><div class=\"line\">然后使用target_link_libraries(native-lib,$&#123;log-lib&#125;) 去链接咱们的本地库和ndk中带的本地库，</div><div class=\"line\"></div><div class=\"line\">_ _ _</div><div class=\"line\"></div><div class=\"line\">也可以将源代码添加进来，</div></pre></td></tr></table></figure>\n<p>add_library( app-glue<br>             STATIC<br>             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">* lib name</div><div class=\"line\">* 类型</div><div class=\"line\">* 文件路径</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 5.2 添加其他预先构建的libraries</div><div class=\"line\"></div><div class=\"line\">因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project</div></pre></td></tr></table></figure></p>\n<p>add_library( imported-lib<br>             SHARED<br>             IMPORTED )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后需要用set_target_properties去指定路径。</div></pre></td></tr></table></figure></p>\n<p>set_target_properties( # Specifies the target library.<br>                       imported-lib</p>\n<pre><code># Specifies the parameter you want to define.\nPROPERTIES IMPORTED_LOCATION\n\n# Provides the path to the library you want to import.\nimported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n</code></pre><p>```</p>\n<ul>\n<li>lib name</li>\n<li>指定参数</li>\n<li>指定so的路径</li>\n</ul>\n<p>这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>有理解的不对的，大家指出，共同学习共同进步。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/ndk/guides/android_mk.html\">Android.mk、文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/application_mk.html\">Application.mk 文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/cmake.html\">Android 文档cmake 文档</a></li>\n<li><a href=\"https://developer.android.com/studio/projects/add-native-code.html#existing-project\">Android studio 中介绍</a></li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"layout":"android","title":"JNI学习笔记（二）－动态注册native函数","date":"2016-11-29T08:33:30.000Z","_content":"<Excerpt in index | 首页摘要> \n\n### 1.前言\n\n在很久之前的一篇[Android 开发艺术探索的笔记](http://blog.csdn.net/qq_21430549/article/details/49535483)当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. 首先声明native函数\n\n现在，我在activity里声明了一个native函数。\n\n```\npublic native String getStringFromC();\n```\n\n然后我们build一下，为啥要build呢，这个马上就说的。\n\n### 3. 创建并编写 .h头文件\n\n创建jni目录，并且右键->new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。\n\n```\n#ifndef NDK_CORE_H\n#define NDK_CORE_H\n\n#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))\n\n#include <jni.h>\n#include <stdlib.h>\n\n__BEGIN_DECLS\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);\nJNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);\n\n\n__END_DECLS\n\n#endif //TEXT_HELLO_H\n\n```\n\n代码说明如下：\n\n*  我们定义了一个宏NELEM，后面会用到\n*  我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，\n\n### 4. 编写cpp文件\n\n代码如下：\n\n```\njstring returnString(JNIEnv *env,jobject jobj){\n  char* str = \"I come from C＋＋\";\n  return env->NewStringUTF(str);\n}\n\nstatic JNINativeMethod gMethods[] = {\n    {\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n};\n\nJNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) {\n  JNIEnv *env;\n  if (vm->GetEnv((void **) &env,JNI_VERSION_1_6) != JNI_OK){\n    return JNI_ERR;\n  }\n\n  jclass javaClass = env->FindClass(\"com/example/hello_jni/MainActivity\");\n  if (javaClass == NULL){\n    return JNI_ERR;\n  }\n  if (env->RegisterNatives(javaClass,gMethods,NELEM(gMethods)) < 0) {\n    return JNI_ERR;\n  }\n\n  return JNI_VERSION_1_6;\n}\n```\n先看JNI_OnLoad方法，这是注册native函数的地方。\n\n*  首先判断jni版本是不是JNI_VERSION_1_6\n*  FindClass方法找到我们对应生命native函数的类，返回一个jclass\n*  RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，\n\n就这样，我们就注册了native函数了。接下来我们看下gMethods。\n\n### 5. JNINativeMethod数组\n\n这个数组里存放着这样的元素。\n\n```\n{\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n```\n\n* 第一个参数对应的native方法名\n* 第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。\n![这里写图片描述](http://img.blog.csdn.net/20161126110049266)\n* 第三个参数对应的是我嗯c++代码里对应的实现\n\n最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。\n\nandroid.mk\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := hello-jni\n\nLOCAL_C_INCLUDES += $(LOCAL_PATH)\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\napplication.mk\n\n```\nAPP_ABI := armeabi x86\nAPP_PLATFORM := android-14\nAPP_STL := stlport_static\nAPP_OPTIM := debug\n```\n\ngradle 配置\n\n![这里写图片描述](http://img.blog.csdn.net/20161126110601745)\n\n最后就会生出so文件了。(会自动打包进apk里)\n![这里写图片描述](http://img.blog.csdn.net/20161126110719106)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/JNI学习笔记（二）－动态注册native函数.md","raw":"layout: android\ntitle: JNI学习笔记（二）－动态注册native函数\ndate: 2016-11-29 16:33:30\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要> \n\n### 1.前言\n\n在很久之前的一篇[Android 开发艺术探索的笔记](http://blog.csdn.net/qq_21430549/article/details/49535483)当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. 首先声明native函数\n\n现在，我在activity里声明了一个native函数。\n\n```\npublic native String getStringFromC();\n```\n\n然后我们build一下，为啥要build呢，这个马上就说的。\n\n### 3. 创建并编写 .h头文件\n\n创建jni目录，并且右键->new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。\n\n```\n#ifndef NDK_CORE_H\n#define NDK_CORE_H\n\n#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))\n\n#include <jni.h>\n#include <stdlib.h>\n\n__BEGIN_DECLS\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);\nJNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);\n\n\n__END_DECLS\n\n#endif //TEXT_HELLO_H\n\n```\n\n代码说明如下：\n\n*  我们定义了一个宏NELEM，后面会用到\n*  我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，\n\n### 4. 编写cpp文件\n\n代码如下：\n\n```\njstring returnString(JNIEnv *env,jobject jobj){\n  char* str = \"I come from C＋＋\";\n  return env->NewStringUTF(str);\n}\n\nstatic JNINativeMethod gMethods[] = {\n    {\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n};\n\nJNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) {\n  JNIEnv *env;\n  if (vm->GetEnv((void **) &env,JNI_VERSION_1_6) != JNI_OK){\n    return JNI_ERR;\n  }\n\n  jclass javaClass = env->FindClass(\"com/example/hello_jni/MainActivity\");\n  if (javaClass == NULL){\n    return JNI_ERR;\n  }\n  if (env->RegisterNatives(javaClass,gMethods,NELEM(gMethods)) < 0) {\n    return JNI_ERR;\n  }\n\n  return JNI_VERSION_1_6;\n}\n```\n先看JNI_OnLoad方法，这是注册native函数的地方。\n\n*  首先判断jni版本是不是JNI_VERSION_1_6\n*  FindClass方法找到我们对应生命native函数的类，返回一个jclass\n*  RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，\n\n就这样，我们就注册了native函数了。接下来我们看下gMethods。\n\n### 5. JNINativeMethod数组\n\n这个数组里存放着这样的元素。\n\n```\n{\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n```\n\n* 第一个参数对应的native方法名\n* 第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。\n![这里写图片描述](http://img.blog.csdn.net/20161126110049266)\n* 第三个参数对应的是我嗯c++代码里对应的实现\n\n最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。\n\nandroid.mk\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := hello-jni\n\nLOCAL_C_INCLUDES += $(LOCAL_PATH)\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\napplication.mk\n\n```\nAPP_ABI := armeabi x86\nAPP_PLATFORM := android-14\nAPP_STL := stlport_static\nAPP_OPTIM := debug\n```\n\ngradle 配置\n\n![这里写图片描述](http://img.blog.csdn.net/20161126110601745)\n\n最后就会生出so文件了。(会自动打包进apk里)\n![这里写图片描述](http://img.blog.csdn.net/20161126110719106)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"JNI学习笔记（二）－动态注册native函数","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"photos":[],"link":"","_id":"cjfrzslxp001c19fydkbl3yi9","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"> \n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在很久之前的一篇<a href=\"http://blog.csdn.net/qq_21430549/article/details/49535483\" target=\"_blank\" rel=\"external\">Android 开发艺术探索的笔记</a>当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。<br><a id=\"more\"></a></p>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"2-首先声明native函数\"><a href=\"#2-首先声明native函数\" class=\"headerlink\" title=\"2. 首先声明native函数\"></a>2. 首先声明native函数</h3><p>现在，我在activity里声明了一个native函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public native String getStringFromC();</div></pre></td></tr></table></figure>\n<p>然后我们build一下，为啥要build呢，这个马上就说的。</p>\n<h3 id=\"3-创建并编写-h头文件\"><a href=\"#3-创建并编写-h头文件\" class=\"headerlink\" title=\"3. 创建并编写 .h头文件\"></a>3. 创建并编写 .h头文件</h3><p>创建jni目录，并且右键-&gt;new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef NDK_CORE_H</div><div class=\"line\">#define NDK_CORE_H</div><div class=\"line\"></div><div class=\"line\">#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))</div><div class=\"line\"></div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\"></div><div class=\"line\">__BEGIN_DECLS</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);</div><div class=\"line\">JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">__END_DECLS</div><div class=\"line\"></div><div class=\"line\">#endif //TEXT_HELLO_H</div></pre></td></tr></table></figure>\n<p>代码说明如下：</p>\n<ul>\n<li>我们定义了一个宏NELEM，后面会用到</li>\n<li>我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，</li>\n</ul>\n<h3 id=\"4-编写cpp文件\"><a href=\"#4-编写cpp文件\" class=\"headerlink\" title=\"4. 编写cpp文件\"></a>4. 编写cpp文件</h3><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">jstring returnString(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;I come from C＋＋&quot;;</div><div class=\"line\">  return env-&gt;NewStringUTF(str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">    &#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) &#123;</div><div class=\"line\">  JNIEnv *env;</div><div class=\"line\">  if (vm-&gt;GetEnv((void **) &amp;env,JNI_VERSION_1_6) != JNI_OK)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jclass javaClass = env-&gt;FindClass(&quot;com/example/hello_jni/MainActivity&quot;);</div><div class=\"line\">  if (javaClass == NULL)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (env-&gt;RegisterNatives(javaClass,gMethods,NELEM(gMethods)) &lt; 0) &#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return JNI_VERSION_1_6;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先看JNI_OnLoad方法，这是注册native函数的地方。</p>\n<ul>\n<li>首先判断jni版本是不是JNI_VERSION_1_6</li>\n<li>FindClass方法找到我们对应生命native函数的类，返回一个jclass</li>\n<li>RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，</li>\n</ul>\n<p>就这样，我们就注册了native函数了。接下来我们看下gMethods。</p>\n<h3 id=\"5-JNINativeMethod数组\"><a href=\"#5-JNINativeMethod数组\" class=\"headerlink\" title=\"5. JNINativeMethod数组\"></a>5. JNINativeMethod数组</h3><p>这个数组里存放着这样的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数对应的native方法名</li>\n<li>第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。<br><img src=\"http://img.blog.csdn.net/20161126110049266\" alt=\"这里写图片描述\"></li>\n<li>第三个参数对应的是我嗯c++代码里对应的实现</li>\n</ul>\n<p>最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。</p>\n<p>android.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_C_INCLUDES += $(LOCAL_PATH)</div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>application.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP_ABI := armeabi x86</div><div class=\"line\">APP_PLATFORM := android-14</div><div class=\"line\">APP_STL := stlport_static</div><div class=\"line\">APP_OPTIM := debug</div></pre></td></tr></table></figure>\n<p>gradle 配置</p>\n<p><img src=\"http://img.blog.csdn.net/20161126110601745\" alt=\"这里写图片描述\"></p>\n<p>最后就会生出so文件了。(会自动打包进apk里)<br><img src=\"http://img.blog.csdn.net/20161126110719106\" alt=\"这里写图片描述\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要> \n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在很久之前的一篇<a href=\"http://blog.csdn.net/qq_21430549/article/details/49535483\">Android 开发艺术探索的笔记</a>当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。<br>","more":"</p>\n<The rest of contents | 余下全文>\n\n<h3 id=\"2-首先声明native函数\"><a href=\"#2-首先声明native函数\" class=\"headerlink\" title=\"2. 首先声明native函数\"></a>2. 首先声明native函数</h3><p>现在，我在activity里声明了一个native函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public native String getStringFromC();</div></pre></td></tr></table></figure>\n<p>然后我们build一下，为啥要build呢，这个马上就说的。</p>\n<h3 id=\"3-创建并编写-h头文件\"><a href=\"#3-创建并编写-h头文件\" class=\"headerlink\" title=\"3. 创建并编写 .h头文件\"></a>3. 创建并编写 .h头文件</h3><p>创建jni目录，并且右键-&gt;new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef NDK_CORE_H</div><div class=\"line\">#define NDK_CORE_H</div><div class=\"line\"></div><div class=\"line\">#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))</div><div class=\"line\"></div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\"></div><div class=\"line\">__BEGIN_DECLS</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);</div><div class=\"line\">JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">__END_DECLS</div><div class=\"line\"></div><div class=\"line\">#endif //TEXT_HELLO_H</div></pre></td></tr></table></figure>\n<p>代码说明如下：</p>\n<ul>\n<li>我们定义了一个宏NELEM，后面会用到</li>\n<li>我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，</li>\n</ul>\n<h3 id=\"4-编写cpp文件\"><a href=\"#4-编写cpp文件\" class=\"headerlink\" title=\"4. 编写cpp文件\"></a>4. 编写cpp文件</h3><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">jstring returnString(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;I come from C＋＋&quot;;</div><div class=\"line\">  return env-&gt;NewStringUTF(str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">    &#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) &#123;</div><div class=\"line\">  JNIEnv *env;</div><div class=\"line\">  if (vm-&gt;GetEnv((void **) &amp;env,JNI_VERSION_1_6) != JNI_OK)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jclass javaClass = env-&gt;FindClass(&quot;com/example/hello_jni/MainActivity&quot;);</div><div class=\"line\">  if (javaClass == NULL)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (env-&gt;RegisterNatives(javaClass,gMethods,NELEM(gMethods)) &lt; 0) &#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return JNI_VERSION_1_6;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先看JNI_OnLoad方法，这是注册native函数的地方。</p>\n<ul>\n<li>首先判断jni版本是不是JNI_VERSION_1_6</li>\n<li>FindClass方法找到我们对应生命native函数的类，返回一个jclass</li>\n<li>RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，</li>\n</ul>\n<p>就这样，我们就注册了native函数了。接下来我们看下gMethods。</p>\n<h3 id=\"5-JNINativeMethod数组\"><a href=\"#5-JNINativeMethod数组\" class=\"headerlink\" title=\"5. JNINativeMethod数组\"></a>5. JNINativeMethod数组</h3><p>这个数组里存放着这样的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数对应的native方法名</li>\n<li>第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。<br><img src=\"http://img.blog.csdn.net/20161126110049266\" alt=\"这里写图片描述\"></li>\n<li>第三个参数对应的是我嗯c++代码里对应的实现</li>\n</ul>\n<p>最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。</p>\n<p>android.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_C_INCLUDES += $(LOCAL_PATH)</div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>application.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP_ABI := armeabi x86</div><div class=\"line\">APP_PLATFORM := android-14</div><div class=\"line\">APP_STL := stlport_static</div><div class=\"line\">APP_OPTIM := debug</div></pre></td></tr></table></figure>\n<p>gradle 配置</p>\n<p><img src=\"http://img.blog.csdn.net/20161126110601745\" alt=\"这里写图片描述\"></p>\n<p>最后就会生出so文件了。(会自动打包进apk里)<br><img src=\"http://img.blog.csdn.net/20161126110719106\" alt=\"这里写图片描述\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"LayoutInflater源码浅析","date":"2017-02-22T13:46:55.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n每天都在使用LayoutInflater,是否了解过其内部实现呢？今天，就来学习下，是如何从xml文件加成成View的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### LayoutInflater#inflate\n\n不管是通过什么方式去加载的，最后都会调用inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)这个方法。这个方法的代码如下：\n\n```\n    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n        synchronized (mConstructorArgs) {\n            Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"inflate\");\n\n            final Context inflaterContext = mContext;\n            final AttributeSet attrs = Xml.asAttributeSet(parser);\n            Context lastContext = (Context) mConstructorArgs[0];\n            mConstructorArgs[0] = inflaterContext;\n            View result = root;\n\n            try {\n                // Look for the root node.\n                int type;\n                while ((type = parser.next()) != XmlPullParser.START_TAG &&\n                        type != XmlPullParser.END_DOCUMENT) {\n                    // Empty\n                }\n\n                if (type != XmlPullParser.START_TAG) {\n                    throw new InflateException(parser.getPositionDescription()\n                            + \": No start tag found!\");\n                }\n\n                final String name = parser.getName();\n                \n                if (DEBUG) {\n                    System.out.println(\"**************************\");\n                    System.out.println(\"Creating root view: \"\n                            + name);\n                    System.out.println(\"**************************\");\n                }\n\n                if (TAG_MERGE.equals(name)) {\n                    if (root == null || !attachToRoot) {\n                        throw new InflateException(\"<merge /> can be used only with a valid \"\n                                + \"ViewGroup root and attachToRoot=true\");\n                    }\n\n                    rInflate(parser, root, inflaterContext, attrs, false);\n                } else {\n                    // Temp is the root view that was found in the xml\n                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n\n                    ViewGroup.LayoutParams params = null;\n\n                    if (root != null) {\n                        if (DEBUG) {\n                            System.out.println(\"Creating params from root: \" +\n                                    root);\n                        }\n                        // Create layout params that match root, if supplied\n                        params = root.generateLayoutParams(attrs);\n                        if (!attachToRoot) {\n                            // Set the layout params for temp if we are not\n                            // attaching. (If we are, we use addView, below)\n                            temp.setLayoutParams(params);\n                        }\n                    }\n\n                    if (DEBUG) {\n                        System.out.println(\"-----> start inflating children\");\n                    }\n\n                    // Inflate all children under temp against its context.\n                    rInflateChildren(parser, temp, attrs, true);\n\n                    if (DEBUG) {\n                        System.out.println(\"-----> done inflating children\");\n                    }\n\n                    // We are supposed to attach all the views we found (int temp)\n                    // to root. Do that now.\n                    if (root != null && attachToRoot) {\n                        root.addView(temp, params);\n                    }\n\n                    // Decide whether to return the root that was passed in or the\n                    // top view found in xml.\n                    if (root == null || !attachToRoot) {\n                        result = temp;\n                    }\n                }\n\n            } catch (XmlPullParserException e) {\n                InflateException ex = new InflateException(e.getMessage());\n                ex.initCause(e);\n                throw ex;\n            } catch (Exception e) {\n                InflateException ex = new InflateException(\n                        parser.getPositionDescription()\n                                + \": \" + e.getMessage());\n                ex.initCause(e);\n                throw ex;\n            } finally {\n                // Don't retain static reference on context.\n                mConstructorArgs[0] = lastContext;\n                mConstructorArgs[1] = null;\n            }\n\n            Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n\n            return result;\n        }\n    }\n\n```\n\n代码较长，主要逻辑如下：\n\n* 从XmlPullParser中的到AttributeSet，设置View的构造函数的第一个参数context\n* 判断标签类型\n\t* merge标签，用rInflate进行解析加载\n\t* 其他，通过createViewFromTag方法，创建xml文件的根节点的view，然后通过rInflateChildren方法解析根view中包含的子view，并根据参数将其add到root view中。\n\t\n逻辑还是比较清晰的，从上面的步骤中，我们能知道几个重要的方法，分别是:\n\n* createViewFromTag 创建root view\n* rInflate解析merge标签的view\n* rInflateChildren解析ViewGroup中的子View\n\n### LayoutInflater#createViewFromTag\n\n那么，我们先来看下，root view是如何创建出来的。代码如下：\n\n\n```\n    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n            boolean ignoreThemeAttr) {\n        if (name.equals(\"view\")) {\n            name = attrs.getAttributeValue(null, \"class\");\n        }\n\n        // Apply a theme wrapper, if allowed and one is specified.\n        if (!ignoreThemeAttr) {\n            final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\n            final int themeResId = ta.getResourceId(0, 0);\n            if (themeResId != 0) {\n                context = new ContextThemeWrapper(context, themeResId);\n            }\n            ta.recycle();\n        }\n\n        if (name.equals(TAG_1995)) {\n            // Let's party like it's 1995!\n            return new BlinkLayout(context, attrs);\n        }\n\n        try {\n            View view;\n            if (mFactory2 != null) {\n                view = mFactory2.onCreateView(parent, name, context, attrs);\n            } else if (mFactory != null) {\n                view = mFactory.onCreateView(name, context, attrs);\n            } else {\n                view = null;\n            }\n\n            if (view == null && mPrivateFactory != null) {\n                view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n            }\n\n            if (view == null) {\n                final Object lastContext = mConstructorArgs[0];\n                mConstructorArgs[0] = context;\n                try {\n                    if (-1 == name.indexOf('.')) {\n                        view = onCreateView(parent, name, attrs);\n                    } else {\n                        view = createView(name, null, attrs);\n                    }\n                } finally {\n                    mConstructorArgs[0] = lastContext;\n                }\n            }\n\n            return view;\n        } catch (InflateException e) {\n            throw e;\n\n        } catch (ClassNotFoundException e) {\n            final InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Error inflating class \" + name);\n            ie.initCause(e);\n            throw ie;\n\n        } catch (Exception e) {\n            final InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Error inflating class \" + name);\n            ie.initCause(e);\n            throw ie;\n        }\n    }\n```\n\n* 首先获取View的name\n* 根据参数，应用主题\n* TAG_1995?这个没怎么看懂\n* 根据mFactory2，mFactory，mPrivateFactory等是否设置过，来通过这些去加载View，我们经常在一些换肤框架中能见到。\n* 如果都没有的话，就判断name中是否包含.，为啥要这样呢？就是根据玩这个路径去加载类，然后构造View。\n* 通过代码能够发现，onCreateView方法内部也会调用createView方法，不过会加android.view.拼成完整的路径。\n\n### LayoutInflater#createView\n\n系统通过这个方法来构造View对象，我们就看下它的具体实现。\n\n```\n    public final View createView(String name, String prefix, AttributeSet attrs)\n            throws ClassNotFoundException, InflateException {\n        Constructor<? extends View> constructor = sConstructorMap.get(name);\n        Class<? extends View> clazz = null;\n\n        try {\n            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n            if (constructor == null) {\n                // Class not found in the cache, see if it's real, and try to add it\n                clazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \n                if (mFilter != null && clazz != null) {\n                    boolean allowed = mFilter.onLoadClass(clazz);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n                constructor = clazz.getConstructor(mConstructorSignature);\n                constructor.setAccessible(true);\n                sConstructorMap.put(name, constructor);\n            } else {\n                // If we have a filter, apply it to cached constructor\n                if (mFilter != null) {\n                    // Have we seen this name before?\n                    Boolean allowedState = mFilterMap.get(name);\n                    if (allowedState == null) {\n                        // New class -- remember whether it is allowed\n                        clazz = mContext.getClassLoader().loadClass(\n                                prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                        \n                        boolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                        mFilterMap.put(name, allowed);\n                        if (!allowed) {\n                            failNotAllowed(name, prefix, attrs);\n                        }\n                    } else if (allowedState.equals(Boolean.FALSE)) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n            }\n\n            Object[] args = mConstructorArgs;\n            args[1] = attrs;\n\n            final View view = constructor.newInstance(args);\n            if (view instanceof ViewStub) {\n                // Use the same context when inflating ViewStub later.\n                final ViewStub viewStub = (ViewStub) view;\n                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n            }\n            return view;\n\n        } catch (NoSuchMethodException e) {\n            InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Error inflating class \"\n                    + (prefix != null ? (prefix + name) : name));\n            ie.initCause(e);\n            throw ie;\n\n        } catch (ClassCastException e) {\n            // If loaded class is not a View subclass\n            InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Class is not a View \"\n                    + (prefix != null ? (prefix + name) : name));\n            ie.initCause(e);\n            throw ie;\n        } catch (ClassNotFoundException e) {\n            // If loadClass fails, we should propagate the exception.\n            throw e;\n        } catch (Exception e) {\n            InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Error inflating class \"\n                    + (clazz == null ? \"<unknown>\" : clazz.getName()));\n            ie.initCause(e);\n            throw ie;\n        } finally {\n            Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n        }\n    }\n```\n\n代码虽然长，但是从逻辑上分为两个部分。\n\n* 已经缓存过构造函数\n* 未缓存过构造函数\n\n在学习源码的过程中，我们经常能见到这种内存缓存的设计，以空间换时间的方法来提升效率。这个技能，我们需要get到。\n\n这里我们只看没有缓存过的部分。逻辑如下：\n\n* 通过classloader加载Class\n* 通过参数获取对应的构造方法，并进行缓存\n* 通过构造方法构造View对象\n* 如果是ViewStub的话，因为这里是按需加载，所以我们需要将这个Context对象设置给他。\n\n\n通过上面一系列方法就成功的根据xml文件构建出来root view了。当然普通view的构造过程也是一样的。\n\n### LayoutInflater#rInflate\n\n```\n    void rInflate(XmlPullParser parser, View parent, Context context,\n            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\n        final int depth = parser.getDepth();\n        int type;\n\n        while (((type = parser.next()) != XmlPullParser.END_TAG ||\n                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\n\n            if (type != XmlPullParser.START_TAG) {\n                continue;\n            }\n\n            final String name = parser.getName();\n            \n            if (TAG_REQUEST_FOCUS.equals(name)) {\n                parseRequestFocus(parser, parent);\n            } else if (TAG_TAG.equals(name)) {\n                parseViewTag(parser, parent, attrs);\n            } else if (TAG_INCLUDE.equals(name)) {\n                if (parser.getDepth() == 0) {\n                    throw new InflateException(\"<include /> cannot be the root element\");\n                }\n                parseInclude(parser, context, parent, attrs);\n            } else if (TAG_MERGE.equals(name)) {\n                throw new InflateException(\"<merge /> must be the root element\");\n            } else {\n                final View view = createViewFromTag(parent, name, context, attrs);\n                final ViewGroup viewGroup = (ViewGroup) parent;\n                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n                rInflateChildren(parser, view, attrs, true);\n                viewGroup.addView(view, params);\n            }\n        }\n\n        if (finishInflate) {\n            parent.onFinishInflate();\n        }\n    }\n```\t\n逻辑比较清晰，也比较简单。\n\n* 根据标签类型，进行不同的操作\n\t* 如include，调用parseInclude去解析\n\t* 正常View，就调用createViewFromTag去构造View，并调用rInflateChildren去解析他的子View，并将这个view加入到他的父控件中。\n\t\n### LayoutInflater#rInflateChildren\n\n这个方法就更简单了。\n\n```\n    final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,\n            boolean finishInflate) throws XmlPullParserException, IOException {\n        rInflate(parser, parent, parent.getContext(), attrs, finishInflate);\n    }\n``` \n\n这里调用rInflate去解析，略过\n\n\n就这样，就从xml解析成View了。\n\n### 剩下的一点东西\n\n* Filter\n* Factory\n* Factory2\n\n上面的几个接口，允许我们去做一些过滤操作，或者我们控制下View的构造过程。\n\n### 总结\n\n逻辑上很清晰，不知道大家有没有学习到呢？\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/LayoutInflater源码浅析.md","raw":"---\ntitle: LayoutInflater源码浅析\ndate: 2017-02-22 21:46:55\ncategories: Android\ntags: 源码\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n每天都在使用LayoutInflater,是否了解过其内部实现呢？今天，就来学习下，是如何从xml文件加成成View的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### LayoutInflater#inflate\n\n不管是通过什么方式去加载的，最后都会调用inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)这个方法。这个方法的代码如下：\n\n```\n    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n        synchronized (mConstructorArgs) {\n            Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"inflate\");\n\n            final Context inflaterContext = mContext;\n            final AttributeSet attrs = Xml.asAttributeSet(parser);\n            Context lastContext = (Context) mConstructorArgs[0];\n            mConstructorArgs[0] = inflaterContext;\n            View result = root;\n\n            try {\n                // Look for the root node.\n                int type;\n                while ((type = parser.next()) != XmlPullParser.START_TAG &&\n                        type != XmlPullParser.END_DOCUMENT) {\n                    // Empty\n                }\n\n                if (type != XmlPullParser.START_TAG) {\n                    throw new InflateException(parser.getPositionDescription()\n                            + \": No start tag found!\");\n                }\n\n                final String name = parser.getName();\n                \n                if (DEBUG) {\n                    System.out.println(\"**************************\");\n                    System.out.println(\"Creating root view: \"\n                            + name);\n                    System.out.println(\"**************************\");\n                }\n\n                if (TAG_MERGE.equals(name)) {\n                    if (root == null || !attachToRoot) {\n                        throw new InflateException(\"<merge /> can be used only with a valid \"\n                                + \"ViewGroup root and attachToRoot=true\");\n                    }\n\n                    rInflate(parser, root, inflaterContext, attrs, false);\n                } else {\n                    // Temp is the root view that was found in the xml\n                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);\n\n                    ViewGroup.LayoutParams params = null;\n\n                    if (root != null) {\n                        if (DEBUG) {\n                            System.out.println(\"Creating params from root: \" +\n                                    root);\n                        }\n                        // Create layout params that match root, if supplied\n                        params = root.generateLayoutParams(attrs);\n                        if (!attachToRoot) {\n                            // Set the layout params for temp if we are not\n                            // attaching. (If we are, we use addView, below)\n                            temp.setLayoutParams(params);\n                        }\n                    }\n\n                    if (DEBUG) {\n                        System.out.println(\"-----> start inflating children\");\n                    }\n\n                    // Inflate all children under temp against its context.\n                    rInflateChildren(parser, temp, attrs, true);\n\n                    if (DEBUG) {\n                        System.out.println(\"-----> done inflating children\");\n                    }\n\n                    // We are supposed to attach all the views we found (int temp)\n                    // to root. Do that now.\n                    if (root != null && attachToRoot) {\n                        root.addView(temp, params);\n                    }\n\n                    // Decide whether to return the root that was passed in or the\n                    // top view found in xml.\n                    if (root == null || !attachToRoot) {\n                        result = temp;\n                    }\n                }\n\n            } catch (XmlPullParserException e) {\n                InflateException ex = new InflateException(e.getMessage());\n                ex.initCause(e);\n                throw ex;\n            } catch (Exception e) {\n                InflateException ex = new InflateException(\n                        parser.getPositionDescription()\n                                + \": \" + e.getMessage());\n                ex.initCause(e);\n                throw ex;\n            } finally {\n                // Don't retain static reference on context.\n                mConstructorArgs[0] = lastContext;\n                mConstructorArgs[1] = null;\n            }\n\n            Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n\n            return result;\n        }\n    }\n\n```\n\n代码较长，主要逻辑如下：\n\n* 从XmlPullParser中的到AttributeSet，设置View的构造函数的第一个参数context\n* 判断标签类型\n\t* merge标签，用rInflate进行解析加载\n\t* 其他，通过createViewFromTag方法，创建xml文件的根节点的view，然后通过rInflateChildren方法解析根view中包含的子view，并根据参数将其add到root view中。\n\t\n逻辑还是比较清晰的，从上面的步骤中，我们能知道几个重要的方法，分别是:\n\n* createViewFromTag 创建root view\n* rInflate解析merge标签的view\n* rInflateChildren解析ViewGroup中的子View\n\n### LayoutInflater#createViewFromTag\n\n那么，我们先来看下，root view是如何创建出来的。代码如下：\n\n\n```\n    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n            boolean ignoreThemeAttr) {\n        if (name.equals(\"view\")) {\n            name = attrs.getAttributeValue(null, \"class\");\n        }\n\n        // Apply a theme wrapper, if allowed and one is specified.\n        if (!ignoreThemeAttr) {\n            final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\n            final int themeResId = ta.getResourceId(0, 0);\n            if (themeResId != 0) {\n                context = new ContextThemeWrapper(context, themeResId);\n            }\n            ta.recycle();\n        }\n\n        if (name.equals(TAG_1995)) {\n            // Let's party like it's 1995!\n            return new BlinkLayout(context, attrs);\n        }\n\n        try {\n            View view;\n            if (mFactory2 != null) {\n                view = mFactory2.onCreateView(parent, name, context, attrs);\n            } else if (mFactory != null) {\n                view = mFactory.onCreateView(name, context, attrs);\n            } else {\n                view = null;\n            }\n\n            if (view == null && mPrivateFactory != null) {\n                view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n            }\n\n            if (view == null) {\n                final Object lastContext = mConstructorArgs[0];\n                mConstructorArgs[0] = context;\n                try {\n                    if (-1 == name.indexOf('.')) {\n                        view = onCreateView(parent, name, attrs);\n                    } else {\n                        view = createView(name, null, attrs);\n                    }\n                } finally {\n                    mConstructorArgs[0] = lastContext;\n                }\n            }\n\n            return view;\n        } catch (InflateException e) {\n            throw e;\n\n        } catch (ClassNotFoundException e) {\n            final InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Error inflating class \" + name);\n            ie.initCause(e);\n            throw ie;\n\n        } catch (Exception e) {\n            final InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Error inflating class \" + name);\n            ie.initCause(e);\n            throw ie;\n        }\n    }\n```\n\n* 首先获取View的name\n* 根据参数，应用主题\n* TAG_1995?这个没怎么看懂\n* 根据mFactory2，mFactory，mPrivateFactory等是否设置过，来通过这些去加载View，我们经常在一些换肤框架中能见到。\n* 如果都没有的话，就判断name中是否包含.，为啥要这样呢？就是根据玩这个路径去加载类，然后构造View。\n* 通过代码能够发现，onCreateView方法内部也会调用createView方法，不过会加android.view.拼成完整的路径。\n\n### LayoutInflater#createView\n\n系统通过这个方法来构造View对象，我们就看下它的具体实现。\n\n```\n    public final View createView(String name, String prefix, AttributeSet attrs)\n            throws ClassNotFoundException, InflateException {\n        Constructor<? extends View> constructor = sConstructorMap.get(name);\n        Class<? extends View> clazz = null;\n\n        try {\n            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n            if (constructor == null) {\n                // Class not found in the cache, see if it's real, and try to add it\n                clazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \n                if (mFilter != null && clazz != null) {\n                    boolean allowed = mFilter.onLoadClass(clazz);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n                constructor = clazz.getConstructor(mConstructorSignature);\n                constructor.setAccessible(true);\n                sConstructorMap.put(name, constructor);\n            } else {\n                // If we have a filter, apply it to cached constructor\n                if (mFilter != null) {\n                    // Have we seen this name before?\n                    Boolean allowedState = mFilterMap.get(name);\n                    if (allowedState == null) {\n                        // New class -- remember whether it is allowed\n                        clazz = mContext.getClassLoader().loadClass(\n                                prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                        \n                        boolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                        mFilterMap.put(name, allowed);\n                        if (!allowed) {\n                            failNotAllowed(name, prefix, attrs);\n                        }\n                    } else if (allowedState.equals(Boolean.FALSE)) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n            }\n\n            Object[] args = mConstructorArgs;\n            args[1] = attrs;\n\n            final View view = constructor.newInstance(args);\n            if (view instanceof ViewStub) {\n                // Use the same context when inflating ViewStub later.\n                final ViewStub viewStub = (ViewStub) view;\n                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n            }\n            return view;\n\n        } catch (NoSuchMethodException e) {\n            InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Error inflating class \"\n                    + (prefix != null ? (prefix + name) : name));\n            ie.initCause(e);\n            throw ie;\n\n        } catch (ClassCastException e) {\n            // If loaded class is not a View subclass\n            InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Class is not a View \"\n                    + (prefix != null ? (prefix + name) : name));\n            ie.initCause(e);\n            throw ie;\n        } catch (ClassNotFoundException e) {\n            // If loadClass fails, we should propagate the exception.\n            throw e;\n        } catch (Exception e) {\n            InflateException ie = new InflateException(attrs.getPositionDescription()\n                    + \": Error inflating class \"\n                    + (clazz == null ? \"<unknown>\" : clazz.getName()));\n            ie.initCause(e);\n            throw ie;\n        } finally {\n            Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n        }\n    }\n```\n\n代码虽然长，但是从逻辑上分为两个部分。\n\n* 已经缓存过构造函数\n* 未缓存过构造函数\n\n在学习源码的过程中，我们经常能见到这种内存缓存的设计，以空间换时间的方法来提升效率。这个技能，我们需要get到。\n\n这里我们只看没有缓存过的部分。逻辑如下：\n\n* 通过classloader加载Class\n* 通过参数获取对应的构造方法，并进行缓存\n* 通过构造方法构造View对象\n* 如果是ViewStub的话，因为这里是按需加载，所以我们需要将这个Context对象设置给他。\n\n\n通过上面一系列方法就成功的根据xml文件构建出来root view了。当然普通view的构造过程也是一样的。\n\n### LayoutInflater#rInflate\n\n```\n    void rInflate(XmlPullParser parser, View parent, Context context,\n            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\n        final int depth = parser.getDepth();\n        int type;\n\n        while (((type = parser.next()) != XmlPullParser.END_TAG ||\n                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\n\n            if (type != XmlPullParser.START_TAG) {\n                continue;\n            }\n\n            final String name = parser.getName();\n            \n            if (TAG_REQUEST_FOCUS.equals(name)) {\n                parseRequestFocus(parser, parent);\n            } else if (TAG_TAG.equals(name)) {\n                parseViewTag(parser, parent, attrs);\n            } else if (TAG_INCLUDE.equals(name)) {\n                if (parser.getDepth() == 0) {\n                    throw new InflateException(\"<include /> cannot be the root element\");\n                }\n                parseInclude(parser, context, parent, attrs);\n            } else if (TAG_MERGE.equals(name)) {\n                throw new InflateException(\"<merge /> must be the root element\");\n            } else {\n                final View view = createViewFromTag(parent, name, context, attrs);\n                final ViewGroup viewGroup = (ViewGroup) parent;\n                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n                rInflateChildren(parser, view, attrs, true);\n                viewGroup.addView(view, params);\n            }\n        }\n\n        if (finishInflate) {\n            parent.onFinishInflate();\n        }\n    }\n```\t\n逻辑比较清晰，也比较简单。\n\n* 根据标签类型，进行不同的操作\n\t* 如include，调用parseInclude去解析\n\t* 正常View，就调用createViewFromTag去构造View，并调用rInflateChildren去解析他的子View，并将这个view加入到他的父控件中。\n\t\n### LayoutInflater#rInflateChildren\n\n这个方法就更简单了。\n\n```\n    final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,\n            boolean finishInflate) throws XmlPullParserException, IOException {\n        rInflate(parser, parent, parent.getContext(), attrs, finishInflate);\n    }\n``` \n\n这里调用rInflate去解析，略过\n\n\n就这样，就从xml解析成View了。\n\n### 剩下的一点东西\n\n* Filter\n* Factory\n* Factory2\n\n上面的几个接口，允许我们去做一些过滤操作，或者我们控制下View的构造过程。\n\n### 总结\n\n逻辑上很清晰，不知道大家有没有学习到呢？\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"LayoutInflater源码浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxs001f19fyd9b7r737","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>每天都在使用LayoutInflater,是否了解过其内部实现呢？今天，就来学习下，是如何从xml文件加成成View的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"LayoutInflater-inflate\"><a href=\"#LayoutInflater-inflate\" class=\"headerlink\" title=\"LayoutInflater#inflate\"></a>LayoutInflater#inflate</h3><p>不管是通过什么方式去加载的，最后都会调用inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)这个方法。这个方法的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class=\"line\">    synchronized (mConstructorArgs) &#123;</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</div><div class=\"line\"></div><div class=\"line\">        final Context inflaterContext = mContext;</div><div class=\"line\">        final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class=\"line\">        Context lastContext = (Context) mConstructorArgs[0];</div><div class=\"line\">        mConstructorArgs[0] = inflaterContext;</div><div class=\"line\">        View result = root;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            // Look for the root node.</div><div class=\"line\">            int type;</div><div class=\"line\">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class=\"line\">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class=\"line\">                // Empty</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (type != XmlPullParser.START_TAG) &#123;</div><div class=\"line\">                throw new InflateException(parser.getPositionDescription()</div><div class=\"line\">                        + &quot;: No start tag found!&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            final String name = parser.getName();</div><div class=\"line\">            </div><div class=\"line\">            if (DEBUG) &#123;</div><div class=\"line\">                System.out.println(&quot;**************************&quot;);</div><div class=\"line\">                System.out.println(&quot;Creating root view: &quot;</div><div class=\"line\">                        + name);</div><div class=\"line\">                System.out.println(&quot;**************************&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (TAG_MERGE.equals(name)) &#123;</div><div class=\"line\">                if (root == null || !attachToRoot) &#123;</div><div class=\"line\">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</div><div class=\"line\">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                rInflate(parser, root, inflaterContext, attrs, false);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Temp is the root view that was found in the xml</div><div class=\"line\">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class=\"line\"></div><div class=\"line\">                ViewGroup.LayoutParams params = null;</div><div class=\"line\"></div><div class=\"line\">                if (root != null) &#123;</div><div class=\"line\">                    if (DEBUG) &#123;</div><div class=\"line\">                        System.out.println(&quot;Creating params from root: &quot; +</div><div class=\"line\">                                root);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Create layout params that match root, if supplied</div><div class=\"line\">                    params = root.generateLayoutParams(attrs);</div><div class=\"line\">                    if (!attachToRoot) &#123;</div><div class=\"line\">                        // Set the layout params for temp if we are not</div><div class=\"line\">                        // attaching. (If we are, we use addView, below)</div><div class=\"line\">                        temp.setLayoutParams(params);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (DEBUG) &#123;</div><div class=\"line\">                    System.out.println(&quot;-----&gt; start inflating children&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Inflate all children under temp against its context.</div><div class=\"line\">                rInflateChildren(parser, temp, attrs, true);</div><div class=\"line\"></div><div class=\"line\">                if (DEBUG) &#123;</div><div class=\"line\">                    System.out.println(&quot;-----&gt; done inflating children&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // We are supposed to attach all the views we found (int temp)</div><div class=\"line\">                // to root. Do that now.</div><div class=\"line\">                if (root != null &amp;&amp; attachToRoot) &#123;</div><div class=\"line\">                    root.addView(temp, params);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Decide whether to return the root that was passed in or the</div><div class=\"line\">                // top view found in xml.</div><div class=\"line\">                if (root == null || !attachToRoot) &#123;</div><div class=\"line\">                    result = temp;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (XmlPullParserException e) &#123;</div><div class=\"line\">            InflateException ex = new InflateException(e.getMessage());</div><div class=\"line\">            ex.initCause(e);</div><div class=\"line\">            throw ex;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            InflateException ex = new InflateException(</div><div class=\"line\">                    parser.getPositionDescription()</div><div class=\"line\">                            + &quot;: &quot; + e.getMessage());</div><div class=\"line\">            ex.initCause(e);</div><div class=\"line\">            throw ex;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            // Don&apos;t retain static reference on context.</div><div class=\"line\">            mConstructorArgs[0] = lastContext;</div><div class=\"line\">            mConstructorArgs[1] = null;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class=\"line\"></div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码较长，主要逻辑如下：</p>\n<ul>\n<li>从XmlPullParser中的到AttributeSet，设置View的构造函数的第一个参数context</li>\n<li>判断标签类型<ul>\n<li>merge标签，用rInflate进行解析加载</li>\n<li>其他，通过createViewFromTag方法，创建xml文件的根节点的view，然后通过rInflateChildren方法解析根view中包含的子view，并根据参数将其add到root view中。</li>\n</ul>\n</li>\n</ul>\n<p>逻辑还是比较清晰的，从上面的步骤中，我们能知道几个重要的方法，分别是:</p>\n<ul>\n<li>createViewFromTag 创建root view</li>\n<li>rInflate解析merge标签的view</li>\n<li>rInflateChildren解析ViewGroup中的子View</li>\n</ul>\n<h3 id=\"LayoutInflater-createViewFromTag\"><a href=\"#LayoutInflater-createViewFromTag\" class=\"headerlink\" title=\"LayoutInflater#createViewFromTag\"></a>LayoutInflater#createViewFromTag</h3><p>那么，我们先来看下，root view是如何创建出来的。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</div><div class=\"line\">        boolean ignoreThemeAttr) &#123;</div><div class=\"line\">    if (name.equals(&quot;view&quot;)) &#123;</div><div class=\"line\">        name = attrs.getAttributeValue(null, &quot;class&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Apply a theme wrapper, if allowed and one is specified.</div><div class=\"line\">    if (!ignoreThemeAttr) &#123;</div><div class=\"line\">        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</div><div class=\"line\">        final int themeResId = ta.getResourceId(0, 0);</div><div class=\"line\">        if (themeResId != 0) &#123;</div><div class=\"line\">            context = new ContextThemeWrapper(context, themeResId);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ta.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (name.equals(TAG_1995)) &#123;</div><div class=\"line\">        // Let&apos;s party like it&apos;s 1995!</div><div class=\"line\">        return new BlinkLayout(context, attrs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        View view;</div><div class=\"line\">        if (mFactory2 != null) &#123;</div><div class=\"line\">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class=\"line\">        &#125; else if (mFactory != null) &#123;</div><div class=\"line\">            view = mFactory.onCreateView(name, context, attrs);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            view = null;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class=\"line\">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (view == null) &#123;</div><div class=\"line\">            final Object lastContext = mConstructorArgs[0];</div><div class=\"line\">            mConstructorArgs[0] = context;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class=\"line\">                    view = onCreateView(parent, name, attrs);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    view = createView(name, null, attrs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                mConstructorArgs[0] = lastContext;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return view;</div><div class=\"line\">    &#125; catch (InflateException e) &#123;</div><div class=\"line\">        throw e;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (ClassNotFoundException e) &#123;</div><div class=\"line\">        final InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Error inflating class &quot; + name);</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        final InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Error inflating class &quot; + name);</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先获取View的name</li>\n<li>根据参数，应用主题</li>\n<li>TAG_1995?这个没怎么看懂</li>\n<li>根据mFactory2，mFactory，mPrivateFactory等是否设置过，来通过这些去加载View，我们经常在一些换肤框架中能见到。</li>\n<li>如果都没有的话，就判断name中是否包含.，为啥要这样呢？就是根据玩这个路径去加载类，然后构造View。</li>\n<li>通过代码能够发现，onCreateView方法内部也会调用createView方法，不过会加android.view.拼成完整的路径。</li>\n</ul>\n<h3 id=\"LayoutInflater-createView\"><a href=\"#LayoutInflater-createView\" class=\"headerlink\" title=\"LayoutInflater#createView\"></a>LayoutInflater#createView</h3><p>系统通过这个方法来构造View对象，我们就看下它的具体实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final View createView(String name, String prefix, AttributeSet attrs)</div><div class=\"line\">        throws ClassNotFoundException, InflateException &#123;</div><div class=\"line\">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</div><div class=\"line\">    Class&lt;? extends View&gt; clazz = null;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</div><div class=\"line\"></div><div class=\"line\">        if (constructor == null) &#123;</div><div class=\"line\">            // Class not found in the cache, see if it&apos;s real, and try to add it</div><div class=\"line\">            clazz = mContext.getClassLoader().loadClass(</div><div class=\"line\">                    prefix != null ? (prefix + name) : name).asSubclass(View.class);</div><div class=\"line\">            </div><div class=\"line\">            if (mFilter != null &amp;&amp; clazz != null) &#123;</div><div class=\"line\">                boolean allowed = mFilter.onLoadClass(clazz);</div><div class=\"line\">                if (!allowed) &#123;</div><div class=\"line\">                    failNotAllowed(name, prefix, attrs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            constructor = clazz.getConstructor(mConstructorSignature);</div><div class=\"line\">            constructor.setAccessible(true);</div><div class=\"line\">            sConstructorMap.put(name, constructor);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // If we have a filter, apply it to cached constructor</div><div class=\"line\">            if (mFilter != null) &#123;</div><div class=\"line\">                // Have we seen this name before?</div><div class=\"line\">                Boolean allowedState = mFilterMap.get(name);</div><div class=\"line\">                if (allowedState == null) &#123;</div><div class=\"line\">                    // New class -- remember whether it is allowed</div><div class=\"line\">                    clazz = mContext.getClassLoader().loadClass(</div><div class=\"line\">                            prefix != null ? (prefix + name) : name).asSubclass(View.class);</div><div class=\"line\">                    </div><div class=\"line\">                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);</div><div class=\"line\">                    mFilterMap.put(name, allowed);</div><div class=\"line\">                    if (!allowed) &#123;</div><div class=\"line\">                        failNotAllowed(name, prefix, attrs);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else if (allowedState.equals(Boolean.FALSE)) &#123;</div><div class=\"line\">                    failNotAllowed(name, prefix, attrs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Object[] args = mConstructorArgs;</div><div class=\"line\">        args[1] = attrs;</div><div class=\"line\"></div><div class=\"line\">        final View view = constructor.newInstance(args);</div><div class=\"line\">        if (view instanceof ViewStub) &#123;</div><div class=\"line\">            // Use the same context when inflating ViewStub later.</div><div class=\"line\">            final ViewStub viewStub = (ViewStub) view;</div><div class=\"line\">            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));</div><div class=\"line\">        &#125;</div><div class=\"line\">        return view;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (NoSuchMethodException e) &#123;</div><div class=\"line\">        InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Error inflating class &quot;</div><div class=\"line\">                + (prefix != null ? (prefix + name) : name));</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (ClassCastException e) &#123;</div><div class=\"line\">        // If loaded class is not a View subclass</div><div class=\"line\">        InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Class is not a View &quot;</div><div class=\"line\">                + (prefix != null ? (prefix + name) : name));</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\">    &#125; catch (ClassNotFoundException e) &#123;</div><div class=\"line\">        // If loadClass fails, we should propagate the exception.</div><div class=\"line\">        throw e;</div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Error inflating class &quot;</div><div class=\"line\">                + (clazz == null ? &quot;&lt;unknown&gt;&quot; : clazz.getName()));</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码虽然长，但是从逻辑上分为两个部分。</p>\n<ul>\n<li>已经缓存过构造函数</li>\n<li>未缓存过构造函数</li>\n</ul>\n<p>在学习源码的过程中，我们经常能见到这种内存缓存的设计，以空间换时间的方法来提升效率。这个技能，我们需要get到。</p>\n<p>这里我们只看没有缓存过的部分。逻辑如下：</p>\n<ul>\n<li>通过classloader加载Class</li>\n<li>通过参数获取对应的构造方法，并进行缓存</li>\n<li>通过构造方法构造View对象</li>\n<li>如果是ViewStub的话，因为这里是按需加载，所以我们需要将这个Context对象设置给他。</li>\n</ul>\n<p>通过上面一系列方法就成功的根据xml文件构建出来root view了。当然普通view的构造过程也是一样的。</p>\n<h3 id=\"LayoutInflater-rInflate\"><a href=\"#LayoutInflater-rInflate\" class=\"headerlink\" title=\"LayoutInflater#rInflate\"></a>LayoutInflater#rInflate</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">    void rInflate(XmlPullParser parser, View parent, Context context,</div><div class=\"line\">            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</div><div class=\"line\"></div><div class=\"line\">        final int depth = parser.getDepth();</div><div class=\"line\">        int type;</div><div class=\"line\"></div><div class=\"line\">        while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div class=\"line\">                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</div><div class=\"line\"></div><div class=\"line\">            if (type != XmlPullParser.START_TAG) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            final String name = parser.getName();</div><div class=\"line\">            </div><div class=\"line\">            if (TAG_REQUEST_FOCUS.equals(name)) &#123;</div><div class=\"line\">                parseRequestFocus(parser, parent);</div><div class=\"line\">            &#125; else if (TAG_TAG.equals(name)) &#123;</div><div class=\"line\">                parseViewTag(parser, parent, attrs);</div><div class=\"line\">            &#125; else if (TAG_INCLUDE.equals(name)) &#123;</div><div class=\"line\">                if (parser.getDepth() == 0) &#123;</div><div class=\"line\">                    throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                parseInclude(parser, context, parent, attrs);</div><div class=\"line\">            &#125; else if (TAG_MERGE.equals(name)) &#123;</div><div class=\"line\">                throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                final View view = createViewFromTag(parent, name, context, attrs);</div><div class=\"line\">                final ViewGroup viewGroup = (ViewGroup) parent;</div><div class=\"line\">                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div class=\"line\">                rInflateChildren(parser, view, attrs, true);</div><div class=\"line\">                viewGroup.addView(view, params);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (finishInflate) &#123;</div><div class=\"line\">            parent.onFinishInflate();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">```\t</div><div class=\"line\">逻辑比较清晰，也比较简单。</div><div class=\"line\"></div><div class=\"line\">* 根据标签类型，进行不同的操作</div><div class=\"line\">\t* 如include，调用parseInclude去解析</div><div class=\"line\">\t* 正常View，就调用createViewFromTag去构造View，并调用rInflateChildren去解析他的子View，并将这个view加入到他的父控件中。</div><div class=\"line\">\t</div><div class=\"line\">### LayoutInflater#rInflateChildren</div><div class=\"line\"></div><div class=\"line\">这个方法就更简单了。</div></pre></td></tr></table></figure>\n<pre><code>final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,\n        boolean finishInflate) throws XmlPullParserException, IOException {\n    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);\n}\n</code></pre><p>``` </p>\n<p>这里调用rInflate去解析，略过</p>\n<p>就这样，就从xml解析成View了。</p>\n<h3 id=\"剩下的一点东西\"><a href=\"#剩下的一点东西\" class=\"headerlink\" title=\"剩下的一点东西\"></a>剩下的一点东西</h3><ul>\n<li>Filter</li>\n<li>Factory</li>\n<li>Factory2</li>\n</ul>\n<p>上面的几个接口，允许我们去做一些过滤操作，或者我们控制下View的构造过程。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>逻辑上很清晰，不知道大家有没有学习到呢？</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>每天都在使用LayoutInflater,是否了解过其内部实现呢？今天，就来学习下，是如何从xml文件加成成View的。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"LayoutInflater-inflate\"><a href=\"#LayoutInflater-inflate\" class=\"headerlink\" title=\"LayoutInflater#inflate\"></a>LayoutInflater#inflate</h3><p>不管是通过什么方式去加载的，最后都会调用inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)这个方法。这个方法的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class=\"line\">    synchronized (mConstructorArgs) &#123;</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</div><div class=\"line\"></div><div class=\"line\">        final Context inflaterContext = mContext;</div><div class=\"line\">        final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class=\"line\">        Context lastContext = (Context) mConstructorArgs[0];</div><div class=\"line\">        mConstructorArgs[0] = inflaterContext;</div><div class=\"line\">        View result = root;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            // Look for the root node.</div><div class=\"line\">            int type;</div><div class=\"line\">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class=\"line\">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class=\"line\">                // Empty</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (type != XmlPullParser.START_TAG) &#123;</div><div class=\"line\">                throw new InflateException(parser.getPositionDescription()</div><div class=\"line\">                        + &quot;: No start tag found!&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            final String name = parser.getName();</div><div class=\"line\">            </div><div class=\"line\">            if (DEBUG) &#123;</div><div class=\"line\">                System.out.println(&quot;**************************&quot;);</div><div class=\"line\">                System.out.println(&quot;Creating root view: &quot;</div><div class=\"line\">                        + name);</div><div class=\"line\">                System.out.println(&quot;**************************&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (TAG_MERGE.equals(name)) &#123;</div><div class=\"line\">                if (root == null || !attachToRoot) &#123;</div><div class=\"line\">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</div><div class=\"line\">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                rInflate(parser, root, inflaterContext, attrs, false);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Temp is the root view that was found in the xml</div><div class=\"line\">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class=\"line\"></div><div class=\"line\">                ViewGroup.LayoutParams params = null;</div><div class=\"line\"></div><div class=\"line\">                if (root != null) &#123;</div><div class=\"line\">                    if (DEBUG) &#123;</div><div class=\"line\">                        System.out.println(&quot;Creating params from root: &quot; +</div><div class=\"line\">                                root);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Create layout params that match root, if supplied</div><div class=\"line\">                    params = root.generateLayoutParams(attrs);</div><div class=\"line\">                    if (!attachToRoot) &#123;</div><div class=\"line\">                        // Set the layout params for temp if we are not</div><div class=\"line\">                        // attaching. (If we are, we use addView, below)</div><div class=\"line\">                        temp.setLayoutParams(params);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (DEBUG) &#123;</div><div class=\"line\">                    System.out.println(&quot;-----&gt; start inflating children&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Inflate all children under temp against its context.</div><div class=\"line\">                rInflateChildren(parser, temp, attrs, true);</div><div class=\"line\"></div><div class=\"line\">                if (DEBUG) &#123;</div><div class=\"line\">                    System.out.println(&quot;-----&gt; done inflating children&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // We are supposed to attach all the views we found (int temp)</div><div class=\"line\">                // to root. Do that now.</div><div class=\"line\">                if (root != null &amp;&amp; attachToRoot) &#123;</div><div class=\"line\">                    root.addView(temp, params);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Decide whether to return the root that was passed in or the</div><div class=\"line\">                // top view found in xml.</div><div class=\"line\">                if (root == null || !attachToRoot) &#123;</div><div class=\"line\">                    result = temp;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (XmlPullParserException e) &#123;</div><div class=\"line\">            InflateException ex = new InflateException(e.getMessage());</div><div class=\"line\">            ex.initCause(e);</div><div class=\"line\">            throw ex;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            InflateException ex = new InflateException(</div><div class=\"line\">                    parser.getPositionDescription()</div><div class=\"line\">                            + &quot;: &quot; + e.getMessage());</div><div class=\"line\">            ex.initCause(e);</div><div class=\"line\">            throw ex;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            // Don&apos;t retain static reference on context.</div><div class=\"line\">            mConstructorArgs[0] = lastContext;</div><div class=\"line\">            mConstructorArgs[1] = null;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class=\"line\"></div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码较长，主要逻辑如下：</p>\n<ul>\n<li>从XmlPullParser中的到AttributeSet，设置View的构造函数的第一个参数context</li>\n<li>判断标签类型<ul>\n<li>merge标签，用rInflate进行解析加载</li>\n<li>其他，通过createViewFromTag方法，创建xml文件的根节点的view，然后通过rInflateChildren方法解析根view中包含的子view，并根据参数将其add到root view中。</li>\n</ul>\n</li>\n</ul>\n<p>逻辑还是比较清晰的，从上面的步骤中，我们能知道几个重要的方法，分别是:</p>\n<ul>\n<li>createViewFromTag 创建root view</li>\n<li>rInflate解析merge标签的view</li>\n<li>rInflateChildren解析ViewGroup中的子View</li>\n</ul>\n<h3 id=\"LayoutInflater-createViewFromTag\"><a href=\"#LayoutInflater-createViewFromTag\" class=\"headerlink\" title=\"LayoutInflater#createViewFromTag\"></a>LayoutInflater#createViewFromTag</h3><p>那么，我们先来看下，root view是如何创建出来的。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</div><div class=\"line\">        boolean ignoreThemeAttr) &#123;</div><div class=\"line\">    if (name.equals(&quot;view&quot;)) &#123;</div><div class=\"line\">        name = attrs.getAttributeValue(null, &quot;class&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Apply a theme wrapper, if allowed and one is specified.</div><div class=\"line\">    if (!ignoreThemeAttr) &#123;</div><div class=\"line\">        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</div><div class=\"line\">        final int themeResId = ta.getResourceId(0, 0);</div><div class=\"line\">        if (themeResId != 0) &#123;</div><div class=\"line\">            context = new ContextThemeWrapper(context, themeResId);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ta.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (name.equals(TAG_1995)) &#123;</div><div class=\"line\">        // Let&apos;s party like it&apos;s 1995!</div><div class=\"line\">        return new BlinkLayout(context, attrs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        View view;</div><div class=\"line\">        if (mFactory2 != null) &#123;</div><div class=\"line\">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class=\"line\">        &#125; else if (mFactory != null) &#123;</div><div class=\"line\">            view = mFactory.onCreateView(name, context, attrs);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            view = null;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class=\"line\">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (view == null) &#123;</div><div class=\"line\">            final Object lastContext = mConstructorArgs[0];</div><div class=\"line\">            mConstructorArgs[0] = context;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class=\"line\">                    view = onCreateView(parent, name, attrs);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    view = createView(name, null, attrs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                mConstructorArgs[0] = lastContext;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return view;</div><div class=\"line\">    &#125; catch (InflateException e) &#123;</div><div class=\"line\">        throw e;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (ClassNotFoundException e) &#123;</div><div class=\"line\">        final InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Error inflating class &quot; + name);</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        final InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Error inflating class &quot; + name);</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先获取View的name</li>\n<li>根据参数，应用主题</li>\n<li>TAG_1995?这个没怎么看懂</li>\n<li>根据mFactory2，mFactory，mPrivateFactory等是否设置过，来通过这些去加载View，我们经常在一些换肤框架中能见到。</li>\n<li>如果都没有的话，就判断name中是否包含.，为啥要这样呢？就是根据玩这个路径去加载类，然后构造View。</li>\n<li>通过代码能够发现，onCreateView方法内部也会调用createView方法，不过会加android.view.拼成完整的路径。</li>\n</ul>\n<h3 id=\"LayoutInflater-createView\"><a href=\"#LayoutInflater-createView\" class=\"headerlink\" title=\"LayoutInflater#createView\"></a>LayoutInflater#createView</h3><p>系统通过这个方法来构造View对象，我们就看下它的具体实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final View createView(String name, String prefix, AttributeSet attrs)</div><div class=\"line\">        throws ClassNotFoundException, InflateException &#123;</div><div class=\"line\">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</div><div class=\"line\">    Class&lt;? extends View&gt; clazz = null;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</div><div class=\"line\"></div><div class=\"line\">        if (constructor == null) &#123;</div><div class=\"line\">            // Class not found in the cache, see if it&apos;s real, and try to add it</div><div class=\"line\">            clazz = mContext.getClassLoader().loadClass(</div><div class=\"line\">                    prefix != null ? (prefix + name) : name).asSubclass(View.class);</div><div class=\"line\">            </div><div class=\"line\">            if (mFilter != null &amp;&amp; clazz != null) &#123;</div><div class=\"line\">                boolean allowed = mFilter.onLoadClass(clazz);</div><div class=\"line\">                if (!allowed) &#123;</div><div class=\"line\">                    failNotAllowed(name, prefix, attrs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            constructor = clazz.getConstructor(mConstructorSignature);</div><div class=\"line\">            constructor.setAccessible(true);</div><div class=\"line\">            sConstructorMap.put(name, constructor);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // If we have a filter, apply it to cached constructor</div><div class=\"line\">            if (mFilter != null) &#123;</div><div class=\"line\">                // Have we seen this name before?</div><div class=\"line\">                Boolean allowedState = mFilterMap.get(name);</div><div class=\"line\">                if (allowedState == null) &#123;</div><div class=\"line\">                    // New class -- remember whether it is allowed</div><div class=\"line\">                    clazz = mContext.getClassLoader().loadClass(</div><div class=\"line\">                            prefix != null ? (prefix + name) : name).asSubclass(View.class);</div><div class=\"line\">                    </div><div class=\"line\">                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);</div><div class=\"line\">                    mFilterMap.put(name, allowed);</div><div class=\"line\">                    if (!allowed) &#123;</div><div class=\"line\">                        failNotAllowed(name, prefix, attrs);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else if (allowedState.equals(Boolean.FALSE)) &#123;</div><div class=\"line\">                    failNotAllowed(name, prefix, attrs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Object[] args = mConstructorArgs;</div><div class=\"line\">        args[1] = attrs;</div><div class=\"line\"></div><div class=\"line\">        final View view = constructor.newInstance(args);</div><div class=\"line\">        if (view instanceof ViewStub) &#123;</div><div class=\"line\">            // Use the same context when inflating ViewStub later.</div><div class=\"line\">            final ViewStub viewStub = (ViewStub) view;</div><div class=\"line\">            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));</div><div class=\"line\">        &#125;</div><div class=\"line\">        return view;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (NoSuchMethodException e) &#123;</div><div class=\"line\">        InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Error inflating class &quot;</div><div class=\"line\">                + (prefix != null ? (prefix + name) : name));</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (ClassCastException e) &#123;</div><div class=\"line\">        // If loaded class is not a View subclass</div><div class=\"line\">        InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Class is not a View &quot;</div><div class=\"line\">                + (prefix != null ? (prefix + name) : name));</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\">    &#125; catch (ClassNotFoundException e) &#123;</div><div class=\"line\">        // If loadClass fails, we should propagate the exception.</div><div class=\"line\">        throw e;</div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        InflateException ie = new InflateException(attrs.getPositionDescription()</div><div class=\"line\">                + &quot;: Error inflating class &quot;</div><div class=\"line\">                + (clazz == null ? &quot;&lt;unknown&gt;&quot; : clazz.getName()));</div><div class=\"line\">        ie.initCause(e);</div><div class=\"line\">        throw ie;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码虽然长，但是从逻辑上分为两个部分。</p>\n<ul>\n<li>已经缓存过构造函数</li>\n<li>未缓存过构造函数</li>\n</ul>\n<p>在学习源码的过程中，我们经常能见到这种内存缓存的设计，以空间换时间的方法来提升效率。这个技能，我们需要get到。</p>\n<p>这里我们只看没有缓存过的部分。逻辑如下：</p>\n<ul>\n<li>通过classloader加载Class</li>\n<li>通过参数获取对应的构造方法，并进行缓存</li>\n<li>通过构造方法构造View对象</li>\n<li>如果是ViewStub的话，因为这里是按需加载，所以我们需要将这个Context对象设置给他。</li>\n</ul>\n<p>通过上面一系列方法就成功的根据xml文件构建出来root view了。当然普通view的构造过程也是一样的。</p>\n<h3 id=\"LayoutInflater-rInflate\"><a href=\"#LayoutInflater-rInflate\" class=\"headerlink\" title=\"LayoutInflater#rInflate\"></a>LayoutInflater#rInflate</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">    void rInflate(XmlPullParser parser, View parent, Context context,</div><div class=\"line\">            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</div><div class=\"line\"></div><div class=\"line\">        final int depth = parser.getDepth();</div><div class=\"line\">        int type;</div><div class=\"line\"></div><div class=\"line\">        while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div class=\"line\">                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</div><div class=\"line\"></div><div class=\"line\">            if (type != XmlPullParser.START_TAG) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            final String name = parser.getName();</div><div class=\"line\">            </div><div class=\"line\">            if (TAG_REQUEST_FOCUS.equals(name)) &#123;</div><div class=\"line\">                parseRequestFocus(parser, parent);</div><div class=\"line\">            &#125; else if (TAG_TAG.equals(name)) &#123;</div><div class=\"line\">                parseViewTag(parser, parent, attrs);</div><div class=\"line\">            &#125; else if (TAG_INCLUDE.equals(name)) &#123;</div><div class=\"line\">                if (parser.getDepth() == 0) &#123;</div><div class=\"line\">                    throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                parseInclude(parser, context, parent, attrs);</div><div class=\"line\">            &#125; else if (TAG_MERGE.equals(name)) &#123;</div><div class=\"line\">                throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                final View view = createViewFromTag(parent, name, context, attrs);</div><div class=\"line\">                final ViewGroup viewGroup = (ViewGroup) parent;</div><div class=\"line\">                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div class=\"line\">                rInflateChildren(parser, view, attrs, true);</div><div class=\"line\">                viewGroup.addView(view, params);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (finishInflate) &#123;</div><div class=\"line\">            parent.onFinishInflate();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">```\t</div><div class=\"line\">逻辑比较清晰，也比较简单。</div><div class=\"line\"></div><div class=\"line\">* 根据标签类型，进行不同的操作</div><div class=\"line\">\t* 如include，调用parseInclude去解析</div><div class=\"line\">\t* 正常View，就调用createViewFromTag去构造View，并调用rInflateChildren去解析他的子View，并将这个view加入到他的父控件中。</div><div class=\"line\">\t</div><div class=\"line\">### LayoutInflater#rInflateChildren</div><div class=\"line\"></div><div class=\"line\">这个方法就更简单了。</div></pre></td></tr></table></figure>\n<pre><code>final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,\n        boolean finishInflate) throws XmlPullParserException, IOException {\n    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);\n}\n</code></pre><p>``` </p>\n<p>这里调用rInflate去解析，略过</p>\n<p>就这样，就从xml解析成View了。</p>\n<h3 id=\"剩下的一点东西\"><a href=\"#剩下的一点东西\" class=\"headerlink\" title=\"剩下的一点东西\"></a>剩下的一点东西</h3><ul>\n<li>Filter</li>\n<li>Factory</li>\n<li>Factory2</li>\n</ul>\n<p>上面的几个接口，允许我们去做一些过滤操作，或者我们控制下View的构造过程。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>逻辑上很清晰，不知道大家有没有学习到呢？</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"LruCache源码浅析","date":"2017-01-12T16:00:14.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n(LRU)Least Recently Used,最近最少使用算法，其中LruCache便是其在的实现，也是今天的主角，它被用在各种各样的图片库中，我们当然有必要去了解他是如何实现的。源码非常简单，但是能看到许多非常有意思的地方。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 如何使用\n\n```\n   int cacheSize = 4 * 1024 * 1024; // 4MiB\n   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {\n        protected int sizeOf(String key, Bitmap value) {\n            return value.getByteCount();\n        }\n    }}\n```\n\n初始化之后，便可放心的put、get了。很简单，不多说。\n\n### 初始化过程\n\n```\n    public LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n\n短短的几行代码，却有一个地方需要注意，LinkedHashMap传入的第三个参数，true。这是由含义的，这个参数表示，我们在访问的时候，会根据时间进行排序，厉害吧。\n\n### get过程\n\n```\n    public final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                hitCount++;\n                return mapValue;\n            }\n            missCount++;\n        }\n\n        /*\n         * Attempt to create a value. This may take a long time, and the map\n         * may be different when create() returns. If a conflicting value was\n         * added to the map while create() was working, we leave that value in\n         * the map and release the created value.\n         */\n\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            if (mapValue != null) {\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n\n* 首先，根据key获取value，根据结果修改对应的命中还是未命中\n* 如果没有找到，就会调用create方法去创建一个value，当然，如果我们没有实现这个方法的话，默认返回null\n* 如果实现了的话，会用put方法，把这个值丢进去，这个方法的返回结果，如果存在hash冲突(也就是已经有了同一hash值对应的value)，返回原有的value，并且撤销操作(通过将原值重新put进去)，不存在hash冲突，则调整我们当前已用size\n* 存在hash冲突的情况下，entryRemoved去做一些操作，需要我们实现，不存在hash冲突，就调整size\n\n### put过程\n\n```\n    public final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key == null || value == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            putCount++;\n            size += safeSizeOf(key, value);\n            previous = map.put(key, value);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n```\n\n这个过程就简单点了\n\n* 调整size\n* put值进去，如果存在hash冲突，返回原有的值\n* 如果previous，即原来有值，调整size\n* 如果原来有值，则调用entryRemoved去做一些释放操作，需要我们实现\n* 最后，调整size大小\n\n### 调整size过程\n\n```\n    public void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.eldest();\n                if (toEvict == null) {\n                    break;\n                }\n\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n\n调整size的过程呢，就是不断重map中取出头，进行销毁释放(entryRemoved),直到容量小于我们的初始化时给定的值。\n\n### remove操作\n\n```\n    public final V remove(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            previous = map.remove(key);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, null);\n        }\n\n        return previous;\n    }\n```\n\n* map中移除\n* 销毁\n\n### 总结\n\n代码补偿，实现也简单清晰，但是却非常巧妙，有许多值得我们学习的地方。而那么多count，就是用来统计命中率啥的。\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/LruCache源码浅析.md","raw":"---\ntitle: LruCache源码浅析\ndate: 2017-01-13 00:00:14\ncategories: Android\ntags: 源码\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n(LRU)Least Recently Used,最近最少使用算法，其中LruCache便是其在的实现，也是今天的主角，它被用在各种各样的图片库中，我们当然有必要去了解他是如何实现的。源码非常简单，但是能看到许多非常有意思的地方。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 如何使用\n\n```\n   int cacheSize = 4 * 1024 * 1024; // 4MiB\n   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {\n        protected int sizeOf(String key, Bitmap value) {\n            return value.getByteCount();\n        }\n    }}\n```\n\n初始化之后，便可放心的put、get了。很简单，不多说。\n\n### 初始化过程\n\n```\n    public LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n\n短短的几行代码，却有一个地方需要注意，LinkedHashMap传入的第三个参数，true。这是由含义的，这个参数表示，我们在访问的时候，会根据时间进行排序，厉害吧。\n\n### get过程\n\n```\n    public final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                hitCount++;\n                return mapValue;\n            }\n            missCount++;\n        }\n\n        /*\n         * Attempt to create a value. This may take a long time, and the map\n         * may be different when create() returns. If a conflicting value was\n         * added to the map while create() was working, we leave that value in\n         * the map and release the created value.\n         */\n\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            if (mapValue != null) {\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n\n* 首先，根据key获取value，根据结果修改对应的命中还是未命中\n* 如果没有找到，就会调用create方法去创建一个value，当然，如果我们没有实现这个方法的话，默认返回null\n* 如果实现了的话，会用put方法，把这个值丢进去，这个方法的返回结果，如果存在hash冲突(也就是已经有了同一hash值对应的value)，返回原有的value，并且撤销操作(通过将原值重新put进去)，不存在hash冲突，则调整我们当前已用size\n* 存在hash冲突的情况下，entryRemoved去做一些操作，需要我们实现，不存在hash冲突，就调整size\n\n### put过程\n\n```\n    public final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key == null || value == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            putCount++;\n            size += safeSizeOf(key, value);\n            previous = map.put(key, value);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n```\n\n这个过程就简单点了\n\n* 调整size\n* put值进去，如果存在hash冲突，返回原有的值\n* 如果previous，即原来有值，调整size\n* 如果原来有值，则调用entryRemoved去做一些释放操作，需要我们实现\n* 最后，调整size大小\n\n### 调整size过程\n\n```\n    public void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.eldest();\n                if (toEvict == null) {\n                    break;\n                }\n\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n\n调整size的过程呢，就是不断重map中取出头，进行销毁释放(entryRemoved),直到容量小于我们的初始化时给定的值。\n\n### remove操作\n\n```\n    public final V remove(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            previous = map.remove(key);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, null);\n        }\n\n        return previous;\n    }\n```\n\n* map中移除\n* 销毁\n\n### 总结\n\n代码补偿，实现也简单清晰，但是却非常巧妙，有许多值得我们学习的地方。而那么多count，就是用来统计命中率啥的。\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"LruCache源码浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxw001j19fykuq2t59y","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>(LRU)Least Recently Used,最近最少使用算法，其中LruCache便是其在的实现，也是今天的主角，它被用在各种各样的图片库中，我们当然有必要去了解他是如何实现的。源码非常简单，但是能看到许多非常有意思的地方。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">int cacheSize = 4 * 1024 * 1024; // 4MiB</div><div class=\"line\">LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class=\"line\">     protected int sizeOf(String key, Bitmap value) &#123;</div><div class=\"line\">         return value.getByteCount();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;&#125;</div></pre></td></tr></table></figure>\n<p>初始化之后，便可放心的put、get了。很简单，不多说。</p>\n<h3 id=\"初始化过程\"><a href=\"#初始化过程\" class=\"headerlink\" title=\"初始化过程\"></a>初始化过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public LruCache(int maxSize) &#123;</div><div class=\"line\">    if (maxSize &lt;= 0) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.maxSize = maxSize;</div><div class=\"line\">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>短短的几行代码，却有一个地方需要注意，LinkedHashMap传入的第三个参数，true。这是由含义的，这个参数表示，我们在访问的时候，会根据时间进行排序，厉害吧。</p>\n<h3 id=\"get过程\"><a href=\"#get过程\" class=\"headerlink\" title=\"get过程\"></a>get过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V get(K key) &#123;</div><div class=\"line\">    if (key == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V mapValue;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        if (mapValue != null) &#123;</div><div class=\"line\">            hitCount++;</div><div class=\"line\">            return mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Attempt to create a value. This may take a long time, and the map</div><div class=\"line\">     * may be different when create() returns. If a conflicting value was</div><div class=\"line\">     * added to the map while create() was working, we leave that value in</div><div class=\"line\">     * the map and release the created value.</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    if (createdValue == null) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        createCount++;</div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\"></div><div class=\"line\">        if (mapValue != null) &#123;</div><div class=\"line\">            // There was a conflict so undo that last put</div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mapValue != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, createdValue, mapValue);</div><div class=\"line\">        return mapValue;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        return createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，根据key获取value，根据结果修改对应的命中还是未命中</li>\n<li>如果没有找到，就会调用create方法去创建一个value，当然，如果我们没有实现这个方法的话，默认返回null</li>\n<li>如果实现了的话，会用put方法，把这个值丢进去，这个方法的返回结果，如果存在hash冲突(也就是已经有了同一hash值对应的value)，返回原有的value，并且撤销操作(通过将原值重新put进去)，不存在hash冲突，则调整我们当前已用size</li>\n<li>存在hash冲突的情况下，entryRemoved去做一些操作，需要我们实现，不存在hash冲突，就调整size</li>\n</ul>\n<h3 id=\"put过程\"><a href=\"#put过程\" class=\"headerlink\" title=\"put过程\"></a>put过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V put(K key, V value) &#123;</div><div class=\"line\">    if (key == null || value == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null || value == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        putCount++;</div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        if (previous != null) &#123;</div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (previous != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">    return previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个过程就简单点了</p>\n<ul>\n<li>调整size</li>\n<li>put值进去，如果存在hash冲突，返回原有的值</li>\n<li>如果previous，即原来有值，调整size</li>\n<li>如果原来有值，则调用entryRemoved去做一些释放操作，需要我们实现</li>\n<li>最后，调整size大小</li>\n</ul>\n<h3 id=\"调整size过程\"><a href=\"#调整size过程\" class=\"headerlink\" title=\"调整size过程\"></a>调整size过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void trimToSize(int maxSize) &#123;</div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</div><div class=\"line\">                throw new IllegalStateException(getClass().getName()</div><div class=\"line\">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (size &lt;= maxSize) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</div><div class=\"line\">            if (toEvict == null) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        entryRemoved(true, key, value, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调整size的过程呢，就是不断重map中取出头，进行销毁释放(entryRemoved),直到容量小于我们的初始化时给定的值。</p>\n<h3 id=\"remove操作\"><a href=\"#remove操作\" class=\"headerlink\" title=\"remove操作\"></a>remove操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V remove(K key) &#123;</div><div class=\"line\">    if (key == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        previous = map.remove(key);</div><div class=\"line\">        if (previous != null) &#123;</div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (previous != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, previous, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>map中移除</li>\n<li>销毁</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>代码补偿，实现也简单清晰，但是却非常巧妙，有许多值得我们学习的地方。而那么多count，就是用来统计命中率啥的。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>(LRU)Least Recently Used,最近最少使用算法，其中LruCache便是其在的实现，也是今天的主角，它被用在各种各样的图片库中，我们当然有必要去了解他是如何实现的。源码非常简单，但是能看到许多非常有意思的地方。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">int cacheSize = 4 * 1024 * 1024; // 4MiB</div><div class=\"line\">LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class=\"line\">     protected int sizeOf(String key, Bitmap value) &#123;</div><div class=\"line\">         return value.getByteCount();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;&#125;</div></pre></td></tr></table></figure>\n<p>初始化之后，便可放心的put、get了。很简单，不多说。</p>\n<h3 id=\"初始化过程\"><a href=\"#初始化过程\" class=\"headerlink\" title=\"初始化过程\"></a>初始化过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public LruCache(int maxSize) &#123;</div><div class=\"line\">    if (maxSize &lt;= 0) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.maxSize = maxSize;</div><div class=\"line\">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>短短的几行代码，却有一个地方需要注意，LinkedHashMap传入的第三个参数，true。这是由含义的，这个参数表示，我们在访问的时候，会根据时间进行排序，厉害吧。</p>\n<h3 id=\"get过程\"><a href=\"#get过程\" class=\"headerlink\" title=\"get过程\"></a>get过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V get(K key) &#123;</div><div class=\"line\">    if (key == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V mapValue;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        if (mapValue != null) &#123;</div><div class=\"line\">            hitCount++;</div><div class=\"line\">            return mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Attempt to create a value. This may take a long time, and the map</div><div class=\"line\">     * may be different when create() returns. If a conflicting value was</div><div class=\"line\">     * added to the map while create() was working, we leave that value in</div><div class=\"line\">     * the map and release the created value.</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    if (createdValue == null) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        createCount++;</div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\"></div><div class=\"line\">        if (mapValue != null) &#123;</div><div class=\"line\">            // There was a conflict so undo that last put</div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mapValue != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, createdValue, mapValue);</div><div class=\"line\">        return mapValue;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        return createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，根据key获取value，根据结果修改对应的命中还是未命中</li>\n<li>如果没有找到，就会调用create方法去创建一个value，当然，如果我们没有实现这个方法的话，默认返回null</li>\n<li>如果实现了的话，会用put方法，把这个值丢进去，这个方法的返回结果，如果存在hash冲突(也就是已经有了同一hash值对应的value)，返回原有的value，并且撤销操作(通过将原值重新put进去)，不存在hash冲突，则调整我们当前已用size</li>\n<li>存在hash冲突的情况下，entryRemoved去做一些操作，需要我们实现，不存在hash冲突，就调整size</li>\n</ul>\n<h3 id=\"put过程\"><a href=\"#put过程\" class=\"headerlink\" title=\"put过程\"></a>put过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V put(K key, V value) &#123;</div><div class=\"line\">    if (key == null || value == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null || value == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        putCount++;</div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        if (previous != null) &#123;</div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (previous != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">    return previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个过程就简单点了</p>\n<ul>\n<li>调整size</li>\n<li>put值进去，如果存在hash冲突，返回原有的值</li>\n<li>如果previous，即原来有值，调整size</li>\n<li>如果原来有值，则调用entryRemoved去做一些释放操作，需要我们实现</li>\n<li>最后，调整size大小</li>\n</ul>\n<h3 id=\"调整size过程\"><a href=\"#调整size过程\" class=\"headerlink\" title=\"调整size过程\"></a>调整size过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void trimToSize(int maxSize) &#123;</div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</div><div class=\"line\">                throw new IllegalStateException(getClass().getName()</div><div class=\"line\">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (size &lt;= maxSize) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</div><div class=\"line\">            if (toEvict == null) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        entryRemoved(true, key, value, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调整size的过程呢，就是不断重map中取出头，进行销毁释放(entryRemoved),直到容量小于我们的初始化时给定的值。</p>\n<h3 id=\"remove操作\"><a href=\"#remove操作\" class=\"headerlink\" title=\"remove操作\"></a>remove操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V remove(K key) &#123;</div><div class=\"line\">    if (key == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        previous = map.remove(key);</div><div class=\"line\">        if (previous != null) &#123;</div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (previous != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, previous, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>map中移除</li>\n<li>销毁</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>代码补偿，实现也简单清晰，但是却非常巧妙，有许多值得我们学习的地方。而那么多count，就是用来统计命中率啥的。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"MaterialDesign动画","date":"2018-01-27T12:38:17.000Z","_content":"\n<Excerpt in index | 首页摘要>\n### 前言\n\n对于现在来说，大多数用户已经在使用5.0的手机了，4.4及以下的已经非常少了，那么，我们有理由把我们的app带向Material Design。Material Design中很重要的一项就是动画。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### Ripple-触摸反馈\n\n默认的，继承了MeaterialDesign主题的都带了反馈效果。系统默认有两种实现\n\n* ?android:attr/selectableItemBackground 指定有界的波纹\n* ?android:attr/selectableItemBackgroundBorderless 指定越过视图边界的波纹\n\n\n自带有界效果\n\n![自带有界效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/selectableItemBackground.gif?raw=true)\n\n自带无界效果\n\n![自带无界效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/selectableItemBackgroundBorderless.gif?raw=true)\n\n\n一个是有边界的，一个是无边界的。当然，某些情况下我们或许不满足与系统提供的，这时，我们可以选择自己是先，在drawable下定义。最简单的是这样\n\n```\n<ripple xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:color=\"@color/colorAccent\"\n    >\n</ripple>\n\n```\n\n自定义无界无mask效果\n\n![自定义无界无mask效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_wujie.gif?raw=true)\n\n上面的效果是无界的。那么，我们怎么定义一个有界的呢？我们只需要在ripple下加一个item，这个item就是我们的边界了。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ripple xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:color=\"@color/colorAccent\"\n    >\n    <item android:drawable=\"@color/colorPrimary\"/>\n</ripple>\n```\n\n自定义有界无mask效果\n\n![自定义有界无mask效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_youjie.gif?raw=true)\n\n那么，既然我们的边界item是一个drawable，我们当然可以选择其他类型的drawable作为边界。如shape，image。这样，我们控件被染成了item的颜色，我们如何去掉这个颜色呢？只要给这个设置id为android:id=\"@android:id/mask\"即可。\n\n```\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ripple xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:color=\"@color/colorAccent\"\n    >\n    <item android:drawable=\"@color/colorPrimary\" android:id=\"@android:id/mask\"/>\n</ripple>\n```\n\n```\n\n\n当我们设置mask之后，默认就是隐藏的拉。\n\n自定义有界有mask效果\n\n![自定义有界有mask效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_youjie_mask.gif?raw=true)\n\n\n关于触摸反馈就说这么多。\n\n### Circular Reveal-揭露效果\n\n这个效果呢，非常简单，我们只需要ViewAnimationUtils.createCircularReveal这个api去create一个Animator即可。\n\n```\n        circularRevealView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                    Animator animator = ViewAnimationUtils.createCircularReveal(circularRevealView,circularRevealView.getWidth(),\n                            circularRevealView.getHeight(),0,\n                            (float) Math.hypot(circularRevealView.getWidth(), circularRevealView.getHeight()));\n                    animator.setDuration(3000);\n                    animator.start();\n                }\n            }\n        });\n```\n\n参数就是起始点，起始半径以及最终半径，在这个效果里，以右下角为例，最终半径为斜边长度。\n\n效果图：\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/ciecular_reveal.gif?raw=true)\n\n### Transitions-场景过度\n\n这个在4.4的版本加入，在5.0上又加了几个动画。那么什么是场景(Scene)呢？我们可以看成是一系列View的集合。我们对着一系列View做动画。一般由View状态发生变化时触发，比如显示隐藏。那么我们如何使用呢？我们可以选择创创建Scene或者不创建Scene两种方式，统一由TransitionManager去管理。\n\n```\n        final Slide slide = new Slide();\n        final Fade fade = new Fade();\n        findViewById(R.id.anim).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n//                TransitionManager.beginDelayedTransition((ViewGroup) findViewById(R.id.sssss),new Fade());\n//                findViewById(R.id.anim).setVisibility(View.INVISIBLE);\n\n                TransitionManager.go(scene,slide);\n                findViewById(R.id.anim).setVisibility(View.INVISIBLE);\n                circularRevealView.setVisibility(View.INVISIBLE);\n            }\n        });\n\n        findViewById(R.id.reset).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                TransitionManager.go(scene,fade);\n                findViewById(R.id.anim).setVisibility(View.VISIBLE);\n                circularRevealView.setVisibility(View.VISIBLE);\n            }\n        });\n```\n\n这里只是最简单的效果，大家可以去研究更深层次的用法。\n\n看下效果。\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/Transition.gif?raw=true)\n\n### Shared Element-共享元素\n\n我们可以通过ActivityOptionsCompant兼容类去创建共享元素动画，有如下几种Api\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/shareelement.png?raw=true)\n\n\n分别创建不同类型的元素共享动画。举个简单的例子。\n\n```\n                Bundle bundle = ActivityOptionsCompat.makeSceneTransitionAnimation(MainActivity.this,\n                        crView, \"cr\")\n                        .toBundle();\n                Intent intent = new Intent(MainActivity.this, ShareEleActivity.class);\n                startActivity(intent, bundle);\n```\n\n其中，\"cr\" 是通过 android:transitionName=\"cr\"这个属性，来告诉系统，transitionName相同的View做过度。看下效果。\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/shareelement.gif?raw=true)\n\n\n共享元素动画还有很多，我这里没有在详细的说下去，大家有兴趣的自己研究下。\n\n### 参考资料\n\n[Transitions动画](https://github.com/hehonghui/android-tech-frontier/tree/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-1)\n\n[Android过度动画框架](http://einverne.github.io/post/2016/10/android-transition-framework.html)\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/MaterialDesign动画.md","raw":"---\ntitle: MaterialDesign动画\ndate: 2018-01-27 20:38:17\ntags: 动画\ncategories: Android\n\n---\n\n<Excerpt in index | 首页摘要>\n### 前言\n\n对于现在来说，大多数用户已经在使用5.0的手机了，4.4及以下的已经非常少了，那么，我们有理由把我们的app带向Material Design。Material Design中很重要的一项就是动画。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### Ripple-触摸反馈\n\n默认的，继承了MeaterialDesign主题的都带了反馈效果。系统默认有两种实现\n\n* ?android:attr/selectableItemBackground 指定有界的波纹\n* ?android:attr/selectableItemBackgroundBorderless 指定越过视图边界的波纹\n\n\n自带有界效果\n\n![自带有界效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/selectableItemBackground.gif?raw=true)\n\n自带无界效果\n\n![自带无界效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/selectableItemBackgroundBorderless.gif?raw=true)\n\n\n一个是有边界的，一个是无边界的。当然，某些情况下我们或许不满足与系统提供的，这时，我们可以选择自己是先，在drawable下定义。最简单的是这样\n\n```\n<ripple xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:color=\"@color/colorAccent\"\n    >\n</ripple>\n\n```\n\n自定义无界无mask效果\n\n![自定义无界无mask效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_wujie.gif?raw=true)\n\n上面的效果是无界的。那么，我们怎么定义一个有界的呢？我们只需要在ripple下加一个item，这个item就是我们的边界了。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ripple xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:color=\"@color/colorAccent\"\n    >\n    <item android:drawable=\"@color/colorPrimary\"/>\n</ripple>\n```\n\n自定义有界无mask效果\n\n![自定义有界无mask效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_youjie.gif?raw=true)\n\n那么，既然我们的边界item是一个drawable，我们当然可以选择其他类型的drawable作为边界。如shape，image。这样，我们控件被染成了item的颜色，我们如何去掉这个颜色呢？只要给这个设置id为android:id=\"@android:id/mask\"即可。\n\n```\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ripple xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:color=\"@color/colorAccent\"\n    >\n    <item android:drawable=\"@color/colorPrimary\" android:id=\"@android:id/mask\"/>\n</ripple>\n```\n\n```\n\n\n当我们设置mask之后，默认就是隐藏的拉。\n\n自定义有界有mask效果\n\n![自定义有界有mask效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_youjie_mask.gif?raw=true)\n\n\n关于触摸反馈就说这么多。\n\n### Circular Reveal-揭露效果\n\n这个效果呢，非常简单，我们只需要ViewAnimationUtils.createCircularReveal这个api去create一个Animator即可。\n\n```\n        circularRevealView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                    Animator animator = ViewAnimationUtils.createCircularReveal(circularRevealView,circularRevealView.getWidth(),\n                            circularRevealView.getHeight(),0,\n                            (float) Math.hypot(circularRevealView.getWidth(), circularRevealView.getHeight()));\n                    animator.setDuration(3000);\n                    animator.start();\n                }\n            }\n        });\n```\n\n参数就是起始点，起始半径以及最终半径，在这个效果里，以右下角为例，最终半径为斜边长度。\n\n效果图：\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/ciecular_reveal.gif?raw=true)\n\n### Transitions-场景过度\n\n这个在4.4的版本加入，在5.0上又加了几个动画。那么什么是场景(Scene)呢？我们可以看成是一系列View的集合。我们对着一系列View做动画。一般由View状态发生变化时触发，比如显示隐藏。那么我们如何使用呢？我们可以选择创创建Scene或者不创建Scene两种方式，统一由TransitionManager去管理。\n\n```\n        final Slide slide = new Slide();\n        final Fade fade = new Fade();\n        findViewById(R.id.anim).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n//                TransitionManager.beginDelayedTransition((ViewGroup) findViewById(R.id.sssss),new Fade());\n//                findViewById(R.id.anim).setVisibility(View.INVISIBLE);\n\n                TransitionManager.go(scene,slide);\n                findViewById(R.id.anim).setVisibility(View.INVISIBLE);\n                circularRevealView.setVisibility(View.INVISIBLE);\n            }\n        });\n\n        findViewById(R.id.reset).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                TransitionManager.go(scene,fade);\n                findViewById(R.id.anim).setVisibility(View.VISIBLE);\n                circularRevealView.setVisibility(View.VISIBLE);\n            }\n        });\n```\n\n这里只是最简单的效果，大家可以去研究更深层次的用法。\n\n看下效果。\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/Transition.gif?raw=true)\n\n### Shared Element-共享元素\n\n我们可以通过ActivityOptionsCompant兼容类去创建共享元素动画，有如下几种Api\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/shareelement.png?raw=true)\n\n\n分别创建不同类型的元素共享动画。举个简单的例子。\n\n```\n                Bundle bundle = ActivityOptionsCompat.makeSceneTransitionAnimation(MainActivity.this,\n                        crView, \"cr\")\n                        .toBundle();\n                Intent intent = new Intent(MainActivity.this, ShareEleActivity.class);\n                startActivity(intent, bundle);\n```\n\n其中，\"cr\" 是通过 android:transitionName=\"cr\"这个属性，来告诉系统，transitionName相同的View做过度。看下效果。\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/shareelement.gif?raw=true)\n\n\n共享元素动画还有很多，我这里没有在详细的说下去，大家有兴趣的自己研究下。\n\n### 参考资料\n\n[Transitions动画](https://github.com/hehonghui/android-tech-frontier/tree/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-1)\n\n[Android过度动画框架](http://einverne.github.io/post/2016/10/android-transition-framework.html)\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"MaterialDesign动画","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxy001m19fyizwbv5es","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>对于现在来说，大多数用户已经在使用5.0的手机了，4.4及以下的已经非常少了，那么，我们有理由把我们的app带向Material Design。Material Design中很重要的一项就是动画。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"Ripple-触摸反馈\"><a href=\"#Ripple-触摸反馈\" class=\"headerlink\" title=\"Ripple-触摸反馈\"></a>Ripple-触摸反馈</h3><p>默认的，继承了MeaterialDesign主题的都带了反馈效果。系统默认有两种实现</p>\n<ul>\n<li>?android:attr/selectableItemBackground 指定有界的波纹</li>\n<li>?android:attr/selectableItemBackgroundBorderless 指定越过视图边界的波纹</li>\n</ul>\n<p>自带有界效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/selectableItemBackground.gif?raw=true\" alt=\"自带有界效果\"></p>\n<p>自带无界效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/selectableItemBackgroundBorderless.gif?raw=true\" alt=\"自带无界效果\"></p>\n<p>一个是有边界的，一个是无边界的。当然，某些情况下我们或许不满足与系统提供的，这时，我们可以选择自己是先，在drawable下定义。最简单的是这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">    android:color=&quot;@color/colorAccent&quot;</div><div class=\"line\">    &gt;</div><div class=\"line\">&lt;/ripple&gt;</div></pre></td></tr></table></figure>\n<p>自定义无界无mask效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_wujie.gif?raw=true\" alt=\"自定义无界无mask效果\"></p>\n<p>上面的效果是无界的。那么，我们怎么定义一个有界的呢？我们只需要在ripple下加一个item，这个item就是我们的边界了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">    android:color=&quot;@color/colorAccent&quot;</div><div class=\"line\">    &gt;</div><div class=\"line\">    &lt;item android:drawable=&quot;@color/colorPrimary&quot;/&gt;</div><div class=\"line\">&lt;/ripple&gt;</div></pre></td></tr></table></figure>\n<p>自定义有界无mask效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_youjie.gif?raw=true\" alt=\"自定义有界无mask效果\"></p>\n<p>那么，既然我们的边界item是一个drawable，我们当然可以选择其他类型的drawable作为边界。如shape，image。这样，我们控件被染成了item的颜色，我们如何去掉这个颜色呢？只要给这个设置id为android:id=”@android:id/mask”即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">```</div><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">    android:color=&quot;@color/colorAccent&quot;</div><div class=\"line\">    &gt;</div><div class=\"line\">    &lt;item android:drawable=&quot;@color/colorPrimary&quot; android:id=&quot;@android:id/mask&quot;/&gt;</div><div class=\"line\">&lt;/ripple&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">当我们设置mask之后，默认就是隐藏的拉。</div><div class=\"line\"></div><div class=\"line\">自定义有界有mask效果</div><div class=\"line\"></div><div class=\"line\">![自定义有界有mask效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_youjie_mask.gif?raw=true)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">关于触摸反馈就说这么多。</div><div class=\"line\"></div><div class=\"line\">### Circular Reveal-揭露效果</div><div class=\"line\"></div><div class=\"line\">这个效果呢，非常简单，我们只需要ViewAnimationUtils.createCircularReveal这个api去create一个Animator即可。</div></pre></td></tr></table></figure>\n<pre><code>circularRevealView.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {\n            Animator animator = ViewAnimationUtils.createCircularReveal(circularRevealView,circularRevealView.getWidth(),\n                    circularRevealView.getHeight(),0,\n                    (float) Math.hypot(circularRevealView.getWidth(), circularRevealView.getHeight()));\n            animator.setDuration(3000);\n            animator.start();\n        }\n    }\n});\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">参数就是起始点，起始半径以及最终半径，在这个效果里，以右下角为例，最终半径为斜边长度。</div><div class=\"line\"></div><div class=\"line\">效果图：</div><div class=\"line\"></div><div class=\"line\">![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/ciecular_reveal.gif?raw=true)</div><div class=\"line\"></div><div class=\"line\">### Transitions-场景过度</div><div class=\"line\"></div><div class=\"line\">这个在4.4的版本加入，在5.0上又加了几个动画。那么什么是场景(Scene)呢？我们可以看成是一系列View的集合。我们对着一系列View做动画。一般由View状态发生变化时触发，比如显示隐藏。那么我们如何使用呢？我们可以选择创创建Scene或者不创建Scene两种方式，统一由TransitionManager去管理。</div></pre></td></tr></table></figure>\n<pre><code>final Slide slide = new Slide();\nfinal Fade fade = new Fade();\nfindViewById(R.id.anim).setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n</code></pre><p>//                TransitionManager.beginDelayedTransition((ViewGroup) findViewById(R.id.sssss),new Fade());<br>//                findViewById(R.id.anim).setVisibility(View.INVISIBLE);</p>\n<pre><code>        TransitionManager.go(scene,slide);\n        findViewById(R.id.anim).setVisibility(View.INVISIBLE);\n        circularRevealView.setVisibility(View.INVISIBLE);\n    }\n});\n\nfindViewById(R.id.reset).setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        TransitionManager.go(scene,fade);\n        findViewById(R.id.anim).setVisibility(View.VISIBLE);\n        circularRevealView.setVisibility(View.VISIBLE);\n    }\n});\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这里只是最简单的效果，大家可以去研究更深层次的用法。</div><div class=\"line\"></div><div class=\"line\">看下效果。</div><div class=\"line\"></div><div class=\"line\">![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/Transition.gif?raw=true)</div><div class=\"line\"></div><div class=\"line\">### Shared Element-共享元素</div><div class=\"line\"></div><div class=\"line\">我们可以通过ActivityOptionsCompant兼容类去创建共享元素动画，有如下几种Api</div><div class=\"line\"></div><div class=\"line\">![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/shareelement.png?raw=true)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">分别创建不同类型的元素共享动画。举个简单的例子。</div></pre></td></tr></table></figure>\n<pre><code>Bundle bundle = ActivityOptionsCompat.makeSceneTransitionAnimation(MainActivity.this,\n        crView, &quot;cr&quot;)\n        .toBundle();\nIntent intent = new Intent(MainActivity.this, ShareEleActivity.class);\nstartActivity(intent, bundle);\n</code></pre><p>```</p>\n<p>其中，”cr” 是通过 android:transitionName=”cr”这个属性，来告诉系统，transitionName相同的View做过度。看下效果。</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/shareelement.gif?raw=true\" alt=\"\"></p>\n<p>共享元素动画还有很多，我这里没有在详细的说下去，大家有兴趣的自己研究下。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://github.com/hehonghui/android-tech-frontier/tree/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-1\" target=\"_blank\" rel=\"external\">Transitions动画</a></p>\n<p><a href=\"http://einverne.github.io/post/2016/10/android-transition-framework.html\" target=\"_blank\" rel=\"external\">Android过度动画框架</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>对于现在来说，大多数用户已经在使用5.0的手机了，4.4及以下的已经非常少了，那么，我们有理由把我们的app带向Material Design。Material Design中很重要的一项就是动画。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"Ripple-触摸反馈\"><a href=\"#Ripple-触摸反馈\" class=\"headerlink\" title=\"Ripple-触摸反馈\"></a>Ripple-触摸反馈</h3><p>默认的，继承了MeaterialDesign主题的都带了反馈效果。系统默认有两种实现</p>\n<ul>\n<li>?android:attr/selectableItemBackground 指定有界的波纹</li>\n<li>?android:attr/selectableItemBackgroundBorderless 指定越过视图边界的波纹</li>\n</ul>\n<p>自带有界效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/selectableItemBackground.gif?raw=true\" alt=\"自带有界效果\"></p>\n<p>自带无界效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/selectableItemBackgroundBorderless.gif?raw=true\" alt=\"自带无界效果\"></p>\n<p>一个是有边界的，一个是无边界的。当然，某些情况下我们或许不满足与系统提供的，这时，我们可以选择自己是先，在drawable下定义。最简单的是这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">    android:color=&quot;@color/colorAccent&quot;</div><div class=\"line\">    &gt;</div><div class=\"line\">&lt;/ripple&gt;</div></pre></td></tr></table></figure>\n<p>自定义无界无mask效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_wujie.gif?raw=true\" alt=\"自定义无界无mask效果\"></p>\n<p>上面的效果是无界的。那么，我们怎么定义一个有界的呢？我们只需要在ripple下加一个item，这个item就是我们的边界了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">    android:color=&quot;@color/colorAccent&quot;</div><div class=\"line\">    &gt;</div><div class=\"line\">    &lt;item android:drawable=&quot;@color/colorPrimary&quot;/&gt;</div><div class=\"line\">&lt;/ripple&gt;</div></pre></td></tr></table></figure>\n<p>自定义有界无mask效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_youjie.gif?raw=true\" alt=\"自定义有界无mask效果\"></p>\n<p>那么，既然我们的边界item是一个drawable，我们当然可以选择其他类型的drawable作为边界。如shape，image。这样，我们控件被染成了item的颜色，我们如何去掉这个颜色呢？只要给这个设置id为android:id=”@android:id/mask”即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">```</div><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">    android:color=&quot;@color/colorAccent&quot;</div><div class=\"line\">    &gt;</div><div class=\"line\">    &lt;item android:drawable=&quot;@color/colorPrimary&quot; android:id=&quot;@android:id/mask&quot;/&gt;</div><div class=\"line\">&lt;/ripple&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">当我们设置mask之后，默认就是隐藏的拉。</div><div class=\"line\"></div><div class=\"line\">自定义有界有mask效果</div><div class=\"line\"></div><div class=\"line\">![自定义有界有mask效果](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/custom_youjie_mask.gif?raw=true)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">关于触摸反馈就说这么多。</div><div class=\"line\"></div><div class=\"line\">### Circular Reveal-揭露效果</div><div class=\"line\"></div><div class=\"line\">这个效果呢，非常简单，我们只需要ViewAnimationUtils.createCircularReveal这个api去create一个Animator即可。</div></pre></td></tr></table></figure>\n<pre><code>circularRevealView.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {\n            Animator animator = ViewAnimationUtils.createCircularReveal(circularRevealView,circularRevealView.getWidth(),\n                    circularRevealView.getHeight(),0,\n                    (float) Math.hypot(circularRevealView.getWidth(), circularRevealView.getHeight()));\n            animator.setDuration(3000);\n            animator.start();\n        }\n    }\n});\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">参数就是起始点，起始半径以及最终半径，在这个效果里，以右下角为例，最终半径为斜边长度。</div><div class=\"line\"></div><div class=\"line\">效果图：</div><div class=\"line\"></div><div class=\"line\">![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/ciecular_reveal.gif?raw=true)</div><div class=\"line\"></div><div class=\"line\">### Transitions-场景过度</div><div class=\"line\"></div><div class=\"line\">这个在4.4的版本加入，在5.0上又加了几个动画。那么什么是场景(Scene)呢？我们可以看成是一系列View的集合。我们对着一系列View做动画。一般由View状态发生变化时触发，比如显示隐藏。那么我们如何使用呢？我们可以选择创创建Scene或者不创建Scene两种方式，统一由TransitionManager去管理。</div></pre></td></tr></table></figure>\n<pre><code>final Slide slide = new Slide();\nfinal Fade fade = new Fade();\nfindViewById(R.id.anim).setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n</code></pre><p>//                TransitionManager.beginDelayedTransition((ViewGroup) findViewById(R.id.sssss),new Fade());<br>//                findViewById(R.id.anim).setVisibility(View.INVISIBLE);</p>\n<pre><code>        TransitionManager.go(scene,slide);\n        findViewById(R.id.anim).setVisibility(View.INVISIBLE);\n        circularRevealView.setVisibility(View.INVISIBLE);\n    }\n});\n\nfindViewById(R.id.reset).setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        TransitionManager.go(scene,fade);\n        findViewById(R.id.anim).setVisibility(View.VISIBLE);\n        circularRevealView.setVisibility(View.VISIBLE);\n    }\n});\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这里只是最简单的效果，大家可以去研究更深层次的用法。</div><div class=\"line\"></div><div class=\"line\">看下效果。</div><div class=\"line\"></div><div class=\"line\">![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/Transition.gif?raw=true)</div><div class=\"line\"></div><div class=\"line\">### Shared Element-共享元素</div><div class=\"line\"></div><div class=\"line\">我们可以通过ActivityOptionsCompant兼容类去创建共享元素动画，有如下几种Api</div><div class=\"line\"></div><div class=\"line\">![](https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/shareelement.png?raw=true)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">分别创建不同类型的元素共享动画。举个简单的例子。</div></pre></td></tr></table></figure>\n<pre><code>Bundle bundle = ActivityOptionsCompat.makeSceneTransitionAnimation(MainActivity.this,\n        crView, &quot;cr&quot;)\n        .toBundle();\nIntent intent = new Intent(MainActivity.this, ShareEleActivity.class);\nstartActivity(intent, bundle);\n</code></pre><p>```</p>\n<p>其中，”cr” 是通过 android:transitionName=”cr”这个属性，来告诉系统，transitionName相同的View做过度。看下效果。</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/md_anim/shareelement.gif?raw=true\" alt=\"\"></p>\n<p>共享元素动画还有很多，我这里没有在详细的说下去，大家有兴趣的自己研究下。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://github.com/hehonghui/android-tech-frontier/tree/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-1\">Transitions动画</a></p>\n<p><a href=\"http://einverne.github.io/post/2016/10/android-transition-framework.html\">Android过度动画框架</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"MultiDex源码浅析","date":"2017-04-29T05:13:39.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\nMultiDex是为了解决65536的问题，虽然说现在我们使用起来很方便了，作为一个有追求的程序员，使用并不是我们的目标，我们的目标是学习其实现原理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### MultiDex#install\n\n```\n    public static void install(Context context) {\n        Log.i(TAG, \"install\");\n        if (IS_VM_MULTIDEX_CAPABLE) {\n            Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\");\n            return;\n        }\n\n        if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) {\n            throw new RuntimeException(\"Multi dex installation failed. SDK \" + Build.VERSION.SDK_INT\n                    + \" is unsupported. Min SDK version is \" + MIN_SDK_VERSION + \".\");\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getApplicationInfo(context);\n            if (applicationInfo == null) {\n                // Looks like running on a test Context, so just return without patching.\n                return;\n            }\n\n            synchronized (installedApk) {\n                String apkPath = applicationInfo.sourceDir;\n                if (installedApk.contains(apkPath)) {\n                    return;\n                }\n                installedApk.add(apkPath);\n\n                if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) {\n                    Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \"\n                            + Build.VERSION.SDK_INT + \": SDK version higher than \"\n                            + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \"\n                            + \"runtime with built-in multidex capabilty but it's not the \"\n                            + \"case here: java.vm.version=\\\"\"\n                            + System.getProperty(\"java.vm.version\") + \"\\\"\");\n                }\n\n                /* The patched class loader is expected to be a descendant of\n                 * dalvik.system.BaseDexClassLoader. We modify its\n                 * dalvik.system.DexPathList pathList field to append additional DEX\n                 * file entries.\n                 */\n                ClassLoader loader;\n                try {\n                    loader = context.getClassLoader();\n                } catch (RuntimeException e) {\n                    /* Ignore those exceptions so that we don't break tests relying on Context like\n                     * a android.test.mock.MockContext or a android.content.ContextWrapper with a\n                     * null base Context.\n                     */\n                    Log.w(TAG, \"Failure while trying to obtain Context class loader. \" +\n                            \"Must be running in test mode. Skip patching.\", e);\n                    return;\n                }\n                if (loader == null) {\n                    // Note, the context class loader is null when running Robolectric tests.\n                    Log.e(TAG,\n                            \"Context class loader is null. Must be running in test mode. \"\n                            + \"Skip patching.\");\n                    return;\n                }\n\n                try {\n                  clearOldDexDir(context);\n                } catch (Throwable t) {\n                  Log.w(TAG, \"Something went wrong when trying to clear old MultiDex extraction, \"\n                      + \"continuing without cleaning.\", t);\n                }\n\n                File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);\n                List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false);\n                if (checkValidZipFiles(files)) {\n                    installSecondaryDexes(loader, dexDir, files);\n                } else {\n                    Log.w(TAG, \"Files were not valid zip files.  Forcing a reload.\");\n                    // Try again, but this time force a reload of the zip file.\n                    files = MultiDexExtractor.load(context, applicationInfo, dexDir, true);\n\n                    if (checkValidZipFiles(files)) {\n                        installSecondaryDexes(loader, dexDir, files);\n                    } else {\n                        // Second time didn't work, give up\n                        throw new RuntimeException(\"Zip files were not valid.\");\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n            Log.e(TAG, \"Multidex installation failure\", e);\n            throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\");\n        }\n        Log.i(TAG, \"install done\");\n    }\n```\n\n这个方法的所有代码都在上面，代码不错，逻辑如下：\n\n* 如果当前虚拟机已经支持MultiDex了，直接退出\n* 首先获取apk文件的路径，并加到installedApk中，防止重复install\n* 获取classloader，这里的这个classloader是BaseDexClassLoader,要记住，我们后面会用到。\n* 清除secondary-dexes文件夹中的dex文件\n* 通过MultiDexExtractor去提取dex文件，注意这时的第四个参数是false，\n* 校验有效性\n\t* 合法installSecondaryDexes，安装\n\t* 不合法，再次提取，不过这次提取就是从apk文件中提取了，进行安装。这一步是一点补救措施。\n\n接下来便对其中一些关键步骤进行分析。\n\n### MultiDexExtractor.load \n\n```\n    static List<File> load(Context context, ApplicationInfo applicationInfo, File dexDir,\n            boolean forceReload) throws IOException {\n        Log.i(TAG, \"MultiDexExtractor.load(\" + applicationInfo.sourceDir + \", \" + forceReload + \")\");\n        final File sourceApk = new File(applicationInfo.sourceDir);\n\n        long currentCrc = getZipCrc(sourceApk);\n\n        List<File> files;\n        if (!forceReload && !isModified(context, sourceApk, currentCrc)) {\n            try {\n                files = loadExistingExtractions(context, sourceApk, dexDir);\n            } catch (IOException ioe) {\n                Log.w(TAG, \"Failed to reload existing extracted secondary dex files,\"\n                        + \" falling back to fresh extraction\", ioe);\n                files = performExtractions(sourceApk, dexDir);\n                putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);\n\n            }\n        } else {\n            Log.i(TAG, \"Detected that extraction must be performed.\");\n            files = performExtractions(sourceApk, dexDir);\n            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);\n        }\n\n        Log.i(TAG, \"load found \" + files.size() + \" secondary dex files\");\n        return files;\n    }\n```\n\n其中dexFile 路径为code_cache/secondary-dexes\n\n在这一步是对dex文件进行提取。其中的逻辑如下，\n\n* 获取apk文件的crc校验码\n* 如果不是强行reload(强行reload是指直接从apk文件提取)，并且apk文件没有进行修改。\n\t* loadExistingExtractions 提取缓存\n\t* 如果失败，则从apk文件中提取\n* 当设置了forceReload时，直接从apk文件中提取\n\n#### 获取apk文件crc校验码\n\n```\n    private static long getZipCrc(File archive) throws IOException {\n        long computedValue = ZipUtil.getZipCrc(archive);\n        if (computedValue == NO_VALUE) {\n            // never return NO_VALUE\n            computedValue--;\n        }\n        return computedValue;\n    }\n```\n\n在这个方法中，通过ZipUtil去获取crc校验码。我们看下他的实现，\n\n```\n    static long getZipCrc(File apk) throws IOException {\n        RandomAccessFile raf = new RandomAccessFile(apk, \"r\");\n        try {\n            CentralDirectory dir = findCentralDirectory(raf);\n\n            return computeCrcOfCentralDir(raf, dir);\n        } finally {\n            raf.close();\n        }\n    }\n```\n\n通过findCentralDirectory去返回一个CentralDirectory对象，这存储了内容的偏移量和size两个字段。关于如何计算，详细看代码和zip文件格式。[ZIP文件格式](https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt)\n\nCRC计算就略过了。\n\n#### isModified\n\n```\n    private static boolean isModified(Context context, File archive, long currentCrc) {\n        SharedPreferences prefs = getMultiDexPreferences(context);\n        return (prefs.getLong(KEY_TIME_STAMP, NO_VALUE) != getTimeStamp(archive))\n                || (prefs.getLong(KEY_CRC, NO_VALUE) != currentCrc);\n    }\n```\n\n这里通过比较文件更改时间以及 crc校验码来判断apk文件是够进行过修改。如升级。\n\n#### loadExistingExtractions \n\n直接加载缓存好的dex文件。\n\n```\n    private static List<File> loadExistingExtractions(Context context, File sourceApk, File dexDir)\n            throws IOException {\n        Log.i(TAG, \"loading existing secondary dex files\");\n\n        final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;\n        int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1);\n        final List<File> files = new ArrayList<File>(totalDexNumber);\n\n        for (int secondaryNumber = 2; secondaryNumber <= totalDexNumber; secondaryNumber++) {\n            String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;\n            File extractedFile = new File(dexDir, fileName);\n            if (extractedFile.isFile()) {\n                files.add(extractedFile);\n                if (!verifyZipFile(extractedFile)) {\n                    Log.i(TAG, \"Invalid zip file: \" + extractedFile);\n                    throw new IOException(\"Invalid ZIP file.\");\n                }\n            } else {\n                throw new IOException(\"Missing extracted secondary dex file '\" +\n                        extractedFile.getPath() + \"'\");\n            }\n        }\n\n        return files;\n    }\n```\n\n上面的代码，直接查找code_cache/secondary-dexes 目录下的dex文件。\n\n#### performExtractions\n\n这个方法是干嘛的呢？当我们load缓存出异常的时候，就会用apk文件中做提取，我们看下逻辑。\n\n```\n    private static List<File> performExtractions(File sourceApk, File dexDir)\n            throws IOException {\n\n        final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;\n\n        // Ensure that whatever deletions happen in prepareDexDir only happen if the zip that\n        // contains a secondary dex file in there is not consistent with the latest apk.  Otherwise,\n        // multi-process race conditions can cause a crash loop where one process deletes the zip\n        // while another had created it.\n        prepareDexDir(dexDir, extractedFilePrefix);\n\n        List<File> files = new ArrayList<File>();\n\n        final ZipFile apk = new ZipFile(sourceApk);\n        try {\n\n            int secondaryNumber = 2;\n\n            ZipEntry dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);\n            while (dexFile != null) {\n                String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;\n                File extractedFile = new File(dexDir, fileName);\n                files.add(extractedFile);\n\n                Log.i(TAG, \"Extraction is needed for file \" + extractedFile);\n                int numAttempts = 0;\n                boolean isExtractionSuccessful = false;\n                while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isExtractionSuccessful) {\n                    numAttempts++;\n\n                    // Create a zip file (extractedFile) containing only the secondary dex file\n                    // (dexFile) from the apk.\n                    extract(apk, dexFile, extractedFile, extractedFilePrefix);\n\n                    // Verify that the extracted file is indeed a zip file.\n                    isExtractionSuccessful = verifyZipFile(extractedFile);\n\n                    // Log the sha1 of the extracted zip file\n                    Log.i(TAG, \"Extraction \" + (isExtractionSuccessful ? \"success\" : \"failed\") +\n                            \" - length \" + extractedFile.getAbsolutePath() + \": \" +\n                            extractedFile.length());\n                    if (!isExtractionSuccessful) {\n                        // Delete the extracted file\n                        extractedFile.delete();\n                        if (extractedFile.exists()) {\n                            Log.w(TAG, \"Failed to delete corrupted secondary dex '\" +\n                                    extractedFile.getPath() + \"'\");\n                        }\n                    }\n                }\n                if (!isExtractionSuccessful) {\n                    throw new IOException(\"Could not create zip file \" +\n                            extractedFile.getAbsolutePath() + \" for secondary dex (\" +\n                            secondaryNumber + \")\");\n                }\n                secondaryNumber++;\n                dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);\n            }\n        } finally {\n            try {\n                apk.close();\n            } catch (IOException e) {\n                Log.w(TAG, \"Failed to close resource\", e);\n            }\n        }\n\n        return files;\n    }\n```\n\n代码也比较简单，提取文件嘛，相信大家都会的，这里就不啰嗦了，哈哈。\n\n\n#### putStoredApkInfo\n\n从apk文件提取完之后呢，就会将apk最后一次修改时间，crc校验码，dex文件数目等信息，存放到SharedPreferences中，以便以后调用。\n\n### MultiDex#installSecondaryDexes\n\n```\n    private static void installSecondaryDexes(ClassLoader loader, File dexDir, List<File> files)\n            throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException,\n            InvocationTargetException, NoSuchMethodException, IOException {\n        if (!files.isEmpty()) {\n            if (Build.VERSION.SDK_INT >= 19) {\n                V19.install(loader, files, dexDir);\n            } else if (Build.VERSION.SDK_INT >= 14) {\n                V14.install(loader, files, dexDir);\n            } else {\n                V4.install(loader, files);\n            }\n        }\n    }\n```\n\n\n 安装这里呢，我想大家都比较熟悉了，看了太多这样的代码。一V19为例。\n \n 在看代码之前，我们需要了解一点小知识。在BaseDexClassLoader中，有个DexPathList类型的字段，而DexPathList中，有个Element[]，dexElements，这个就是我们的dex文件对应的，当findclass的时候，会依次去里面每个元素进行查找。多的不说了，具体去了解下类加载。\n \n \n ```\n        private static void install(ClassLoader loader, List<File> additionalClassPathEntries,\n                File optimizedDirectory)\n                        throws IllegalArgumentException, IllegalAccessException,\n                        NoSuchFieldException, InvocationTargetException, NoSuchMethodException {\n            /* The patched class loader is expected to be a descendant of\n             * dalvik.system.BaseDexClassLoader. We modify its\n             * dalvik.system.DexPathList pathList field to append additional DEX\n             * file entries.\n             */\n            Field pathListField = findField(loader, \"pathList\");\n            Object dexPathList = pathListField.get(loader);\n            ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>();\n            expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList,\n                    new ArrayList<File>(additionalClassPathEntries), optimizedDirectory,\n                    suppressedExceptions));\n            if (suppressedExceptions.size() > 0) {\n                for (IOException e : suppressedExceptions) {\n                    Log.w(TAG, \"Exception in makeDexElement\", e);\n                }\n                Field suppressedExceptionsField =\n                        findField(loader, \"dexElementsSuppressedExceptions\");\n                IOException[] dexElementsSuppressedExceptions =\n                        (IOException[]) suppressedExceptionsField.get(loader);\n\n                if (dexElementsSuppressedExceptions == null) {\n                    dexElementsSuppressedExceptions =\n                            suppressedExceptions.toArray(\n                                    new IOException[suppressedExceptions.size()]);\n                } else {\n                    IOException[] combined =\n                            new IOException[suppressedExceptions.size() +\n                                            dexElementsSuppressedExceptions.length];\n                    suppressedExceptions.toArray(combined);\n                    System.arraycopy(dexElementsSuppressedExceptions, 0, combined,\n                            suppressedExceptions.size(), dexElementsSuppressedExceptions.length);\n                    dexElementsSuppressedExceptions = combined;\n                }\n\n                suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);\n            }\n        }\n ```\n \n* 首先通过classloader获取到pathList，再通过DexPathList的makeDexElements方法构造一个Element[]数组，注意，不同版本的方法名和字段名可能不一样，这里以5.0位例的。\n* 通过expandFieldArray方法，去扩展原先的Element数组，将除了第一个dex文件外的其他dex文件添加到里面。\n* 略过。。。\n\n大体的流程就是这样的。\n\n### 总结\n\n看了简单的源码之后，还有几个问题需要我们思考：\n\n1. clearOldDexDir 目的是什么？节省空间么？\n2. 其中，做了哪些异常处理，比如异常重试，这个有必要学习下，是一种保护措施\n3. 都说在首次加载会出现耗时的情况，没看到相关的Dex优化的代码啊。\n4. odex和dex，odex是优化过后的dex，其后缀也可以是dex，code_cache/secondary-dexes中，就是优化过后的dex存放路径。\n\n关于第三点，是在DexFile的构造函数中，会调用native的方法，做一些优化，比如opt，或者是oat\n\n\n如果错误或者理解片面的地方，请各位同学赐教。\n \n\n \n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/MultiDex源码浅析.md","raw":"---\ntitle: MultiDex源码浅析\ndate: 2017-04-29 13:13:39\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\nMultiDex是为了解决65536的问题，虽然说现在我们使用起来很方便了，作为一个有追求的程序员，使用并不是我们的目标，我们的目标是学习其实现原理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### MultiDex#install\n\n```\n    public static void install(Context context) {\n        Log.i(TAG, \"install\");\n        if (IS_VM_MULTIDEX_CAPABLE) {\n            Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\");\n            return;\n        }\n\n        if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) {\n            throw new RuntimeException(\"Multi dex installation failed. SDK \" + Build.VERSION.SDK_INT\n                    + \" is unsupported. Min SDK version is \" + MIN_SDK_VERSION + \".\");\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getApplicationInfo(context);\n            if (applicationInfo == null) {\n                // Looks like running on a test Context, so just return without patching.\n                return;\n            }\n\n            synchronized (installedApk) {\n                String apkPath = applicationInfo.sourceDir;\n                if (installedApk.contains(apkPath)) {\n                    return;\n                }\n                installedApk.add(apkPath);\n\n                if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) {\n                    Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \"\n                            + Build.VERSION.SDK_INT + \": SDK version higher than \"\n                            + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \"\n                            + \"runtime with built-in multidex capabilty but it's not the \"\n                            + \"case here: java.vm.version=\\\"\"\n                            + System.getProperty(\"java.vm.version\") + \"\\\"\");\n                }\n\n                /* The patched class loader is expected to be a descendant of\n                 * dalvik.system.BaseDexClassLoader. We modify its\n                 * dalvik.system.DexPathList pathList field to append additional DEX\n                 * file entries.\n                 */\n                ClassLoader loader;\n                try {\n                    loader = context.getClassLoader();\n                } catch (RuntimeException e) {\n                    /* Ignore those exceptions so that we don't break tests relying on Context like\n                     * a android.test.mock.MockContext or a android.content.ContextWrapper with a\n                     * null base Context.\n                     */\n                    Log.w(TAG, \"Failure while trying to obtain Context class loader. \" +\n                            \"Must be running in test mode. Skip patching.\", e);\n                    return;\n                }\n                if (loader == null) {\n                    // Note, the context class loader is null when running Robolectric tests.\n                    Log.e(TAG,\n                            \"Context class loader is null. Must be running in test mode. \"\n                            + \"Skip patching.\");\n                    return;\n                }\n\n                try {\n                  clearOldDexDir(context);\n                } catch (Throwable t) {\n                  Log.w(TAG, \"Something went wrong when trying to clear old MultiDex extraction, \"\n                      + \"continuing without cleaning.\", t);\n                }\n\n                File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);\n                List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false);\n                if (checkValidZipFiles(files)) {\n                    installSecondaryDexes(loader, dexDir, files);\n                } else {\n                    Log.w(TAG, \"Files were not valid zip files.  Forcing a reload.\");\n                    // Try again, but this time force a reload of the zip file.\n                    files = MultiDexExtractor.load(context, applicationInfo, dexDir, true);\n\n                    if (checkValidZipFiles(files)) {\n                        installSecondaryDexes(loader, dexDir, files);\n                    } else {\n                        // Second time didn't work, give up\n                        throw new RuntimeException(\"Zip files were not valid.\");\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n            Log.e(TAG, \"Multidex installation failure\", e);\n            throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\");\n        }\n        Log.i(TAG, \"install done\");\n    }\n```\n\n这个方法的所有代码都在上面，代码不错，逻辑如下：\n\n* 如果当前虚拟机已经支持MultiDex了，直接退出\n* 首先获取apk文件的路径，并加到installedApk中，防止重复install\n* 获取classloader，这里的这个classloader是BaseDexClassLoader,要记住，我们后面会用到。\n* 清除secondary-dexes文件夹中的dex文件\n* 通过MultiDexExtractor去提取dex文件，注意这时的第四个参数是false，\n* 校验有效性\n\t* 合法installSecondaryDexes，安装\n\t* 不合法，再次提取，不过这次提取就是从apk文件中提取了，进行安装。这一步是一点补救措施。\n\n接下来便对其中一些关键步骤进行分析。\n\n### MultiDexExtractor.load \n\n```\n    static List<File> load(Context context, ApplicationInfo applicationInfo, File dexDir,\n            boolean forceReload) throws IOException {\n        Log.i(TAG, \"MultiDexExtractor.load(\" + applicationInfo.sourceDir + \", \" + forceReload + \")\");\n        final File sourceApk = new File(applicationInfo.sourceDir);\n\n        long currentCrc = getZipCrc(sourceApk);\n\n        List<File> files;\n        if (!forceReload && !isModified(context, sourceApk, currentCrc)) {\n            try {\n                files = loadExistingExtractions(context, sourceApk, dexDir);\n            } catch (IOException ioe) {\n                Log.w(TAG, \"Failed to reload existing extracted secondary dex files,\"\n                        + \" falling back to fresh extraction\", ioe);\n                files = performExtractions(sourceApk, dexDir);\n                putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);\n\n            }\n        } else {\n            Log.i(TAG, \"Detected that extraction must be performed.\");\n            files = performExtractions(sourceApk, dexDir);\n            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);\n        }\n\n        Log.i(TAG, \"load found \" + files.size() + \" secondary dex files\");\n        return files;\n    }\n```\n\n其中dexFile 路径为code_cache/secondary-dexes\n\n在这一步是对dex文件进行提取。其中的逻辑如下，\n\n* 获取apk文件的crc校验码\n* 如果不是强行reload(强行reload是指直接从apk文件提取)，并且apk文件没有进行修改。\n\t* loadExistingExtractions 提取缓存\n\t* 如果失败，则从apk文件中提取\n* 当设置了forceReload时，直接从apk文件中提取\n\n#### 获取apk文件crc校验码\n\n```\n    private static long getZipCrc(File archive) throws IOException {\n        long computedValue = ZipUtil.getZipCrc(archive);\n        if (computedValue == NO_VALUE) {\n            // never return NO_VALUE\n            computedValue--;\n        }\n        return computedValue;\n    }\n```\n\n在这个方法中，通过ZipUtil去获取crc校验码。我们看下他的实现，\n\n```\n    static long getZipCrc(File apk) throws IOException {\n        RandomAccessFile raf = new RandomAccessFile(apk, \"r\");\n        try {\n            CentralDirectory dir = findCentralDirectory(raf);\n\n            return computeCrcOfCentralDir(raf, dir);\n        } finally {\n            raf.close();\n        }\n    }\n```\n\n通过findCentralDirectory去返回一个CentralDirectory对象，这存储了内容的偏移量和size两个字段。关于如何计算，详细看代码和zip文件格式。[ZIP文件格式](https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt)\n\nCRC计算就略过了。\n\n#### isModified\n\n```\n    private static boolean isModified(Context context, File archive, long currentCrc) {\n        SharedPreferences prefs = getMultiDexPreferences(context);\n        return (prefs.getLong(KEY_TIME_STAMP, NO_VALUE) != getTimeStamp(archive))\n                || (prefs.getLong(KEY_CRC, NO_VALUE) != currentCrc);\n    }\n```\n\n这里通过比较文件更改时间以及 crc校验码来判断apk文件是够进行过修改。如升级。\n\n#### loadExistingExtractions \n\n直接加载缓存好的dex文件。\n\n```\n    private static List<File> loadExistingExtractions(Context context, File sourceApk, File dexDir)\n            throws IOException {\n        Log.i(TAG, \"loading existing secondary dex files\");\n\n        final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;\n        int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1);\n        final List<File> files = new ArrayList<File>(totalDexNumber);\n\n        for (int secondaryNumber = 2; secondaryNumber <= totalDexNumber; secondaryNumber++) {\n            String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;\n            File extractedFile = new File(dexDir, fileName);\n            if (extractedFile.isFile()) {\n                files.add(extractedFile);\n                if (!verifyZipFile(extractedFile)) {\n                    Log.i(TAG, \"Invalid zip file: \" + extractedFile);\n                    throw new IOException(\"Invalid ZIP file.\");\n                }\n            } else {\n                throw new IOException(\"Missing extracted secondary dex file '\" +\n                        extractedFile.getPath() + \"'\");\n            }\n        }\n\n        return files;\n    }\n```\n\n上面的代码，直接查找code_cache/secondary-dexes 目录下的dex文件。\n\n#### performExtractions\n\n这个方法是干嘛的呢？当我们load缓存出异常的时候，就会用apk文件中做提取，我们看下逻辑。\n\n```\n    private static List<File> performExtractions(File sourceApk, File dexDir)\n            throws IOException {\n\n        final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;\n\n        // Ensure that whatever deletions happen in prepareDexDir only happen if the zip that\n        // contains a secondary dex file in there is not consistent with the latest apk.  Otherwise,\n        // multi-process race conditions can cause a crash loop where one process deletes the zip\n        // while another had created it.\n        prepareDexDir(dexDir, extractedFilePrefix);\n\n        List<File> files = new ArrayList<File>();\n\n        final ZipFile apk = new ZipFile(sourceApk);\n        try {\n\n            int secondaryNumber = 2;\n\n            ZipEntry dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);\n            while (dexFile != null) {\n                String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;\n                File extractedFile = new File(dexDir, fileName);\n                files.add(extractedFile);\n\n                Log.i(TAG, \"Extraction is needed for file \" + extractedFile);\n                int numAttempts = 0;\n                boolean isExtractionSuccessful = false;\n                while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isExtractionSuccessful) {\n                    numAttempts++;\n\n                    // Create a zip file (extractedFile) containing only the secondary dex file\n                    // (dexFile) from the apk.\n                    extract(apk, dexFile, extractedFile, extractedFilePrefix);\n\n                    // Verify that the extracted file is indeed a zip file.\n                    isExtractionSuccessful = verifyZipFile(extractedFile);\n\n                    // Log the sha1 of the extracted zip file\n                    Log.i(TAG, \"Extraction \" + (isExtractionSuccessful ? \"success\" : \"failed\") +\n                            \" - length \" + extractedFile.getAbsolutePath() + \": \" +\n                            extractedFile.length());\n                    if (!isExtractionSuccessful) {\n                        // Delete the extracted file\n                        extractedFile.delete();\n                        if (extractedFile.exists()) {\n                            Log.w(TAG, \"Failed to delete corrupted secondary dex '\" +\n                                    extractedFile.getPath() + \"'\");\n                        }\n                    }\n                }\n                if (!isExtractionSuccessful) {\n                    throw new IOException(\"Could not create zip file \" +\n                            extractedFile.getAbsolutePath() + \" for secondary dex (\" +\n                            secondaryNumber + \")\");\n                }\n                secondaryNumber++;\n                dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);\n            }\n        } finally {\n            try {\n                apk.close();\n            } catch (IOException e) {\n                Log.w(TAG, \"Failed to close resource\", e);\n            }\n        }\n\n        return files;\n    }\n```\n\n代码也比较简单，提取文件嘛，相信大家都会的，这里就不啰嗦了，哈哈。\n\n\n#### putStoredApkInfo\n\n从apk文件提取完之后呢，就会将apk最后一次修改时间，crc校验码，dex文件数目等信息，存放到SharedPreferences中，以便以后调用。\n\n### MultiDex#installSecondaryDexes\n\n```\n    private static void installSecondaryDexes(ClassLoader loader, File dexDir, List<File> files)\n            throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException,\n            InvocationTargetException, NoSuchMethodException, IOException {\n        if (!files.isEmpty()) {\n            if (Build.VERSION.SDK_INT >= 19) {\n                V19.install(loader, files, dexDir);\n            } else if (Build.VERSION.SDK_INT >= 14) {\n                V14.install(loader, files, dexDir);\n            } else {\n                V4.install(loader, files);\n            }\n        }\n    }\n```\n\n\n 安装这里呢，我想大家都比较熟悉了，看了太多这样的代码。一V19为例。\n \n 在看代码之前，我们需要了解一点小知识。在BaseDexClassLoader中，有个DexPathList类型的字段，而DexPathList中，有个Element[]，dexElements，这个就是我们的dex文件对应的，当findclass的时候，会依次去里面每个元素进行查找。多的不说了，具体去了解下类加载。\n \n \n ```\n        private static void install(ClassLoader loader, List<File> additionalClassPathEntries,\n                File optimizedDirectory)\n                        throws IllegalArgumentException, IllegalAccessException,\n                        NoSuchFieldException, InvocationTargetException, NoSuchMethodException {\n            /* The patched class loader is expected to be a descendant of\n             * dalvik.system.BaseDexClassLoader. We modify its\n             * dalvik.system.DexPathList pathList field to append additional DEX\n             * file entries.\n             */\n            Field pathListField = findField(loader, \"pathList\");\n            Object dexPathList = pathListField.get(loader);\n            ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>();\n            expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList,\n                    new ArrayList<File>(additionalClassPathEntries), optimizedDirectory,\n                    suppressedExceptions));\n            if (suppressedExceptions.size() > 0) {\n                for (IOException e : suppressedExceptions) {\n                    Log.w(TAG, \"Exception in makeDexElement\", e);\n                }\n                Field suppressedExceptionsField =\n                        findField(loader, \"dexElementsSuppressedExceptions\");\n                IOException[] dexElementsSuppressedExceptions =\n                        (IOException[]) suppressedExceptionsField.get(loader);\n\n                if (dexElementsSuppressedExceptions == null) {\n                    dexElementsSuppressedExceptions =\n                            suppressedExceptions.toArray(\n                                    new IOException[suppressedExceptions.size()]);\n                } else {\n                    IOException[] combined =\n                            new IOException[suppressedExceptions.size() +\n                                            dexElementsSuppressedExceptions.length];\n                    suppressedExceptions.toArray(combined);\n                    System.arraycopy(dexElementsSuppressedExceptions, 0, combined,\n                            suppressedExceptions.size(), dexElementsSuppressedExceptions.length);\n                    dexElementsSuppressedExceptions = combined;\n                }\n\n                suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);\n            }\n        }\n ```\n \n* 首先通过classloader获取到pathList，再通过DexPathList的makeDexElements方法构造一个Element[]数组，注意，不同版本的方法名和字段名可能不一样，这里以5.0位例的。\n* 通过expandFieldArray方法，去扩展原先的Element数组，将除了第一个dex文件外的其他dex文件添加到里面。\n* 略过。。。\n\n大体的流程就是这样的。\n\n### 总结\n\n看了简单的源码之后，还有几个问题需要我们思考：\n\n1. clearOldDexDir 目的是什么？节省空间么？\n2. 其中，做了哪些异常处理，比如异常重试，这个有必要学习下，是一种保护措施\n3. 都说在首次加载会出现耗时的情况，没看到相关的Dex优化的代码啊。\n4. odex和dex，odex是优化过后的dex，其后缀也可以是dex，code_cache/secondary-dexes中，就是优化过后的dex存放路径。\n\n关于第三点，是在DexFile的构造函数中，会调用native的方法，做一些优化，比如opt，或者是oat\n\n\n如果错误或者理解片面的地方，请各位同学赐教。\n \n\n \n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"MultiDex源码浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslxz001q19fya3x5ssh5","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>MultiDex是为了解决65536的问题，虽然说现在我们使用起来很方便了，作为一个有追求的程序员，使用并不是我们的目标，我们的目标是学习其实现原理。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"MultiDex-install\"><a href=\"#MultiDex-install\" class=\"headerlink\" title=\"MultiDex#install\"></a>MultiDex#install</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void install(Context context) &#123;</div><div class=\"line\">    Log.i(TAG, &quot;install&quot;);</div><div class=\"line\">    if (IS_VM_MULTIDEX_CAPABLE) &#123;</div><div class=\"line\">        Log.i(TAG, &quot;VM has multidex support, MultiDex support library is disabled.&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (Build.VERSION.SDK_INT &lt; MIN_SDK_VERSION) &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Multi dex installation failed. SDK &quot; + Build.VERSION.SDK_INT</div><div class=\"line\">                + &quot; is unsupported. Min SDK version is &quot; + MIN_SDK_VERSION + &quot;.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        ApplicationInfo applicationInfo = getApplicationInfo(context);</div><div class=\"line\">        if (applicationInfo == null) &#123;</div><div class=\"line\">            // Looks like running on a test Context, so just return without patching.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        synchronized (installedApk) &#123;</div><div class=\"line\">            String apkPath = applicationInfo.sourceDir;</div><div class=\"line\">            if (installedApk.contains(apkPath)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            installedApk.add(apkPath);</div><div class=\"line\"></div><div class=\"line\">            if (Build.VERSION.SDK_INT &gt; MAX_SUPPORTED_SDK_VERSION) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;MultiDex is not guaranteed to work in SDK version &quot;</div><div class=\"line\">                        + Build.VERSION.SDK_INT + &quot;: SDK version higher than &quot;</div><div class=\"line\">                        + MAX_SUPPORTED_SDK_VERSION + &quot; should be backed by &quot;</div><div class=\"line\">                        + &quot;runtime with built-in multidex capabilty but it&apos;s not the &quot;</div><div class=\"line\">                        + &quot;case here: java.vm.version=\\&quot;&quot;</div><div class=\"line\">                        + System.getProperty(&quot;java.vm.version&quot;) + &quot;\\&quot;&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /* The patched class loader is expected to be a descendant of</div><div class=\"line\">             * dalvik.system.BaseDexClassLoader. We modify its</div><div class=\"line\">             * dalvik.system.DexPathList pathList field to append additional DEX</div><div class=\"line\">             * file entries.</div><div class=\"line\">             */</div><div class=\"line\">            ClassLoader loader;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                loader = context.getClassLoader();</div><div class=\"line\">            &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">                /* Ignore those exceptions so that we don&apos;t break tests relying on Context like</div><div class=\"line\">                 * a android.test.mock.MockContext or a android.content.ContextWrapper with a</div><div class=\"line\">                 * null base Context.</div><div class=\"line\">                 */</div><div class=\"line\">                Log.w(TAG, &quot;Failure while trying to obtain Context class loader. &quot; +</div><div class=\"line\">                        &quot;Must be running in test mode. Skip patching.&quot;, e);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (loader == null) &#123;</div><div class=\"line\">                // Note, the context class loader is null when running Robolectric tests.</div><div class=\"line\">                Log.e(TAG,</div><div class=\"line\">                        &quot;Context class loader is null. Must be running in test mode. &quot;</div><div class=\"line\">                        + &quot;Skip patching.&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">              clearOldDexDir(context);</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">              Log.w(TAG, &quot;Something went wrong when trying to clear old MultiDex extraction, &quot;</div><div class=\"line\">                  + &quot;continuing without cleaning.&quot;, t);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</div><div class=\"line\">            List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, false);</div><div class=\"line\">            if (checkValidZipFiles(files)) &#123;</div><div class=\"line\">                installSecondaryDexes(loader, dexDir, files);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                Log.w(TAG, &quot;Files were not valid zip files.  Forcing a reload.&quot;);</div><div class=\"line\">                // Try again, but this time force a reload of the zip file.</div><div class=\"line\">                files = MultiDexExtractor.load(context, applicationInfo, dexDir, true);</div><div class=\"line\"></div><div class=\"line\">                if (checkValidZipFiles(files)) &#123;</div><div class=\"line\">                    installSecondaryDexes(loader, dexDir, files);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Second time didn&apos;t work, give up</div><div class=\"line\">                    throw new RuntimeException(&quot;Zip files were not valid.&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Multidex installation failure&quot;, e);</div><div class=\"line\">        throw new RuntimeException(&quot;Multi dex installation failed (&quot; + e.getMessage() + &quot;).&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    Log.i(TAG, &quot;install done&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的所有代码都在上面，代码不错，逻辑如下：</p>\n<ul>\n<li>如果当前虚拟机已经支持MultiDex了，直接退出</li>\n<li>首先获取apk文件的路径，并加到installedApk中，防止重复install</li>\n<li>获取classloader，这里的这个classloader是BaseDexClassLoader,要记住，我们后面会用到。</li>\n<li>清除secondary-dexes文件夹中的dex文件</li>\n<li>通过MultiDexExtractor去提取dex文件，注意这时的第四个参数是false，</li>\n<li>校验有效性<ul>\n<li>合法installSecondaryDexes，安装</li>\n<li>不合法，再次提取，不过这次提取就是从apk文件中提取了，进行安装。这一步是一点补救措施。</li>\n</ul>\n</li>\n</ul>\n<p>接下来便对其中一些关键步骤进行分析。</p>\n<h3 id=\"MultiDexExtractor-load\"><a href=\"#MultiDexExtractor-load\" class=\"headerlink\" title=\"MultiDexExtractor.load\"></a>MultiDexExtractor.load</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">static List&lt;File&gt; load(Context context, ApplicationInfo applicationInfo, File dexDir,</div><div class=\"line\">        boolean forceReload) throws IOException &#123;</div><div class=\"line\">    Log.i(TAG, &quot;MultiDexExtractor.load(&quot; + applicationInfo.sourceDir + &quot;, &quot; + forceReload + &quot;)&quot;);</div><div class=\"line\">    final File sourceApk = new File(applicationInfo.sourceDir);</div><div class=\"line\"></div><div class=\"line\">    long currentCrc = getZipCrc(sourceApk);</div><div class=\"line\"></div><div class=\"line\">    List&lt;File&gt; files;</div><div class=\"line\">    if (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            files = loadExistingExtractions(context, sourceApk, dexDir);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;Failed to reload existing extracted secondary dex files,&quot;</div><div class=\"line\">                    + &quot; falling back to fresh extraction&quot;, ioe);</div><div class=\"line\">            files = performExtractions(sourceApk, dexDir);</div><div class=\"line\">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        Log.i(TAG, &quot;Detected that extraction must be performed.&quot;);</div><div class=\"line\">        files = performExtractions(sourceApk, dexDir);</div><div class=\"line\">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Log.i(TAG, &quot;load found &quot; + files.size() + &quot; secondary dex files&quot;);</div><div class=\"line\">    return files;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中dexFile 路径为code_cache/secondary-dexes</p>\n<p>在这一步是对dex文件进行提取。其中的逻辑如下，</p>\n<ul>\n<li>获取apk文件的crc校验码</li>\n<li>如果不是强行reload(强行reload是指直接从apk文件提取)，并且apk文件没有进行修改。<ul>\n<li>loadExistingExtractions 提取缓存</li>\n<li>如果失败，则从apk文件中提取</li>\n</ul>\n</li>\n<li>当设置了forceReload时，直接从apk文件中提取</li>\n</ul>\n<h4 id=\"获取apk文件crc校验码\"><a href=\"#获取apk文件crc校验码\" class=\"headerlink\" title=\"获取apk文件crc校验码\"></a>获取apk文件crc校验码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static long getZipCrc(File archive) throws IOException &#123;</div><div class=\"line\">    long computedValue = ZipUtil.getZipCrc(archive);</div><div class=\"line\">    if (computedValue == NO_VALUE) &#123;</div><div class=\"line\">        // never return NO_VALUE</div><div class=\"line\">        computedValue--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return computedValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，通过ZipUtil去获取crc校验码。我们看下他的实现，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static long getZipCrc(File apk) throws IOException &#123;</div><div class=\"line\">    RandomAccessFile raf = new RandomAccessFile(apk, &quot;r&quot;);</div><div class=\"line\">    try &#123;</div><div class=\"line\">        CentralDirectory dir = findCentralDirectory(raf);</div><div class=\"line\"></div><div class=\"line\">        return computeCrcOfCentralDir(raf, dir);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        raf.close();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过findCentralDirectory去返回一个CentralDirectory对象，这存储了内容的偏移量和size两个字段。关于如何计算，详细看代码和zip文件格式。<a href=\"https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt\" target=\"_blank\" rel=\"external\">ZIP文件格式</a></p>\n<p>CRC计算就略过了。</p>\n<h4 id=\"isModified\"><a href=\"#isModified\" class=\"headerlink\" title=\"isModified\"></a>isModified</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean isModified(Context context, File archive, long currentCrc) &#123;</div><div class=\"line\">    SharedPreferences prefs = getMultiDexPreferences(context);</div><div class=\"line\">    return (prefs.getLong(KEY_TIME_STAMP, NO_VALUE) != getTimeStamp(archive))</div><div class=\"line\">            || (prefs.getLong(KEY_CRC, NO_VALUE) != currentCrc);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里通过比较文件更改时间以及 crc校验码来判断apk文件是够进行过修改。如升级。</p>\n<h4 id=\"loadExistingExtractions\"><a href=\"#loadExistingExtractions\" class=\"headerlink\" title=\"loadExistingExtractions\"></a>loadExistingExtractions</h4><p>直接加载缓存好的dex文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static List&lt;File&gt; loadExistingExtractions(Context context, File sourceApk, File dexDir)</div><div class=\"line\">        throws IOException &#123;</div><div class=\"line\">    Log.i(TAG, &quot;loading existing secondary dex files&quot;);</div><div class=\"line\"></div><div class=\"line\">    final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</div><div class=\"line\">    int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1);</div><div class=\"line\">    final List&lt;File&gt; files = new ArrayList&lt;File&gt;(totalDexNumber);</div><div class=\"line\"></div><div class=\"line\">    for (int secondaryNumber = 2; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</div><div class=\"line\">        String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</div><div class=\"line\">        File extractedFile = new File(dexDir, fileName);</div><div class=\"line\">        if (extractedFile.isFile()) &#123;</div><div class=\"line\">            files.add(extractedFile);</div><div class=\"line\">            if (!verifyZipFile(extractedFile)) &#123;</div><div class=\"line\">                Log.i(TAG, &quot;Invalid zip file: &quot; + extractedFile);</div><div class=\"line\">                throw new IOException(&quot;Invalid ZIP file.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            throw new IOException(&quot;Missing extracted secondary dex file &apos;&quot; +</div><div class=\"line\">                    extractedFile.getPath() + &quot;&apos;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return files;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码，直接查找code_cache/secondary-dexes 目录下的dex文件。</p>\n<h4 id=\"performExtractions\"><a href=\"#performExtractions\" class=\"headerlink\" title=\"performExtractions\"></a>performExtractions</h4><p>这个方法是干嘛的呢？当我们load缓存出异常的时候，就会用apk文件中做提取，我们看下逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static List&lt;File&gt; performExtractions(File sourceApk, File dexDir)</div><div class=\"line\">        throws IOException &#123;</div><div class=\"line\"></div><div class=\"line\">    final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</div><div class=\"line\"></div><div class=\"line\">    // Ensure that whatever deletions happen in prepareDexDir only happen if the zip that</div><div class=\"line\">    // contains a secondary dex file in there is not consistent with the latest apk.  Otherwise,</div><div class=\"line\">    // multi-process race conditions can cause a crash loop where one process deletes the zip</div><div class=\"line\">    // while another had created it.</div><div class=\"line\">    prepareDexDir(dexDir, extractedFilePrefix);</div><div class=\"line\"></div><div class=\"line\">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</div><div class=\"line\"></div><div class=\"line\">    final ZipFile apk = new ZipFile(sourceApk);</div><div class=\"line\">    try &#123;</div><div class=\"line\"></div><div class=\"line\">        int secondaryNumber = 2;</div><div class=\"line\"></div><div class=\"line\">        ZipEntry dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);</div><div class=\"line\">        while (dexFile != null) &#123;</div><div class=\"line\">            String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</div><div class=\"line\">            File extractedFile = new File(dexDir, fileName);</div><div class=\"line\">            files.add(extractedFile);</div><div class=\"line\"></div><div class=\"line\">            Log.i(TAG, &quot;Extraction is needed for file &quot; + extractedFile);</div><div class=\"line\">            int numAttempts = 0;</div><div class=\"line\">            boolean isExtractionSuccessful = false;</div><div class=\"line\">            while (numAttempts &lt; MAX_EXTRACT_ATTEMPTS &amp;&amp; !isExtractionSuccessful) &#123;</div><div class=\"line\">                numAttempts++;</div><div class=\"line\"></div><div class=\"line\">                // Create a zip file (extractedFile) containing only the secondary dex file</div><div class=\"line\">                // (dexFile) from the apk.</div><div class=\"line\">                extract(apk, dexFile, extractedFile, extractedFilePrefix);</div><div class=\"line\"></div><div class=\"line\">                // Verify that the extracted file is indeed a zip file.</div><div class=\"line\">                isExtractionSuccessful = verifyZipFile(extractedFile);</div><div class=\"line\"></div><div class=\"line\">                // Log the sha1 of the extracted zip file</div><div class=\"line\">                Log.i(TAG, &quot;Extraction &quot; + (isExtractionSuccessful ? &quot;success&quot; : &quot;failed&quot;) +</div><div class=\"line\">                        &quot; - length &quot; + extractedFile.getAbsolutePath() + &quot;: &quot; +</div><div class=\"line\">                        extractedFile.length());</div><div class=\"line\">                if (!isExtractionSuccessful) &#123;</div><div class=\"line\">                    // Delete the extracted file</div><div class=\"line\">                    extractedFile.delete();</div><div class=\"line\">                    if (extractedFile.exists()) &#123;</div><div class=\"line\">                        Log.w(TAG, &quot;Failed to delete corrupted secondary dex &apos;&quot; +</div><div class=\"line\">                                extractedFile.getPath() + &quot;&apos;&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!isExtractionSuccessful) &#123;</div><div class=\"line\">                throw new IOException(&quot;Could not create zip file &quot; +</div><div class=\"line\">                        extractedFile.getAbsolutePath() + &quot; for secondary dex (&quot; +</div><div class=\"line\">                        secondaryNumber + &quot;)&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            secondaryNumber++;</div><div class=\"line\">            dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            apk.close();</div><div class=\"line\">        &#125; catch (IOException e) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;Failed to close resource&quot;, e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return files;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码也比较简单，提取文件嘛，相信大家都会的，这里就不啰嗦了，哈哈。</p>\n<h4 id=\"putStoredApkInfo\"><a href=\"#putStoredApkInfo\" class=\"headerlink\" title=\"putStoredApkInfo\"></a>putStoredApkInfo</h4><p>从apk文件提取完之后呢，就会将apk最后一次修改时间，crc校验码，dex文件数目等信息，存放到SharedPreferences中，以便以后调用。</p>\n<h3 id=\"MultiDex-installSecondaryDexes\"><a href=\"#MultiDex-installSecondaryDexes\" class=\"headerlink\" title=\"MultiDex#installSecondaryDexes\"></a>MultiDex#installSecondaryDexes</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void installSecondaryDexes(ClassLoader loader, File dexDir, List&lt;File&gt; files)</div><div class=\"line\">        throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</div><div class=\"line\">        InvocationTargetException, NoSuchMethodException, IOException &#123;</div><div class=\"line\">    if (!files.isEmpty()) &#123;</div><div class=\"line\">        if (Build.VERSION.SDK_INT &gt;= 19) &#123;</div><div class=\"line\">            V19.install(loader, files, dexDir);</div><div class=\"line\">        &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</div><div class=\"line\">            V14.install(loader, files, dexDir);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            V4.install(loader, files);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 安装这里呢，我想大家都比较熟悉了，看了太多这样的代码。一V19为例。</p>\n<p> 在看代码之前，我们需要了解一点小知识。在BaseDexClassLoader中，有个DexPathList类型的字段，而DexPathList中，有个Element[]，dexElements，这个就是我们的dex文件对应的，当findclass的时候，会依次去里面每个元素进行查找。多的不说了，具体去了解下类加载。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</div><div class=\"line\">        File optimizedDirectory)</div><div class=\"line\">                throws IllegalArgumentException, IllegalAccessException,</div><div class=\"line\">                NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123;</div><div class=\"line\">    /* The patched class loader is expected to be a descendant of</div><div class=\"line\">     * dalvik.system.BaseDexClassLoader. We modify its</div><div class=\"line\">     * dalvik.system.DexPathList pathList field to append additional DEX</div><div class=\"line\">     * file entries.</div><div class=\"line\">     */</div><div class=\"line\">    Field pathListField = findField(loader, &quot;pathList&quot;);</div><div class=\"line\">    Object dexPathList = pathListField.get(loader);</div><div class=\"line\">    ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</div><div class=\"line\">    expandFieldArray(dexPathList, &quot;dexElements&quot;, makeDexElements(dexPathList,</div><div class=\"line\">            new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</div><div class=\"line\">            suppressedExceptions));</div><div class=\"line\">    if (suppressedExceptions.size() &gt; 0) &#123;</div><div class=\"line\">        for (IOException e : suppressedExceptions) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;Exception in makeDexElement&quot;, e);</div><div class=\"line\">        &#125;</div><div class=\"line\">        Field suppressedExceptionsField =</div><div class=\"line\">                findField(loader, &quot;dexElementsSuppressedExceptions&quot;);</div><div class=\"line\">        IOException[] dexElementsSuppressedExceptions =</div><div class=\"line\">                (IOException[]) suppressedExceptionsField.get(loader);</div><div class=\"line\"></div><div class=\"line\">        if (dexElementsSuppressedExceptions == null) &#123;</div><div class=\"line\">            dexElementsSuppressedExceptions =</div><div class=\"line\">                    suppressedExceptions.toArray(</div><div class=\"line\">                            new IOException[suppressedExceptions.size()]);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            IOException[] combined =</div><div class=\"line\">                    new IOException[suppressedExceptions.size() +</div><div class=\"line\">                                    dexElementsSuppressedExceptions.length];</div><div class=\"line\">            suppressedExceptions.toArray(combined);</div><div class=\"line\">            System.arraycopy(dexElementsSuppressedExceptions, 0, combined,</div><div class=\"line\">                    suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</div><div class=\"line\">            dexElementsSuppressedExceptions = combined;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先通过classloader获取到pathList，再通过DexPathList的makeDexElements方法构造一个Element[]数组，注意，不同版本的方法名和字段名可能不一样，这里以5.0位例的。</li>\n<li>通过expandFieldArray方法，去扩展原先的Element数组，将除了第一个dex文件外的其他dex文件添加到里面。</li>\n<li>略过。。。</li>\n</ul>\n<p>大体的流程就是这样的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>看了简单的源码之后，还有几个问题需要我们思考：</p>\n<ol>\n<li>clearOldDexDir 目的是什么？节省空间么？</li>\n<li>其中，做了哪些异常处理，比如异常重试，这个有必要学习下，是一种保护措施</li>\n<li>都说在首次加载会出现耗时的情况，没看到相关的Dex优化的代码啊。</li>\n<li>odex和dex，odex是优化过后的dex，其后缀也可以是dex，code_cache/secondary-dexes中，就是优化过后的dex存放路径。</li>\n</ol>\n<p>关于第三点，是在DexFile的构造函数中，会调用native的方法，做一些优化，比如opt，或者是oat</p>\n<p>如果错误或者理解片面的地方，请各位同学赐教。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>MultiDex是为了解决65536的问题，虽然说现在我们使用起来很方便了，作为一个有追求的程序员，使用并不是我们的目标，我们的目标是学习其实现原理。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"MultiDex-install\"><a href=\"#MultiDex-install\" class=\"headerlink\" title=\"MultiDex#install\"></a>MultiDex#install</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void install(Context context) &#123;</div><div class=\"line\">    Log.i(TAG, &quot;install&quot;);</div><div class=\"line\">    if (IS_VM_MULTIDEX_CAPABLE) &#123;</div><div class=\"line\">        Log.i(TAG, &quot;VM has multidex support, MultiDex support library is disabled.&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (Build.VERSION.SDK_INT &lt; MIN_SDK_VERSION) &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Multi dex installation failed. SDK &quot; + Build.VERSION.SDK_INT</div><div class=\"line\">                + &quot; is unsupported. Min SDK version is &quot; + MIN_SDK_VERSION + &quot;.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        ApplicationInfo applicationInfo = getApplicationInfo(context);</div><div class=\"line\">        if (applicationInfo == null) &#123;</div><div class=\"line\">            // Looks like running on a test Context, so just return without patching.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        synchronized (installedApk) &#123;</div><div class=\"line\">            String apkPath = applicationInfo.sourceDir;</div><div class=\"line\">            if (installedApk.contains(apkPath)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            installedApk.add(apkPath);</div><div class=\"line\"></div><div class=\"line\">            if (Build.VERSION.SDK_INT &gt; MAX_SUPPORTED_SDK_VERSION) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;MultiDex is not guaranteed to work in SDK version &quot;</div><div class=\"line\">                        + Build.VERSION.SDK_INT + &quot;: SDK version higher than &quot;</div><div class=\"line\">                        + MAX_SUPPORTED_SDK_VERSION + &quot; should be backed by &quot;</div><div class=\"line\">                        + &quot;runtime with built-in multidex capabilty but it&apos;s not the &quot;</div><div class=\"line\">                        + &quot;case here: java.vm.version=\\&quot;&quot;</div><div class=\"line\">                        + System.getProperty(&quot;java.vm.version&quot;) + &quot;\\&quot;&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /* The patched class loader is expected to be a descendant of</div><div class=\"line\">             * dalvik.system.BaseDexClassLoader. We modify its</div><div class=\"line\">             * dalvik.system.DexPathList pathList field to append additional DEX</div><div class=\"line\">             * file entries.</div><div class=\"line\">             */</div><div class=\"line\">            ClassLoader loader;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                loader = context.getClassLoader();</div><div class=\"line\">            &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">                /* Ignore those exceptions so that we don&apos;t break tests relying on Context like</div><div class=\"line\">                 * a android.test.mock.MockContext or a android.content.ContextWrapper with a</div><div class=\"line\">                 * null base Context.</div><div class=\"line\">                 */</div><div class=\"line\">                Log.w(TAG, &quot;Failure while trying to obtain Context class loader. &quot; +</div><div class=\"line\">                        &quot;Must be running in test mode. Skip patching.&quot;, e);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (loader == null) &#123;</div><div class=\"line\">                // Note, the context class loader is null when running Robolectric tests.</div><div class=\"line\">                Log.e(TAG,</div><div class=\"line\">                        &quot;Context class loader is null. Must be running in test mode. &quot;</div><div class=\"line\">                        + &quot;Skip patching.&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">              clearOldDexDir(context);</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">              Log.w(TAG, &quot;Something went wrong when trying to clear old MultiDex extraction, &quot;</div><div class=\"line\">                  + &quot;continuing without cleaning.&quot;, t);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</div><div class=\"line\">            List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, false);</div><div class=\"line\">            if (checkValidZipFiles(files)) &#123;</div><div class=\"line\">                installSecondaryDexes(loader, dexDir, files);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                Log.w(TAG, &quot;Files were not valid zip files.  Forcing a reload.&quot;);</div><div class=\"line\">                // Try again, but this time force a reload of the zip file.</div><div class=\"line\">                files = MultiDexExtractor.load(context, applicationInfo, dexDir, true);</div><div class=\"line\"></div><div class=\"line\">                if (checkValidZipFiles(files)) &#123;</div><div class=\"line\">                    installSecondaryDexes(loader, dexDir, files);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Second time didn&apos;t work, give up</div><div class=\"line\">                    throw new RuntimeException(&quot;Zip files were not valid.&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Multidex installation failure&quot;, e);</div><div class=\"line\">        throw new RuntimeException(&quot;Multi dex installation failed (&quot; + e.getMessage() + &quot;).&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    Log.i(TAG, &quot;install done&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的所有代码都在上面，代码不错，逻辑如下：</p>\n<ul>\n<li>如果当前虚拟机已经支持MultiDex了，直接退出</li>\n<li>首先获取apk文件的路径，并加到installedApk中，防止重复install</li>\n<li>获取classloader，这里的这个classloader是BaseDexClassLoader,要记住，我们后面会用到。</li>\n<li>清除secondary-dexes文件夹中的dex文件</li>\n<li>通过MultiDexExtractor去提取dex文件，注意这时的第四个参数是false，</li>\n<li>校验有效性<ul>\n<li>合法installSecondaryDexes，安装</li>\n<li>不合法，再次提取，不过这次提取就是从apk文件中提取了，进行安装。这一步是一点补救措施。</li>\n</ul>\n</li>\n</ul>\n<p>接下来便对其中一些关键步骤进行分析。</p>\n<h3 id=\"MultiDexExtractor-load\"><a href=\"#MultiDexExtractor-load\" class=\"headerlink\" title=\"MultiDexExtractor.load\"></a>MultiDexExtractor.load</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">static List&lt;File&gt; load(Context context, ApplicationInfo applicationInfo, File dexDir,</div><div class=\"line\">        boolean forceReload) throws IOException &#123;</div><div class=\"line\">    Log.i(TAG, &quot;MultiDexExtractor.load(&quot; + applicationInfo.sourceDir + &quot;, &quot; + forceReload + &quot;)&quot;);</div><div class=\"line\">    final File sourceApk = new File(applicationInfo.sourceDir);</div><div class=\"line\"></div><div class=\"line\">    long currentCrc = getZipCrc(sourceApk);</div><div class=\"line\"></div><div class=\"line\">    List&lt;File&gt; files;</div><div class=\"line\">    if (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            files = loadExistingExtractions(context, sourceApk, dexDir);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;Failed to reload existing extracted secondary dex files,&quot;</div><div class=\"line\">                    + &quot; falling back to fresh extraction&quot;, ioe);</div><div class=\"line\">            files = performExtractions(sourceApk, dexDir);</div><div class=\"line\">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        Log.i(TAG, &quot;Detected that extraction must be performed.&quot;);</div><div class=\"line\">        files = performExtractions(sourceApk, dexDir);</div><div class=\"line\">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Log.i(TAG, &quot;load found &quot; + files.size() + &quot; secondary dex files&quot;);</div><div class=\"line\">    return files;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中dexFile 路径为code_cache/secondary-dexes</p>\n<p>在这一步是对dex文件进行提取。其中的逻辑如下，</p>\n<ul>\n<li>获取apk文件的crc校验码</li>\n<li>如果不是强行reload(强行reload是指直接从apk文件提取)，并且apk文件没有进行修改。<ul>\n<li>loadExistingExtractions 提取缓存</li>\n<li>如果失败，则从apk文件中提取</li>\n</ul>\n</li>\n<li>当设置了forceReload时，直接从apk文件中提取</li>\n</ul>\n<h4 id=\"获取apk文件crc校验码\"><a href=\"#获取apk文件crc校验码\" class=\"headerlink\" title=\"获取apk文件crc校验码\"></a>获取apk文件crc校验码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static long getZipCrc(File archive) throws IOException &#123;</div><div class=\"line\">    long computedValue = ZipUtil.getZipCrc(archive);</div><div class=\"line\">    if (computedValue == NO_VALUE) &#123;</div><div class=\"line\">        // never return NO_VALUE</div><div class=\"line\">        computedValue--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return computedValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，通过ZipUtil去获取crc校验码。我们看下他的实现，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static long getZipCrc(File apk) throws IOException &#123;</div><div class=\"line\">    RandomAccessFile raf = new RandomAccessFile(apk, &quot;r&quot;);</div><div class=\"line\">    try &#123;</div><div class=\"line\">        CentralDirectory dir = findCentralDirectory(raf);</div><div class=\"line\"></div><div class=\"line\">        return computeCrcOfCentralDir(raf, dir);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        raf.close();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过findCentralDirectory去返回一个CentralDirectory对象，这存储了内容的偏移量和size两个字段。关于如何计算，详细看代码和zip文件格式。<a href=\"https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt\">ZIP文件格式</a></p>\n<p>CRC计算就略过了。</p>\n<h4 id=\"isModified\"><a href=\"#isModified\" class=\"headerlink\" title=\"isModified\"></a>isModified</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean isModified(Context context, File archive, long currentCrc) &#123;</div><div class=\"line\">    SharedPreferences prefs = getMultiDexPreferences(context);</div><div class=\"line\">    return (prefs.getLong(KEY_TIME_STAMP, NO_VALUE) != getTimeStamp(archive))</div><div class=\"line\">            || (prefs.getLong(KEY_CRC, NO_VALUE) != currentCrc);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里通过比较文件更改时间以及 crc校验码来判断apk文件是够进行过修改。如升级。</p>\n<h4 id=\"loadExistingExtractions\"><a href=\"#loadExistingExtractions\" class=\"headerlink\" title=\"loadExistingExtractions\"></a>loadExistingExtractions</h4><p>直接加载缓存好的dex文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static List&lt;File&gt; loadExistingExtractions(Context context, File sourceApk, File dexDir)</div><div class=\"line\">        throws IOException &#123;</div><div class=\"line\">    Log.i(TAG, &quot;loading existing secondary dex files&quot;);</div><div class=\"line\"></div><div class=\"line\">    final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</div><div class=\"line\">    int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1);</div><div class=\"line\">    final List&lt;File&gt; files = new ArrayList&lt;File&gt;(totalDexNumber);</div><div class=\"line\"></div><div class=\"line\">    for (int secondaryNumber = 2; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</div><div class=\"line\">        String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</div><div class=\"line\">        File extractedFile = new File(dexDir, fileName);</div><div class=\"line\">        if (extractedFile.isFile()) &#123;</div><div class=\"line\">            files.add(extractedFile);</div><div class=\"line\">            if (!verifyZipFile(extractedFile)) &#123;</div><div class=\"line\">                Log.i(TAG, &quot;Invalid zip file: &quot; + extractedFile);</div><div class=\"line\">                throw new IOException(&quot;Invalid ZIP file.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            throw new IOException(&quot;Missing extracted secondary dex file &apos;&quot; +</div><div class=\"line\">                    extractedFile.getPath() + &quot;&apos;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return files;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码，直接查找code_cache/secondary-dexes 目录下的dex文件。</p>\n<h4 id=\"performExtractions\"><a href=\"#performExtractions\" class=\"headerlink\" title=\"performExtractions\"></a>performExtractions</h4><p>这个方法是干嘛的呢？当我们load缓存出异常的时候，就会用apk文件中做提取，我们看下逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static List&lt;File&gt; performExtractions(File sourceApk, File dexDir)</div><div class=\"line\">        throws IOException &#123;</div><div class=\"line\"></div><div class=\"line\">    final String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</div><div class=\"line\"></div><div class=\"line\">    // Ensure that whatever deletions happen in prepareDexDir only happen if the zip that</div><div class=\"line\">    // contains a secondary dex file in there is not consistent with the latest apk.  Otherwise,</div><div class=\"line\">    // multi-process race conditions can cause a crash loop where one process deletes the zip</div><div class=\"line\">    // while another had created it.</div><div class=\"line\">    prepareDexDir(dexDir, extractedFilePrefix);</div><div class=\"line\"></div><div class=\"line\">    List&lt;File&gt; files = new ArrayList&lt;File&gt;();</div><div class=\"line\"></div><div class=\"line\">    final ZipFile apk = new ZipFile(sourceApk);</div><div class=\"line\">    try &#123;</div><div class=\"line\"></div><div class=\"line\">        int secondaryNumber = 2;</div><div class=\"line\"></div><div class=\"line\">        ZipEntry dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);</div><div class=\"line\">        while (dexFile != null) &#123;</div><div class=\"line\">            String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</div><div class=\"line\">            File extractedFile = new File(dexDir, fileName);</div><div class=\"line\">            files.add(extractedFile);</div><div class=\"line\"></div><div class=\"line\">            Log.i(TAG, &quot;Extraction is needed for file &quot; + extractedFile);</div><div class=\"line\">            int numAttempts = 0;</div><div class=\"line\">            boolean isExtractionSuccessful = false;</div><div class=\"line\">            while (numAttempts &lt; MAX_EXTRACT_ATTEMPTS &amp;&amp; !isExtractionSuccessful) &#123;</div><div class=\"line\">                numAttempts++;</div><div class=\"line\"></div><div class=\"line\">                // Create a zip file (extractedFile) containing only the secondary dex file</div><div class=\"line\">                // (dexFile) from the apk.</div><div class=\"line\">                extract(apk, dexFile, extractedFile, extractedFilePrefix);</div><div class=\"line\"></div><div class=\"line\">                // Verify that the extracted file is indeed a zip file.</div><div class=\"line\">                isExtractionSuccessful = verifyZipFile(extractedFile);</div><div class=\"line\"></div><div class=\"line\">                // Log the sha1 of the extracted zip file</div><div class=\"line\">                Log.i(TAG, &quot;Extraction &quot; + (isExtractionSuccessful ? &quot;success&quot; : &quot;failed&quot;) +</div><div class=\"line\">                        &quot; - length &quot; + extractedFile.getAbsolutePath() + &quot;: &quot; +</div><div class=\"line\">                        extractedFile.length());</div><div class=\"line\">                if (!isExtractionSuccessful) &#123;</div><div class=\"line\">                    // Delete the extracted file</div><div class=\"line\">                    extractedFile.delete();</div><div class=\"line\">                    if (extractedFile.exists()) &#123;</div><div class=\"line\">                        Log.w(TAG, &quot;Failed to delete corrupted secondary dex &apos;&quot; +</div><div class=\"line\">                                extractedFile.getPath() + &quot;&apos;&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!isExtractionSuccessful) &#123;</div><div class=\"line\">                throw new IOException(&quot;Could not create zip file &quot; +</div><div class=\"line\">                        extractedFile.getAbsolutePath() + &quot; for secondary dex (&quot; +</div><div class=\"line\">                        secondaryNumber + &quot;)&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            secondaryNumber++;</div><div class=\"line\">            dexFile = apk.getEntry(DEX_PREFIX + secondaryNumber + DEX_SUFFIX);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            apk.close();</div><div class=\"line\">        &#125; catch (IOException e) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;Failed to close resource&quot;, e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return files;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码也比较简单，提取文件嘛，相信大家都会的，这里就不啰嗦了，哈哈。</p>\n<h4 id=\"putStoredApkInfo\"><a href=\"#putStoredApkInfo\" class=\"headerlink\" title=\"putStoredApkInfo\"></a>putStoredApkInfo</h4><p>从apk文件提取完之后呢，就会将apk最后一次修改时间，crc校验码，dex文件数目等信息，存放到SharedPreferences中，以便以后调用。</p>\n<h3 id=\"MultiDex-installSecondaryDexes\"><a href=\"#MultiDex-installSecondaryDexes\" class=\"headerlink\" title=\"MultiDex#installSecondaryDexes\"></a>MultiDex#installSecondaryDexes</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void installSecondaryDexes(ClassLoader loader, File dexDir, List&lt;File&gt; files)</div><div class=\"line\">        throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</div><div class=\"line\">        InvocationTargetException, NoSuchMethodException, IOException &#123;</div><div class=\"line\">    if (!files.isEmpty()) &#123;</div><div class=\"line\">        if (Build.VERSION.SDK_INT &gt;= 19) &#123;</div><div class=\"line\">            V19.install(loader, files, dexDir);</div><div class=\"line\">        &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</div><div class=\"line\">            V14.install(loader, files, dexDir);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            V4.install(loader, files);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 安装这里呢，我想大家都比较熟悉了，看了太多这样的代码。一V19为例。</p>\n<p> 在看代码之前，我们需要了解一点小知识。在BaseDexClassLoader中，有个DexPathList类型的字段，而DexPathList中，有个Element[]，dexElements，这个就是我们的dex文件对应的，当findclass的时候，会依次去里面每个元素进行查找。多的不说了，具体去了解下类加载。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</div><div class=\"line\">        File optimizedDirectory)</div><div class=\"line\">                throws IllegalArgumentException, IllegalAccessException,</div><div class=\"line\">                NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123;</div><div class=\"line\">    /* The patched class loader is expected to be a descendant of</div><div class=\"line\">     * dalvik.system.BaseDexClassLoader. We modify its</div><div class=\"line\">     * dalvik.system.DexPathList pathList field to append additional DEX</div><div class=\"line\">     * file entries.</div><div class=\"line\">     */</div><div class=\"line\">    Field pathListField = findField(loader, &quot;pathList&quot;);</div><div class=\"line\">    Object dexPathList = pathListField.get(loader);</div><div class=\"line\">    ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</div><div class=\"line\">    expandFieldArray(dexPathList, &quot;dexElements&quot;, makeDexElements(dexPathList,</div><div class=\"line\">            new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</div><div class=\"line\">            suppressedExceptions));</div><div class=\"line\">    if (suppressedExceptions.size() &gt; 0) &#123;</div><div class=\"line\">        for (IOException e : suppressedExceptions) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;Exception in makeDexElement&quot;, e);</div><div class=\"line\">        &#125;</div><div class=\"line\">        Field suppressedExceptionsField =</div><div class=\"line\">                findField(loader, &quot;dexElementsSuppressedExceptions&quot;);</div><div class=\"line\">        IOException[] dexElementsSuppressedExceptions =</div><div class=\"line\">                (IOException[]) suppressedExceptionsField.get(loader);</div><div class=\"line\"></div><div class=\"line\">        if (dexElementsSuppressedExceptions == null) &#123;</div><div class=\"line\">            dexElementsSuppressedExceptions =</div><div class=\"line\">                    suppressedExceptions.toArray(</div><div class=\"line\">                            new IOException[suppressedExceptions.size()]);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            IOException[] combined =</div><div class=\"line\">                    new IOException[suppressedExceptions.size() +</div><div class=\"line\">                                    dexElementsSuppressedExceptions.length];</div><div class=\"line\">            suppressedExceptions.toArray(combined);</div><div class=\"line\">            System.arraycopy(dexElementsSuppressedExceptions, 0, combined,</div><div class=\"line\">                    suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</div><div class=\"line\">            dexElementsSuppressedExceptions = combined;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先通过classloader获取到pathList，再通过DexPathList的makeDexElements方法构造一个Element[]数组，注意，不同版本的方法名和字段名可能不一样，这里以5.0位例的。</li>\n<li>通过expandFieldArray方法，去扩展原先的Element数组，将除了第一个dex文件外的其他dex文件添加到里面。</li>\n<li>略过。。。</li>\n</ul>\n<p>大体的流程就是这样的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>看了简单的源码之后，还有几个问题需要我们思考：</p>\n<ol>\n<li>clearOldDexDir 目的是什么？节省空间么？</li>\n<li>其中，做了哪些异常处理，比如异常重试，这个有必要学习下，是一种保护措施</li>\n<li>都说在首次加载会出现耗时的情况，没看到相关的Dex优化的代码啊。</li>\n<li>odex和dex，odex是优化过后的dex，其后缀也可以是dex，code_cache/secondary-dexes中，就是优化过后的dex存放路径。</li>\n</ol>\n<p>关于第三点，是在DexFile的构造函数中，会调用native的方法，做一些优化，比如opt，或者是oat</p>\n<p>如果错误或者理解片面的地方，请各位同学赐教。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Service启动流程","date":"2016-12-26T07:19:04.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n我们启动service分为两种情况\n\n* startService\n* bindService\n\n我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。\n\n### 2.startService的方式\n\n#### 2.1 ContextImpl#startServiceCommon\n\n在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：\n\n```\n            ComponentName cn = ActivityManagerNative.getDefault().startService(\n                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(\n                            getContentResolver()), getOpPackageName(), user.getIdentifier());\n```\nActivityManagerNative.getDefault()，为binder客户端，上篇说到过。\n\n在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。\n\n因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。\n\n#### 2.2 ActivityManagerService#startService\n\n在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，\n\n```\n            final int callingPid = Binder.getCallingPid();\n            final int callingUid = Binder.getCallingUid();\n            final long origId = Binder.clearCallingIdentity();\n            ComponentName res = mServices.startServiceLocked(caller, service,\n                    resolvedType, callingPid, callingUid, callingPackage, userId);\n            Binder.restoreCallingIdentity(origId);\n            return res;\n```\n\n#### 2.3 ActivityService#startServiceLocked\n\n在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法\n\n#### 2.4 ActivityService#startServiceInnerLocked\n\n\n\n```\nString error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);\n```\n在这个方法中,后续操作交由bringUpServiceLocked处理。\n\n\n#### 2.5 ActivityService#bringUpServiceLocked\n\n在这个方法中，有两种情况：\n\n* 需要的进程存在\n* 需要的进程不存在\n\n当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。\n\n如果需要的进程不存在，则需要fork进程，这个后面的文章在说。\n\n解析来我们直接看realStartServiceLocked操作吧。\n\n#### 2.6 ActivityService#realStartServiceLocked\n\n改方法核心代码；\n\n```\n            app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),\n                    app.repProcState);\n```\n\n这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。\n\n#### 2.7 ActivityThread#handleCreateService\n\n```\n   private void handleCreateService(CreateServiceData data) {\n        // If we are getting ready to gc after going to the background, well\n        // we are back active so skip it.\n        unscheduleGcIdler();\n\n        LoadedApk packageInfo = getPackageInfoNoCheck(\n                data.info.applicationInfo, data.compatInfo);\n        Service service = null;\n        try {\n            java.lang.ClassLoader cl = packageInfo.getClassLoader();\n            service = (Service) cl.loadClass(data.info.name).newInstance();\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to instantiate service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n\n        try {\n            if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name);\n\n            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n            context.setOuterContext(service);\n\n            Application app = packageInfo.makeApplication(false, mInstrumentation);\n            service.attach(context, this, data.info.name, data.token, app,\n                    ActivityManagerNative.getDefault());\n            service.onCreate();\n            mServices.put(data.token, service);\n            try {\n                ActivityManagerNative.getDefault().serviceDoneExecuting(\n                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);\n            } catch (RemoteException e) {\n                // nothing to do.\n            }\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to create service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n    }\n```\n\n* 构造service\n* 关联application\n* 调用onCreate 执行\n\n就这样，一个全新的service就启动了。\n\n\n\n\n\n\n### 3.bindService的方式\n\n这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；\n\n```\n                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,\n                        r.app.repProcState);\n\n```\n\n随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。\n\n### 4.上图\n这里只是简单的介绍了流程，很多细节的东西并没有看。\n\n![](/images/framework/service/startservice.png)\n\n\n![](/images/framework/service/bindservice.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Service启动流程.md","raw":"---\ntitle: Service启动流程\ndate: 2016-12-26 15:19:04\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n我们启动service分为两种情况\n\n* startService\n* bindService\n\n我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。\n\n### 2.startService的方式\n\n#### 2.1 ContextImpl#startServiceCommon\n\n在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：\n\n```\n            ComponentName cn = ActivityManagerNative.getDefault().startService(\n                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(\n                            getContentResolver()), getOpPackageName(), user.getIdentifier());\n```\nActivityManagerNative.getDefault()，为binder客户端，上篇说到过。\n\n在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。\n\n因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。\n\n#### 2.2 ActivityManagerService#startService\n\n在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，\n\n```\n            final int callingPid = Binder.getCallingPid();\n            final int callingUid = Binder.getCallingUid();\n            final long origId = Binder.clearCallingIdentity();\n            ComponentName res = mServices.startServiceLocked(caller, service,\n                    resolvedType, callingPid, callingUid, callingPackage, userId);\n            Binder.restoreCallingIdentity(origId);\n            return res;\n```\n\n#### 2.3 ActivityService#startServiceLocked\n\n在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法\n\n#### 2.4 ActivityService#startServiceInnerLocked\n\n\n\n```\nString error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);\n```\n在这个方法中,后续操作交由bringUpServiceLocked处理。\n\n\n#### 2.5 ActivityService#bringUpServiceLocked\n\n在这个方法中，有两种情况：\n\n* 需要的进程存在\n* 需要的进程不存在\n\n当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。\n\n如果需要的进程不存在，则需要fork进程，这个后面的文章在说。\n\n解析来我们直接看realStartServiceLocked操作吧。\n\n#### 2.6 ActivityService#realStartServiceLocked\n\n改方法核心代码；\n\n```\n            app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),\n                    app.repProcState);\n```\n\n这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。\n\n#### 2.7 ActivityThread#handleCreateService\n\n```\n   private void handleCreateService(CreateServiceData data) {\n        // If we are getting ready to gc after going to the background, well\n        // we are back active so skip it.\n        unscheduleGcIdler();\n\n        LoadedApk packageInfo = getPackageInfoNoCheck(\n                data.info.applicationInfo, data.compatInfo);\n        Service service = null;\n        try {\n            java.lang.ClassLoader cl = packageInfo.getClassLoader();\n            service = (Service) cl.loadClass(data.info.name).newInstance();\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to instantiate service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n\n        try {\n            if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name);\n\n            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n            context.setOuterContext(service);\n\n            Application app = packageInfo.makeApplication(false, mInstrumentation);\n            service.attach(context, this, data.info.name, data.token, app,\n                    ActivityManagerNative.getDefault());\n            service.onCreate();\n            mServices.put(data.token, service);\n            try {\n                ActivityManagerNative.getDefault().serviceDoneExecuting(\n                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);\n            } catch (RemoteException e) {\n                // nothing to do.\n            }\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to create service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n    }\n```\n\n* 构造service\n* 关联application\n* 调用onCreate 执行\n\n就这样，一个全新的service就启动了。\n\n\n\n\n\n\n### 3.bindService的方式\n\n这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；\n\n```\n                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,\n                        r.app.repProcState);\n\n```\n\n随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。\n\n### 4.上图\n这里只是简单的介绍了流程，很多细节的东西并没有看。\n\n![](/images/framework/service/startservice.png)\n\n\n![](/images/framework/service/bindservice.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Service启动流程","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsly1001t19fy1u7pf8fs","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<p>我们启动service分为两种情况</p>\n<ul>\n<li>startService</li>\n<li>bindService</li>\n</ul>\n<p>我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。</p>\n<h3 id=\"2-startService的方式\"><a href=\"#2-startService的方式\" class=\"headerlink\" title=\"2.startService的方式\"></a>2.startService的方式</h3><h4 id=\"2-1-ContextImpl-startServiceCommon\"><a href=\"#2-1-ContextImpl-startServiceCommon\" class=\"headerlink\" title=\"2.1 ContextImpl#startServiceCommon\"></a>2.1 ContextImpl#startServiceCommon</h4><p>在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ComponentName cn = ActivityManagerNative.getDefault().startService(</div><div class=\"line\">    mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</div><div class=\"line\">                getContentResolver()), getOpPackageName(), user.getIdentifier());</div></pre></td></tr></table></figure>\n<p>ActivityManagerNative.getDefault()，为binder客户端，上篇说到过。</p>\n<p>在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。</p>\n<p>因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。</p>\n<h4 id=\"2-2-ActivityManagerService-startService\"><a href=\"#2-2-ActivityManagerService-startService\" class=\"headerlink\" title=\"2.2 ActivityManagerService#startService\"></a>2.2 ActivityManagerService#startService</h4><p>在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int callingPid = Binder.getCallingPid();</div><div class=\"line\">final int callingUid = Binder.getCallingUid();</div><div class=\"line\">final long origId = Binder.clearCallingIdentity();</div><div class=\"line\">ComponentName res = mServices.startServiceLocked(caller, service,</div><div class=\"line\">        resolvedType, callingPid, callingUid, callingPackage, userId);</div><div class=\"line\">Binder.restoreCallingIdentity(origId);</div><div class=\"line\">return res;</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-ActivityService-startServiceLocked\"><a href=\"#2-3-ActivityService-startServiceLocked\" class=\"headerlink\" title=\"2.3 ActivityService#startServiceLocked\"></a>2.3 ActivityService#startServiceLocked</h4><p>在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法</p>\n<h4 id=\"2-4-ActivityService-startServiceInnerLocked\"><a href=\"#2-4-ActivityService-startServiceInnerLocked\" class=\"headerlink\" title=\"2.4 ActivityService#startServiceInnerLocked\"></a>2.4 ActivityService#startServiceInnerLocked</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);</div></pre></td></tr></table></figure>\n<p>在这个方法中,后续操作交由bringUpServiceLocked处理。</p>\n<h4 id=\"2-5-ActivityService-bringUpServiceLocked\"><a href=\"#2-5-ActivityService-bringUpServiceLocked\" class=\"headerlink\" title=\"2.5 ActivityService#bringUpServiceLocked\"></a>2.5 ActivityService#bringUpServiceLocked</h4><p>在这个方法中，有两种情况：</p>\n<ul>\n<li>需要的进程存在</li>\n<li>需要的进程不存在</li>\n</ul>\n<p>当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。</p>\n<p>如果需要的进程不存在，则需要fork进程，这个后面的文章在说。</p>\n<p>解析来我们直接看realStartServiceLocked操作吧。</p>\n<h4 id=\"2-6-ActivityService-realStartServiceLocked\"><a href=\"#2-6-ActivityService-realStartServiceLocked\" class=\"headerlink\" title=\"2.6 ActivityService#realStartServiceLocked\"></a>2.6 ActivityService#realStartServiceLocked</h4><p>改方法核心代码；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleCreateService(r, r.serviceInfo,</div><div class=\"line\">        mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</div><div class=\"line\">        app.repProcState);</div></pre></td></tr></table></figure>\n<p>这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。</p>\n<h4 id=\"2-7-ActivityThread-handleCreateService\"><a href=\"#2-7-ActivityThread-handleCreateService\" class=\"headerlink\" title=\"2.7 ActivityThread#handleCreateService\"></a>2.7 ActivityThread#handleCreateService</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void handleCreateService(CreateServiceData data) &#123;</div><div class=\"line\">     // If we are getting ready to gc after going to the background, well</div><div class=\"line\">     // we are back active so skip it.</div><div class=\"line\">     unscheduleGcIdler();</div><div class=\"line\"></div><div class=\"line\">     LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class=\"line\">             data.info.applicationInfo, data.compatInfo);</div><div class=\"line\">     Service service = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class=\"line\">         service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to instantiate service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</div><div class=\"line\"></div><div class=\"line\">         ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</div><div class=\"line\">         context.setOuterContext(service);</div><div class=\"line\"></div><div class=\"line\">         Application app = packageInfo.makeApplication(false, mInstrumentation);</div><div class=\"line\">         service.attach(context, this, data.info.name, data.token, app,</div><div class=\"line\">                 ActivityManagerNative.getDefault());</div><div class=\"line\">         service.onCreate();</div><div class=\"line\">         mServices.put(data.token, service);</div><div class=\"line\">         try &#123;</div><div class=\"line\">             ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class=\"line\">                     data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</div><div class=\"line\">         &#125; catch (RemoteException e) &#123;</div><div class=\"line\">             // nothing to do.</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to create service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造service</li>\n<li>关联application</li>\n<li>调用onCreate 执行</li>\n</ul>\n<p>就这样，一个全新的service就启动了。</p>\n<h3 id=\"3-bindService的方式\"><a href=\"#3-bindService的方式\" class=\"headerlink\" title=\"3.bindService的方式\"></a>3.bindService的方式</h3><p>这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</div><div class=\"line\">        r.app.repProcState);</div></pre></td></tr></table></figure>\n<p>随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。</p>\n<h3 id=\"4-上图\"><a href=\"#4-上图\" class=\"headerlink\" title=\"4.上图\"></a>4.上图</h3><p>这里只是简单的介绍了流程，很多细节的东西并没有看。</p>\n<p><img src=\"/images/framework/service/startservice.png\" alt=\"\"></p>\n<p><img src=\"/images/framework/service/bindservice.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<p>我们启动service分为两种情况</p>\n<ul>\n<li>startService</li>\n<li>bindService</li>\n</ul>\n<p>我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。</p>\n<h3 id=\"2-startService的方式\"><a href=\"#2-startService的方式\" class=\"headerlink\" title=\"2.startService的方式\"></a>2.startService的方式</h3><h4 id=\"2-1-ContextImpl-startServiceCommon\"><a href=\"#2-1-ContextImpl-startServiceCommon\" class=\"headerlink\" title=\"2.1 ContextImpl#startServiceCommon\"></a>2.1 ContextImpl#startServiceCommon</h4><p>在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ComponentName cn = ActivityManagerNative.getDefault().startService(</div><div class=\"line\">    mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</div><div class=\"line\">                getContentResolver()), getOpPackageName(), user.getIdentifier());</div></pre></td></tr></table></figure>\n<p>ActivityManagerNative.getDefault()，为binder客户端，上篇说到过。</p>\n<p>在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。</p>\n<p>因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。</p>\n<h4 id=\"2-2-ActivityManagerService-startService\"><a href=\"#2-2-ActivityManagerService-startService\" class=\"headerlink\" title=\"2.2 ActivityManagerService#startService\"></a>2.2 ActivityManagerService#startService</h4><p>在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int callingPid = Binder.getCallingPid();</div><div class=\"line\">final int callingUid = Binder.getCallingUid();</div><div class=\"line\">final long origId = Binder.clearCallingIdentity();</div><div class=\"line\">ComponentName res = mServices.startServiceLocked(caller, service,</div><div class=\"line\">        resolvedType, callingPid, callingUid, callingPackage, userId);</div><div class=\"line\">Binder.restoreCallingIdentity(origId);</div><div class=\"line\">return res;</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-ActivityService-startServiceLocked\"><a href=\"#2-3-ActivityService-startServiceLocked\" class=\"headerlink\" title=\"2.3 ActivityService#startServiceLocked\"></a>2.3 ActivityService#startServiceLocked</h4><p>在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法</p>\n<h4 id=\"2-4-ActivityService-startServiceInnerLocked\"><a href=\"#2-4-ActivityService-startServiceInnerLocked\" class=\"headerlink\" title=\"2.4 ActivityService#startServiceInnerLocked\"></a>2.4 ActivityService#startServiceInnerLocked</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);</div></pre></td></tr></table></figure>\n<p>在这个方法中,后续操作交由bringUpServiceLocked处理。</p>\n<h4 id=\"2-5-ActivityService-bringUpServiceLocked\"><a href=\"#2-5-ActivityService-bringUpServiceLocked\" class=\"headerlink\" title=\"2.5 ActivityService#bringUpServiceLocked\"></a>2.5 ActivityService#bringUpServiceLocked</h4><p>在这个方法中，有两种情况：</p>\n<ul>\n<li>需要的进程存在</li>\n<li>需要的进程不存在</li>\n</ul>\n<p>当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。</p>\n<p>如果需要的进程不存在，则需要fork进程，这个后面的文章在说。</p>\n<p>解析来我们直接看realStartServiceLocked操作吧。</p>\n<h4 id=\"2-6-ActivityService-realStartServiceLocked\"><a href=\"#2-6-ActivityService-realStartServiceLocked\" class=\"headerlink\" title=\"2.6 ActivityService#realStartServiceLocked\"></a>2.6 ActivityService#realStartServiceLocked</h4><p>改方法核心代码；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleCreateService(r, r.serviceInfo,</div><div class=\"line\">        mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</div><div class=\"line\">        app.repProcState);</div></pre></td></tr></table></figure>\n<p>这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。</p>\n<h4 id=\"2-7-ActivityThread-handleCreateService\"><a href=\"#2-7-ActivityThread-handleCreateService\" class=\"headerlink\" title=\"2.7 ActivityThread#handleCreateService\"></a>2.7 ActivityThread#handleCreateService</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void handleCreateService(CreateServiceData data) &#123;</div><div class=\"line\">     // If we are getting ready to gc after going to the background, well</div><div class=\"line\">     // we are back active so skip it.</div><div class=\"line\">     unscheduleGcIdler();</div><div class=\"line\"></div><div class=\"line\">     LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class=\"line\">             data.info.applicationInfo, data.compatInfo);</div><div class=\"line\">     Service service = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class=\"line\">         service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to instantiate service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</div><div class=\"line\"></div><div class=\"line\">         ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</div><div class=\"line\">         context.setOuterContext(service);</div><div class=\"line\"></div><div class=\"line\">         Application app = packageInfo.makeApplication(false, mInstrumentation);</div><div class=\"line\">         service.attach(context, this, data.info.name, data.token, app,</div><div class=\"line\">                 ActivityManagerNative.getDefault());</div><div class=\"line\">         service.onCreate();</div><div class=\"line\">         mServices.put(data.token, service);</div><div class=\"line\">         try &#123;</div><div class=\"line\">             ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class=\"line\">                     data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</div><div class=\"line\">         &#125; catch (RemoteException e) &#123;</div><div class=\"line\">             // nothing to do.</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to create service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造service</li>\n<li>关联application</li>\n<li>调用onCreate 执行</li>\n</ul>\n<p>就这样，一个全新的service就启动了。</p>\n<h3 id=\"3-bindService的方式\"><a href=\"#3-bindService的方式\" class=\"headerlink\" title=\"3.bindService的方式\"></a>3.bindService的方式</h3><p>这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</div><div class=\"line\">        r.app.repProcState);</div></pre></td></tr></table></figure>\n<p>随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。</p>\n<h3 id=\"4-上图\"><a href=\"#4-上图\" class=\"headerlink\" title=\"4.上图\"></a>4.上图</h3><p>这里只是简单的介绍了流程，很多细节的东西并没有看。</p>\n<p><img src=\"/images/framework/service/startservice.png\" alt=\"\"></p>\n<p><img src=\"/images/framework/service/bindservice.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"PMS初始化做了什么","date":"2017-01-05T09:21:21.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```java\n    public static PackageManagerService main(Context context, Installer installer,\n            boolean factoryTest, boolean onlyCore) {\n        PackageManagerService m = new PackageManagerService(context, installer,\n                factoryTest, onlyCore);\n        ServiceManager.addService(\"package\", m);\n        return m;\n    }\n```\n\n### 2.从pms构造函数说起\n\npms的构造函数相当长，根据[gityuan大神](http://gityuan.com/2016/11/06/packagemanager/)的提示，按照log的打印进行分布查看却是清晰了很多。\n\n#### 2.1 BOOT_PROGRESS_PMS_START\n\n```java\n        mContext = context;\n        mFactoryTest = factoryTest;\n        mOnlyCore = onlyCore;\n        mLazyDexOpt = \"eng\".equals(SystemProperties.get(\"ro.build.type\"));\n        mMetrics = new DisplayMetrics();\n        mSettings = new Settings(mPackages);\n        mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n\n        // TODO: add a property to control this?\n        long dexOptLRUThresholdInMinutes;\n        if (mLazyDexOpt) {\n            dexOptLRUThresholdInMinutes = 30; // only last 30 minutes of apps for eng builds.\n        } else {\n            dexOptLRUThresholdInMinutes = 7 * 24 * 60; // apps used in the 7 days for users.\n        }\n        mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * 60 * 1000;\n\n        String separateProcesses = SystemProperties.get(\"debug.separate_processes\");\n        if (separateProcesses != null && separateProcesses.length() > 0) {\n            if (\"*\".equals(separateProcesses)) {\n                mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;\n                mSeparateProcesses = null;\n                Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\");\n            } else {\n                mDefParseFlags = 0;\n                mSeparateProcesses = separateProcesses.split(\",\");\n                Slog.w(TAG, \"Running with debug.separate_processes: \"\n                        + separateProcesses);\n            }\n        } else {\n            mDefParseFlags = 0;\n            mSeparateProcesses = null;\n        }\n\n        mInstaller = installer;\n        mPackageDexOptimizer = new PackageDexOptimizer(this);\n        mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());\n\n        mOnPermissionChangeListeners = new OnPermissionChangeListeners(\n                FgThread.get().getLooper());\n\n        getDefaultDisplayMetrics(context, mMetrics);\n\n        SystemConfig systemConfig = SystemConfig.getInstance();\n        mGlobalGids = systemConfig.getGlobalGids();\n        mSystemPermissions = systemConfig.getSystemPermissions();\n        mAvailableFeatures = systemConfig.getAvailableFeatures();\n\n        synchronized (mInstallLock) {\n        // writer\n        synchronized (mPackages) {\n            mHandlerThread = new ServiceThread(TAG,\n                    Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);\n            mHandlerThread.start();\n            mHandler = new PackageHandler(mHandlerThread.getLooper());\n            Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);\n\n            File dataDir = Environment.getDataDirectory();\n            mAppDataDir = new File(dataDir, \"data\");\n            mAppInstallDir = new File(dataDir, \"app\");\n            mAppLib32InstallDir = new File(dataDir, \"app-lib\");\n            mAsecInternalPath = new File(dataDir, \"app-asec\").getPath();\n            mUserAppDataDir = new File(dataDir, \"user\");\n            mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\");\n\n            sUserManager = new UserManagerService(context, this,\n                    mInstallLock, mPackages);\n\n            // Propagate permission configuration in to package manager.\n            ArrayMap<String, SystemConfig.PermissionEntry> permConfig\n                    = systemConfig.getPermissions();\n            for (int i=0; i<permConfig.size(); i++) {\n                SystemConfig.PermissionEntry perm = permConfig.valueAt(i);\n                BasePermission bp = mSettings.mPermissions.get(perm.name);\n                if (bp == null) {\n                    bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN);\n                    mSettings.mPermissions.put(perm.name, bp);\n                }\n                if (perm.gids != null) {\n                    bp.setGids(perm.gids, perm.perUser);\n                }\n            }\n\n            ArrayMap<String, String> libConfig = systemConfig.getSharedLibraries();\n            for (int i=0; i<libConfig.size(); i++) {\n                mSharedLibraries.put(libConfig.keyAt(i),\n                        new SharedLibraryEntry(libConfig.valueAt(i), null));\n            }\n\n            mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();\n\n            mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false),\n                    mSdkVersion, mOnlyCore);\n\n            String customResolverActivity = Resources.getSystem().getString(\n                    R.string.config_customResolverActivity);\n            if (TextUtils.isEmpty(customResolverActivity)) {\n                customResolverActivity = null;\n            } else {\n                mCustomResolverComponentName = ComponentName.unflattenFromString(\n                        customResolverActivity);\n            }\n\n            long startTime = SystemClock.uptimeMillis();\n```\n\n* 构造Settings对象，添加shareUserId\n* 构造SystemConfig，获取mSystemPermissions灯属性\n* 创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象\n* 从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，\n\n#### 2.2 PMS_SYSTEM_SCAN_START\n\n```java\n            final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;\n\n            final ArraySet<String> alreadyDexOpted = new ArraySet<String>();\n\n            /**\n             * Add everything in the in the boot class path to the\n             * list of process files because dexopt will have been run\n             * if necessary during zygote startup.\n             */\n            final String bootClassPath = System.getenv(\"BOOTCLASSPATH\");\n            final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\");\n\n            if (bootClassPath != null) {\n                String[] bootClassPathElements = splitString(bootClassPath, ':');\n                for (String element : bootClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No BOOTCLASSPATH found!\");\n            }\n\n            if (systemServerClassPath != null) {\n                String[] systemServerClassPathElements = splitString(systemServerClassPath, ':');\n                for (String element : systemServerClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No SYSTEMSERVERCLASSPATH found!\");\n            }\n\n            final List<String> allInstructionSets = InstructionSets.getAllInstructionSets();\n            final String[] dexCodeInstructionSets =\n                    getDexCodeInstructionSets(\n                            allInstructionSets.toArray(new String[allInstructionSets.size()]));\n\n            /**\n             * Ensure all external libraries have had dexopt run on them.\n             */\n            if (mSharedLibraries.size() > 0) {\n                // NOTE: For now, we're compiling these system \"shared libraries\"\n                // (and framework jars) into all available architectures. It's possible\n                // to compile them only when we come across an app that uses them (there's\n                // already logic for that in scanPackageLI) but that adds some complexity.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (SharedLibraryEntry libEntry : mSharedLibraries.values()) {\n                        final String lib = libEntry.path;\n                        if (lib == null) {\n                            continue;\n                        }\n\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                alreadyDexOpted.add(lib);\n                                mInstaller.dexopt(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Library not found: \" + lib);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n\n            File frameworkDir = new File(Environment.getRootDirectory(), \"framework\");\n\n            // Gross hack for now: we know this file doesn't contain any\n            // code, so don't dexopt it to avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/framework-res.apk\");\n\n            // Gross hack for now: we know this file is only part of\n            // the boot class path for art, so don't dexopt it to\n            // avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/core-libart.jar\");\n\n            /**\n             * There are a number of commands implemented in Java, which\n             * we currently need to do the dexopt on so that they can be\n             * run from a non-root shell.\n             */\n            String[] frameworkFiles = frameworkDir.list();\n            if (frameworkFiles != null) {\n                // TODO: We could compile these only for the most preferred ABI. We should\n                // first double check that the dex files for these commands are not referenced\n                // by other system apps.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (int i=0; i<frameworkFiles.length; i++) {\n                        File libPath = new File(frameworkDir, frameworkFiles[i]);\n                        String path = libPath.getPath();\n                        // Skip the file if we already did it.\n                        if (alreadyDexOpted.contains(path)) {\n                            continue;\n                        }\n                        // Skip the file if it is not a type we want to dexopt.\n                        if (!path.endsWith(\".apk\") && !path.endsWith(\".jar\")) {\n                            continue;\n                        }\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                mInstaller.dexopt(path, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Jar not found: \" + path);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Exception reading jar: \" + path, e);\n                        }\n                    }\n                }\n            }\n\n            final VersionInfo ver = mSettings.getInternalVersion();\n            mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);\n            // when upgrading from pre-M, promote system app permissions from install to runtime\n            mPromoteSystemApps =\n                    mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;\n\n            // save off the names of pre-existing system packages prior to scanning; we don't\n            // want to automatically grant runtime permissions for new system apps\n            if (mPromoteSystemApps) {\n                Iterator<PackageSetting> pkgSettingIter = mSettings.mPackages.values().iterator();\n                while (pkgSettingIter.hasNext()) {\n                    PackageSetting ps = pkgSettingIter.next();\n                    if (isSystemApp(ps)) {\n                        mExistingSystemPackages.add(ps.name);\n                    }\n                }\n            }\n\n            // Collect vendor overlay packages.\n            // (Do this before scanning any apps.)\n            // For security and version matching reason, only consider\n            // overlay packages if they reside in VENDOR_OVERLAY_DIR.\n            File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);\n            scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);\n\n            // Find base frameworks (resource packages without code).\n            scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED,\n                    scanFlags | SCAN_NO_DEX, 0);\n\n            // Collected privileged system packages.\n            final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");\n            scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);\n\n            // Collect ordinary system packages.\n            final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");\n            scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all vendor packages.\n            File vendorAppDir = new File(\"/vendor/app\");\n            try {\n                vendorAppDir = vendorAppDir.getCanonicalFile();\n            } catch (IOException e) {\n                // failed to look up canonical path, continue with original one\n            }\n            scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all OEM packages.\n            final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");\n            scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            if (DEBUG_UPGRADE) Log.v(TAG, \"Running installd update commands\");\n            mInstaller.moveFiles();\n\n            // Prune any system packages that no longer exist.\n            final List<String> possiblyDeletedUpdatedSystemApps = new ArrayList<String>();\n            if (!mOnlyCore) {\n                Iterator<PackageSetting> psit = mSettings.mPackages.values().iterator();\n                while (psit.hasNext()) {\n                    PackageSetting ps = psit.next();\n\n                    /*\n                     * If this is not a system app, it can't be a\n                     * disable system app.\n                     */\n                    if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {\n                        continue;\n                    }\n\n                    /*\n                     * If the package is scanned, it's not erased.\n                     */\n                    final PackageParser.Package scannedPkg = mPackages.get(ps.name);\n                    if (scannedPkg != null) {\n                        /*\n                         * If the system app is both scanned and in the\n                         * disabled packages list, then it must have been\n                         * added via OTA. Remove it from the currently\n                         * scanned package so the previously user-installed\n                         * application can be scanned.\n                         */\n                        if (mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                            logCriticalInfo(Log.WARN, \"Expecting better updated system app for \"\n                                    + ps.name + \"; removing system app.  Last known codePath=\"\n                                    + ps.codePathString + \", installStatus=\" + ps.installStatus\n                                    + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\"\n                                    + scannedPkg.mVersionCode);\n                            removePackageLI(ps, true);\n                            mExpectingBetter.put(ps.name, ps.codePath);\n                        }\n\n                        continue;\n                    }\n\n                    if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                        psit.remove();\n                        logCriticalInfo(Log.WARN, \"System package \" + ps.name\n                                + \" no longer exists; wiping its data\");\n                        removeDataDirsLI(null, ps.name);\n                    } else {\n                        final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);\n                        if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {\n                            possiblyDeletedUpdatedSystemApps.add(ps.name);\n                        }\n                    }\n                }\n            }\n\n            //look for any incomplete package installations\n            ArrayList<PackageSetting> deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();\n            //clean up list\n            for(int i = 0; i < deletePkgsList.size(); i++) {\n                //clean up here\n                cleanupInstallFailedPackage(deletePkgsList.get(i));\n            }\n            //delete tmp files\n            deleteTempPackageFiles();\n\n            // Remove any shared userIDs that have no associated packages\n            mSettings.pruneSharedUsersLPw();\n\n            if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。\n\n* 首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,\n\n\t```\n/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found\n```\nSYSTEMSERVERCLASSPATH内容为下\n\n\t```\n/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found\n```\n\n* 获取构建时指定的cpu指令\n* 根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中\n* 将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表\n* 将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表\n* 收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息\n* 删除系统不存在的包removePackageLI\n* 清理安装失败的包 cleanupInstallFailedPackage\n* 删除临时文件\n* 移除不想干的包中的shared userIDs\n\n#### 2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\n\n```java\n          if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n* mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，\n\n\n#### 2.4 PMS_SCAN_END\n\n```java\n          int updateFlags = UPDATE_PERMISSIONS_ALL;\n            if (ver.sdkVersion != mSdkVersion) {\n                Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \"\n                        + mSdkVersion + \"; regranting permissions for internal storage\");\n                updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;\n            }\n            updatePermissionsLPw(null, null, updateFlags);\n            ver.sdkVersion = mSdkVersion;\n\n            // If this is the first boot or an update from pre-M, and it is a normal\n            // boot, then we need to initialize the default preferred apps across\n            // all defined users.\n            if (!onlyCore && (mPromoteSystemApps || !mRestoredSettings)) {\n                for (UserInfo user : sUserManager.getUsers(true)) {\n                    mSettings.applyDefaultPreferredAppsLPw(this, user.id);\n                    applyFactoryDefaultBrowserLPw(user.id);\n                    primeDomainVerificationsLPw(user.id);\n                }\n            }\n\n            // If this is first boot after an OTA, and a normal boot, then\n            // we need to clear code cache directories.\n            if (mIsUpgrade && !onlyCore) {\n                Slog.i(TAG, \"Build fingerprint changed; clearing code caches\");\n                for (int i = 0; i < mSettings.mPackages.size(); i++) {\n                    final PackageSetting ps = mSettings.mPackages.valueAt(i);\n                    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) {\n                        deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);\n                    }\n                }\n                ver.fingerprint = Build.FINGERPRINT;\n            }\n\n            checkDefaultBrowser();\n\n            // clear only after permissions and other defaults have been updated\n            mExistingSystemPackages.clear();\n            mPromoteSystemApps = false;\n\n            // All the changes are done during package scanning.\n            ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;\n\n            // can downgrade to reader\n            mSettings.writeLPr();\n```\n\n* 当sdk版本不一致时，需要更新权限\n* 当这是ota后的首次启动，正常启动则需要清除目录的缓存代码\n* 当权限和其他默认项都完成更新，则清理相关信息\n* 信息写回packages.xml文件\n\n这部分不是很懂。\n\n#### 2.5 BOOT_PROGRESS_PMS_READY\n\n```java\n          mRequiredVerifierPackage = getRequiredVerifierLPr();\n            mRequiredInstallerPackage = getRequiredInstallerLPr();\n\n            mInstallerService = new PackageInstallerService(context, this);\n\n            mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();\n            mIntentFilterVerifier = new IntentVerifierProxy(mContext,\n                    mIntentFilterVerifierComponent);\n\n        } // synchronized (mPackages)\n        } // synchronized (mInstallLock)\n\n        // Now after opening every single application zip, make sure they\n        // are all flushed.  Not really needed, but keeps things nice and\n        // tidy.\n        Runtime.getRuntime().gc();\n\n        // Expose private service for system components to use.\n        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());\n```\n\n* 初始化PackageInstallerService\n* gc，回收下内存\n\n\n### 3.Settings\n\n这个类负责读取data/system下的几个xml文件。收集其中的一些信息。\n\n* packages.xml\t记录所有安装app的信息\n* packages-backup.xml\t备份文件\n* packages-stopped.xml\t记录系统被强制停止的文件\n* packages-stopped-backup.xml\t备份文件\n* packages.list\t记录应用的数据信息\n\n### 4.scanDirLI\n\n这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。\n\n```java\n       final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(scanFile, parseFlags);\n        } catch (PackageParserException e) {\n            throw PackageManagerException.from(e);\n        }\n```\n\n重点看解析部分的代码。\n\n```java\n   public Package parsePackage(File packageFile, int flags) throws PackageParserException {\n        if (packageFile.isDirectory()) {\n            return parseClusterPackage(packageFile, flags);\n        } else {\n            return parseMonolithicPackage(packageFile, flags);\n        }\n    }\n```\n\n三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，\n\n```java\n            res = new Resources(assets, mMetrics, null);\n            assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                    Build.VERSION.RESOURCES_SDK_INT);\n            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\n\n            final String[] outError = new String[1];\n            final Package pkg = parseBaseApk(res, parser, flags, outError);\n```\n\n在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。\n\n```java\nif (tagName.equals(\"application\")) {\n                if (foundApp) {\n                    if (RIGID_PARSER) {\n                        outError[0] = \"<manifest> has more than one <application>\";\n                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                        return null;\n                    } else {\n                        Slog.w(TAG, \"<manifest> has more than one <application>\");\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                }\n\n                foundApp = true;\n                if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) {\n                    return null;\n                }\n            }\n```\n\n用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。\n\n```java\nif (tagName.equals(\"activity\")) {\n                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false,\n                        owner.baseHardwareAccelerated);\n                if (a == null) {\n                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                    return false;\n                }\n\n                owner.activities.add(a);\n\n            }\n```\n\n这里就不多说了。\n\n### 4. dex优化\n\n在Installer中，\n\n```java\n    public int dexopt(String apkPath, int uid, boolean isPublic, String pkgName,\n            String instructionSet, int dexoptNeeded, boolean vmSafeMode,\n            boolean debuggable, String outputPath) {\n        StringBuilder builder = new StringBuilder(\"dexopt\");\n        builder.append(' ');\n        builder.append(apkPath);\n        builder.append(' ');\n        builder.append(uid);\n        builder.append(isPublic ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(pkgName);\n        builder.append(' ');\n        builder.append(instructionSet);\n        builder.append(' ');\n        builder.append(dexoptNeeded);\n        builder.append(vmSafeMode ? \" 1\" : \" 0\");\n        builder.append(debuggable ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(outputPath != null ? outputPath : \"!\");\n        return execute(builder.toString());\n    }\n```\n\n进行参数封装，\n\n```java\n    public int execute(String cmd) {\n        String res = transact(cmd);\n        try {\n            return Integer.parseInt(res);\n        } catch (NumberFormatException ex) {\n            return -1;\n        }\n    }\n```\n\n在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。\n\n\n参考资料\n\n* [gityuan](http://gityuan.com/2016/11/06/packagemanager/)\n* Android 5.0 源代码\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/PMS初始化做了什么.md","raw":"---\ntitle: PMS初始化做了什么\ndate: 2017-01-05 17:21:21\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```java\n    public static PackageManagerService main(Context context, Installer installer,\n            boolean factoryTest, boolean onlyCore) {\n        PackageManagerService m = new PackageManagerService(context, installer,\n                factoryTest, onlyCore);\n        ServiceManager.addService(\"package\", m);\n        return m;\n    }\n```\n\n### 2.从pms构造函数说起\n\npms的构造函数相当长，根据[gityuan大神](http://gityuan.com/2016/11/06/packagemanager/)的提示，按照log的打印进行分布查看却是清晰了很多。\n\n#### 2.1 BOOT_PROGRESS_PMS_START\n\n```java\n        mContext = context;\n        mFactoryTest = factoryTest;\n        mOnlyCore = onlyCore;\n        mLazyDexOpt = \"eng\".equals(SystemProperties.get(\"ro.build.type\"));\n        mMetrics = new DisplayMetrics();\n        mSettings = new Settings(mPackages);\n        mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n\n        // TODO: add a property to control this?\n        long dexOptLRUThresholdInMinutes;\n        if (mLazyDexOpt) {\n            dexOptLRUThresholdInMinutes = 30; // only last 30 minutes of apps for eng builds.\n        } else {\n            dexOptLRUThresholdInMinutes = 7 * 24 * 60; // apps used in the 7 days for users.\n        }\n        mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * 60 * 1000;\n\n        String separateProcesses = SystemProperties.get(\"debug.separate_processes\");\n        if (separateProcesses != null && separateProcesses.length() > 0) {\n            if (\"*\".equals(separateProcesses)) {\n                mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;\n                mSeparateProcesses = null;\n                Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\");\n            } else {\n                mDefParseFlags = 0;\n                mSeparateProcesses = separateProcesses.split(\",\");\n                Slog.w(TAG, \"Running with debug.separate_processes: \"\n                        + separateProcesses);\n            }\n        } else {\n            mDefParseFlags = 0;\n            mSeparateProcesses = null;\n        }\n\n        mInstaller = installer;\n        mPackageDexOptimizer = new PackageDexOptimizer(this);\n        mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());\n\n        mOnPermissionChangeListeners = new OnPermissionChangeListeners(\n                FgThread.get().getLooper());\n\n        getDefaultDisplayMetrics(context, mMetrics);\n\n        SystemConfig systemConfig = SystemConfig.getInstance();\n        mGlobalGids = systemConfig.getGlobalGids();\n        mSystemPermissions = systemConfig.getSystemPermissions();\n        mAvailableFeatures = systemConfig.getAvailableFeatures();\n\n        synchronized (mInstallLock) {\n        // writer\n        synchronized (mPackages) {\n            mHandlerThread = new ServiceThread(TAG,\n                    Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);\n            mHandlerThread.start();\n            mHandler = new PackageHandler(mHandlerThread.getLooper());\n            Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);\n\n            File dataDir = Environment.getDataDirectory();\n            mAppDataDir = new File(dataDir, \"data\");\n            mAppInstallDir = new File(dataDir, \"app\");\n            mAppLib32InstallDir = new File(dataDir, \"app-lib\");\n            mAsecInternalPath = new File(dataDir, \"app-asec\").getPath();\n            mUserAppDataDir = new File(dataDir, \"user\");\n            mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\");\n\n            sUserManager = new UserManagerService(context, this,\n                    mInstallLock, mPackages);\n\n            // Propagate permission configuration in to package manager.\n            ArrayMap<String, SystemConfig.PermissionEntry> permConfig\n                    = systemConfig.getPermissions();\n            for (int i=0; i<permConfig.size(); i++) {\n                SystemConfig.PermissionEntry perm = permConfig.valueAt(i);\n                BasePermission bp = mSettings.mPermissions.get(perm.name);\n                if (bp == null) {\n                    bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN);\n                    mSettings.mPermissions.put(perm.name, bp);\n                }\n                if (perm.gids != null) {\n                    bp.setGids(perm.gids, perm.perUser);\n                }\n            }\n\n            ArrayMap<String, String> libConfig = systemConfig.getSharedLibraries();\n            for (int i=0; i<libConfig.size(); i++) {\n                mSharedLibraries.put(libConfig.keyAt(i),\n                        new SharedLibraryEntry(libConfig.valueAt(i), null));\n            }\n\n            mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();\n\n            mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false),\n                    mSdkVersion, mOnlyCore);\n\n            String customResolverActivity = Resources.getSystem().getString(\n                    R.string.config_customResolverActivity);\n            if (TextUtils.isEmpty(customResolverActivity)) {\n                customResolverActivity = null;\n            } else {\n                mCustomResolverComponentName = ComponentName.unflattenFromString(\n                        customResolverActivity);\n            }\n\n            long startTime = SystemClock.uptimeMillis();\n```\n\n* 构造Settings对象，添加shareUserId\n* 构造SystemConfig，获取mSystemPermissions灯属性\n* 创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象\n* 从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，\n\n#### 2.2 PMS_SYSTEM_SCAN_START\n\n```java\n            final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;\n\n            final ArraySet<String> alreadyDexOpted = new ArraySet<String>();\n\n            /**\n             * Add everything in the in the boot class path to the\n             * list of process files because dexopt will have been run\n             * if necessary during zygote startup.\n             */\n            final String bootClassPath = System.getenv(\"BOOTCLASSPATH\");\n            final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\");\n\n            if (bootClassPath != null) {\n                String[] bootClassPathElements = splitString(bootClassPath, ':');\n                for (String element : bootClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No BOOTCLASSPATH found!\");\n            }\n\n            if (systemServerClassPath != null) {\n                String[] systemServerClassPathElements = splitString(systemServerClassPath, ':');\n                for (String element : systemServerClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No SYSTEMSERVERCLASSPATH found!\");\n            }\n\n            final List<String> allInstructionSets = InstructionSets.getAllInstructionSets();\n            final String[] dexCodeInstructionSets =\n                    getDexCodeInstructionSets(\n                            allInstructionSets.toArray(new String[allInstructionSets.size()]));\n\n            /**\n             * Ensure all external libraries have had dexopt run on them.\n             */\n            if (mSharedLibraries.size() > 0) {\n                // NOTE: For now, we're compiling these system \"shared libraries\"\n                // (and framework jars) into all available architectures. It's possible\n                // to compile them only when we come across an app that uses them (there's\n                // already logic for that in scanPackageLI) but that adds some complexity.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (SharedLibraryEntry libEntry : mSharedLibraries.values()) {\n                        final String lib = libEntry.path;\n                        if (lib == null) {\n                            continue;\n                        }\n\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                alreadyDexOpted.add(lib);\n                                mInstaller.dexopt(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Library not found: \" + lib);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n\n            File frameworkDir = new File(Environment.getRootDirectory(), \"framework\");\n\n            // Gross hack for now: we know this file doesn't contain any\n            // code, so don't dexopt it to avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/framework-res.apk\");\n\n            // Gross hack for now: we know this file is only part of\n            // the boot class path for art, so don't dexopt it to\n            // avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/core-libart.jar\");\n\n            /**\n             * There are a number of commands implemented in Java, which\n             * we currently need to do the dexopt on so that they can be\n             * run from a non-root shell.\n             */\n            String[] frameworkFiles = frameworkDir.list();\n            if (frameworkFiles != null) {\n                // TODO: We could compile these only for the most preferred ABI. We should\n                // first double check that the dex files for these commands are not referenced\n                // by other system apps.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (int i=0; i<frameworkFiles.length; i++) {\n                        File libPath = new File(frameworkDir, frameworkFiles[i]);\n                        String path = libPath.getPath();\n                        // Skip the file if we already did it.\n                        if (alreadyDexOpted.contains(path)) {\n                            continue;\n                        }\n                        // Skip the file if it is not a type we want to dexopt.\n                        if (!path.endsWith(\".apk\") && !path.endsWith(\".jar\")) {\n                            continue;\n                        }\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                mInstaller.dexopt(path, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Jar not found: \" + path);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Exception reading jar: \" + path, e);\n                        }\n                    }\n                }\n            }\n\n            final VersionInfo ver = mSettings.getInternalVersion();\n            mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);\n            // when upgrading from pre-M, promote system app permissions from install to runtime\n            mPromoteSystemApps =\n                    mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;\n\n            // save off the names of pre-existing system packages prior to scanning; we don't\n            // want to automatically grant runtime permissions for new system apps\n            if (mPromoteSystemApps) {\n                Iterator<PackageSetting> pkgSettingIter = mSettings.mPackages.values().iterator();\n                while (pkgSettingIter.hasNext()) {\n                    PackageSetting ps = pkgSettingIter.next();\n                    if (isSystemApp(ps)) {\n                        mExistingSystemPackages.add(ps.name);\n                    }\n                }\n            }\n\n            // Collect vendor overlay packages.\n            // (Do this before scanning any apps.)\n            // For security and version matching reason, only consider\n            // overlay packages if they reside in VENDOR_OVERLAY_DIR.\n            File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);\n            scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);\n\n            // Find base frameworks (resource packages without code).\n            scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED,\n                    scanFlags | SCAN_NO_DEX, 0);\n\n            // Collected privileged system packages.\n            final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");\n            scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);\n\n            // Collect ordinary system packages.\n            final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");\n            scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all vendor packages.\n            File vendorAppDir = new File(\"/vendor/app\");\n            try {\n                vendorAppDir = vendorAppDir.getCanonicalFile();\n            } catch (IOException e) {\n                // failed to look up canonical path, continue with original one\n            }\n            scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all OEM packages.\n            final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");\n            scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            if (DEBUG_UPGRADE) Log.v(TAG, \"Running installd update commands\");\n            mInstaller.moveFiles();\n\n            // Prune any system packages that no longer exist.\n            final List<String> possiblyDeletedUpdatedSystemApps = new ArrayList<String>();\n            if (!mOnlyCore) {\n                Iterator<PackageSetting> psit = mSettings.mPackages.values().iterator();\n                while (psit.hasNext()) {\n                    PackageSetting ps = psit.next();\n\n                    /*\n                     * If this is not a system app, it can't be a\n                     * disable system app.\n                     */\n                    if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {\n                        continue;\n                    }\n\n                    /*\n                     * If the package is scanned, it's not erased.\n                     */\n                    final PackageParser.Package scannedPkg = mPackages.get(ps.name);\n                    if (scannedPkg != null) {\n                        /*\n                         * If the system app is both scanned and in the\n                         * disabled packages list, then it must have been\n                         * added via OTA. Remove it from the currently\n                         * scanned package so the previously user-installed\n                         * application can be scanned.\n                         */\n                        if (mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                            logCriticalInfo(Log.WARN, \"Expecting better updated system app for \"\n                                    + ps.name + \"; removing system app.  Last known codePath=\"\n                                    + ps.codePathString + \", installStatus=\" + ps.installStatus\n                                    + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\"\n                                    + scannedPkg.mVersionCode);\n                            removePackageLI(ps, true);\n                            mExpectingBetter.put(ps.name, ps.codePath);\n                        }\n\n                        continue;\n                    }\n\n                    if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                        psit.remove();\n                        logCriticalInfo(Log.WARN, \"System package \" + ps.name\n                                + \" no longer exists; wiping its data\");\n                        removeDataDirsLI(null, ps.name);\n                    } else {\n                        final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);\n                        if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {\n                            possiblyDeletedUpdatedSystemApps.add(ps.name);\n                        }\n                    }\n                }\n            }\n\n            //look for any incomplete package installations\n            ArrayList<PackageSetting> deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();\n            //clean up list\n            for(int i = 0; i < deletePkgsList.size(); i++) {\n                //clean up here\n                cleanupInstallFailedPackage(deletePkgsList.get(i));\n            }\n            //delete tmp files\n            deleteTempPackageFiles();\n\n            // Remove any shared userIDs that have no associated packages\n            mSettings.pruneSharedUsersLPw();\n\n            if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。\n\n* 首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,\n\n\t```\n/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found\n```\nSYSTEMSERVERCLASSPATH内容为下\n\n\t```\n/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found\n```\n\n* 获取构建时指定的cpu指令\n* 根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中\n* 将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表\n* 将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表\n* 收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息\n* 删除系统不存在的包removePackageLI\n* 清理安装失败的包 cleanupInstallFailedPackage\n* 删除临时文件\n* 移除不想干的包中的shared userIDs\n\n#### 2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\n\n```java\n          if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n* mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，\n\n\n#### 2.4 PMS_SCAN_END\n\n```java\n          int updateFlags = UPDATE_PERMISSIONS_ALL;\n            if (ver.sdkVersion != mSdkVersion) {\n                Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \"\n                        + mSdkVersion + \"; regranting permissions for internal storage\");\n                updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;\n            }\n            updatePermissionsLPw(null, null, updateFlags);\n            ver.sdkVersion = mSdkVersion;\n\n            // If this is the first boot or an update from pre-M, and it is a normal\n            // boot, then we need to initialize the default preferred apps across\n            // all defined users.\n            if (!onlyCore && (mPromoteSystemApps || !mRestoredSettings)) {\n                for (UserInfo user : sUserManager.getUsers(true)) {\n                    mSettings.applyDefaultPreferredAppsLPw(this, user.id);\n                    applyFactoryDefaultBrowserLPw(user.id);\n                    primeDomainVerificationsLPw(user.id);\n                }\n            }\n\n            // If this is first boot after an OTA, and a normal boot, then\n            // we need to clear code cache directories.\n            if (mIsUpgrade && !onlyCore) {\n                Slog.i(TAG, \"Build fingerprint changed; clearing code caches\");\n                for (int i = 0; i < mSettings.mPackages.size(); i++) {\n                    final PackageSetting ps = mSettings.mPackages.valueAt(i);\n                    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) {\n                        deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);\n                    }\n                }\n                ver.fingerprint = Build.FINGERPRINT;\n            }\n\n            checkDefaultBrowser();\n\n            // clear only after permissions and other defaults have been updated\n            mExistingSystemPackages.clear();\n            mPromoteSystemApps = false;\n\n            // All the changes are done during package scanning.\n            ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;\n\n            // can downgrade to reader\n            mSettings.writeLPr();\n```\n\n* 当sdk版本不一致时，需要更新权限\n* 当这是ota后的首次启动，正常启动则需要清除目录的缓存代码\n* 当权限和其他默认项都完成更新，则清理相关信息\n* 信息写回packages.xml文件\n\n这部分不是很懂。\n\n#### 2.5 BOOT_PROGRESS_PMS_READY\n\n```java\n          mRequiredVerifierPackage = getRequiredVerifierLPr();\n            mRequiredInstallerPackage = getRequiredInstallerLPr();\n\n            mInstallerService = new PackageInstallerService(context, this);\n\n            mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();\n            mIntentFilterVerifier = new IntentVerifierProxy(mContext,\n                    mIntentFilterVerifierComponent);\n\n        } // synchronized (mPackages)\n        } // synchronized (mInstallLock)\n\n        // Now after opening every single application zip, make sure they\n        // are all flushed.  Not really needed, but keeps things nice and\n        // tidy.\n        Runtime.getRuntime().gc();\n\n        // Expose private service for system components to use.\n        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());\n```\n\n* 初始化PackageInstallerService\n* gc，回收下内存\n\n\n### 3.Settings\n\n这个类负责读取data/system下的几个xml文件。收集其中的一些信息。\n\n* packages.xml\t记录所有安装app的信息\n* packages-backup.xml\t备份文件\n* packages-stopped.xml\t记录系统被强制停止的文件\n* packages-stopped-backup.xml\t备份文件\n* packages.list\t记录应用的数据信息\n\n### 4.scanDirLI\n\n这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。\n\n```java\n       final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(scanFile, parseFlags);\n        } catch (PackageParserException e) {\n            throw PackageManagerException.from(e);\n        }\n```\n\n重点看解析部分的代码。\n\n```java\n   public Package parsePackage(File packageFile, int flags) throws PackageParserException {\n        if (packageFile.isDirectory()) {\n            return parseClusterPackage(packageFile, flags);\n        } else {\n            return parseMonolithicPackage(packageFile, flags);\n        }\n    }\n```\n\n三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，\n\n```java\n            res = new Resources(assets, mMetrics, null);\n            assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                    Build.VERSION.RESOURCES_SDK_INT);\n            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\n\n            final String[] outError = new String[1];\n            final Package pkg = parseBaseApk(res, parser, flags, outError);\n```\n\n在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。\n\n```java\nif (tagName.equals(\"application\")) {\n                if (foundApp) {\n                    if (RIGID_PARSER) {\n                        outError[0] = \"<manifest> has more than one <application>\";\n                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                        return null;\n                    } else {\n                        Slog.w(TAG, \"<manifest> has more than one <application>\");\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                }\n\n                foundApp = true;\n                if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) {\n                    return null;\n                }\n            }\n```\n\n用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。\n\n```java\nif (tagName.equals(\"activity\")) {\n                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false,\n                        owner.baseHardwareAccelerated);\n                if (a == null) {\n                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                    return false;\n                }\n\n                owner.activities.add(a);\n\n            }\n```\n\n这里就不多说了。\n\n### 4. dex优化\n\n在Installer中，\n\n```java\n    public int dexopt(String apkPath, int uid, boolean isPublic, String pkgName,\n            String instructionSet, int dexoptNeeded, boolean vmSafeMode,\n            boolean debuggable, String outputPath) {\n        StringBuilder builder = new StringBuilder(\"dexopt\");\n        builder.append(' ');\n        builder.append(apkPath);\n        builder.append(' ');\n        builder.append(uid);\n        builder.append(isPublic ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(pkgName);\n        builder.append(' ');\n        builder.append(instructionSet);\n        builder.append(' ');\n        builder.append(dexoptNeeded);\n        builder.append(vmSafeMode ? \" 1\" : \" 0\");\n        builder.append(debuggable ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(outputPath != null ? outputPath : \"!\");\n        return execute(builder.toString());\n    }\n```\n\n进行参数封装，\n\n```java\n    public int execute(String cmd) {\n        String res = transact(cmd);\n        try {\n            return Integer.parseInt(res);\n        } catch (NumberFormatException ex) {\n            return -1;\n        }\n    }\n```\n\n在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。\n\n\n参考资料\n\n* [gityuan](http://gityuan.com/2016/11/06/packagemanager/)\n* Android 5.0 源代码\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"PMS初始化做了什么","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsly4001x19fyflvc3276","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PackageManagerService <span class=\"title\">main</span><span class=\"params\">(Context context, Installer installer,</span></span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> factoryTest, <span class=\"keyword\">boolean</span> onlyCore) &#123;</div><div class=\"line\">    PackageManagerService m = <span class=\"keyword\">new</span> PackageManagerService(context, installer,</div><div class=\"line\">            factoryTest, onlyCore);</div><div class=\"line\">    ServiceManager.addService(<span class=\"string\">\"package\"</span>, m);</div><div class=\"line\">    <span class=\"keyword\">return</span> m;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-从pms构造函数说起\"><a href=\"#2-从pms构造函数说起\" class=\"headerlink\" title=\"2.从pms构造函数说起\"></a>2.从pms构造函数说起</h3><p>pms的构造函数相当长，根据<a href=\"http://gityuan.com/2016/11/06/packagemanager/\" target=\"_blank\" rel=\"external\">gityuan大神</a>的提示，按照log的打印进行分布查看却是清晰了很多。</p>\n<h4 id=\"2-1-BOOT-PROGRESS-PMS-START\"><a href=\"#2-1-BOOT-PROGRESS-PMS-START\" class=\"headerlink\" title=\"2.1 BOOT_PROGRESS_PMS_START\"></a>2.1 BOOT_PROGRESS_PMS_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">mContext = context;</div><div class=\"line\">mFactoryTest = factoryTest;</div><div class=\"line\">mOnlyCore = onlyCore;</div><div class=\"line\">mLazyDexOpt = <span class=\"string\">\"eng\"</span>.equals(SystemProperties.get(<span class=\"string\">\"ro.build.type\"</span>));</div><div class=\"line\">mMetrics = <span class=\"keyword\">new</span> DisplayMetrics();</div><div class=\"line\">mSettings = <span class=\"keyword\">new</span> Settings(mPackages);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.system\"</span>, Process.SYSTEM_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.phone\"</span>, RADIO_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.log\"</span>, LOG_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.nfc\"</span>, NFC_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.bluetooth\"</span>, BLUETOOTH_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.shell\"</span>, SHELL_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> add a property to control this?</span></div><div class=\"line\"><span class=\"keyword\">long</span> dexOptLRUThresholdInMinutes;</div><div class=\"line\"><span class=\"keyword\">if</span> (mLazyDexOpt) &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">30</span>; <span class=\"comment\">// only last 30 minutes of apps for eng builds.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">7</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span>; <span class=\"comment\">// apps used in the 7 days for users.</span></div><div class=\"line\">&#125;</div><div class=\"line\">mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\">String separateProcesses = SystemProperties.get(<span class=\"string\">\"debug.separate_processes\"</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (separateProcesses != <span class=\"keyword\">null</span> &amp;&amp; separateProcesses.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"*\"</span>.equals(separateProcesses)) &#123;</div><div class=\"line\">        mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</div><div class=\"line\">        mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: * (ALL)\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">        mSeparateProcesses = separateProcesses.split(<span class=\"string\">\",\"</span>);</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: \"</span></div><div class=\"line\">                + separateProcesses);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">    mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mInstaller = installer;</div><div class=\"line\">mPackageDexOptimizer = <span class=\"keyword\">new</span> PackageDexOptimizer(<span class=\"keyword\">this</span>);</div><div class=\"line\">mMoveCallbacks = <span class=\"keyword\">new</span> MoveCallbacks(FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">mOnPermissionChangeListeners = <span class=\"keyword\">new</span> OnPermissionChangeListeners(</div><div class=\"line\">        FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">getDefaultDisplayMetrics(context, mMetrics);</div><div class=\"line\"></div><div class=\"line\">SystemConfig systemConfig = SystemConfig.getInstance();</div><div class=\"line\">mGlobalGids = systemConfig.getGlobalGids();</div><div class=\"line\">mSystemPermissions = systemConfig.getSystemPermissions();</div><div class=\"line\">mAvailableFeatures = systemConfig.getAvailableFeatures();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mInstallLock) &#123;</div><div class=\"line\"><span class=\"comment\">// writer</span></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mPackages) &#123;</div><div class=\"line\">    mHandlerThread = <span class=\"keyword\">new</span> ServiceThread(TAG,</div><div class=\"line\">            Process.THREAD_PRIORITY_BACKGROUND, <span class=\"keyword\">true</span> <span class=\"comment\">/*allowIo*/</span>);</div><div class=\"line\">    mHandlerThread.start();</div><div class=\"line\">    mHandler = <span class=\"keyword\">new</span> PackageHandler(mHandlerThread.getLooper());</div><div class=\"line\">    Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</div><div class=\"line\"></div><div class=\"line\">    File dataDir = Environment.getDataDirectory();</div><div class=\"line\">    mAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"data\"</span>);</div><div class=\"line\">    mAppInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app\"</span>);</div><div class=\"line\">    mAppLib32InstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-lib\"</span>);</div><div class=\"line\">    mAsecInternalPath = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-asec\"</span>).getPath();</div><div class=\"line\">    mUserAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"user\"</span>);</div><div class=\"line\">    mDrmAppPrivateInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-private\"</span>);</div><div class=\"line\"></div><div class=\"line\">    sUserManager = <span class=\"keyword\">new</span> UserManagerService(context, <span class=\"keyword\">this</span>,</div><div class=\"line\">            mInstallLock, mPackages);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Propagate permission configuration in to package manager.</span></div><div class=\"line\">    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</div><div class=\"line\">            = systemConfig.getPermissions();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;permConfig.size(); i++) &#123;</div><div class=\"line\">        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</div><div class=\"line\">        BasePermission bp = mSettings.mPermissions.get(perm.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (bp == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp = <span class=\"keyword\">new</span> BasePermission(perm.name, <span class=\"string\">\"android\"</span>, BasePermission.TYPE_BUILTIN);</div><div class=\"line\">            mSettings.mPermissions.put(perm.name, bp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm.gids != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp.setGids(perm.gids, perm.perUser);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;libConfig.size(); i++) &#123;</div><div class=\"line\">        mSharedLibraries.put(libConfig.keyAt(i),</div><div class=\"line\">                <span class=\"keyword\">new</span> SharedLibraryEntry(libConfig.valueAt(i), <span class=\"keyword\">null</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</div><div class=\"line\"></div><div class=\"line\">    mRestoredSettings = mSettings.readLPw(<span class=\"keyword\">this</span>, sUserManager.getUsers(<span class=\"keyword\">false</span>),</div><div class=\"line\">            mSdkVersion, mOnlyCore);</div><div class=\"line\"></div><div class=\"line\">    String customResolverActivity = Resources.getSystem().getString(</div><div class=\"line\">            R.string.config_customResolverActivity);</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(customResolverActivity)) &#123;</div><div class=\"line\">        customResolverActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mCustomResolverComponentName = ComponentName.unflattenFromString(</div><div class=\"line\">                customResolverActivity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">long</span> startTime = SystemClock.uptimeMillis();</div></pre></td></tr></table></figure>\n<ul>\n<li>构造Settings对象，添加shareUserId</li>\n<li>构造SystemConfig，获取mSystemPermissions灯属性</li>\n<li>创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象</li>\n<li>从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，</li>\n</ul>\n<h4 id=\"2-2-PMS-SYSTEM-SCAN-START\"><a href=\"#2-2-PMS-SYSTEM-SCAN-START\" class=\"headerlink\" title=\"2.2 PMS_SYSTEM_SCAN_START\"></a>2.2 PMS_SYSTEM_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> ArraySet&lt;String&gt; alreadyDexOpted = <span class=\"keyword\">new</span> ArraySet&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Add everything in the in the boot class path to the</div><div class=\"line\"> * list of process files because dexopt will have been run</div><div class=\"line\"> * if necessary during zygote startup.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">final</span> String bootClassPath = System.getenv(<span class=\"string\">\"BOOTCLASSPATH\"</span>);</div><div class=\"line\"><span class=\"keyword\">final</span> String systemServerClassPath = System.getenv(<span class=\"string\">\"SYSTEMSERVERCLASSPATH\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (bootClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] bootClassPathElements = splitString(bootClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : bootClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No BOOTCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (systemServerClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : systemServerClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No SYSTEMSERVERCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</div><div class=\"line\"><span class=\"keyword\">final</span> String[] dexCodeInstructionSets =</div><div class=\"line\">        getDexCodeInstructionSets(</div><div class=\"line\">                allInstructionSets.toArray(<span class=\"keyword\">new</span> String[allInstructionSets.size()]));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Ensure all external libraries have had dexopt run on them.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">if</span> (mSharedLibraries.size() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> For now, we're compiling these system \"shared libraries\"</span></div><div class=\"line\">    <span class=\"comment\">// (and framework jars) into all available architectures. It's possible</span></div><div class=\"line\">    <span class=\"comment\">// to compile them only when we come across an app that uses them (there's</span></div><div class=\"line\">    <span class=\"comment\">// already logic for that in scanPackageLI) but that adds some complexity.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> String lib = libEntry.path;</div><div class=\"line\">            <span class=\"keyword\">if</span> (lib == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(lib, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    alreadyDexOpted.add(lib);</div><div class=\"line\">                    mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Library not found: \"</span> + lib);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Cannot dexopt \"</span> + lib + <span class=\"string\">\"; is it an APK or JAR? \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">File frameworkDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"framework\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file doesn't contain any</span></div><div class=\"line\"><span class=\"comment\">// code, so don't dexopt it to avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/framework-res.apk\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file is only part of</span></div><div class=\"line\"><span class=\"comment\">// the boot class path for art, so don't dexopt it to</span></div><div class=\"line\"><span class=\"comment\">// avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/core-libart.jar\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * There are a number of commands implemented in Java, which</div><div class=\"line\"> * we currently need to do the dexopt on so that they can be</div><div class=\"line\"> * run from a non-root shell.</div><div class=\"line\"> */</div><div class=\"line\">String[] frameworkFiles = frameworkDir.list();</div><div class=\"line\"><span class=\"keyword\">if</span> (frameworkFiles != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We could compile these only for the most preferred ABI. We should</span></div><div class=\"line\">    <span class=\"comment\">// first double check that the dex files for these commands are not referenced</span></div><div class=\"line\">    <span class=\"comment\">// by other system apps.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;frameworkFiles.length; i++) &#123;</div><div class=\"line\">            File libPath = <span class=\"keyword\">new</span> File(frameworkDir, frameworkFiles[i]);</div><div class=\"line\">            String path = libPath.getPath();</div><div class=\"line\">            <span class=\"comment\">// Skip the file if we already did it.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (alreadyDexOpted.contains(path)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// Skip the file if it is not a type we want to dexopt.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!path.endsWith(<span class=\"string\">\".apk\"</span>) &amp;&amp; !path.endsWith(<span class=\"string\">\".jar\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(path, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    mInstaller.dexopt(path, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Jar not found: \"</span> + path);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Exception reading jar: \"</span> + path, e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> VersionInfo ver = mSettings.getInternalVersion();</div><div class=\"line\">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</div><div class=\"line\"><span class=\"comment\">// when upgrading from pre-M, promote system app permissions from install to runtime</span></div><div class=\"line\">mPromoteSystemApps =</div><div class=\"line\">        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// save off the names of pre-existing system packages prior to scanning; we don't</span></div><div class=\"line\"><span class=\"comment\">// want to automatically grant runtime permissions for new system apps</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mPromoteSystemApps) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (pkgSettingIter.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = pkgSettingIter.next();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isSystemApp(ps)) &#123;</div><div class=\"line\">            mExistingSystemPackages.add(ps.name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect vendor overlay packages.</span></div><div class=\"line\"><span class=\"comment\">// (Do this before scanning any apps.)</span></div><div class=\"line\"><span class=\"comment\">// For security and version matching reason, only consider</span></div><div class=\"line\"><span class=\"comment\">// overlay packages if they reside in VENDOR_OVERLAY_DIR.</span></div><div class=\"line\">File vendorOverlayDir = <span class=\"keyword\">new</span> File(VENDOR_OVERLAY_DIR);</div><div class=\"line\">scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Find base frameworks (resource packages without code).</span></div><div class=\"line\">scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED,</div><div class=\"line\">        scanFlags | SCAN_NO_DEX, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collected privileged system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File privilegedAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"priv-app\"</span>);</div><div class=\"line\">scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect ordinary system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File systemAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all vendor packages.</span></div><div class=\"line\">File vendorAppDir = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/vendor/app\"</span>);</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    vendorAppDir = vendorAppDir.getCanonicalFile();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">    <span class=\"comment\">// failed to look up canonical path, continue with original one</span></div><div class=\"line\">&#125;</div><div class=\"line\">scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all OEM packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File oemAppDir = <span class=\"keyword\">new</span> File(Environment.getOemDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (DEBUG_UPGRADE) Log.v(TAG, <span class=\"string\">\"Running installd update commands\"</span>);</div><div class=\"line\">mInstaller.moveFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prune any system packages that no longer exist.</span></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; possiblyDeletedUpdatedSystemApps = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (psit.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = psit.next();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * If this is not a system app, it can't be a</div><div class=\"line\">         * disable system app.</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * If the package is scanned, it's not erased.</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">final</span> PackageParser.Package scannedPkg = mPackages.get(ps.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (scannedPkg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</span></div><div class=\"line\">             * If the system app is both scanned and in the</div><div class=\"line\">             * disabled packages list, then it must have been</div><div class=\"line\">             * added via OTA. Remove it from the currently</div><div class=\"line\">             * scanned package so the previously user-installed</div><div class=\"line\">             * application can be scanned.</div><div class=\"line\">             */</div><div class=\"line\">            <span class=\"keyword\">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">                logCriticalInfo(Log.WARN, <span class=\"string\">\"Expecting better updated system app for \"</span></div><div class=\"line\">                        + ps.name + <span class=\"string\">\"; removing system app.  Last known codePath=\"</span></div><div class=\"line\">                        + ps.codePathString + <span class=\"string\">\", installStatus=\"</span> + ps.installStatus</div><div class=\"line\">                        + <span class=\"string\">\", versionCode=\"</span> + ps.versionCode + <span class=\"string\">\"; scanned versionCode=\"</span></div><div class=\"line\">                        + scannedPkg.mVersionCode);</div><div class=\"line\">                removePackageLI(ps, <span class=\"keyword\">true</span>);</div><div class=\"line\">                mExpectingBetter.put(ps.name, ps.codePath);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">            psit.remove();</div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"System package \"</span> + ps.name</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>);</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, ps.name);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</div><div class=\"line\">            <span class=\"keyword\">if</span> (disabledPs.codePath == <span class=\"keyword\">null</span> || !disabledPs.codePath.exists()) &#123;</div><div class=\"line\">                possiblyDeletedUpdatedSystemApps.add(ps.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//look for any incomplete package installations</span></div><div class=\"line\">ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</div><div class=\"line\"><span class=\"comment\">//clean up list</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deletePkgsList.size(); i++) &#123;</div><div class=\"line\">    <span class=\"comment\">//clean up here</span></div><div class=\"line\">    cleanupInstallFailedPackage(deletePkgsList.get(i));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//delete tmp files</span></div><div class=\"line\">deleteTempPackageFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Remove any shared userIDs that have no associated packages</span></div><div class=\"line\">mSettings.pruneSharedUsersLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">    scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">            scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Remove disable package settings for any updated system</div><div class=\"line\">     * apps that were removed via an OTA. If they're not a</div><div class=\"line\">     * previously-updated app, remove them completely.</div><div class=\"line\">     * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">        PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">        mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">        String msg;</div><div class=\"line\">        <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                    + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">            deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">            PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">            deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">        &#125;</div><div class=\"line\">        logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Make sure all system apps that we expected to appear on</div><div class=\"line\">     * the userdata partition actually showed up. If they never</div><div class=\"line\">     * appeared, crawl back and revive the system version.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                    + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">            <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                        | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\"><span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">    <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">    <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">    adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">            <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\"><span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<p>扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。</p>\n<ul>\n<li><p>首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>SYSTEMSERVERCLASSPATH内容为下</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>获取构建时指定的cpu指令</li>\n<li>根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中</li>\n<li>将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表</li>\n<li>将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表</li>\n<li>收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息</li>\n<li>删除系统不存在的包removePackageLI</li>\n<li>清理安装失败的包 cleanupInstallFailedPackage</li>\n<li>删除临时文件</li>\n<li>移除不想干的包中的shared userIDs</li>\n</ul>\n<h4 id=\"2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\"><a href=\"#2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\" class=\"headerlink\" title=\"2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\"></a>2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">              SystemClock.uptimeMillis());</div><div class=\"line\">      scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">              scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</span></div><div class=\"line\">       * Remove disable package settings for any updated system</div><div class=\"line\">       * apps that were removed via an OTA. If they're not a</div><div class=\"line\">       * previously-updated app, remove them completely.</div><div class=\"line\">       * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">       */</div><div class=\"line\">      <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">          PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">          mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">          String msg;</div><div class=\"line\">          <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">              removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                      + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">              deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">              PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">              deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">          &#125;</div><div class=\"line\">          logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</span></div><div class=\"line\">       * Make sure all system apps that we expected to appear on</div><div class=\"line\">       * the userdata partition actually showed up. If they never</div><div class=\"line\">       * appeared, crawl back and revive the system version.</div><div class=\"line\">       */</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">              <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">              logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                      + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">              <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                          | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                  <span class=\"keyword\">continue</span>;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">              mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                  scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">              &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                          + e.getMessage());</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\">  <span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">  updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">      <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">      <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">      adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">              <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\">  <span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">  mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<ul>\n<li>mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，</li>\n</ul>\n<h4 id=\"2-4-PMS-SCAN-END\"><a href=\"#2-4-PMS-SCAN-END\" class=\"headerlink\" title=\"2.4 PMS_SCAN_END\"></a>2.4 PMS_SCAN_END</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> updateFlags = UPDATE_PERMISSIONS_ALL;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ver.sdkVersion != mSdkVersion) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Platform changed from \"</span> + ver.sdkVersion + <span class=\"string\">\" to \"</span></div><div class=\"line\">              + mSdkVersion + <span class=\"string\">\"; regranting permissions for internal storage\"</span>);</div><div class=\"line\">      updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</div><div class=\"line\">  &#125;</div><div class=\"line\">  updatePermissionsLPw(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, updateFlags);</div><div class=\"line\">  ver.sdkVersion = mSdkVersion;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is the first boot or an update from pre-M, and it is a normal</span></div><div class=\"line\">  <span class=\"comment\">// boot, then we need to initialize the default preferred apps across</span></div><div class=\"line\">  <span class=\"comment\">// all defined users.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (UserInfo user : sUserManager.getUsers(<span class=\"keyword\">true</span>)) &#123;</div><div class=\"line\">          mSettings.applyDefaultPreferredAppsLPw(<span class=\"keyword\">this</span>, user.id);</div><div class=\"line\">          applyFactoryDefaultBrowserLPw(user.id);</div><div class=\"line\">          primeDomainVerificationsLPw(user.id);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is first boot after an OTA, and a normal boot, then</span></div><div class=\"line\">  <span class=\"comment\">// we need to clear code cache directories.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Build fingerprint changed; clearing code caches\"</span>);</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mSettings.mPackages.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</div><div class=\"line\">              deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      ver.fingerprint = Build.FINGERPRINT;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  checkDefaultBrowser();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// clear only after permissions and other defaults have been updated</span></div><div class=\"line\">  mExistingSystemPackages.clear();</div><div class=\"line\">  mPromoteSystemApps = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// All the changes are done during package scanning.</span></div><div class=\"line\">  ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// can downgrade to reader</span></div><div class=\"line\">  mSettings.writeLPr();</div></pre></td></tr></table></figure>\n<ul>\n<li>当sdk版本不一致时，需要更新权限</li>\n<li>当这是ota后的首次启动，正常启动则需要清除目录的缓存代码</li>\n<li>当权限和其他默认项都完成更新，则清理相关信息</li>\n<li>信息写回packages.xml文件</li>\n</ul>\n<p>这部分不是很懂。</p>\n<h4 id=\"2-5-BOOT-PROGRESS-PMS-READY\"><a href=\"#2-5-BOOT-PROGRESS-PMS-READY\" class=\"headerlink\" title=\"2.5 BOOT_PROGRESS_PMS_READY\"></a>2.5 BOOT_PROGRESS_PMS_READY</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">  mRequiredVerifierPackage = getRequiredVerifierLPr();</div><div class=\"line\">    mRequiredInstallerPackage = getRequiredInstallerLPr();</div><div class=\"line\"></div><div class=\"line\">    mInstallerService = <span class=\"keyword\">new</span> PackageInstallerService(context, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</div><div class=\"line\">    mIntentFilterVerifier = <span class=\"keyword\">new</span> IntentVerifierProxy(mContext,</div><div class=\"line\">            mIntentFilterVerifierComponent);</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mPackages)</span></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mInstallLock)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now after opening every single application zip, make sure they</span></div><div class=\"line\"><span class=\"comment\">// are all flushed.  Not really needed, but keeps things nice and</span></div><div class=\"line\"><span class=\"comment\">// tidy.</span></div><div class=\"line\">Runtime.getRuntime().gc();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Expose private service for system components to use.</span></div><div class=\"line\">LocalServices.addService(PackageManagerInternal.class, <span class=\"keyword\">new</span> PackageManagerInternalImpl());</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化PackageInstallerService</li>\n<li>gc，回收下内存</li>\n</ul>\n<h3 id=\"3-Settings\"><a href=\"#3-Settings\" class=\"headerlink\" title=\"3.Settings\"></a>3.Settings</h3><p>这个类负责读取data/system下的几个xml文件。收集其中的一些信息。</p>\n<ul>\n<li>packages.xml    记录所有安装app的信息</li>\n<li>packages-backup.xml    备份文件</li>\n<li>packages-stopped.xml    记录系统被强制停止的文件</li>\n<li>packages-stopped-backup.xml    备份文件</li>\n<li>packages.list    记录应用的数据信息</li>\n</ul>\n<h3 id=\"4-scanDirLI\"><a href=\"#4-scanDirLI\" class=\"headerlink\" title=\"4.scanDirLI\"></a>4.scanDirLI</h3><p>这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> PackageParser.Package pkg;</div><div class=\"line\"> <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     pkg = pp.parsePackage(scanFile, parseFlags);</div><div class=\"line\"> &#125; <span class=\"keyword\">catch</span> (PackageParserException e) &#123;</div><div class=\"line\">     <span class=\"keyword\">throw</span> PackageManagerException.from(e);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>重点看解析部分的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Package <span class=\"title\">parsePackage</span><span class=\"params\">(File packageFile, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> PackageParserException </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (packageFile.isDirectory()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseClusterPackage(packageFile, flags);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseMonolithicPackage(packageFile, flags);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = <span class=\"keyword\">new</span> Resources(assets, mMetrics, <span class=\"keyword\">null</span>);</div><div class=\"line\">assets.setConfiguration(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        Build.VERSION.RESOURCES_SDK_INT);</div><div class=\"line\">parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> String[] outError = <span class=\"keyword\">new</span> String[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">final</span> Package pkg = parseBaseApk(res, parser, flags, outError);</div></pre></td></tr></table></figure>\n<p>在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"application\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (foundApp) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (RIGID_PARSER) &#123;</div><div class=\"line\">                        outError[<span class=\"number\">0</span>] = <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>;</div><div class=\"line\">                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        Slog.w(TAG, <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>);</div><div class=\"line\">                        XmlUtils.skipCurrentTag(parser);</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                foundApp = <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"activity\"</span>)) &#123;</div><div class=\"line\">                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, <span class=\"keyword\">false</span>,</div><div class=\"line\">                        owner.baseHardwareAccelerated);</div><div class=\"line\">                <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                owner.activities.add(a);</div><div class=\"line\"></div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>这里就不多说了。</p>\n<h3 id=\"4-dex优化\"><a href=\"#4-dex优化\" class=\"headerlink\" title=\"4. dex优化\"></a>4. dex优化</h3><p>在Installer中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dexopt</span><span class=\"params\">(String apkPath, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">boolean</span> isPublic, String pkgName,</span></span></div><div class=\"line\">        String instructionSet, <span class=\"keyword\">int</span> dexoptNeeded, <span class=\"keyword\">boolean</span> vmSafeMode,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> debuggable, String outputPath) &#123;</div><div class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"dexopt\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(apkPath);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(uid);</div><div class=\"line\">    builder.append(isPublic ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(pkgName);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(instructionSet);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(dexoptNeeded);</div><div class=\"line\">    builder.append(vmSafeMode ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(debuggable ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(outputPath != <span class=\"keyword\">null</span> ? outputPath : <span class=\"string\">\"!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> execute(builder.toString());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进行参数封装，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">execute</span><span class=\"params\">(String cmd)</span> </span>&#123;</div><div class=\"line\">    String res = transact(cmd);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Integer.parseInt(res);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException ex) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。</p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://gityuan.com/2016/11/06/packagemanager/\" target=\"_blank\" rel=\"external\">gityuan</a></li>\n<li>Android 5.0 源代码</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。</p>","more":"<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PackageManagerService <span class=\"title\">main</span><span class=\"params\">(Context context, Installer installer,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> factoryTest, <span class=\"keyword\">boolean</span> onlyCore)</span> </span>&#123;</div><div class=\"line\">    PackageManagerService m = <span class=\"keyword\">new</span> PackageManagerService(context, installer,</div><div class=\"line\">            factoryTest, onlyCore);</div><div class=\"line\">    ServiceManager.addService(<span class=\"string\">\"package\"</span>, m);</div><div class=\"line\">    <span class=\"keyword\">return</span> m;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-从pms构造函数说起\"><a href=\"#2-从pms构造函数说起\" class=\"headerlink\" title=\"2.从pms构造函数说起\"></a>2.从pms构造函数说起</h3><p>pms的构造函数相当长，根据<a href=\"http://gityuan.com/2016/11/06/packagemanager/\">gityuan大神</a>的提示，按照log的打印进行分布查看却是清晰了很多。</p>\n<h4 id=\"2-1-BOOT-PROGRESS-PMS-START\"><a href=\"#2-1-BOOT-PROGRESS-PMS-START\" class=\"headerlink\" title=\"2.1 BOOT_PROGRESS_PMS_START\"></a>2.1 BOOT_PROGRESS_PMS_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">mContext = context;</div><div class=\"line\">mFactoryTest = factoryTest;</div><div class=\"line\">mOnlyCore = onlyCore;</div><div class=\"line\">mLazyDexOpt = <span class=\"string\">\"eng\"</span>.equals(SystemProperties.get(<span class=\"string\">\"ro.build.type\"</span>));</div><div class=\"line\">mMetrics = <span class=\"keyword\">new</span> DisplayMetrics();</div><div class=\"line\">mSettings = <span class=\"keyword\">new</span> Settings(mPackages);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.system\"</span>, Process.SYSTEM_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.phone\"</span>, RADIO_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.log\"</span>, LOG_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.nfc\"</span>, NFC_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.bluetooth\"</span>, BLUETOOTH_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.shell\"</span>, SHELL_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> add a property to control this?</span></div><div class=\"line\"><span class=\"keyword\">long</span> dexOptLRUThresholdInMinutes;</div><div class=\"line\"><span class=\"keyword\">if</span> (mLazyDexOpt) &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">30</span>; <span class=\"comment\">// only last 30 minutes of apps for eng builds.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">7</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span>; <span class=\"comment\">// apps used in the 7 days for users.</span></div><div class=\"line\">&#125;</div><div class=\"line\">mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\">String separateProcesses = SystemProperties.get(<span class=\"string\">\"debug.separate_processes\"</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (separateProcesses != <span class=\"keyword\">null</span> &amp;&amp; separateProcesses.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"*\"</span>.equals(separateProcesses)) &#123;</div><div class=\"line\">        mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</div><div class=\"line\">        mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: * (ALL)\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">        mSeparateProcesses = separateProcesses.split(<span class=\"string\">\",\"</span>);</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: \"</span></div><div class=\"line\">                + separateProcesses);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">    mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mInstaller = installer;</div><div class=\"line\">mPackageDexOptimizer = <span class=\"keyword\">new</span> PackageDexOptimizer(<span class=\"keyword\">this</span>);</div><div class=\"line\">mMoveCallbacks = <span class=\"keyword\">new</span> MoveCallbacks(FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">mOnPermissionChangeListeners = <span class=\"keyword\">new</span> OnPermissionChangeListeners(</div><div class=\"line\">        FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">getDefaultDisplayMetrics(context, mMetrics);</div><div class=\"line\"></div><div class=\"line\">SystemConfig systemConfig = SystemConfig.getInstance();</div><div class=\"line\">mGlobalGids = systemConfig.getGlobalGids();</div><div class=\"line\">mSystemPermissions = systemConfig.getSystemPermissions();</div><div class=\"line\">mAvailableFeatures = systemConfig.getAvailableFeatures();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mInstallLock) &#123;</div><div class=\"line\"><span class=\"comment\">// writer</span></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mPackages) &#123;</div><div class=\"line\">    mHandlerThread = <span class=\"keyword\">new</span> ServiceThread(TAG,</div><div class=\"line\">            Process.THREAD_PRIORITY_BACKGROUND, <span class=\"keyword\">true</span> <span class=\"comment\">/*allowIo*/</span>);</div><div class=\"line\">    mHandlerThread.start();</div><div class=\"line\">    mHandler = <span class=\"keyword\">new</span> PackageHandler(mHandlerThread.getLooper());</div><div class=\"line\">    Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</div><div class=\"line\"></div><div class=\"line\">    File dataDir = Environment.getDataDirectory();</div><div class=\"line\">    mAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"data\"</span>);</div><div class=\"line\">    mAppInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app\"</span>);</div><div class=\"line\">    mAppLib32InstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-lib\"</span>);</div><div class=\"line\">    mAsecInternalPath = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-asec\"</span>).getPath();</div><div class=\"line\">    mUserAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"user\"</span>);</div><div class=\"line\">    mDrmAppPrivateInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-private\"</span>);</div><div class=\"line\"></div><div class=\"line\">    sUserManager = <span class=\"keyword\">new</span> UserManagerService(context, <span class=\"keyword\">this</span>,</div><div class=\"line\">            mInstallLock, mPackages);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Propagate permission configuration in to package manager.</span></div><div class=\"line\">    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</div><div class=\"line\">            = systemConfig.getPermissions();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;permConfig.size(); i++) &#123;</div><div class=\"line\">        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</div><div class=\"line\">        BasePermission bp = mSettings.mPermissions.get(perm.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (bp == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp = <span class=\"keyword\">new</span> BasePermission(perm.name, <span class=\"string\">\"android\"</span>, BasePermission.TYPE_BUILTIN);</div><div class=\"line\">            mSettings.mPermissions.put(perm.name, bp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm.gids != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp.setGids(perm.gids, perm.perUser);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;libConfig.size(); i++) &#123;</div><div class=\"line\">        mSharedLibraries.put(libConfig.keyAt(i),</div><div class=\"line\">                <span class=\"keyword\">new</span> SharedLibraryEntry(libConfig.valueAt(i), <span class=\"keyword\">null</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</div><div class=\"line\"></div><div class=\"line\">    mRestoredSettings = mSettings.readLPw(<span class=\"keyword\">this</span>, sUserManager.getUsers(<span class=\"keyword\">false</span>),</div><div class=\"line\">            mSdkVersion, mOnlyCore);</div><div class=\"line\"></div><div class=\"line\">    String customResolverActivity = Resources.getSystem().getString(</div><div class=\"line\">            R.string.config_customResolverActivity);</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(customResolverActivity)) &#123;</div><div class=\"line\">        customResolverActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mCustomResolverComponentName = ComponentName.unflattenFromString(</div><div class=\"line\">                customResolverActivity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">long</span> startTime = SystemClock.uptimeMillis();</div></pre></td></tr></table></figure>\n<ul>\n<li>构造Settings对象，添加shareUserId</li>\n<li>构造SystemConfig，获取mSystemPermissions灯属性</li>\n<li>创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象</li>\n<li>从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，</li>\n</ul>\n<h4 id=\"2-2-PMS-SYSTEM-SCAN-START\"><a href=\"#2-2-PMS-SYSTEM-SCAN-START\" class=\"headerlink\" title=\"2.2 PMS_SYSTEM_SCAN_START\"></a>2.2 PMS_SYSTEM_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> ArraySet&lt;String&gt; alreadyDexOpted = <span class=\"keyword\">new</span> ArraySet&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Add everything in the in the boot class path to the</div><div class=\"line\"> * list of process files because dexopt will have been run</div><div class=\"line\"> * if necessary during zygote startup.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">final</span> String bootClassPath = System.getenv(<span class=\"string\">\"BOOTCLASSPATH\"</span>);</div><div class=\"line\"><span class=\"keyword\">final</span> String systemServerClassPath = System.getenv(<span class=\"string\">\"SYSTEMSERVERCLASSPATH\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (bootClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] bootClassPathElements = splitString(bootClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : bootClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No BOOTCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (systemServerClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : systemServerClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No SYSTEMSERVERCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</div><div class=\"line\"><span class=\"keyword\">final</span> String[] dexCodeInstructionSets =</div><div class=\"line\">        getDexCodeInstructionSets(</div><div class=\"line\">                allInstructionSets.toArray(<span class=\"keyword\">new</span> String[allInstructionSets.size()]));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Ensure all external libraries have had dexopt run on them.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mSharedLibraries.size() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> For now, we're compiling these system \"shared libraries\"</span></div><div class=\"line\">    <span class=\"comment\">// (and framework jars) into all available architectures. It's possible</span></div><div class=\"line\">    <span class=\"comment\">// to compile them only when we come across an app that uses them (there's</span></div><div class=\"line\">    <span class=\"comment\">// already logic for that in scanPackageLI) but that adds some complexity.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> String lib = libEntry.path;</div><div class=\"line\">            <span class=\"keyword\">if</span> (lib == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(lib, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    alreadyDexOpted.add(lib);</div><div class=\"line\">                    mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Library not found: \"</span> + lib);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Cannot dexopt \"</span> + lib + <span class=\"string\">\"; is it an APK or JAR? \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">File frameworkDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"framework\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file doesn't contain any</span></div><div class=\"line\"><span class=\"comment\">// code, so don't dexopt it to avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/framework-res.apk\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file is only part of</span></div><div class=\"line\"><span class=\"comment\">// the boot class path for art, so don't dexopt it to</span></div><div class=\"line\"><span class=\"comment\">// avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/core-libart.jar\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * There are a number of commands implemented in Java, which</div><div class=\"line\"> * we currently need to do the dexopt on so that they can be</div><div class=\"line\"> * run from a non-root shell.</div><div class=\"line\"> */</span></div><div class=\"line\">String[] frameworkFiles = frameworkDir.list();</div><div class=\"line\"><span class=\"keyword\">if</span> (frameworkFiles != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We could compile these only for the most preferred ABI. We should</span></div><div class=\"line\">    <span class=\"comment\">// first double check that the dex files for these commands are not referenced</span></div><div class=\"line\">    <span class=\"comment\">// by other system apps.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;frameworkFiles.length; i++) &#123;</div><div class=\"line\">            File libPath = <span class=\"keyword\">new</span> File(frameworkDir, frameworkFiles[i]);</div><div class=\"line\">            String path = libPath.getPath();</div><div class=\"line\">            <span class=\"comment\">// Skip the file if we already did it.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (alreadyDexOpted.contains(path)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// Skip the file if it is not a type we want to dexopt.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!path.endsWith(<span class=\"string\">\".apk\"</span>) &amp;&amp; !path.endsWith(<span class=\"string\">\".jar\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(path, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    mInstaller.dexopt(path, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Jar not found: \"</span> + path);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Exception reading jar: \"</span> + path, e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> VersionInfo ver = mSettings.getInternalVersion();</div><div class=\"line\">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</div><div class=\"line\"><span class=\"comment\">// when upgrading from pre-M, promote system app permissions from install to runtime</span></div><div class=\"line\">mPromoteSystemApps =</div><div class=\"line\">        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// save off the names of pre-existing system packages prior to scanning; we don't</span></div><div class=\"line\"><span class=\"comment\">// want to automatically grant runtime permissions for new system apps</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mPromoteSystemApps) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (pkgSettingIter.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = pkgSettingIter.next();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isSystemApp(ps)) &#123;</div><div class=\"line\">            mExistingSystemPackages.add(ps.name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect vendor overlay packages.</span></div><div class=\"line\"><span class=\"comment\">// (Do this before scanning any apps.)</span></div><div class=\"line\"><span class=\"comment\">// For security and version matching reason, only consider</span></div><div class=\"line\"><span class=\"comment\">// overlay packages if they reside in VENDOR_OVERLAY_DIR.</span></div><div class=\"line\">File vendorOverlayDir = <span class=\"keyword\">new</span> File(VENDOR_OVERLAY_DIR);</div><div class=\"line\">scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Find base frameworks (resource packages without code).</span></div><div class=\"line\">scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED,</div><div class=\"line\">        scanFlags | SCAN_NO_DEX, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collected privileged system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File privilegedAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"priv-app\"</span>);</div><div class=\"line\">scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect ordinary system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File systemAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all vendor packages.</span></div><div class=\"line\">File vendorAppDir = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/vendor/app\"</span>);</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    vendorAppDir = vendorAppDir.getCanonicalFile();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">    <span class=\"comment\">// failed to look up canonical path, continue with original one</span></div><div class=\"line\">&#125;</div><div class=\"line\">scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all OEM packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File oemAppDir = <span class=\"keyword\">new</span> File(Environment.getOemDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (DEBUG_UPGRADE) Log.v(TAG, <span class=\"string\">\"Running installd update commands\"</span>);</div><div class=\"line\">mInstaller.moveFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prune any system packages that no longer exist.</span></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; possiblyDeletedUpdatedSystemApps = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (psit.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = psit.next();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * If this is not a system app, it can't be a</div><div class=\"line\">         * disable system app.</div><div class=\"line\">         */</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * If the package is scanned, it's not erased.</div><div class=\"line\">         */</span></div><div class=\"line\">        <span class=\"keyword\">final</span> PackageParser.Package scannedPkg = mPackages.get(ps.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (scannedPkg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</div><div class=\"line\">             * If the system app is both scanned and in the</div><div class=\"line\">             * disabled packages list, then it must have been</div><div class=\"line\">             * added via OTA. Remove it from the currently</div><div class=\"line\">             * scanned package so the previously user-installed</div><div class=\"line\">             * application can be scanned.</div><div class=\"line\">             */</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">                logCriticalInfo(Log.WARN, <span class=\"string\">\"Expecting better updated system app for \"</span></div><div class=\"line\">                        + ps.name + <span class=\"string\">\"; removing system app.  Last known codePath=\"</span></div><div class=\"line\">                        + ps.codePathString + <span class=\"string\">\", installStatus=\"</span> + ps.installStatus</div><div class=\"line\">                        + <span class=\"string\">\", versionCode=\"</span> + ps.versionCode + <span class=\"string\">\"; scanned versionCode=\"</span></div><div class=\"line\">                        + scannedPkg.mVersionCode);</div><div class=\"line\">                removePackageLI(ps, <span class=\"keyword\">true</span>);</div><div class=\"line\">                mExpectingBetter.put(ps.name, ps.codePath);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">            psit.remove();</div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"System package \"</span> + ps.name</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>);</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, ps.name);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</div><div class=\"line\">            <span class=\"keyword\">if</span> (disabledPs.codePath == <span class=\"keyword\">null</span> || !disabledPs.codePath.exists()) &#123;</div><div class=\"line\">                possiblyDeletedUpdatedSystemApps.add(ps.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//look for any incomplete package installations</span></div><div class=\"line\">ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</div><div class=\"line\"><span class=\"comment\">//clean up list</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deletePkgsList.size(); i++) &#123;</div><div class=\"line\">    <span class=\"comment\">//clean up here</span></div><div class=\"line\">    cleanupInstallFailedPackage(deletePkgsList.get(i));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//delete tmp files</span></div><div class=\"line\">deleteTempPackageFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Remove any shared userIDs that have no associated packages</span></div><div class=\"line\">mSettings.pruneSharedUsersLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">    scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">            scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Remove disable package settings for any updated system</div><div class=\"line\">     * apps that were removed via an OTA. If they're not a</div><div class=\"line\">     * previously-updated app, remove them completely.</div><div class=\"line\">     * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">        PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">        mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">        String msg;</div><div class=\"line\">        <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                    + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">            deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">            PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">            deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">        &#125;</div><div class=\"line\">        logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Make sure all system apps that we expected to appear on</div><div class=\"line\">     * the userdata partition actually showed up. If they never</div><div class=\"line\">     * appeared, crawl back and revive the system version.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                    + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">            <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                        | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\"><span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">    <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">    <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">    adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">            <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\"><span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<p>扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。</p>\n<ul>\n<li><p>首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>SYSTEMSERVERCLASSPATH内容为下</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>获取构建时指定的cpu指令</li>\n<li>根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中</li>\n<li>将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表</li>\n<li>将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表</li>\n<li>收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息</li>\n<li>删除系统不存在的包removePackageLI</li>\n<li>清理安装失败的包 cleanupInstallFailedPackage</li>\n<li>删除临时文件</li>\n<li>移除不想干的包中的shared userIDs</li>\n</ul>\n<h4 id=\"2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\"><a href=\"#2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\" class=\"headerlink\" title=\"2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\"></a>2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">              SystemClock.uptimeMillis());</div><div class=\"line\">      scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">              scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</div><div class=\"line\">       * Remove disable package settings for any updated system</div><div class=\"line\">       * apps that were removed via an OTA. If they're not a</div><div class=\"line\">       * previously-updated app, remove them completely.</div><div class=\"line\">       * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">       */</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">          PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">          mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">          String msg;</div><div class=\"line\">          <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">              removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                      + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">              deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">              PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">              deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">          &#125;</div><div class=\"line\">          logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</div><div class=\"line\">       * Make sure all system apps that we expected to appear on</div><div class=\"line\">       * the userdata partition actually showed up. If they never</div><div class=\"line\">       * appeared, crawl back and revive the system version.</div><div class=\"line\">       */</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">              <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">              logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                      + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">              <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                          | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                  <span class=\"keyword\">continue</span>;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">              mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                  scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">              &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                          + e.getMessage());</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\">  <span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">  updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">      <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">      <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">      adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">              <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\">  <span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">  mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<ul>\n<li>mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，</li>\n</ul>\n<h4 id=\"2-4-PMS-SCAN-END\"><a href=\"#2-4-PMS-SCAN-END\" class=\"headerlink\" title=\"2.4 PMS_SCAN_END\"></a>2.4 PMS_SCAN_END</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> updateFlags = UPDATE_PERMISSIONS_ALL;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ver.sdkVersion != mSdkVersion) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Platform changed from \"</span> + ver.sdkVersion + <span class=\"string\">\" to \"</span></div><div class=\"line\">              + mSdkVersion + <span class=\"string\">\"; regranting permissions for internal storage\"</span>);</div><div class=\"line\">      updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</div><div class=\"line\">  &#125;</div><div class=\"line\">  updatePermissionsLPw(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, updateFlags);</div><div class=\"line\">  ver.sdkVersion = mSdkVersion;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is the first boot or an update from pre-M, and it is a normal</span></div><div class=\"line\">  <span class=\"comment\">// boot, then we need to initialize the default preferred apps across</span></div><div class=\"line\">  <span class=\"comment\">// all defined users.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (UserInfo user : sUserManager.getUsers(<span class=\"keyword\">true</span>)) &#123;</div><div class=\"line\">          mSettings.applyDefaultPreferredAppsLPw(<span class=\"keyword\">this</span>, user.id);</div><div class=\"line\">          applyFactoryDefaultBrowserLPw(user.id);</div><div class=\"line\">          primeDomainVerificationsLPw(user.id);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is first boot after an OTA, and a normal boot, then</span></div><div class=\"line\">  <span class=\"comment\">// we need to clear code cache directories.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Build fingerprint changed; clearing code caches\"</span>);</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mSettings.mPackages.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</div><div class=\"line\">              deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      ver.fingerprint = Build.FINGERPRINT;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  checkDefaultBrowser();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// clear only after permissions and other defaults have been updated</span></div><div class=\"line\">  mExistingSystemPackages.clear();</div><div class=\"line\">  mPromoteSystemApps = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// All the changes are done during package scanning.</span></div><div class=\"line\">  ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// can downgrade to reader</span></div><div class=\"line\">  mSettings.writeLPr();</div></pre></td></tr></table></figure>\n<ul>\n<li>当sdk版本不一致时，需要更新权限</li>\n<li>当这是ota后的首次启动，正常启动则需要清除目录的缓存代码</li>\n<li>当权限和其他默认项都完成更新，则清理相关信息</li>\n<li>信息写回packages.xml文件</li>\n</ul>\n<p>这部分不是很懂。</p>\n<h4 id=\"2-5-BOOT-PROGRESS-PMS-READY\"><a href=\"#2-5-BOOT-PROGRESS-PMS-READY\" class=\"headerlink\" title=\"2.5 BOOT_PROGRESS_PMS_READY\"></a>2.5 BOOT_PROGRESS_PMS_READY</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">  mRequiredVerifierPackage = getRequiredVerifierLPr();</div><div class=\"line\">    mRequiredInstallerPackage = getRequiredInstallerLPr();</div><div class=\"line\"></div><div class=\"line\">    mInstallerService = <span class=\"keyword\">new</span> PackageInstallerService(context, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</div><div class=\"line\">    mIntentFilterVerifier = <span class=\"keyword\">new</span> IntentVerifierProxy(mContext,</div><div class=\"line\">            mIntentFilterVerifierComponent);</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mPackages)</span></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mInstallLock)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now after opening every single application zip, make sure they</span></div><div class=\"line\"><span class=\"comment\">// are all flushed.  Not really needed, but keeps things nice and</span></div><div class=\"line\"><span class=\"comment\">// tidy.</span></div><div class=\"line\">Runtime.getRuntime().gc();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Expose private service for system components to use.</span></div><div class=\"line\">LocalServices.addService(PackageManagerInternal.class, <span class=\"keyword\">new</span> PackageManagerInternalImpl());</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化PackageInstallerService</li>\n<li>gc，回收下内存</li>\n</ul>\n<h3 id=\"3-Settings\"><a href=\"#3-Settings\" class=\"headerlink\" title=\"3.Settings\"></a>3.Settings</h3><p>这个类负责读取data/system下的几个xml文件。收集其中的一些信息。</p>\n<ul>\n<li>packages.xml    记录所有安装app的信息</li>\n<li>packages-backup.xml    备份文件</li>\n<li>packages-stopped.xml    记录系统被强制停止的文件</li>\n<li>packages-stopped-backup.xml    备份文件</li>\n<li>packages.list    记录应用的数据信息</li>\n</ul>\n<h3 id=\"4-scanDirLI\"><a href=\"#4-scanDirLI\" class=\"headerlink\" title=\"4.scanDirLI\"></a>4.scanDirLI</h3><p>这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> PackageParser.Package pkg;</div><div class=\"line\"> <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     pkg = pp.parsePackage(scanFile, parseFlags);</div><div class=\"line\"> &#125; <span class=\"keyword\">catch</span> (PackageParserException e) &#123;</div><div class=\"line\">     <span class=\"keyword\">throw</span> PackageManagerException.from(e);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>重点看解析部分的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Package <span class=\"title\">parsePackage</span><span class=\"params\">(File packageFile, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> PackageParserException </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (packageFile.isDirectory()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseClusterPackage(packageFile, flags);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseMonolithicPackage(packageFile, flags);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = <span class=\"keyword\">new</span> Resources(assets, mMetrics, <span class=\"keyword\">null</span>);</div><div class=\"line\">assets.setConfiguration(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        Build.VERSION.RESOURCES_SDK_INT);</div><div class=\"line\">parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> String[] outError = <span class=\"keyword\">new</span> String[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">final</span> Package pkg = parseBaseApk(res, parser, flags, outError);</div></pre></td></tr></table></figure>\n<p>在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"application\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (foundApp) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (RIGID_PARSER) &#123;</div><div class=\"line\">                        outError[<span class=\"number\">0</span>] = <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>;</div><div class=\"line\">                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        Slog.w(TAG, <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>);</div><div class=\"line\">                        XmlUtils.skipCurrentTag(parser);</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                foundApp = <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"activity\"</span>)) &#123;</div><div class=\"line\">                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, <span class=\"keyword\">false</span>,</div><div class=\"line\">                        owner.baseHardwareAccelerated);</div><div class=\"line\">                <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                owner.activities.add(a);</div><div class=\"line\"></div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>这里就不多说了。</p>\n<h3 id=\"4-dex优化\"><a href=\"#4-dex优化\" class=\"headerlink\" title=\"4. dex优化\"></a>4. dex优化</h3><p>在Installer中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dexopt</span><span class=\"params\">(String apkPath, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">boolean</span> isPublic, String pkgName,</div><div class=\"line\">        String instructionSet, <span class=\"keyword\">int</span> dexoptNeeded, <span class=\"keyword\">boolean</span> vmSafeMode,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> debuggable, String outputPath)</span> </span>&#123;</div><div class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"dexopt\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(apkPath);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(uid);</div><div class=\"line\">    builder.append(isPublic ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(pkgName);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(instructionSet);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(dexoptNeeded);</div><div class=\"line\">    builder.append(vmSafeMode ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(debuggable ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(outputPath != <span class=\"keyword\">null</span> ? outputPath : <span class=\"string\">\"!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> execute(builder.toString());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进行参数封装，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">execute</span><span class=\"params\">(String cmd)</span> </span>&#123;</div><div class=\"line\">    String res = transact(cmd);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Integer.parseInt(res);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException ex) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。</p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://gityuan.com/2016/11/06/packagemanager/\">gityuan</a></li>\n<li>Android 5.0 源代码</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"SystemServer进程的初始化","date":"2017-01-07T14:45:40.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n从上一篇我们知道，在Zygote进程的启动过程中，通过startSystemServer方法，来启动Android中另外一个核心进程SystemServer进程。那么，就来看下SystemServer进程的一些东西。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### ZygoteInit#startSystemServer\n\n```\n// 省去一部分参数代码\n        ZygoteConnection.Arguments parsedArgs = null;\n\n        int pid;\n\n        try {\n            parsedArgs = new ZygoteConnection.Arguments(args);\n            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n            /* Request to fork the system server process */\n            pid = Zygote.forkSystemServer(\n                    parsedArgs.uid, parsedArgs.gid,\n                    parsedArgs.gids,\n                    parsedArgs.debugFlags,\n                    null,\n                    parsedArgs.permittedCapabilities,\n                    parsedArgs.effectiveCapabilities);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        /* For child process */\n        if (pid == 0) {\n            if (hasSecondZygote(abiList)) {\n                waitForSecondaryZygote(socketName);\n            }\n\n            handleSystemServerProcess(parsedArgs);\n        }\n\n        return true;\n```\n\n* fork进程(和以前进程启动类似)\n* handleSystemServerProcess来处理SystemServer进程\n\n### ZygoteInit#handleSystemServerProcess\n\n```\n    private static void handleSystemServerProcess(\n            ZygoteConnection.Arguments parsedArgs)\n            throws ZygoteInit.MethodAndArgsCaller {\n\n        closeServerSocket();\n\n        // set umask to 0077 so new files and directories will default to owner-only permissions.\n        Os.umask(S_IRWXG | S_IRWXO);\n\n        if (parsedArgs.niceName != null) {\n            Process.setArgV0(parsedArgs.niceName);\n        }\n\n        final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\");\n        if (systemServerClasspath != null) {\n            performSystemServerDexOpt(systemServerClasspath);\n        }\n\n        if (parsedArgs.invokeWith != null) {\n            String[] args = parsedArgs.remainingArgs;\n            // If we have a non-null system server class path, we'll have to duplicate the\n            // existing arguments and append the classpath to it. ART will handle the classpath\n            // correctly when we exec a new process.\n            if (systemServerClasspath != null) {\n                String[] amendedArgs = new String[args.length + 2];\n                amendedArgs[0] = \"-cp\";\n                amendedArgs[1] = systemServerClasspath;\n                System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);\n            }\n\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(), null, args);\n        } else {\n            ClassLoader cl = null;\n            if (systemServerClasspath != null) {\n                cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());\n                Thread.currentThread().setContextClassLoader(cl);\n            }\n\n            /*\n             * Pass the remaining arguments to SystemServer.\n             */\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);\n        }\n\n        /* should never reach here */\n    }\n```\n\n* 通过umask设置创建文件的默认权限\n* 设置进程的nicename\n* 获取SYSTEMSERVERCLASSPATH环境变量值(一系列jar)，如果需要，进行dex优化\n* 在这里，invokeWith为null，所以会通过RuntimeInit.zygoteInit去启动\n\nRuntimeInit.zygoteInit中调用applicationInit，调用invokeStaticMain，然后就会调用SystemServer的main方法。\n\n```\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n```\n\n在SystemServer的构造函数中，获取mFactoryTestMode值，我们的重点在run方法。\n\n### SystemServer#run\n\nrun方法的代码如下：\n\n```\n    private void run() {\n        // If a device's clock is before 1970 (before 0), a lot of\n        // APIs crash dealing with negative numbers, notably\n        // java.io.File#setLastModified, so instead we fake it and\n        // hope that time from cell towers or NTP fixes it shortly.\n        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {\n            Slog.w(TAG, \"System clock is before 1970; setting to 1970.\");\n            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);\n        }\n\n        // If the system has \"persist.sys.language\" and friends set, replace them with\n        // \"persist.sys.locale\". Note that the default locale at this point is calculated\n        // using the \"-Duser.locale\" command line flag. That flag is usually populated by\n        // AndroidRuntime using the same set of system properties, but only the system_server\n        // and system apps are allowed to set them.\n        //\n        // NOTE: Most changes made here will need an equivalent change to\n        // core/jni/AndroidRuntime.cpp\n        if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) {\n            final String languageTag = Locale.getDefault().toLanguageTag();\n\n            SystemProperties.set(\"persist.sys.locale\", languageTag);\n            SystemProperties.set(\"persist.sys.language\", \"\");\n            SystemProperties.set(\"persist.sys.country\", \"\");\n            SystemProperties.set(\"persist.sys.localevar\", \"\");\n        }\n\n        // Here we go!\n        Slog.i(TAG, \"Entered the Android system server!\");\n        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());\n\n        // In case the runtime switched since last boot (such as when\n        // the old runtime was removed in an OTA), set the system\n        // property so that it is in sync. We can't do this in\n        // libnativehelper's JniInvocation::Init code where we already\n        // had to fallback to a different runtime because it is\n        // running as root and we need to be the system user to set\n        // the property. http://b/11463182\n        SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary());\n\n        // Enable the sampling profiler.\n        if (SamplingProfilerIntegration.isEnabled()) {\n            SamplingProfilerIntegration.start();\n            mProfilerSnapshotTimer = new Timer();\n            mProfilerSnapshotTimer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    SamplingProfilerIntegration.writeSnapshot(\"system_server\", null);\n                }\n            }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);\n        }\n\n        // Mmmmmm... more memory!\n        VMRuntime.getRuntime().clearGrowthLimit();\n\n        // The system server has to run all of the time, so it needs to be\n        // as efficient as possible with its memory usage.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);\n\n        // Some devices rely on runtime fingerprint generation, so make sure\n        // we've defined it before booting further.\n        Build.ensureFingerprintProperty();\n\n        // Within the system server, it is an error to access Environment paths without\n        // explicitly specifying a user.\n        Environment.setUserRequired(true);\n\n        // Ensure binder calls into the system always run at foreground priority.\n        BinderInternal.disableBackgroundScheduling(true);\n\n        // Prepare the main looper thread (this thread).\n        android.os.Process.setThreadPriority(\n                android.os.Process.THREAD_PRIORITY_FOREGROUND);\n        android.os.Process.setCanSelfBackground(false);\n        Looper.prepareMainLooper();\n\n        // Initialize native services.\n        System.loadLibrary(\"android_servers\");\n\n        // Check whether we failed to shut down last time we tried.\n        // This call may not return.\n        performPendingShutdown();\n\n        // Initialize the system context.\n        createSystemContext();\n\n        // Create the system service manager.\n        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);\n\n        // Start services.\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(\"System\", \"******************************************\");\n            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n            throw ex;\n        }\n\n        // For debug builds, log event loop stalls to dropbox for analysis.\n        if (StrictMode.conditionallyEnableDebugLogging()) {\n            Slog.i(TAG, \"Enabled StrictMode for system server main thread.\");\n        }\n\n        // Loop forever.\n        Looper.loop();\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n主要干了这些事：\n\n* 校验时间是否合法(1970)\n* 设置语言\n* 设置虚拟机库文件\n* 如果允许抽样分析器，则开启SamplingProfilerIntegration(抽样分析器)\n* clearGrowthLimit 清除内存增长上限\n* 设置内存使用率，setTargetHeapUtilization\n* 加载android_servers库\n* 创建上下文，创建SystemServiceManager，添加到LocalServices\n* startBootstrapServices 启动引导服务\n* startCoreServices 启动核心服务\n* startOtherServices 启动其他服务\n\n最后的启动服务 是核心，我们分别来看下。\n\n### SystemServer#startBootstrapServices\n\n```\n    private void startBootstrapServices() {\n        // Wait for installd to finish starting up so that it has a chance to\n        // create critical directories such as /data/user with the appropriate\n        // permissions.  We need this to complete before we initialize other services.\n        Installer installer = mSystemServiceManager.startService(Installer.class);\n\n        // Activity manager runs the show.\n        mActivityManagerService = mSystemServiceManager.startService(\n                ActivityManagerService.Lifecycle.class).getService();\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n        mActivityManagerService.setInstaller(installer);\n\n        // Power manager needs to be started early because other services need it.\n        // Native daemons may be watching for it to be registered so it must be ready\n        // to handle incoming binder calls immediately (including being able to verify\n        // the permissions for those calls).\n        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\n        // Now that the power manager has been started, let the activity manager\n        // initialize power management features.\n        mActivityManagerService.initPowerManagement();\n\n        // Manages LEDs and display backlight so we need it to bring up the display.\n        mSystemServiceManager.startService(LightsService.class);\n\n        // Display manager is needed to provide display metrics before package manager\n        // starts up.\n        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\n        // We need the default display before we can initialize the package manager.\n        mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);\n\n        // Only run \"core\" apps if we're encrypting the device.\n        String cryptState = SystemProperties.get(\"vold.decrypt\");\n        if (ENCRYPTING_STATE.equals(cryptState)) {\n            Slog.w(TAG, \"Detected encryption in progress - only parsing core apps\");\n            mOnlyCore = true;\n        } else if (ENCRYPTED_STATE.equals(cryptState)) {\n            Slog.w(TAG, \"Device encrypted - only parsing core apps\");\n            mOnlyCore = true;\n        }\n\n        // Start the package manager.\n        Slog.i(TAG, \"Package Manager\");\n        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,\n                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n        mFirstBoot = mPackageManagerService.isFirstBoot();\n        mPackageManager = mSystemContext.getPackageManager();\n\n        Slog.i(TAG, \"User Service\");\n        ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());\n\n        // Initialize attribute cache used to cache resources from packages.\n        AttributeCache.init(mSystemContext);\n\n        // Set up the Application instance for the system process and get started.\n        mActivityManagerService.setSystemProcess();\n\n        // The sensor service needs access to package manager service, app ops\n        // service, and permissions service, therefore we start it after them.\n        startSensorService();\n    }\n```\n\n* 启动Installer,用于应用程序安装，卸载，dex优化等等\n* 启动ActivityManagerService\n* 启动PowerManagerService\n* 启动LightsService\n* 启动DisplayManagerService\n* 启动PackageManagerService\n* 启动UserManagerService\n* 启动传感器服务(native)\n\n### SystemServer#startCoreServices\n\n```\n    private void startCoreServices() {\n        // Tracks the battery level.  Requires LightService.\n        mSystemServiceManager.startService(BatteryService.class);\n\n        // Tracks application usage stats.\n        mSystemServiceManager.startService(UsageStatsService.class);\n        mActivityManagerService.setUsageStatsManager(\n                LocalServices.getService(UsageStatsManagerInternal.class));\n        // Update after UsageStatsService is available, needed before performBootDexOpt.\n        mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();\n\n        // Tracks whether the updatable WebView is in a ready state and watches for update installs.\n        mSystemServiceManager.startService(WebViewUpdateService.class);\n    }\n```\n\n同样是启动几个核心的系统服务。\n\n### SystemServer#startOtherServices\n\n\n在这个方法中，同样启动了很多服务，不过，这里不仅仅有startService，也有ServiceManager.addService,不过这个是通过binder，像native注册的服务。\n\n```\n            case IServiceManager.ADD_SERVICE_TRANSACTION: {\n                data.enforceInterface(IServiceManager.descriptor);\n                String name = data.readString();\n                IBinder service = data.readStrongBinder();\n                boolean allowIsolated = data.readInt() != 0;\n                addService(name, service, allowIsolated);\n                return true;\n            }\n```\n\n当启动注册完毕之后，会调用各个服务的systemReady方法。这里就不介绍了。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/SystemServer进程的初始化.md","raw":"---\ntitle: SystemServer进程的初始化\ndate: 2017-01-07 22:45:40\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n从上一篇我们知道，在Zygote进程的启动过程中，通过startSystemServer方法，来启动Android中另外一个核心进程SystemServer进程。那么，就来看下SystemServer进程的一些东西。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### ZygoteInit#startSystemServer\n\n```\n// 省去一部分参数代码\n        ZygoteConnection.Arguments parsedArgs = null;\n\n        int pid;\n\n        try {\n            parsedArgs = new ZygoteConnection.Arguments(args);\n            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n            /* Request to fork the system server process */\n            pid = Zygote.forkSystemServer(\n                    parsedArgs.uid, parsedArgs.gid,\n                    parsedArgs.gids,\n                    parsedArgs.debugFlags,\n                    null,\n                    parsedArgs.permittedCapabilities,\n                    parsedArgs.effectiveCapabilities);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        /* For child process */\n        if (pid == 0) {\n            if (hasSecondZygote(abiList)) {\n                waitForSecondaryZygote(socketName);\n            }\n\n            handleSystemServerProcess(parsedArgs);\n        }\n\n        return true;\n```\n\n* fork进程(和以前进程启动类似)\n* handleSystemServerProcess来处理SystemServer进程\n\n### ZygoteInit#handleSystemServerProcess\n\n```\n    private static void handleSystemServerProcess(\n            ZygoteConnection.Arguments parsedArgs)\n            throws ZygoteInit.MethodAndArgsCaller {\n\n        closeServerSocket();\n\n        // set umask to 0077 so new files and directories will default to owner-only permissions.\n        Os.umask(S_IRWXG | S_IRWXO);\n\n        if (parsedArgs.niceName != null) {\n            Process.setArgV0(parsedArgs.niceName);\n        }\n\n        final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\");\n        if (systemServerClasspath != null) {\n            performSystemServerDexOpt(systemServerClasspath);\n        }\n\n        if (parsedArgs.invokeWith != null) {\n            String[] args = parsedArgs.remainingArgs;\n            // If we have a non-null system server class path, we'll have to duplicate the\n            // existing arguments and append the classpath to it. ART will handle the classpath\n            // correctly when we exec a new process.\n            if (systemServerClasspath != null) {\n                String[] amendedArgs = new String[args.length + 2];\n                amendedArgs[0] = \"-cp\";\n                amendedArgs[1] = systemServerClasspath;\n                System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);\n            }\n\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(), null, args);\n        } else {\n            ClassLoader cl = null;\n            if (systemServerClasspath != null) {\n                cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());\n                Thread.currentThread().setContextClassLoader(cl);\n            }\n\n            /*\n             * Pass the remaining arguments to SystemServer.\n             */\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);\n        }\n\n        /* should never reach here */\n    }\n```\n\n* 通过umask设置创建文件的默认权限\n* 设置进程的nicename\n* 获取SYSTEMSERVERCLASSPATH环境变量值(一系列jar)，如果需要，进行dex优化\n* 在这里，invokeWith为null，所以会通过RuntimeInit.zygoteInit去启动\n\nRuntimeInit.zygoteInit中调用applicationInit，调用invokeStaticMain，然后就会调用SystemServer的main方法。\n\n```\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n```\n\n在SystemServer的构造函数中，获取mFactoryTestMode值，我们的重点在run方法。\n\n### SystemServer#run\n\nrun方法的代码如下：\n\n```\n    private void run() {\n        // If a device's clock is before 1970 (before 0), a lot of\n        // APIs crash dealing with negative numbers, notably\n        // java.io.File#setLastModified, so instead we fake it and\n        // hope that time from cell towers or NTP fixes it shortly.\n        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {\n            Slog.w(TAG, \"System clock is before 1970; setting to 1970.\");\n            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);\n        }\n\n        // If the system has \"persist.sys.language\" and friends set, replace them with\n        // \"persist.sys.locale\". Note that the default locale at this point is calculated\n        // using the \"-Duser.locale\" command line flag. That flag is usually populated by\n        // AndroidRuntime using the same set of system properties, but only the system_server\n        // and system apps are allowed to set them.\n        //\n        // NOTE: Most changes made here will need an equivalent change to\n        // core/jni/AndroidRuntime.cpp\n        if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) {\n            final String languageTag = Locale.getDefault().toLanguageTag();\n\n            SystemProperties.set(\"persist.sys.locale\", languageTag);\n            SystemProperties.set(\"persist.sys.language\", \"\");\n            SystemProperties.set(\"persist.sys.country\", \"\");\n            SystemProperties.set(\"persist.sys.localevar\", \"\");\n        }\n\n        // Here we go!\n        Slog.i(TAG, \"Entered the Android system server!\");\n        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());\n\n        // In case the runtime switched since last boot (such as when\n        // the old runtime was removed in an OTA), set the system\n        // property so that it is in sync. We can't do this in\n        // libnativehelper's JniInvocation::Init code where we already\n        // had to fallback to a different runtime because it is\n        // running as root and we need to be the system user to set\n        // the property. http://b/11463182\n        SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary());\n\n        // Enable the sampling profiler.\n        if (SamplingProfilerIntegration.isEnabled()) {\n            SamplingProfilerIntegration.start();\n            mProfilerSnapshotTimer = new Timer();\n            mProfilerSnapshotTimer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    SamplingProfilerIntegration.writeSnapshot(\"system_server\", null);\n                }\n            }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);\n        }\n\n        // Mmmmmm... more memory!\n        VMRuntime.getRuntime().clearGrowthLimit();\n\n        // The system server has to run all of the time, so it needs to be\n        // as efficient as possible with its memory usage.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);\n\n        // Some devices rely on runtime fingerprint generation, so make sure\n        // we've defined it before booting further.\n        Build.ensureFingerprintProperty();\n\n        // Within the system server, it is an error to access Environment paths without\n        // explicitly specifying a user.\n        Environment.setUserRequired(true);\n\n        // Ensure binder calls into the system always run at foreground priority.\n        BinderInternal.disableBackgroundScheduling(true);\n\n        // Prepare the main looper thread (this thread).\n        android.os.Process.setThreadPriority(\n                android.os.Process.THREAD_PRIORITY_FOREGROUND);\n        android.os.Process.setCanSelfBackground(false);\n        Looper.prepareMainLooper();\n\n        // Initialize native services.\n        System.loadLibrary(\"android_servers\");\n\n        // Check whether we failed to shut down last time we tried.\n        // This call may not return.\n        performPendingShutdown();\n\n        // Initialize the system context.\n        createSystemContext();\n\n        // Create the system service manager.\n        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);\n\n        // Start services.\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(\"System\", \"******************************************\");\n            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n            throw ex;\n        }\n\n        // For debug builds, log event loop stalls to dropbox for analysis.\n        if (StrictMode.conditionallyEnableDebugLogging()) {\n            Slog.i(TAG, \"Enabled StrictMode for system server main thread.\");\n        }\n\n        // Loop forever.\n        Looper.loop();\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n主要干了这些事：\n\n* 校验时间是否合法(1970)\n* 设置语言\n* 设置虚拟机库文件\n* 如果允许抽样分析器，则开启SamplingProfilerIntegration(抽样分析器)\n* clearGrowthLimit 清除内存增长上限\n* 设置内存使用率，setTargetHeapUtilization\n* 加载android_servers库\n* 创建上下文，创建SystemServiceManager，添加到LocalServices\n* startBootstrapServices 启动引导服务\n* startCoreServices 启动核心服务\n* startOtherServices 启动其他服务\n\n最后的启动服务 是核心，我们分别来看下。\n\n### SystemServer#startBootstrapServices\n\n```\n    private void startBootstrapServices() {\n        // Wait for installd to finish starting up so that it has a chance to\n        // create critical directories such as /data/user with the appropriate\n        // permissions.  We need this to complete before we initialize other services.\n        Installer installer = mSystemServiceManager.startService(Installer.class);\n\n        // Activity manager runs the show.\n        mActivityManagerService = mSystemServiceManager.startService(\n                ActivityManagerService.Lifecycle.class).getService();\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n        mActivityManagerService.setInstaller(installer);\n\n        // Power manager needs to be started early because other services need it.\n        // Native daemons may be watching for it to be registered so it must be ready\n        // to handle incoming binder calls immediately (including being able to verify\n        // the permissions for those calls).\n        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\n        // Now that the power manager has been started, let the activity manager\n        // initialize power management features.\n        mActivityManagerService.initPowerManagement();\n\n        // Manages LEDs and display backlight so we need it to bring up the display.\n        mSystemServiceManager.startService(LightsService.class);\n\n        // Display manager is needed to provide display metrics before package manager\n        // starts up.\n        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\n        // We need the default display before we can initialize the package manager.\n        mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);\n\n        // Only run \"core\" apps if we're encrypting the device.\n        String cryptState = SystemProperties.get(\"vold.decrypt\");\n        if (ENCRYPTING_STATE.equals(cryptState)) {\n            Slog.w(TAG, \"Detected encryption in progress - only parsing core apps\");\n            mOnlyCore = true;\n        } else if (ENCRYPTED_STATE.equals(cryptState)) {\n            Slog.w(TAG, \"Device encrypted - only parsing core apps\");\n            mOnlyCore = true;\n        }\n\n        // Start the package manager.\n        Slog.i(TAG, \"Package Manager\");\n        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,\n                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n        mFirstBoot = mPackageManagerService.isFirstBoot();\n        mPackageManager = mSystemContext.getPackageManager();\n\n        Slog.i(TAG, \"User Service\");\n        ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());\n\n        // Initialize attribute cache used to cache resources from packages.\n        AttributeCache.init(mSystemContext);\n\n        // Set up the Application instance for the system process and get started.\n        mActivityManagerService.setSystemProcess();\n\n        // The sensor service needs access to package manager service, app ops\n        // service, and permissions service, therefore we start it after them.\n        startSensorService();\n    }\n```\n\n* 启动Installer,用于应用程序安装，卸载，dex优化等等\n* 启动ActivityManagerService\n* 启动PowerManagerService\n* 启动LightsService\n* 启动DisplayManagerService\n* 启动PackageManagerService\n* 启动UserManagerService\n* 启动传感器服务(native)\n\n### SystemServer#startCoreServices\n\n```\n    private void startCoreServices() {\n        // Tracks the battery level.  Requires LightService.\n        mSystemServiceManager.startService(BatteryService.class);\n\n        // Tracks application usage stats.\n        mSystemServiceManager.startService(UsageStatsService.class);\n        mActivityManagerService.setUsageStatsManager(\n                LocalServices.getService(UsageStatsManagerInternal.class));\n        // Update after UsageStatsService is available, needed before performBootDexOpt.\n        mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();\n\n        // Tracks whether the updatable WebView is in a ready state and watches for update installs.\n        mSystemServiceManager.startService(WebViewUpdateService.class);\n    }\n```\n\n同样是启动几个核心的系统服务。\n\n### SystemServer#startOtherServices\n\n\n在这个方法中，同样启动了很多服务，不过，这里不仅仅有startService，也有ServiceManager.addService,不过这个是通过binder，像native注册的服务。\n\n```\n            case IServiceManager.ADD_SERVICE_TRANSACTION: {\n                data.enforceInterface(IServiceManager.descriptor);\n                String name = data.readString();\n                IBinder service = data.readStrongBinder();\n                boolean allowIsolated = data.readInt() != 0;\n                addService(name, service, allowIsolated);\n                return true;\n            }\n```\n\n当启动注册完毕之后，会调用各个服务的systemReady方法。这里就不介绍了。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"SystemServer进程的初始化","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsly6002019fyfqen4frh","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从上一篇我们知道，在Zygote进程的启动过程中，通过startSystemServer方法，来启动Android中另外一个核心进程SystemServer进程。那么，就来看下SystemServer进程的一些东西。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"ZygoteInit-startSystemServer\"><a href=\"#ZygoteInit-startSystemServer\" class=\"headerlink\" title=\"ZygoteInit#startSystemServer\"></a>ZygoteInit#startSystemServer</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 省去一部分参数代码</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs = null;</div><div class=\"line\"></div><div class=\"line\">        int pid;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            parsedArgs = new ZygoteConnection.Arguments(args);</div><div class=\"line\">            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">            /* Request to fork the system server process */</div><div class=\"line\">            pid = Zygote.forkSystemServer(</div><div class=\"line\">                    parsedArgs.uid, parsedArgs.gid,</div><div class=\"line\">                    parsedArgs.gids,</div><div class=\"line\">                    parsedArgs.debugFlags,</div><div class=\"line\">                    null,</div><div class=\"line\">                    parsedArgs.permittedCapabilities,</div><div class=\"line\">                    parsedArgs.effectiveCapabilities);</div><div class=\"line\">        &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(ex);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /* For child process */</div><div class=\"line\">        if (pid == 0) &#123;</div><div class=\"line\">            if (hasSecondZygote(abiList)) &#123;</div><div class=\"line\">                waitForSecondaryZygote(socketName);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handleSystemServerProcess(parsedArgs);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return true;</div></pre></td></tr></table></figure>\n<ul>\n<li>fork进程(和以前进程启动类似)</li>\n<li>handleSystemServerProcess来处理SystemServer进程</li>\n</ul>\n<h3 id=\"ZygoteInit-handleSystemServerProcess\"><a href=\"#ZygoteInit-handleSystemServerProcess\" class=\"headerlink\" title=\"ZygoteInit#handleSystemServerProcess\"></a>ZygoteInit#handleSystemServerProcess</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void handleSystemServerProcess(</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">    closeServerSocket();</div><div class=\"line\"></div><div class=\"line\">    // set umask to 0077 so new files and directories will default to owner-only permissions.</div><div class=\"line\">    Os.umask(S_IRWXG | S_IRWXO);</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.niceName != null) &#123;</div><div class=\"line\">        Process.setArgV0(parsedArgs.niceName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</div><div class=\"line\">    if (systemServerClasspath != null) &#123;</div><div class=\"line\">        performSystemServerDexOpt(systemServerClasspath);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">        String[] args = parsedArgs.remainingArgs;</div><div class=\"line\">        // If we have a non-null system server class path, we&apos;ll have to duplicate the</div><div class=\"line\">        // existing arguments and append the classpath to it. ART will handle the classpath</div><div class=\"line\">        // correctly when we exec a new process.</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            String[] amendedArgs = new String[args.length + 2];</div><div class=\"line\">            amendedArgs[0] = &quot;-cp&quot;;</div><div class=\"line\">            amendedArgs[1] = systemServerClasspath;</div><div class=\"line\">            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">                VMRuntime.getCurrentInstructionSet(), null, args);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ClassLoader cl = null;</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</div><div class=\"line\">            Thread.currentThread().setContextClassLoader(cl);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * Pass the remaining arguments to SystemServer.</div><div class=\"line\">         */</div><div class=\"line\">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* should never reach here */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过umask设置创建文件的默认权限</li>\n<li>设置进程的nicename</li>\n<li>获取SYSTEMSERVERCLASSPATH环境变量值(一系列jar)，如果需要，进行dex优化</li>\n<li>在这里，invokeWith为null，所以会通过RuntimeInit.zygoteInit去启动</li>\n</ul>\n<p>RuntimeInit.zygoteInit中调用applicationInit，调用invokeStaticMain，然后就会调用SystemServer的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\">    new SystemServer().run();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在SystemServer的构造函数中，获取mFactoryTestMode值，我们的重点在run方法。</p>\n<h3 id=\"SystemServer-run\"><a href=\"#SystemServer-run\" class=\"headerlink\" title=\"SystemServer#run\"></a>SystemServer#run</h3><p>run方法的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void run() &#123;</div><div class=\"line\">    // If a device&apos;s clock is before 1970 (before 0), a lot of</div><div class=\"line\">    // APIs crash dealing with negative numbers, notably</div><div class=\"line\">    // java.io.File#setLastModified, so instead we fake it and</div><div class=\"line\">    // hope that time from cell towers or NTP fixes it shortly.</div><div class=\"line\">    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</div><div class=\"line\">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If the system has &quot;persist.sys.language&quot; and friends set, replace them with</div><div class=\"line\">    // &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated</div><div class=\"line\">    // using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by</div><div class=\"line\">    // AndroidRuntime using the same set of system properties, but only the system_server</div><div class=\"line\">    // and system apps are allowed to set them.</div><div class=\"line\">    //</div><div class=\"line\">    // NOTE: Most changes made here will need an equivalent change to</div><div class=\"line\">    // core/jni/AndroidRuntime.cpp</div><div class=\"line\">    if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;</div><div class=\"line\">        final String languageTag = Locale.getDefault().toLanguageTag();</div><div class=\"line\"></div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Here we go!</div><div class=\"line\">    Slog.i(TAG, &quot;Entered the Android system server!&quot;);</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());</div><div class=\"line\"></div><div class=\"line\">    // In case the runtime switched since last boot (such as when</div><div class=\"line\">    // the old runtime was removed in an OTA), set the system</div><div class=\"line\">    // property so that it is in sync. We can&apos;t do this in</div><div class=\"line\">    // libnativehelper&apos;s JniInvocation::Init code where we already</div><div class=\"line\">    // had to fallback to a different runtime because it is</div><div class=\"line\">    // running as root and we need to be the system user to set</div><div class=\"line\">    // the property. http://b/11463182</div><div class=\"line\">    SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());</div><div class=\"line\"></div><div class=\"line\">    // Enable the sampling profiler.</div><div class=\"line\">    if (SamplingProfilerIntegration.isEnabled()) &#123;</div><div class=\"line\">        SamplingProfilerIntegration.start();</div><div class=\"line\">        mProfilerSnapshotTimer = new Timer();</div><div class=\"line\">        mProfilerSnapshotTimer.schedule(new TimerTask() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Mmmmmm... more memory!</div><div class=\"line\">    VMRuntime.getRuntime().clearGrowthLimit();</div><div class=\"line\"></div><div class=\"line\">    // The system server has to run all of the time, so it needs to be</div><div class=\"line\">    // as efficient as possible with its memory usage.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);</div><div class=\"line\"></div><div class=\"line\">    // Some devices rely on runtime fingerprint generation, so make sure</div><div class=\"line\">    // we&apos;ve defined it before booting further.</div><div class=\"line\">    Build.ensureFingerprintProperty();</div><div class=\"line\"></div><div class=\"line\">    // Within the system server, it is an error to access Environment paths without</div><div class=\"line\">    // explicitly specifying a user.</div><div class=\"line\">    Environment.setUserRequired(true);</div><div class=\"line\"></div><div class=\"line\">    // Ensure binder calls into the system always run at foreground priority.</div><div class=\"line\">    BinderInternal.disableBackgroundScheduling(true);</div><div class=\"line\"></div><div class=\"line\">    // Prepare the main looper thread (this thread).</div><div class=\"line\">    android.os.Process.setThreadPriority(</div><div class=\"line\">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</div><div class=\"line\">    android.os.Process.setCanSelfBackground(false);</div><div class=\"line\">    Looper.prepareMainLooper();</div><div class=\"line\"></div><div class=\"line\">    // Initialize native services.</div><div class=\"line\">    System.loadLibrary(&quot;android_servers&quot;);</div><div class=\"line\"></div><div class=\"line\">    // Check whether we failed to shut down last time we tried.</div><div class=\"line\">    // This call may not return.</div><div class=\"line\">    performPendingShutdown();</div><div class=\"line\"></div><div class=\"line\">    // Initialize the system context.</div><div class=\"line\">    createSystemContext();</div><div class=\"line\"></div><div class=\"line\">    // Create the system service manager.</div><div class=\"line\">    mSystemServiceManager = new SystemServiceManager(mSystemContext);</div><div class=\"line\">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</div><div class=\"line\"></div><div class=\"line\">    // Start services.</div><div class=\"line\">    try &#123;</div><div class=\"line\">        startBootstrapServices();</div><div class=\"line\">        startCoreServices();</div><div class=\"line\">        startOtherServices();</div><div class=\"line\">    &#125; catch (Throwable ex) &#123;</div><div class=\"line\">        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</div><div class=\"line\">        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // For debug builds, log event loop stalls to dropbox for analysis.</div><div class=\"line\">    if (StrictMode.conditionallyEnableDebugLogging()) &#123;</div><div class=\"line\">        Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Loop forever.</div><div class=\"line\">    Looper.loop();</div><div class=\"line\">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要干了这些事：</p>\n<ul>\n<li>校验时间是否合法(1970)</li>\n<li>设置语言</li>\n<li>设置虚拟机库文件</li>\n<li>如果允许抽样分析器，则开启SamplingProfilerIntegration(抽样分析器)</li>\n<li>clearGrowthLimit 清除内存增长上限</li>\n<li>设置内存使用率，setTargetHeapUtilization</li>\n<li>加载android_servers库</li>\n<li>创建上下文，创建SystemServiceManager，添加到LocalServices</li>\n<li>startBootstrapServices 启动引导服务</li>\n<li>startCoreServices 启动核心服务</li>\n<li>startOtherServices 启动其他服务</li>\n</ul>\n<p>最后的启动服务 是核心，我们分别来看下。</p>\n<h3 id=\"SystemServer-startBootstrapServices\"><a href=\"#SystemServer-startBootstrapServices\" class=\"headerlink\" title=\"SystemServer#startBootstrapServices\"></a>SystemServer#startBootstrapServices</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void startBootstrapServices() &#123;</div><div class=\"line\">    // Wait for installd to finish starting up so that it has a chance to</div><div class=\"line\">    // create critical directories such as /data/user with the appropriate</div><div class=\"line\">    // permissions.  We need this to complete before we initialize other services.</div><div class=\"line\">    Installer installer = mSystemServiceManager.startService(Installer.class);</div><div class=\"line\"></div><div class=\"line\">    // Activity manager runs the show.</div><div class=\"line\">    mActivityManagerService = mSystemServiceManager.startService(</div><div class=\"line\">            ActivityManagerService.Lifecycle.class).getService();</div><div class=\"line\">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</div><div class=\"line\">    mActivityManagerService.setInstaller(installer);</div><div class=\"line\"></div><div class=\"line\">    // Power manager needs to be started early because other services need it.</div><div class=\"line\">    // Native daemons may be watching for it to be registered so it must be ready</div><div class=\"line\">    // to handle incoming binder calls immediately (including being able to verify</div><div class=\"line\">    // the permissions for those calls).</div><div class=\"line\">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</div><div class=\"line\"></div><div class=\"line\">    // Now that the power manager has been started, let the activity manager</div><div class=\"line\">    // initialize power management features.</div><div class=\"line\">    mActivityManagerService.initPowerManagement();</div><div class=\"line\"></div><div class=\"line\">    // Manages LEDs and display backlight so we need it to bring up the display.</div><div class=\"line\">    mSystemServiceManager.startService(LightsService.class);</div><div class=\"line\"></div><div class=\"line\">    // Display manager is needed to provide display metrics before package manager</div><div class=\"line\">    // starts up.</div><div class=\"line\">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</div><div class=\"line\"></div><div class=\"line\">    // We need the default display before we can initialize the package manager.</div><div class=\"line\">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</div><div class=\"line\"></div><div class=\"line\">    // Only run &quot;core&quot; apps if we&apos;re encrypting the device.</div><div class=\"line\">    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</div><div class=\"line\">    if (ENCRYPTING_STATE.equals(cryptState)) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</div><div class=\"line\">        mOnlyCore = true;</div><div class=\"line\">    &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</div><div class=\"line\">        mOnlyCore = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Start the package manager.</div><div class=\"line\">    Slog.i(TAG, &quot;Package Manager&quot;);</div><div class=\"line\">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</div><div class=\"line\">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</div><div class=\"line\">    mFirstBoot = mPackageManagerService.isFirstBoot();</div><div class=\"line\">    mPackageManager = mSystemContext.getPackageManager();</div><div class=\"line\"></div><div class=\"line\">    Slog.i(TAG, &quot;User Service&quot;);</div><div class=\"line\">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</div><div class=\"line\"></div><div class=\"line\">    // Initialize attribute cache used to cache resources from packages.</div><div class=\"line\">    AttributeCache.init(mSystemContext);</div><div class=\"line\"></div><div class=\"line\">    // Set up the Application instance for the system process and get started.</div><div class=\"line\">    mActivityManagerService.setSystemProcess();</div><div class=\"line\"></div><div class=\"line\">    // The sensor service needs access to package manager service, app ops</div><div class=\"line\">    // service, and permissions service, therefore we start it after them.</div><div class=\"line\">    startSensorService();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>启动Installer,用于应用程序安装，卸载，dex优化等等</li>\n<li>启动ActivityManagerService</li>\n<li>启动PowerManagerService</li>\n<li>启动LightsService</li>\n<li>启动DisplayManagerService</li>\n<li>启动PackageManagerService</li>\n<li>启动UserManagerService</li>\n<li>启动传感器服务(native)</li>\n</ul>\n<h3 id=\"SystemServer-startCoreServices\"><a href=\"#SystemServer-startCoreServices\" class=\"headerlink\" title=\"SystemServer#startCoreServices\"></a>SystemServer#startCoreServices</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void startCoreServices() &#123;</div><div class=\"line\">    // Tracks the battery level.  Requires LightService.</div><div class=\"line\">    mSystemServiceManager.startService(BatteryService.class);</div><div class=\"line\"></div><div class=\"line\">    // Tracks application usage stats.</div><div class=\"line\">    mSystemServiceManager.startService(UsageStatsService.class);</div><div class=\"line\">    mActivityManagerService.setUsageStatsManager(</div><div class=\"line\">            LocalServices.getService(UsageStatsManagerInternal.class));</div><div class=\"line\">    // Update after UsageStatsService is available, needed before performBootDexOpt.</div><div class=\"line\">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</div><div class=\"line\"></div><div class=\"line\">    // Tracks whether the updatable WebView is in a ready state and watches for update installs.</div><div class=\"line\">    mSystemServiceManager.startService(WebViewUpdateService.class);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样是启动几个核心的系统服务。</p>\n<h3 id=\"SystemServer-startOtherServices\"><a href=\"#SystemServer-startOtherServices\" class=\"headerlink\" title=\"SystemServer#startOtherServices\"></a>SystemServer#startOtherServices</h3><p>在这个方法中，同样启动了很多服务，不过，这里不仅仅有startService，也有ServiceManager.addService,不过这个是通过binder，像native注册的服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">case IServiceManager.ADD_SERVICE_TRANSACTION: &#123;</div><div class=\"line\">    data.enforceInterface(IServiceManager.descriptor);</div><div class=\"line\">    String name = data.readString();</div><div class=\"line\">    IBinder service = data.readStrongBinder();</div><div class=\"line\">    boolean allowIsolated = data.readInt() != 0;</div><div class=\"line\">    addService(name, service, allowIsolated);</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当启动注册完毕之后，会调用各个服务的systemReady方法。这里就不介绍了。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从上一篇我们知道，在Zygote进程的启动过程中，通过startSystemServer方法，来启动Android中另外一个核心进程SystemServer进程。那么，就来看下SystemServer进程的一些东西。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"ZygoteInit-startSystemServer\"><a href=\"#ZygoteInit-startSystemServer\" class=\"headerlink\" title=\"ZygoteInit#startSystemServer\"></a>ZygoteInit#startSystemServer</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 省去一部分参数代码</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs = null;</div><div class=\"line\"></div><div class=\"line\">        int pid;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            parsedArgs = new ZygoteConnection.Arguments(args);</div><div class=\"line\">            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">            /* Request to fork the system server process */</div><div class=\"line\">            pid = Zygote.forkSystemServer(</div><div class=\"line\">                    parsedArgs.uid, parsedArgs.gid,</div><div class=\"line\">                    parsedArgs.gids,</div><div class=\"line\">                    parsedArgs.debugFlags,</div><div class=\"line\">                    null,</div><div class=\"line\">                    parsedArgs.permittedCapabilities,</div><div class=\"line\">                    parsedArgs.effectiveCapabilities);</div><div class=\"line\">        &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(ex);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /* For child process */</div><div class=\"line\">        if (pid == 0) &#123;</div><div class=\"line\">            if (hasSecondZygote(abiList)) &#123;</div><div class=\"line\">                waitForSecondaryZygote(socketName);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handleSystemServerProcess(parsedArgs);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return true;</div></pre></td></tr></table></figure>\n<ul>\n<li>fork进程(和以前进程启动类似)</li>\n<li>handleSystemServerProcess来处理SystemServer进程</li>\n</ul>\n<h3 id=\"ZygoteInit-handleSystemServerProcess\"><a href=\"#ZygoteInit-handleSystemServerProcess\" class=\"headerlink\" title=\"ZygoteInit#handleSystemServerProcess\"></a>ZygoteInit#handleSystemServerProcess</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void handleSystemServerProcess(</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">    closeServerSocket();</div><div class=\"line\"></div><div class=\"line\">    // set umask to 0077 so new files and directories will default to owner-only permissions.</div><div class=\"line\">    Os.umask(S_IRWXG | S_IRWXO);</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.niceName != null) &#123;</div><div class=\"line\">        Process.setArgV0(parsedArgs.niceName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</div><div class=\"line\">    if (systemServerClasspath != null) &#123;</div><div class=\"line\">        performSystemServerDexOpt(systemServerClasspath);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">        String[] args = parsedArgs.remainingArgs;</div><div class=\"line\">        // If we have a non-null system server class path, we&apos;ll have to duplicate the</div><div class=\"line\">        // existing arguments and append the classpath to it. ART will handle the classpath</div><div class=\"line\">        // correctly when we exec a new process.</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            String[] amendedArgs = new String[args.length + 2];</div><div class=\"line\">            amendedArgs[0] = &quot;-cp&quot;;</div><div class=\"line\">            amendedArgs[1] = systemServerClasspath;</div><div class=\"line\">            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">                VMRuntime.getCurrentInstructionSet(), null, args);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ClassLoader cl = null;</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</div><div class=\"line\">            Thread.currentThread().setContextClassLoader(cl);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * Pass the remaining arguments to SystemServer.</div><div class=\"line\">         */</div><div class=\"line\">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* should never reach here */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过umask设置创建文件的默认权限</li>\n<li>设置进程的nicename</li>\n<li>获取SYSTEMSERVERCLASSPATH环境变量值(一系列jar)，如果需要，进行dex优化</li>\n<li>在这里，invokeWith为null，所以会通过RuntimeInit.zygoteInit去启动</li>\n</ul>\n<p>RuntimeInit.zygoteInit中调用applicationInit，调用invokeStaticMain，然后就会调用SystemServer的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\">    new SystemServer().run();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在SystemServer的构造函数中，获取mFactoryTestMode值，我们的重点在run方法。</p>\n<h3 id=\"SystemServer-run\"><a href=\"#SystemServer-run\" class=\"headerlink\" title=\"SystemServer#run\"></a>SystemServer#run</h3><p>run方法的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void run() &#123;</div><div class=\"line\">    // If a device&apos;s clock is before 1970 (before 0), a lot of</div><div class=\"line\">    // APIs crash dealing with negative numbers, notably</div><div class=\"line\">    // java.io.File#setLastModified, so instead we fake it and</div><div class=\"line\">    // hope that time from cell towers or NTP fixes it shortly.</div><div class=\"line\">    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</div><div class=\"line\">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If the system has &quot;persist.sys.language&quot; and friends set, replace them with</div><div class=\"line\">    // &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated</div><div class=\"line\">    // using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by</div><div class=\"line\">    // AndroidRuntime using the same set of system properties, but only the system_server</div><div class=\"line\">    // and system apps are allowed to set them.</div><div class=\"line\">    //</div><div class=\"line\">    // NOTE: Most changes made here will need an equivalent change to</div><div class=\"line\">    // core/jni/AndroidRuntime.cpp</div><div class=\"line\">    if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;</div><div class=\"line\">        final String languageTag = Locale.getDefault().toLanguageTag();</div><div class=\"line\"></div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Here we go!</div><div class=\"line\">    Slog.i(TAG, &quot;Entered the Android system server!&quot;);</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());</div><div class=\"line\"></div><div class=\"line\">    // In case the runtime switched since last boot (such as when</div><div class=\"line\">    // the old runtime was removed in an OTA), set the system</div><div class=\"line\">    // property so that it is in sync. We can&apos;t do this in</div><div class=\"line\">    // libnativehelper&apos;s JniInvocation::Init code where we already</div><div class=\"line\">    // had to fallback to a different runtime because it is</div><div class=\"line\">    // running as root and we need to be the system user to set</div><div class=\"line\">    // the property. http://b/11463182</div><div class=\"line\">    SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());</div><div class=\"line\"></div><div class=\"line\">    // Enable the sampling profiler.</div><div class=\"line\">    if (SamplingProfilerIntegration.isEnabled()) &#123;</div><div class=\"line\">        SamplingProfilerIntegration.start();</div><div class=\"line\">        mProfilerSnapshotTimer = new Timer();</div><div class=\"line\">        mProfilerSnapshotTimer.schedule(new TimerTask() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Mmmmmm... more memory!</div><div class=\"line\">    VMRuntime.getRuntime().clearGrowthLimit();</div><div class=\"line\"></div><div class=\"line\">    // The system server has to run all of the time, so it needs to be</div><div class=\"line\">    // as efficient as possible with its memory usage.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);</div><div class=\"line\"></div><div class=\"line\">    // Some devices rely on runtime fingerprint generation, so make sure</div><div class=\"line\">    // we&apos;ve defined it before booting further.</div><div class=\"line\">    Build.ensureFingerprintProperty();</div><div class=\"line\"></div><div class=\"line\">    // Within the system server, it is an error to access Environment paths without</div><div class=\"line\">    // explicitly specifying a user.</div><div class=\"line\">    Environment.setUserRequired(true);</div><div class=\"line\"></div><div class=\"line\">    // Ensure binder calls into the system always run at foreground priority.</div><div class=\"line\">    BinderInternal.disableBackgroundScheduling(true);</div><div class=\"line\"></div><div class=\"line\">    // Prepare the main looper thread (this thread).</div><div class=\"line\">    android.os.Process.setThreadPriority(</div><div class=\"line\">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</div><div class=\"line\">    android.os.Process.setCanSelfBackground(false);</div><div class=\"line\">    Looper.prepareMainLooper();</div><div class=\"line\"></div><div class=\"line\">    // Initialize native services.</div><div class=\"line\">    System.loadLibrary(&quot;android_servers&quot;);</div><div class=\"line\"></div><div class=\"line\">    // Check whether we failed to shut down last time we tried.</div><div class=\"line\">    // This call may not return.</div><div class=\"line\">    performPendingShutdown();</div><div class=\"line\"></div><div class=\"line\">    // Initialize the system context.</div><div class=\"line\">    createSystemContext();</div><div class=\"line\"></div><div class=\"line\">    // Create the system service manager.</div><div class=\"line\">    mSystemServiceManager = new SystemServiceManager(mSystemContext);</div><div class=\"line\">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</div><div class=\"line\"></div><div class=\"line\">    // Start services.</div><div class=\"line\">    try &#123;</div><div class=\"line\">        startBootstrapServices();</div><div class=\"line\">        startCoreServices();</div><div class=\"line\">        startOtherServices();</div><div class=\"line\">    &#125; catch (Throwable ex) &#123;</div><div class=\"line\">        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</div><div class=\"line\">        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // For debug builds, log event loop stalls to dropbox for analysis.</div><div class=\"line\">    if (StrictMode.conditionallyEnableDebugLogging()) &#123;</div><div class=\"line\">        Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Loop forever.</div><div class=\"line\">    Looper.loop();</div><div class=\"line\">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要干了这些事：</p>\n<ul>\n<li>校验时间是否合法(1970)</li>\n<li>设置语言</li>\n<li>设置虚拟机库文件</li>\n<li>如果允许抽样分析器，则开启SamplingProfilerIntegration(抽样分析器)</li>\n<li>clearGrowthLimit 清除内存增长上限</li>\n<li>设置内存使用率，setTargetHeapUtilization</li>\n<li>加载android_servers库</li>\n<li>创建上下文，创建SystemServiceManager，添加到LocalServices</li>\n<li>startBootstrapServices 启动引导服务</li>\n<li>startCoreServices 启动核心服务</li>\n<li>startOtherServices 启动其他服务</li>\n</ul>\n<p>最后的启动服务 是核心，我们分别来看下。</p>\n<h3 id=\"SystemServer-startBootstrapServices\"><a href=\"#SystemServer-startBootstrapServices\" class=\"headerlink\" title=\"SystemServer#startBootstrapServices\"></a>SystemServer#startBootstrapServices</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void startBootstrapServices() &#123;</div><div class=\"line\">    // Wait for installd to finish starting up so that it has a chance to</div><div class=\"line\">    // create critical directories such as /data/user with the appropriate</div><div class=\"line\">    // permissions.  We need this to complete before we initialize other services.</div><div class=\"line\">    Installer installer = mSystemServiceManager.startService(Installer.class);</div><div class=\"line\"></div><div class=\"line\">    // Activity manager runs the show.</div><div class=\"line\">    mActivityManagerService = mSystemServiceManager.startService(</div><div class=\"line\">            ActivityManagerService.Lifecycle.class).getService();</div><div class=\"line\">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</div><div class=\"line\">    mActivityManagerService.setInstaller(installer);</div><div class=\"line\"></div><div class=\"line\">    // Power manager needs to be started early because other services need it.</div><div class=\"line\">    // Native daemons may be watching for it to be registered so it must be ready</div><div class=\"line\">    // to handle incoming binder calls immediately (including being able to verify</div><div class=\"line\">    // the permissions for those calls).</div><div class=\"line\">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</div><div class=\"line\"></div><div class=\"line\">    // Now that the power manager has been started, let the activity manager</div><div class=\"line\">    // initialize power management features.</div><div class=\"line\">    mActivityManagerService.initPowerManagement();</div><div class=\"line\"></div><div class=\"line\">    // Manages LEDs and display backlight so we need it to bring up the display.</div><div class=\"line\">    mSystemServiceManager.startService(LightsService.class);</div><div class=\"line\"></div><div class=\"line\">    // Display manager is needed to provide display metrics before package manager</div><div class=\"line\">    // starts up.</div><div class=\"line\">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</div><div class=\"line\"></div><div class=\"line\">    // We need the default display before we can initialize the package manager.</div><div class=\"line\">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</div><div class=\"line\"></div><div class=\"line\">    // Only run &quot;core&quot; apps if we&apos;re encrypting the device.</div><div class=\"line\">    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</div><div class=\"line\">    if (ENCRYPTING_STATE.equals(cryptState)) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</div><div class=\"line\">        mOnlyCore = true;</div><div class=\"line\">    &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</div><div class=\"line\">        mOnlyCore = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Start the package manager.</div><div class=\"line\">    Slog.i(TAG, &quot;Package Manager&quot;);</div><div class=\"line\">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</div><div class=\"line\">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</div><div class=\"line\">    mFirstBoot = mPackageManagerService.isFirstBoot();</div><div class=\"line\">    mPackageManager = mSystemContext.getPackageManager();</div><div class=\"line\"></div><div class=\"line\">    Slog.i(TAG, &quot;User Service&quot;);</div><div class=\"line\">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</div><div class=\"line\"></div><div class=\"line\">    // Initialize attribute cache used to cache resources from packages.</div><div class=\"line\">    AttributeCache.init(mSystemContext);</div><div class=\"line\"></div><div class=\"line\">    // Set up the Application instance for the system process and get started.</div><div class=\"line\">    mActivityManagerService.setSystemProcess();</div><div class=\"line\"></div><div class=\"line\">    // The sensor service needs access to package manager service, app ops</div><div class=\"line\">    // service, and permissions service, therefore we start it after them.</div><div class=\"line\">    startSensorService();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>启动Installer,用于应用程序安装，卸载，dex优化等等</li>\n<li>启动ActivityManagerService</li>\n<li>启动PowerManagerService</li>\n<li>启动LightsService</li>\n<li>启动DisplayManagerService</li>\n<li>启动PackageManagerService</li>\n<li>启动UserManagerService</li>\n<li>启动传感器服务(native)</li>\n</ul>\n<h3 id=\"SystemServer-startCoreServices\"><a href=\"#SystemServer-startCoreServices\" class=\"headerlink\" title=\"SystemServer#startCoreServices\"></a>SystemServer#startCoreServices</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void startCoreServices() &#123;</div><div class=\"line\">    // Tracks the battery level.  Requires LightService.</div><div class=\"line\">    mSystemServiceManager.startService(BatteryService.class);</div><div class=\"line\"></div><div class=\"line\">    // Tracks application usage stats.</div><div class=\"line\">    mSystemServiceManager.startService(UsageStatsService.class);</div><div class=\"line\">    mActivityManagerService.setUsageStatsManager(</div><div class=\"line\">            LocalServices.getService(UsageStatsManagerInternal.class));</div><div class=\"line\">    // Update after UsageStatsService is available, needed before performBootDexOpt.</div><div class=\"line\">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</div><div class=\"line\"></div><div class=\"line\">    // Tracks whether the updatable WebView is in a ready state and watches for update installs.</div><div class=\"line\">    mSystemServiceManager.startService(WebViewUpdateService.class);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样是启动几个核心的系统服务。</p>\n<h3 id=\"SystemServer-startOtherServices\"><a href=\"#SystemServer-startOtherServices\" class=\"headerlink\" title=\"SystemServer#startOtherServices\"></a>SystemServer#startOtherServices</h3><p>在这个方法中，同样启动了很多服务，不过，这里不仅仅有startService，也有ServiceManager.addService,不过这个是通过binder，像native注册的服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">case IServiceManager.ADD_SERVICE_TRANSACTION: &#123;</div><div class=\"line\">    data.enforceInterface(IServiceManager.descriptor);</div><div class=\"line\">    String name = data.readString();</div><div class=\"line\">    IBinder service = data.readStrongBinder();</div><div class=\"line\">    boolean allowIsolated = data.readInt() != 0;</div><div class=\"line\">    addService(name, service, allowIsolated);</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当启动注册完毕之后，会调用各个服务的systemReady方法。这里就不介绍了。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"ThreadLocal源码浅析","date":"2017-01-13T14:24:36.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\nThreadLocal是用来实现本地线程存储的，就是每个线程都有自己的值。java和android sdk中的这个类实现有点小差别，这篇文章以android sdk中的ThreadLocal源码来解析，看看是如何实现的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 设置值-set方法\n\n```\n    public void set(T value) {\n        Thread currentThread = Thread.currentThread();\n        Values values = values(currentThread);\n        if (values == null) {\n            values = initializeValues(currentThread);\n        }\n        values.put(this, value);\n    }\n```\n\nset值的方法很简单，首先是获取当前线程对象，然后，通过values方法获取当前线程的localValues对象，这是一个Values对象，在ThreadLocal中起着很很重要的作用。如果为null的话，用initializeValues为当前线程初始化一个Values对象。最后，将值put进去。\n\n#### Values的初始化\n\n在initializeValues方法中，只是初始化一个Values对象\n\n```\n    Values initializeValues(Thread current) {\n        return current.localValues = new Values();\n    }\n```\n\n我们看下Values的无参构造函数的实现。\n\n```\n        Values() {\n            initializeTable(INITIAL_SIZE);\n            this.size = 0;\n            this.tombstones = 0;\n        }\n\n```\n\n* initializeTable 初始化一个容量为INITIAL_SIZE(16)*2的Object数组\n* 设置存活对象数目size 为0\n* 设置死亡对象数目size 为0\n\n在看看initializeTable做了下啥\n\n```\n        private void initializeTable(int capacity) {\n            this.table = new Object[capacity * 2];\n            this.mask = table.length - 1;\n            this.clean = 0;\n            this.maximumLoad = capacity * 2 / 3; // 2/3\n        }\n\n```\n\n* 初始化一个容量为16*2的对象数组，为什么要这样呢？因为这里没有使用map的结构来保存key，value，要是用数组保存key，value，容量当然得为value的2倍。而这里是用数组的结构，我想是因为访问和修改的速度快的原因吧。\n* mark 用于散列索引,15\n* clean 指向下一个将要清除的位置，这里指向最后一个元素\n* maximumLoad 存活和死亡对象的最大数(用于扩容)，设置为容量的2/3\n\n#### 存储到values中\n\n```\n        void put(ThreadLocal<?> key, Object value) {\n            cleanUp();\n\n            // Keep track of first tombstone. That's where we want to go back\n            // and add an entry if necessary.\n            int firstTombstone = -1;\n\n            for (int index = key.hash & mask;; index = next(index)) {\n                Object k = table[index];\n\n                if (k == key.reference) {\n                    // Replace existing entry.\n                    table[index + 1] = value;\n                    return;\n                }\n\n                if (k == null) {\n                    if (firstTombstone == -1) {\n                        // Fill in null slot.\n                        table[index] = key.reference;\n                        table[index + 1] = value;\n                        size++;\n                        return;\n                    }\n\n                    // Go back and replace first tombstone.\n                    table[firstTombstone] = key.reference;\n                    table[firstTombstone + 1] = value;\n                    tombstones--;\n                    size++;\n                    return;\n                }\n\n                // Remember first tombstone.\n                if (firstTombstone == -1 && k == TOMBSTONE) {\n                    firstTombstone = index;\n                }\n            }\n        }\n```\n\n* 清理垃圾回收后的线程本地变量\n* firstTombstones为－1，用于追踪第一个死亡对象。\n* 循环，index值为threadlocal的hash变量和mask变量的&，hash值对应为0，mask，当我们初始化的时候设置为15，也就是1111，两个&之后为0，而next操作，我们这里可以看出是index+2\n* index处对应的就为key值，\n\t* 如果key.reference和k等，则将value存放于index+1处，替换已经存放的\n\t* 如果k为null，说明没放过\n\t\t* 如果firstTombstone为-1， 则index处放key.reference，index+1处放value\n\t\t* 如果不是，则将key和对应的value放在firstTombstone,firstTombstone+1处。\n\t* 不等于\tkey.reference，也不等于null，(threadlocal被gc回收了。)\n\t\t* firstTombstone 设置为index\n\n\nput的操作还是有点复杂的，要考虑到gc回收的问题。\n\n### 获取值-get方法\n\n```\n    public T get() {\n        // Optimized for the fast path.\n        Thread currentThread = Thread.currentThread();\n        Values values = values(currentThread);\n        if (values != null) {\n            Object[] table = values.table;\n            int index = hash & values.mask;\n            if (this.reference == table[index]) {\n                return (T) table[index + 1];\n            }\n        } else {\n            values = initializeValues(currentThread);\n        }\n\n        return (T) values.getAfterMiss(this);\n    }\n```\n\n在知道上面存在gc回收之后，这里就比较好理解了,gc回收之后，会吧index处的key，设置为TOMBSTONE对象。\n\n* 如果index处的值是this.reference,也就是没被gc回收，那么就是index+1处的值\n* 否则，getAfterMiss返回,这个函数后面会说到\n\n### gc带来的影响及处理\n\n因为key的reference变量是个WeakReference，因此，要考虑到gc的影响。\n\n```\n    private final Reference<ThreadLocal<T>> reference\n            = new WeakReference<ThreadLocal<T>>(this);\n```\n\n关于java中的四种引用类型及其gc，这里不说了。\n\n#### 清理过程\n\n清理过程有cleanUp来完成。\n\n```\n        private void cleanUp() {\n            if (rehash()) {\n                // If we rehashed, we needn't clean up (clean up happens as\n                // a side effect).\n                return;\n            }\n\n            if (size == 0) {\n                // No live entries == nothing to clean.\n                return;\n            }\n\n            // Clean log(table.length) entries picking up where we left off\n            // last time.\n            int index = clean;\n            Object[] table = this.table;\n            for (int counter = table.length; counter > 0; counter >>= 1,\n                    index = next(index)) {\n                Object k = table[index];\n\n                if (k == TOMBSTONE || k == null) {\n                    continue; // on to next entry\n                }\n\n                // The table can only contain null, tombstones and references.\n                @SuppressWarnings(\"unchecked\")\n                Reference<ThreadLocal<?>> reference\n                        = (Reference<ThreadLocal<?>>) k;\n                if (reference.get() == null) {\n                    // This thread local was reclaimed by the garbage collector.\n                    table[index] = TOMBSTONE;\n                    table[index + 1] = null;\n                    tombstones++;\n                    size--;\n                }\n            }\n\n            // Point cursor to next index.\n            clean = index;\n        }\n```\n\n\n* rehash返回true，或者live size为0，直接返回\n* clean的初始值为0\n* 不断从数组中取出key值，并判断是否被回收，如果被回收，则将key，设置为TOMBSTONE，value置null\n\n这个过程就是将gc回收掉的key对应的value回收。\n\n\n#### rehash过程-调整\n\n```\n        private boolean rehash() {\n            if (tombstones + size < maximumLoad) {\n                return false;\n            }\n\n            int capacity = table.length >> 1;\n\n            // Default to the same capacity. This will create a table of the\n            // same size and move over the live entries, analogous to a\n            // garbage collection. This should only happen if you churn a\n            // bunch of thread local garbage (removing and reinserting\n            // the same thread locals over and over will overwrite tombstones\n            // and not fill up the table).\n            int newCapacity = capacity;\n\n            if (size > (capacity >> 1)) {\n                // More than 1/2 filled w/ live entries.\n                // Double size.\n                newCapacity = capacity * 2;\n            }\n\n            Object[] oldTable = this.table;\n\n            // Allocate new table.\n            initializeTable(newCapacity);\n\n            // We won't have any tombstones after this.\n            this.tombstones = 0;\n\n            // If we have no live entries, we can quit here.\n            if (size == 0) {\n                return true;\n            }\n\n            // Move over entries.\n            for (int i = oldTable.length - 2; i >= 0; i -= 2) {\n                Object k = oldTable[i];\n                if (k == null || k == TOMBSTONE) {\n                    // Skip this entry.\n                    continue;\n                }\n\n                // The table can only contain null, tombstones and references.\n                @SuppressWarnings(\"unchecked\")\n                Reference<ThreadLocal<?>> reference\n                        = (Reference<ThreadLocal<?>>) k;\n                ThreadLocal<?> key = reference.get();\n                if (key != null) {\n                    // Entry is still live. Move it over.\n                    add(key, oldTable[i + 1]);\n                } else {\n                    // The key was reclaimed.\n                    size--;\n                }\n            }\n\n            return true;\n        }\n```\n\n* 如果死亡对象+存活对象达不到maximumLoad(阀值),不需要进行调整\n* 计算出值的容量(length/2)\n* 新容量仍然和旧容量一样，这是一种乐观的做法，当存活对象大于value容量/2时，才需要进行扩展\n* 申请新的数组，将旧值中没被gc的活对象添加进去。\n\n\n\n#### getAfterMiss过程\n\n在第一个槽位(index)处没发现合适值的时候，会调用这个方法返回一个。\n\n```\n        Object getAfterMiss(ThreadLocal<?> key) {\n            Object[] table = this.table;\n            int index = key.hash & mask;\n\n            // If the first slot is empty, the search is over.\n            if (table[index] == null) {\n                Object value = key.initialValue();\n\n                // If the table is still the same and the slot is still empty...\n                if (this.table == table && table[index] == null) {\n                    table[index] = key.reference;\n                    table[index + 1] = value;\n                    size++;\n\n                    cleanUp();\n                    return value;\n                }\n\n                // The table changed during initialValue().\n                put(key, value);\n                return value;\n            }\n\n            // Keep track of first tombstone. That's where we want to go back\n            // and add an entry if necessary.\n            int firstTombstone = -1;\n\n            // Continue search.\n            for (index = next(index);; index = next(index)) {\n                Object reference = table[index];\n                if (reference == key.reference) {\n                    return table[index + 1];\n                }\n\n                // If no entry was found...\n                if (reference == null) {\n                    Object value = key.initialValue();\n\n                    // If the table is still the same...\n                    if (this.table == table) {\n                        // If we passed a tombstone and that slot still\n                        // contains a tombstone...\n                        if (firstTombstone > -1\n                                && table[firstTombstone] == TOMBSTONE) {\n                            table[firstTombstone] = key.reference;\n                            table[firstTombstone + 1] = value;\n                            tombstones--;\n                            size++;\n\n                            // No need to clean up here. We aren't filling\n                            // in a null slot.\n                            return value;\n                        }\n\n                        // If this slot is still empty...\n                        if (table[index] == null) {\n                            table[index] = key.reference;\n                            table[index + 1] = value;\n                            size++;\n\n                            cleanUp();\n                            return value;\n                        }\n                    }\n\n                    // The table changed during initialValue().\n                    put(key, value);\n                    return value;\n                }\n\n                if (firstTombstone == -1 && reference == TOMBSTONE) {\n                    // Keep track of this tombstone so we can overwrite it.\n                    firstTombstone = index;\n                }\n            }\n        }\n```\n\n方法较长，逻辑如下：\n\n* 第一个槽位index处key为null，生成一个value，\n\t* 如果生成value的过程成数组没变，index处插入key，index+1处插入value，清理无用\n\t* 过程中，数组改变了.将value put进去 \n* 循环处理\n\t* 数组中的key和传入的key.reference相等，返回数组index+1处的值\n\t* 数组中的key为null，初始化一个value \n\t\t* 数组无变化，firstTombstone>-1,切firstTombstone为无效对象(TOMBSTONE)，修改firstTombstone为key，firstTombstone+1处为value，如果index处为null，加入到index处\n\n\t\t* 省略\n\t\t\n### 总结\n\n能看到，ThreadLocal的实现并不是想象中的那么简单。其中有一些问题我也没想明白，需要解析来思考下。\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/ThreadLocal源码浅析.md","raw":"---\ntitle: ThreadLocal源码浅析\ndate: 2017-01-13 22:24:36\ntags: 源码\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\nThreadLocal是用来实现本地线程存储的，就是每个线程都有自己的值。java和android sdk中的这个类实现有点小差别，这篇文章以android sdk中的ThreadLocal源码来解析，看看是如何实现的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 设置值-set方法\n\n```\n    public void set(T value) {\n        Thread currentThread = Thread.currentThread();\n        Values values = values(currentThread);\n        if (values == null) {\n            values = initializeValues(currentThread);\n        }\n        values.put(this, value);\n    }\n```\n\nset值的方法很简单，首先是获取当前线程对象，然后，通过values方法获取当前线程的localValues对象，这是一个Values对象，在ThreadLocal中起着很很重要的作用。如果为null的话，用initializeValues为当前线程初始化一个Values对象。最后，将值put进去。\n\n#### Values的初始化\n\n在initializeValues方法中，只是初始化一个Values对象\n\n```\n    Values initializeValues(Thread current) {\n        return current.localValues = new Values();\n    }\n```\n\n我们看下Values的无参构造函数的实现。\n\n```\n        Values() {\n            initializeTable(INITIAL_SIZE);\n            this.size = 0;\n            this.tombstones = 0;\n        }\n\n```\n\n* initializeTable 初始化一个容量为INITIAL_SIZE(16)*2的Object数组\n* 设置存活对象数目size 为0\n* 设置死亡对象数目size 为0\n\n在看看initializeTable做了下啥\n\n```\n        private void initializeTable(int capacity) {\n            this.table = new Object[capacity * 2];\n            this.mask = table.length - 1;\n            this.clean = 0;\n            this.maximumLoad = capacity * 2 / 3; // 2/3\n        }\n\n```\n\n* 初始化一个容量为16*2的对象数组，为什么要这样呢？因为这里没有使用map的结构来保存key，value，要是用数组保存key，value，容量当然得为value的2倍。而这里是用数组的结构，我想是因为访问和修改的速度快的原因吧。\n* mark 用于散列索引,15\n* clean 指向下一个将要清除的位置，这里指向最后一个元素\n* maximumLoad 存活和死亡对象的最大数(用于扩容)，设置为容量的2/3\n\n#### 存储到values中\n\n```\n        void put(ThreadLocal<?> key, Object value) {\n            cleanUp();\n\n            // Keep track of first tombstone. That's where we want to go back\n            // and add an entry if necessary.\n            int firstTombstone = -1;\n\n            for (int index = key.hash & mask;; index = next(index)) {\n                Object k = table[index];\n\n                if (k == key.reference) {\n                    // Replace existing entry.\n                    table[index + 1] = value;\n                    return;\n                }\n\n                if (k == null) {\n                    if (firstTombstone == -1) {\n                        // Fill in null slot.\n                        table[index] = key.reference;\n                        table[index + 1] = value;\n                        size++;\n                        return;\n                    }\n\n                    // Go back and replace first tombstone.\n                    table[firstTombstone] = key.reference;\n                    table[firstTombstone + 1] = value;\n                    tombstones--;\n                    size++;\n                    return;\n                }\n\n                // Remember first tombstone.\n                if (firstTombstone == -1 && k == TOMBSTONE) {\n                    firstTombstone = index;\n                }\n            }\n        }\n```\n\n* 清理垃圾回收后的线程本地变量\n* firstTombstones为－1，用于追踪第一个死亡对象。\n* 循环，index值为threadlocal的hash变量和mask变量的&，hash值对应为0，mask，当我们初始化的时候设置为15，也就是1111，两个&之后为0，而next操作，我们这里可以看出是index+2\n* index处对应的就为key值，\n\t* 如果key.reference和k等，则将value存放于index+1处，替换已经存放的\n\t* 如果k为null，说明没放过\n\t\t* 如果firstTombstone为-1， 则index处放key.reference，index+1处放value\n\t\t* 如果不是，则将key和对应的value放在firstTombstone,firstTombstone+1处。\n\t* 不等于\tkey.reference，也不等于null，(threadlocal被gc回收了。)\n\t\t* firstTombstone 设置为index\n\n\nput的操作还是有点复杂的，要考虑到gc回收的问题。\n\n### 获取值-get方法\n\n```\n    public T get() {\n        // Optimized for the fast path.\n        Thread currentThread = Thread.currentThread();\n        Values values = values(currentThread);\n        if (values != null) {\n            Object[] table = values.table;\n            int index = hash & values.mask;\n            if (this.reference == table[index]) {\n                return (T) table[index + 1];\n            }\n        } else {\n            values = initializeValues(currentThread);\n        }\n\n        return (T) values.getAfterMiss(this);\n    }\n```\n\n在知道上面存在gc回收之后，这里就比较好理解了,gc回收之后，会吧index处的key，设置为TOMBSTONE对象。\n\n* 如果index处的值是this.reference,也就是没被gc回收，那么就是index+1处的值\n* 否则，getAfterMiss返回,这个函数后面会说到\n\n### gc带来的影响及处理\n\n因为key的reference变量是个WeakReference，因此，要考虑到gc的影响。\n\n```\n    private final Reference<ThreadLocal<T>> reference\n            = new WeakReference<ThreadLocal<T>>(this);\n```\n\n关于java中的四种引用类型及其gc，这里不说了。\n\n#### 清理过程\n\n清理过程有cleanUp来完成。\n\n```\n        private void cleanUp() {\n            if (rehash()) {\n                // If we rehashed, we needn't clean up (clean up happens as\n                // a side effect).\n                return;\n            }\n\n            if (size == 0) {\n                // No live entries == nothing to clean.\n                return;\n            }\n\n            // Clean log(table.length) entries picking up where we left off\n            // last time.\n            int index = clean;\n            Object[] table = this.table;\n            for (int counter = table.length; counter > 0; counter >>= 1,\n                    index = next(index)) {\n                Object k = table[index];\n\n                if (k == TOMBSTONE || k == null) {\n                    continue; // on to next entry\n                }\n\n                // The table can only contain null, tombstones and references.\n                @SuppressWarnings(\"unchecked\")\n                Reference<ThreadLocal<?>> reference\n                        = (Reference<ThreadLocal<?>>) k;\n                if (reference.get() == null) {\n                    // This thread local was reclaimed by the garbage collector.\n                    table[index] = TOMBSTONE;\n                    table[index + 1] = null;\n                    tombstones++;\n                    size--;\n                }\n            }\n\n            // Point cursor to next index.\n            clean = index;\n        }\n```\n\n\n* rehash返回true，或者live size为0，直接返回\n* clean的初始值为0\n* 不断从数组中取出key值，并判断是否被回收，如果被回收，则将key，设置为TOMBSTONE，value置null\n\n这个过程就是将gc回收掉的key对应的value回收。\n\n\n#### rehash过程-调整\n\n```\n        private boolean rehash() {\n            if (tombstones + size < maximumLoad) {\n                return false;\n            }\n\n            int capacity = table.length >> 1;\n\n            // Default to the same capacity. This will create a table of the\n            // same size and move over the live entries, analogous to a\n            // garbage collection. This should only happen if you churn a\n            // bunch of thread local garbage (removing and reinserting\n            // the same thread locals over and over will overwrite tombstones\n            // and not fill up the table).\n            int newCapacity = capacity;\n\n            if (size > (capacity >> 1)) {\n                // More than 1/2 filled w/ live entries.\n                // Double size.\n                newCapacity = capacity * 2;\n            }\n\n            Object[] oldTable = this.table;\n\n            // Allocate new table.\n            initializeTable(newCapacity);\n\n            // We won't have any tombstones after this.\n            this.tombstones = 0;\n\n            // If we have no live entries, we can quit here.\n            if (size == 0) {\n                return true;\n            }\n\n            // Move over entries.\n            for (int i = oldTable.length - 2; i >= 0; i -= 2) {\n                Object k = oldTable[i];\n                if (k == null || k == TOMBSTONE) {\n                    // Skip this entry.\n                    continue;\n                }\n\n                // The table can only contain null, tombstones and references.\n                @SuppressWarnings(\"unchecked\")\n                Reference<ThreadLocal<?>> reference\n                        = (Reference<ThreadLocal<?>>) k;\n                ThreadLocal<?> key = reference.get();\n                if (key != null) {\n                    // Entry is still live. Move it over.\n                    add(key, oldTable[i + 1]);\n                } else {\n                    // The key was reclaimed.\n                    size--;\n                }\n            }\n\n            return true;\n        }\n```\n\n* 如果死亡对象+存活对象达不到maximumLoad(阀值),不需要进行调整\n* 计算出值的容量(length/2)\n* 新容量仍然和旧容量一样，这是一种乐观的做法，当存活对象大于value容量/2时，才需要进行扩展\n* 申请新的数组，将旧值中没被gc的活对象添加进去。\n\n\n\n#### getAfterMiss过程\n\n在第一个槽位(index)处没发现合适值的时候，会调用这个方法返回一个。\n\n```\n        Object getAfterMiss(ThreadLocal<?> key) {\n            Object[] table = this.table;\n            int index = key.hash & mask;\n\n            // If the first slot is empty, the search is over.\n            if (table[index] == null) {\n                Object value = key.initialValue();\n\n                // If the table is still the same and the slot is still empty...\n                if (this.table == table && table[index] == null) {\n                    table[index] = key.reference;\n                    table[index + 1] = value;\n                    size++;\n\n                    cleanUp();\n                    return value;\n                }\n\n                // The table changed during initialValue().\n                put(key, value);\n                return value;\n            }\n\n            // Keep track of first tombstone. That's where we want to go back\n            // and add an entry if necessary.\n            int firstTombstone = -1;\n\n            // Continue search.\n            for (index = next(index);; index = next(index)) {\n                Object reference = table[index];\n                if (reference == key.reference) {\n                    return table[index + 1];\n                }\n\n                // If no entry was found...\n                if (reference == null) {\n                    Object value = key.initialValue();\n\n                    // If the table is still the same...\n                    if (this.table == table) {\n                        // If we passed a tombstone and that slot still\n                        // contains a tombstone...\n                        if (firstTombstone > -1\n                                && table[firstTombstone] == TOMBSTONE) {\n                            table[firstTombstone] = key.reference;\n                            table[firstTombstone + 1] = value;\n                            tombstones--;\n                            size++;\n\n                            // No need to clean up here. We aren't filling\n                            // in a null slot.\n                            return value;\n                        }\n\n                        // If this slot is still empty...\n                        if (table[index] == null) {\n                            table[index] = key.reference;\n                            table[index + 1] = value;\n                            size++;\n\n                            cleanUp();\n                            return value;\n                        }\n                    }\n\n                    // The table changed during initialValue().\n                    put(key, value);\n                    return value;\n                }\n\n                if (firstTombstone == -1 && reference == TOMBSTONE) {\n                    // Keep track of this tombstone so we can overwrite it.\n                    firstTombstone = index;\n                }\n            }\n        }\n```\n\n方法较长，逻辑如下：\n\n* 第一个槽位index处key为null，生成一个value，\n\t* 如果生成value的过程成数组没变，index处插入key，index+1处插入value，清理无用\n\t* 过程中，数组改变了.将value put进去 \n* 循环处理\n\t* 数组中的key和传入的key.reference相等，返回数组index+1处的值\n\t* 数组中的key为null，初始化一个value \n\t\t* 数组无变化，firstTombstone>-1,切firstTombstone为无效对象(TOMBSTONE)，修改firstTombstone为key，firstTombstone+1处为value，如果index处为null，加入到index处\n\n\t\t* 省略\n\t\t\n### 总结\n\n能看到，ThreadLocal的实现并不是想象中的那么简单。其中有一些问题我也没想明白，需要解析来思考下。\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"ThreadLocal源码浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsly8002419fyjhkzzulj","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>ThreadLocal是用来实现本地线程存储的，就是每个线程都有自己的值。java和android sdk中的这个类实现有点小差别，这篇文章以android sdk中的ThreadLocal源码来解析，看看是如何实现的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"设置值-set方法\"><a href=\"#设置值-set方法\" class=\"headerlink\" title=\"设置值-set方法\"></a>设置值-set方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void set(T value) &#123;</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    Values values = values(currentThread);</div><div class=\"line\">    if (values == null) &#123;</div><div class=\"line\">        values = initializeValues(currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\">    values.put(this, value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>set值的方法很简单，首先是获取当前线程对象，然后，通过values方法获取当前线程的localValues对象，这是一个Values对象，在ThreadLocal中起着很很重要的作用。如果为null的话，用initializeValues为当前线程初始化一个Values对象。最后，将值put进去。</p>\n<h4 id=\"Values的初始化\"><a href=\"#Values的初始化\" class=\"headerlink\" title=\"Values的初始化\"></a>Values的初始化</h4><p>在initializeValues方法中，只是初始化一个Values对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Values initializeValues(Thread current) &#123;</div><div class=\"line\">    return current.localValues = new Values();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看下Values的无参构造函数的实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Values() &#123;</div><div class=\"line\">    initializeTable(INITIAL_SIZE);</div><div class=\"line\">    this.size = 0;</div><div class=\"line\">    this.tombstones = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>initializeTable 初始化一个容量为INITIAL_SIZE(16)*2的Object数组</li>\n<li>设置存活对象数目size 为0</li>\n<li>设置死亡对象数目size 为0</li>\n</ul>\n<p>在看看initializeTable做了下啥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void initializeTable(int capacity) &#123;</div><div class=\"line\">    this.table = new Object[capacity * 2];</div><div class=\"line\">    this.mask = table.length - 1;</div><div class=\"line\">    this.clean = 0;</div><div class=\"line\">    this.maximumLoad = capacity * 2 / 3; // 2/3</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化一个容量为16*2的对象数组，为什么要这样呢？因为这里没有使用map的结构来保存key，value，要是用数组保存key，value，容量当然得为value的2倍。而这里是用数组的结构，我想是因为访问和修改的速度快的原因吧。</li>\n<li>mark 用于散列索引,15</li>\n<li>clean 指向下一个将要清除的位置，这里指向最后一个元素</li>\n<li>maximumLoad 存活和死亡对象的最大数(用于扩容)，设置为容量的2/3</li>\n</ul>\n<h4 id=\"存储到values中\"><a href=\"#存储到values中\" class=\"headerlink\" title=\"存储到values中\"></a>存储到values中</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">void put(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class=\"line\">    cleanUp();</div><div class=\"line\"></div><div class=\"line\">    // Keep track of first tombstone. That&apos;s where we want to go back</div><div class=\"line\">    // and add an entry if necessary.</div><div class=\"line\">    int firstTombstone = -1;</div><div class=\"line\"></div><div class=\"line\">    for (int index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class=\"line\">        Object k = table[index];</div><div class=\"line\"></div><div class=\"line\">        if (k == key.reference) &#123;</div><div class=\"line\">            // Replace existing entry.</div><div class=\"line\">            table[index + 1] = value;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (k == null) &#123;</div><div class=\"line\">            if (firstTombstone == -1) &#123;</div><div class=\"line\">                // Fill in null slot.</div><div class=\"line\">                table[index] = key.reference;</div><div class=\"line\">                table[index + 1] = value;</div><div class=\"line\">                size++;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Go back and replace first tombstone.</div><div class=\"line\">            table[firstTombstone] = key.reference;</div><div class=\"line\">            table[firstTombstone + 1] = value;</div><div class=\"line\">            tombstones--;</div><div class=\"line\">            size++;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Remember first tombstone.</div><div class=\"line\">        if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123;</div><div class=\"line\">            firstTombstone = index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>清理垃圾回收后的线程本地变量</li>\n<li>firstTombstones为－1，用于追踪第一个死亡对象。</li>\n<li>循环，index值为threadlocal的hash变量和mask变量的&amp;，hash值对应为0，mask，当我们初始化的时候设置为15，也就是1111，两个&amp;之后为0，而next操作，我们这里可以看出是index+2</li>\n<li>index处对应的就为key值，<ul>\n<li>如果key.reference和k等，则将value存放于index+1处，替换已经存放的</li>\n<li>如果k为null，说明没放过<ul>\n<li>如果firstTombstone为-1， 则index处放key.reference，index+1处放value</li>\n<li>如果不是，则将key和对应的value放在firstTombstone,firstTombstone+1处。</li>\n</ul>\n</li>\n<li>不等于    key.reference，也不等于null，(threadlocal被gc回收了。)<ul>\n<li>firstTombstone 设置为index</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>put的操作还是有点复杂的，要考虑到gc回收的问题。</p>\n<h3 id=\"获取值-get方法\"><a href=\"#获取值-get方法\" class=\"headerlink\" title=\"获取值-get方法\"></a>获取值-get方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public T get() &#123;</div><div class=\"line\">    // Optimized for the fast path.</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    Values values = values(currentThread);</div><div class=\"line\">    if (values != null) &#123;</div><div class=\"line\">        Object[] table = values.table;</div><div class=\"line\">        int index = hash &amp; values.mask;</div><div class=\"line\">        if (this.reference == table[index]) &#123;</div><div class=\"line\">            return (T) table[index + 1];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        values = initializeValues(currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return (T) values.getAfterMiss(this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在知道上面存在gc回收之后，这里就比较好理解了,gc回收之后，会吧index处的key，设置为TOMBSTONE对象。</p>\n<ul>\n<li>如果index处的值是this.reference,也就是没被gc回收，那么就是index+1处的值</li>\n<li>否则，getAfterMiss返回,这个函数后面会说到</li>\n</ul>\n<h3 id=\"gc带来的影响及处理\"><a href=\"#gc带来的影响及处理\" class=\"headerlink\" title=\"gc带来的影响及处理\"></a>gc带来的影响及处理</h3><p>因为key的reference变量是个WeakReference，因此，要考虑到gc的影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Reference&lt;ThreadLocal&lt;T&gt;&gt; reference</div><div class=\"line\">        = new WeakReference&lt;ThreadLocal&lt;T&gt;&gt;(this);</div></pre></td></tr></table></figure>\n<p>关于java中的四种引用类型及其gc，这里不说了。</p>\n<h4 id=\"清理过程\"><a href=\"#清理过程\" class=\"headerlink\" title=\"清理过程\"></a>清理过程</h4><p>清理过程有cleanUp来完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void cleanUp() &#123;</div><div class=\"line\">    if (rehash()) &#123;</div><div class=\"line\">        // If we rehashed, we needn&apos;t clean up (clean up happens as</div><div class=\"line\">        // a side effect).</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        // No live entries == nothing to clean.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Clean log(table.length) entries picking up where we left off</div><div class=\"line\">    // last time.</div><div class=\"line\">    int index = clean;</div><div class=\"line\">    Object[] table = this.table;</div><div class=\"line\">    for (int counter = table.length; counter &gt; 0; counter &gt;&gt;= 1,</div><div class=\"line\">            index = next(index)) &#123;</div><div class=\"line\">        Object k = table[index];</div><div class=\"line\"></div><div class=\"line\">        if (k == TOMBSTONE || k == null) &#123;</div><div class=\"line\">            continue; // on to next entry</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table can only contain null, tombstones and references.</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class=\"line\">                = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class=\"line\">        if (reference.get() == null) &#123;</div><div class=\"line\">            // This thread local was reclaimed by the garbage collector.</div><div class=\"line\">            table[index] = TOMBSTONE;</div><div class=\"line\">            table[index + 1] = null;</div><div class=\"line\">            tombstones++;</div><div class=\"line\">            size--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Point cursor to next index.</div><div class=\"line\">    clean = index;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>rehash返回true，或者live size为0，直接返回</li>\n<li>clean的初始值为0</li>\n<li>不断从数组中取出key值，并判断是否被回收，如果被回收，则将key，设置为TOMBSTONE，value置null</li>\n</ul>\n<p>这个过程就是将gc回收掉的key对应的value回收。</p>\n<h4 id=\"rehash过程-调整\"><a href=\"#rehash过程-调整\" class=\"headerlink\" title=\"rehash过程-调整\"></a>rehash过程-调整</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean rehash() &#123;</div><div class=\"line\">    if (tombstones + size &lt; maximumLoad) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int capacity = table.length &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">    // Default to the same capacity. This will create a table of the</div><div class=\"line\">    // same size and move over the live entries, analogous to a</div><div class=\"line\">    // garbage collection. This should only happen if you churn a</div><div class=\"line\">    // bunch of thread local garbage (removing and reinserting</div><div class=\"line\">    // the same thread locals over and over will overwrite tombstones</div><div class=\"line\">    // and not fill up the table).</div><div class=\"line\">    int newCapacity = capacity;</div><div class=\"line\"></div><div class=\"line\">    if (size &gt; (capacity &gt;&gt; 1)) &#123;</div><div class=\"line\">        // More than 1/2 filled w/ live entries.</div><div class=\"line\">        // Double size.</div><div class=\"line\">        newCapacity = capacity * 2;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Object[] oldTable = this.table;</div><div class=\"line\"></div><div class=\"line\">    // Allocate new table.</div><div class=\"line\">    initializeTable(newCapacity);</div><div class=\"line\"></div><div class=\"line\">    // We won&apos;t have any tombstones after this.</div><div class=\"line\">    this.tombstones = 0;</div><div class=\"line\"></div><div class=\"line\">    // If we have no live entries, we can quit here.</div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Move over entries.</div><div class=\"line\">    for (int i = oldTable.length - 2; i &gt;= 0; i -= 2) &#123;</div><div class=\"line\">        Object k = oldTable[i];</div><div class=\"line\">        if (k == null || k == TOMBSTONE) &#123;</div><div class=\"line\">            // Skip this entry.</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table can only contain null, tombstones and references.</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class=\"line\">                = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class=\"line\">        ThreadLocal&lt;?&gt; key = reference.get();</div><div class=\"line\">        if (key != null) &#123;</div><div class=\"line\">            // Entry is still live. Move it over.</div><div class=\"line\">            add(key, oldTable[i + 1]);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // The key was reclaimed.</div><div class=\"line\">            size--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果死亡对象+存活对象达不到maximumLoad(阀值),不需要进行调整</li>\n<li>计算出值的容量(length/2)</li>\n<li>新容量仍然和旧容量一样，这是一种乐观的做法，当存活对象大于value容量/2时，才需要进行扩展</li>\n<li>申请新的数组，将旧值中没被gc的活对象添加进去。</li>\n</ul>\n<h4 id=\"getAfterMiss过程\"><a href=\"#getAfterMiss过程\" class=\"headerlink\" title=\"getAfterMiss过程\"></a>getAfterMiss过程</h4><p>在第一个槽位(index)处没发现合适值的时候，会调用这个方法返回一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object getAfterMiss(ThreadLocal&lt;?&gt; key) &#123;</div><div class=\"line\">    Object[] table = this.table;</div><div class=\"line\">    int index = key.hash &amp; mask;</div><div class=\"line\"></div><div class=\"line\">    // If the first slot is empty, the search is over.</div><div class=\"line\">    if (table[index] == null) &#123;</div><div class=\"line\">        Object value = key.initialValue();</div><div class=\"line\"></div><div class=\"line\">        // If the table is still the same and the slot is still empty...</div><div class=\"line\">        if (this.table == table &amp;&amp; table[index] == null) &#123;</div><div class=\"line\">            table[index] = key.reference;</div><div class=\"line\">            table[index + 1] = value;</div><div class=\"line\">            size++;</div><div class=\"line\"></div><div class=\"line\">            cleanUp();</div><div class=\"line\">            return value;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table changed during initialValue().</div><div class=\"line\">        put(key, value);</div><div class=\"line\">        return value;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Keep track of first tombstone. That&apos;s where we want to go back</div><div class=\"line\">    // and add an entry if necessary.</div><div class=\"line\">    int firstTombstone = -1;</div><div class=\"line\"></div><div class=\"line\">    // Continue search.</div><div class=\"line\">    for (index = next(index);; index = next(index)) &#123;</div><div class=\"line\">        Object reference = table[index];</div><div class=\"line\">        if (reference == key.reference) &#123;</div><div class=\"line\">            return table[index + 1];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If no entry was found...</div><div class=\"line\">        if (reference == null) &#123;</div><div class=\"line\">            Object value = key.initialValue();</div><div class=\"line\"></div><div class=\"line\">            // If the table is still the same...</div><div class=\"line\">            if (this.table == table) &#123;</div><div class=\"line\">                // If we passed a tombstone and that slot still</div><div class=\"line\">                // contains a tombstone...</div><div class=\"line\">                if (firstTombstone &gt; -1</div><div class=\"line\">                        &amp;&amp; table[firstTombstone] == TOMBSTONE) &#123;</div><div class=\"line\">                    table[firstTombstone] = key.reference;</div><div class=\"line\">                    table[firstTombstone + 1] = value;</div><div class=\"line\">                    tombstones--;</div><div class=\"line\">                    size++;</div><div class=\"line\"></div><div class=\"line\">                    // No need to clean up here. We aren&apos;t filling</div><div class=\"line\">                    // in a null slot.</div><div class=\"line\">                    return value;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // If this slot is still empty...</div><div class=\"line\">                if (table[index] == null) &#123;</div><div class=\"line\">                    table[index] = key.reference;</div><div class=\"line\">                    table[index + 1] = value;</div><div class=\"line\">                    size++;</div><div class=\"line\"></div><div class=\"line\">                    cleanUp();</div><div class=\"line\">                    return value;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // The table changed during initialValue().</div><div class=\"line\">            put(key, value);</div><div class=\"line\">            return value;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (firstTombstone == -1 &amp;&amp; reference == TOMBSTONE) &#123;</div><div class=\"line\">            // Keep track of this tombstone so we can overwrite it.</div><div class=\"line\">            firstTombstone = index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法较长，逻辑如下：</p>\n<ul>\n<li>第一个槽位index处key为null，生成一个value，<ul>\n<li>如果生成value的过程成数组没变，index处插入key，index+1处插入value，清理无用</li>\n<li>过程中，数组改变了.将value put进去 </li>\n</ul>\n</li>\n<li><p>循环处理</p>\n<ul>\n<li>数组中的key和传入的key.reference相等，返回数组index+1处的值</li>\n<li><p>数组中的key为null，初始化一个value </p>\n<ul>\n<li><p>数组无变化，firstTombstone&gt;-1,切firstTombstone为无效对象(TOMBSTONE)，修改firstTombstone为key，firstTombstone+1处为value，如果index处为null，加入到index处</p>\n</li>\n<li><p>省略</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>能看到，ThreadLocal的实现并不是想象中的那么简单。其中有一些问题我也没想明白，需要解析来思考下。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>ThreadLocal是用来实现本地线程存储的，就是每个线程都有自己的值。java和android sdk中的这个类实现有点小差别，这篇文章以android sdk中的ThreadLocal源码来解析，看看是如何实现的。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"设置值-set方法\"><a href=\"#设置值-set方法\" class=\"headerlink\" title=\"设置值-set方法\"></a>设置值-set方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void set(T value) &#123;</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    Values values = values(currentThread);</div><div class=\"line\">    if (values == null) &#123;</div><div class=\"line\">        values = initializeValues(currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\">    values.put(this, value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>set值的方法很简单，首先是获取当前线程对象，然后，通过values方法获取当前线程的localValues对象，这是一个Values对象，在ThreadLocal中起着很很重要的作用。如果为null的话，用initializeValues为当前线程初始化一个Values对象。最后，将值put进去。</p>\n<h4 id=\"Values的初始化\"><a href=\"#Values的初始化\" class=\"headerlink\" title=\"Values的初始化\"></a>Values的初始化</h4><p>在initializeValues方法中，只是初始化一个Values对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Values initializeValues(Thread current) &#123;</div><div class=\"line\">    return current.localValues = new Values();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看下Values的无参构造函数的实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Values() &#123;</div><div class=\"line\">    initializeTable(INITIAL_SIZE);</div><div class=\"line\">    this.size = 0;</div><div class=\"line\">    this.tombstones = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>initializeTable 初始化一个容量为INITIAL_SIZE(16)*2的Object数组</li>\n<li>设置存活对象数目size 为0</li>\n<li>设置死亡对象数目size 为0</li>\n</ul>\n<p>在看看initializeTable做了下啥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void initializeTable(int capacity) &#123;</div><div class=\"line\">    this.table = new Object[capacity * 2];</div><div class=\"line\">    this.mask = table.length - 1;</div><div class=\"line\">    this.clean = 0;</div><div class=\"line\">    this.maximumLoad = capacity * 2 / 3; // 2/3</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化一个容量为16*2的对象数组，为什么要这样呢？因为这里没有使用map的结构来保存key，value，要是用数组保存key，value，容量当然得为value的2倍。而这里是用数组的结构，我想是因为访问和修改的速度快的原因吧。</li>\n<li>mark 用于散列索引,15</li>\n<li>clean 指向下一个将要清除的位置，这里指向最后一个元素</li>\n<li>maximumLoad 存活和死亡对象的最大数(用于扩容)，设置为容量的2/3</li>\n</ul>\n<h4 id=\"存储到values中\"><a href=\"#存储到values中\" class=\"headerlink\" title=\"存储到values中\"></a>存储到values中</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">void put(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class=\"line\">    cleanUp();</div><div class=\"line\"></div><div class=\"line\">    // Keep track of first tombstone. That&apos;s where we want to go back</div><div class=\"line\">    // and add an entry if necessary.</div><div class=\"line\">    int firstTombstone = -1;</div><div class=\"line\"></div><div class=\"line\">    for (int index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class=\"line\">        Object k = table[index];</div><div class=\"line\"></div><div class=\"line\">        if (k == key.reference) &#123;</div><div class=\"line\">            // Replace existing entry.</div><div class=\"line\">            table[index + 1] = value;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (k == null) &#123;</div><div class=\"line\">            if (firstTombstone == -1) &#123;</div><div class=\"line\">                // Fill in null slot.</div><div class=\"line\">                table[index] = key.reference;</div><div class=\"line\">                table[index + 1] = value;</div><div class=\"line\">                size++;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Go back and replace first tombstone.</div><div class=\"line\">            table[firstTombstone] = key.reference;</div><div class=\"line\">            table[firstTombstone + 1] = value;</div><div class=\"line\">            tombstones--;</div><div class=\"line\">            size++;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Remember first tombstone.</div><div class=\"line\">        if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123;</div><div class=\"line\">            firstTombstone = index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>清理垃圾回收后的线程本地变量</li>\n<li>firstTombstones为－1，用于追踪第一个死亡对象。</li>\n<li>循环，index值为threadlocal的hash变量和mask变量的&amp;，hash值对应为0，mask，当我们初始化的时候设置为15，也就是1111，两个&amp;之后为0，而next操作，我们这里可以看出是index+2</li>\n<li>index处对应的就为key值，<ul>\n<li>如果key.reference和k等，则将value存放于index+1处，替换已经存放的</li>\n<li>如果k为null，说明没放过<ul>\n<li>如果firstTombstone为-1， 则index处放key.reference，index+1处放value</li>\n<li>如果不是，则将key和对应的value放在firstTombstone,firstTombstone+1处。</li>\n</ul>\n</li>\n<li>不等于    key.reference，也不等于null，(threadlocal被gc回收了。)<ul>\n<li>firstTombstone 设置为index</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>put的操作还是有点复杂的，要考虑到gc回收的问题。</p>\n<h3 id=\"获取值-get方法\"><a href=\"#获取值-get方法\" class=\"headerlink\" title=\"获取值-get方法\"></a>获取值-get方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public T get() &#123;</div><div class=\"line\">    // Optimized for the fast path.</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    Values values = values(currentThread);</div><div class=\"line\">    if (values != null) &#123;</div><div class=\"line\">        Object[] table = values.table;</div><div class=\"line\">        int index = hash &amp; values.mask;</div><div class=\"line\">        if (this.reference == table[index]) &#123;</div><div class=\"line\">            return (T) table[index + 1];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        values = initializeValues(currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return (T) values.getAfterMiss(this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在知道上面存在gc回收之后，这里就比较好理解了,gc回收之后，会吧index处的key，设置为TOMBSTONE对象。</p>\n<ul>\n<li>如果index处的值是this.reference,也就是没被gc回收，那么就是index+1处的值</li>\n<li>否则，getAfterMiss返回,这个函数后面会说到</li>\n</ul>\n<h3 id=\"gc带来的影响及处理\"><a href=\"#gc带来的影响及处理\" class=\"headerlink\" title=\"gc带来的影响及处理\"></a>gc带来的影响及处理</h3><p>因为key的reference变量是个WeakReference，因此，要考虑到gc的影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Reference&lt;ThreadLocal&lt;T&gt;&gt; reference</div><div class=\"line\">        = new WeakReference&lt;ThreadLocal&lt;T&gt;&gt;(this);</div></pre></td></tr></table></figure>\n<p>关于java中的四种引用类型及其gc，这里不说了。</p>\n<h4 id=\"清理过程\"><a href=\"#清理过程\" class=\"headerlink\" title=\"清理过程\"></a>清理过程</h4><p>清理过程有cleanUp来完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void cleanUp() &#123;</div><div class=\"line\">    if (rehash()) &#123;</div><div class=\"line\">        // If we rehashed, we needn&apos;t clean up (clean up happens as</div><div class=\"line\">        // a side effect).</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        // No live entries == nothing to clean.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Clean log(table.length) entries picking up where we left off</div><div class=\"line\">    // last time.</div><div class=\"line\">    int index = clean;</div><div class=\"line\">    Object[] table = this.table;</div><div class=\"line\">    for (int counter = table.length; counter &gt; 0; counter &gt;&gt;= 1,</div><div class=\"line\">            index = next(index)) &#123;</div><div class=\"line\">        Object k = table[index];</div><div class=\"line\"></div><div class=\"line\">        if (k == TOMBSTONE || k == null) &#123;</div><div class=\"line\">            continue; // on to next entry</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table can only contain null, tombstones and references.</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class=\"line\">                = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class=\"line\">        if (reference.get() == null) &#123;</div><div class=\"line\">            // This thread local was reclaimed by the garbage collector.</div><div class=\"line\">            table[index] = TOMBSTONE;</div><div class=\"line\">            table[index + 1] = null;</div><div class=\"line\">            tombstones++;</div><div class=\"line\">            size--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Point cursor to next index.</div><div class=\"line\">    clean = index;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>rehash返回true，或者live size为0，直接返回</li>\n<li>clean的初始值为0</li>\n<li>不断从数组中取出key值，并判断是否被回收，如果被回收，则将key，设置为TOMBSTONE，value置null</li>\n</ul>\n<p>这个过程就是将gc回收掉的key对应的value回收。</p>\n<h4 id=\"rehash过程-调整\"><a href=\"#rehash过程-调整\" class=\"headerlink\" title=\"rehash过程-调整\"></a>rehash过程-调整</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean rehash() &#123;</div><div class=\"line\">    if (tombstones + size &lt; maximumLoad) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int capacity = table.length &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">    // Default to the same capacity. This will create a table of the</div><div class=\"line\">    // same size and move over the live entries, analogous to a</div><div class=\"line\">    // garbage collection. This should only happen if you churn a</div><div class=\"line\">    // bunch of thread local garbage (removing and reinserting</div><div class=\"line\">    // the same thread locals over and over will overwrite tombstones</div><div class=\"line\">    // and not fill up the table).</div><div class=\"line\">    int newCapacity = capacity;</div><div class=\"line\"></div><div class=\"line\">    if (size &gt; (capacity &gt;&gt; 1)) &#123;</div><div class=\"line\">        // More than 1/2 filled w/ live entries.</div><div class=\"line\">        // Double size.</div><div class=\"line\">        newCapacity = capacity * 2;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Object[] oldTable = this.table;</div><div class=\"line\"></div><div class=\"line\">    // Allocate new table.</div><div class=\"line\">    initializeTable(newCapacity);</div><div class=\"line\"></div><div class=\"line\">    // We won&apos;t have any tombstones after this.</div><div class=\"line\">    this.tombstones = 0;</div><div class=\"line\"></div><div class=\"line\">    // If we have no live entries, we can quit here.</div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Move over entries.</div><div class=\"line\">    for (int i = oldTable.length - 2; i &gt;= 0; i -= 2) &#123;</div><div class=\"line\">        Object k = oldTable[i];</div><div class=\"line\">        if (k == null || k == TOMBSTONE) &#123;</div><div class=\"line\">            // Skip this entry.</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table can only contain null, tombstones and references.</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class=\"line\">                = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class=\"line\">        ThreadLocal&lt;?&gt; key = reference.get();</div><div class=\"line\">        if (key != null) &#123;</div><div class=\"line\">            // Entry is still live. Move it over.</div><div class=\"line\">            add(key, oldTable[i + 1]);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // The key was reclaimed.</div><div class=\"line\">            size--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果死亡对象+存活对象达不到maximumLoad(阀值),不需要进行调整</li>\n<li>计算出值的容量(length/2)</li>\n<li>新容量仍然和旧容量一样，这是一种乐观的做法，当存活对象大于value容量/2时，才需要进行扩展</li>\n<li>申请新的数组，将旧值中没被gc的活对象添加进去。</li>\n</ul>\n<h4 id=\"getAfterMiss过程\"><a href=\"#getAfterMiss过程\" class=\"headerlink\" title=\"getAfterMiss过程\"></a>getAfterMiss过程</h4><p>在第一个槽位(index)处没发现合适值的时候，会调用这个方法返回一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object getAfterMiss(ThreadLocal&lt;?&gt; key) &#123;</div><div class=\"line\">    Object[] table = this.table;</div><div class=\"line\">    int index = key.hash &amp; mask;</div><div class=\"line\"></div><div class=\"line\">    // If the first slot is empty, the search is over.</div><div class=\"line\">    if (table[index] == null) &#123;</div><div class=\"line\">        Object value = key.initialValue();</div><div class=\"line\"></div><div class=\"line\">        // If the table is still the same and the slot is still empty...</div><div class=\"line\">        if (this.table == table &amp;&amp; table[index] == null) &#123;</div><div class=\"line\">            table[index] = key.reference;</div><div class=\"line\">            table[index + 1] = value;</div><div class=\"line\">            size++;</div><div class=\"line\"></div><div class=\"line\">            cleanUp();</div><div class=\"line\">            return value;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table changed during initialValue().</div><div class=\"line\">        put(key, value);</div><div class=\"line\">        return value;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Keep track of first tombstone. That&apos;s where we want to go back</div><div class=\"line\">    // and add an entry if necessary.</div><div class=\"line\">    int firstTombstone = -1;</div><div class=\"line\"></div><div class=\"line\">    // Continue search.</div><div class=\"line\">    for (index = next(index);; index = next(index)) &#123;</div><div class=\"line\">        Object reference = table[index];</div><div class=\"line\">        if (reference == key.reference) &#123;</div><div class=\"line\">            return table[index + 1];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If no entry was found...</div><div class=\"line\">        if (reference == null) &#123;</div><div class=\"line\">            Object value = key.initialValue();</div><div class=\"line\"></div><div class=\"line\">            // If the table is still the same...</div><div class=\"line\">            if (this.table == table) &#123;</div><div class=\"line\">                // If we passed a tombstone and that slot still</div><div class=\"line\">                // contains a tombstone...</div><div class=\"line\">                if (firstTombstone &gt; -1</div><div class=\"line\">                        &amp;&amp; table[firstTombstone] == TOMBSTONE) &#123;</div><div class=\"line\">                    table[firstTombstone] = key.reference;</div><div class=\"line\">                    table[firstTombstone + 1] = value;</div><div class=\"line\">                    tombstones--;</div><div class=\"line\">                    size++;</div><div class=\"line\"></div><div class=\"line\">                    // No need to clean up here. We aren&apos;t filling</div><div class=\"line\">                    // in a null slot.</div><div class=\"line\">                    return value;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // If this slot is still empty...</div><div class=\"line\">                if (table[index] == null) &#123;</div><div class=\"line\">                    table[index] = key.reference;</div><div class=\"line\">                    table[index + 1] = value;</div><div class=\"line\">                    size++;</div><div class=\"line\"></div><div class=\"line\">                    cleanUp();</div><div class=\"line\">                    return value;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // The table changed during initialValue().</div><div class=\"line\">            put(key, value);</div><div class=\"line\">            return value;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (firstTombstone == -1 &amp;&amp; reference == TOMBSTONE) &#123;</div><div class=\"line\">            // Keep track of this tombstone so we can overwrite it.</div><div class=\"line\">            firstTombstone = index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法较长，逻辑如下：</p>\n<ul>\n<li>第一个槽位index处key为null，生成一个value，<ul>\n<li>如果生成value的过程成数组没变，index处插入key，index+1处插入value，清理无用</li>\n<li>过程中，数组改变了.将value put进去 </li>\n</ul>\n</li>\n<li><p>循环处理</p>\n<ul>\n<li>数组中的key和传入的key.reference相等，返回数组index+1处的值</li>\n<li><p>数组中的key为null，初始化一个value </p>\n<ul>\n<li><p>数组无变化，firstTombstone&gt;-1,切firstTombstone为无效对象(TOMBSTONE)，修改firstTombstone为key，firstTombstone+1处为value，如果index处为null，加入到index处</p>\n</li>\n<li><p>省略</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>能看到，ThreadLocal的实现并不是想象中的那么简单。其中有一些问题我也没想明白，需要解析来思考下。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"ViewModel的一些思考","date":"2018-01-21T13:07:42.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n最近很长一段时间都在使用MVVM,但是遇到一点问题导致代码写不太好。今天就思考下VM层和V层的一些问题。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 几个问题\n\n1. VM和V的通信\n2. 在列表类型的视图中，Activity的ViewModel与Item的ViewModel通信问题\n3. 当多个界面拥有共同控件时，是选择继承还是组合\n4. 同一组件，但是在不同场景下对应的modle层Entity不同\n\n\n下面根据上面的几个问题，做一些思考。\n\n### VM和V的通信\n\n在[Google Sample中](https://github.com/googlesamples/android-architecture)，ViewModel和View层的通信使用Navigator的形式。刚开始，我也模仿着使用Navigator，但是用了一端时间之后，感觉并不是很合适。Navigator在意思上更偏向于导航，跳转这样的场景。那么，应该怎么样使用或者命名呢？想了以下几种：\n\n1. Navigator\n2. EventBus\n3. EventDelegate\n\n事实上，1和3是同一种写法，只不过在命名上有一点差别，EventBus的方法维护起来不方便。\n\n\n\n\n### 父ViewModel和子ViewModel通信的问题\n\n这个是一个很常见的场景，比如说一个Activity的ViewModel中包含的子ViewModel，子ViewModel的变化能影响到父ViewModel，对于这样的场景，通常，我选择在父ViewModel构建子ViewModel的时候，注入一个CallBack接口，利用这个CallBack接口来做。\n\n**补充**\n\n上面的几种方法，不好解决viewmodel嵌套情况下，listener的传递问题，因此，可以使用IOC的思想，参考ViewModelProvider的设计，或者用dagger2去解决这个问题\n\n\n### 多个界面共同组件问题\n\n这也是一个很常见的场景，例如多个页面底部都有个评论框这种，这种业务场景下的话，我们会把评论框部分做成组件。用<include>去引用，这种情况下，我们就要考虑我们是使用组合还是继承了。更推荐继承。\n\n\n### 同一组件，对应不同的Entity\n\n这种场景应该不是特别多，但是还是会有的。那么，这种情况下，我们构建ViewModel的时候，就不能已Entity作为参数了，怎么办呢？我们可以声明一个接口，这个接口中，定义一些列我们这个组件需要的数据的get方法。对应不同的Entity，我们有不同的实现，而我们只需要传给ViewModel我们的实现即可。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/ViewModel的一些思考.md","raw":"---\ntitle: ViewModel的一些思考\ndate: 2018-01-21 21:07:42\ntags: Android\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n最近很长一段时间都在使用MVVM,但是遇到一点问题导致代码写不太好。今天就思考下VM层和V层的一些问题。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 几个问题\n\n1. VM和V的通信\n2. 在列表类型的视图中，Activity的ViewModel与Item的ViewModel通信问题\n3. 当多个界面拥有共同控件时，是选择继承还是组合\n4. 同一组件，但是在不同场景下对应的modle层Entity不同\n\n\n下面根据上面的几个问题，做一些思考。\n\n### VM和V的通信\n\n在[Google Sample中](https://github.com/googlesamples/android-architecture)，ViewModel和View层的通信使用Navigator的形式。刚开始，我也模仿着使用Navigator，但是用了一端时间之后，感觉并不是很合适。Navigator在意思上更偏向于导航，跳转这样的场景。那么，应该怎么样使用或者命名呢？想了以下几种：\n\n1. Navigator\n2. EventBus\n3. EventDelegate\n\n事实上，1和3是同一种写法，只不过在命名上有一点差别，EventBus的方法维护起来不方便。\n\n\n\n\n### 父ViewModel和子ViewModel通信的问题\n\n这个是一个很常见的场景，比如说一个Activity的ViewModel中包含的子ViewModel，子ViewModel的变化能影响到父ViewModel，对于这样的场景，通常，我选择在父ViewModel构建子ViewModel的时候，注入一个CallBack接口，利用这个CallBack接口来做。\n\n**补充**\n\n上面的几种方法，不好解决viewmodel嵌套情况下，listener的传递问题，因此，可以使用IOC的思想，参考ViewModelProvider的设计，或者用dagger2去解决这个问题\n\n\n### 多个界面共同组件问题\n\n这也是一个很常见的场景，例如多个页面底部都有个评论框这种，这种业务场景下的话，我们会把评论框部分做成组件。用<include>去引用，这种情况下，我们就要考虑我们是使用组合还是继承了。更推荐继承。\n\n\n### 同一组件，对应不同的Entity\n\n这种场景应该不是特别多，但是还是会有的。那么，这种情况下，我们构建ViewModel的时候，就不能已Entity作为参数了，怎么办呢？我们可以声明一个接口，这个接口中，定义一些列我们这个组件需要的数据的get方法。对应不同的Entity，我们有不同的实现，而我们只需要传给ViewModel我们的实现即可。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"ViewModel的一些思考","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsly9002719fy2jgq776k","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近很长一段时间都在使用MVVM,但是遇到一点问题导致代码写不太好。今天就思考下VM层和V层的一些问题。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"几个问题\"><a href=\"#几个问题\" class=\"headerlink\" title=\"几个问题\"></a>几个问题</h3><ol>\n<li>VM和V的通信</li>\n<li>在列表类型的视图中，Activity的ViewModel与Item的ViewModel通信问题</li>\n<li>当多个界面拥有共同控件时，是选择继承还是组合</li>\n<li>同一组件，但是在不同场景下对应的modle层Entity不同</li>\n</ol>\n<p>下面根据上面的几个问题，做一些思考。</p>\n<h3 id=\"VM和V的通信\"><a href=\"#VM和V的通信\" class=\"headerlink\" title=\"VM和V的通信\"></a>VM和V的通信</h3><p>在<a href=\"https://github.com/googlesamples/android-architecture\" target=\"_blank\" rel=\"external\">Google Sample中</a>，ViewModel和View层的通信使用Navigator的形式。刚开始，我也模仿着使用Navigator，但是用了一端时间之后，感觉并不是很合适。Navigator在意思上更偏向于导航，跳转这样的场景。那么，应该怎么样使用或者命名呢？想了以下几种：</p>\n<ol>\n<li>Navigator</li>\n<li>EventBus</li>\n<li>EventDelegate</li>\n</ol>\n<p>事实上，1和3是同一种写法，只不过在命名上有一点差别，EventBus的方法维护起来不方便。</p>\n<h3 id=\"父ViewModel和子ViewModel通信的问题\"><a href=\"#父ViewModel和子ViewModel通信的问题\" class=\"headerlink\" title=\"父ViewModel和子ViewModel通信的问题\"></a>父ViewModel和子ViewModel通信的问题</h3><p>这个是一个很常见的场景，比如说一个Activity的ViewModel中包含的子ViewModel，子ViewModel的变化能影响到父ViewModel，对于这样的场景，通常，我选择在父ViewModel构建子ViewModel的时候，注入一个CallBack接口，利用这个CallBack接口来做。</p>\n<p><strong>补充</strong></p>\n<p>上面的几种方法，不好解决viewmodel嵌套情况下，listener的传递问题，因此，可以使用IOC的思想，参考ViewModelProvider的设计，或者用dagger2去解决这个问题</p>\n<h3 id=\"多个界面共同组件问题\"><a href=\"#多个界面共同组件问题\" class=\"headerlink\" title=\"多个界面共同组件问题\"></a>多个界面共同组件问题</h3><p>这也是一个很常见的场景，例如多个页面底部都有个评论框这种，这种业务场景下的话，我们会把评论框部分做成组件。用<include>去引用，这种情况下，我们就要考虑我们是使用组合还是继承了。更推荐继承。</include></p>\n<h3 id=\"同一组件，对应不同的Entity\"><a href=\"#同一组件，对应不同的Entity\" class=\"headerlink\" title=\"同一组件，对应不同的Entity\"></a>同一组件，对应不同的Entity</h3><p>这种场景应该不是特别多，但是还是会有的。那么，这种情况下，我们构建ViewModel的时候，就不能已Entity作为参数了，怎么办呢？我们可以声明一个接口，这个接口中，定义一些列我们这个组件需要的数据的get方法。对应不同的Entity，我们有不同的实现，而我们只需要传给ViewModel我们的实现即可。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近很长一段时间都在使用MVVM,但是遇到一点问题导致代码写不太好。今天就思考下VM层和V层的一些问题。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"几个问题\"><a href=\"#几个问题\" class=\"headerlink\" title=\"几个问题\"></a>几个问题</h3><ol>\n<li>VM和V的通信</li>\n<li>在列表类型的视图中，Activity的ViewModel与Item的ViewModel通信问题</li>\n<li>当多个界面拥有共同控件时，是选择继承还是组合</li>\n<li>同一组件，但是在不同场景下对应的modle层Entity不同</li>\n</ol>\n<p>下面根据上面的几个问题，做一些思考。</p>\n<h3 id=\"VM和V的通信\"><a href=\"#VM和V的通信\" class=\"headerlink\" title=\"VM和V的通信\"></a>VM和V的通信</h3><p>在<a href=\"https://github.com/googlesamples/android-architecture\">Google Sample中</a>，ViewModel和View层的通信使用Navigator的形式。刚开始，我也模仿着使用Navigator，但是用了一端时间之后，感觉并不是很合适。Navigator在意思上更偏向于导航，跳转这样的场景。那么，应该怎么样使用或者命名呢？想了以下几种：</p>\n<ol>\n<li>Navigator</li>\n<li>EventBus</li>\n<li>EventDelegate</li>\n</ol>\n<p>事实上，1和3是同一种写法，只不过在命名上有一点差别，EventBus的方法维护起来不方便。</p>\n<h3 id=\"父ViewModel和子ViewModel通信的问题\"><a href=\"#父ViewModel和子ViewModel通信的问题\" class=\"headerlink\" title=\"父ViewModel和子ViewModel通信的问题\"></a>父ViewModel和子ViewModel通信的问题</h3><p>这个是一个很常见的场景，比如说一个Activity的ViewModel中包含的子ViewModel，子ViewModel的变化能影响到父ViewModel，对于这样的场景，通常，我选择在父ViewModel构建子ViewModel的时候，注入一个CallBack接口，利用这个CallBack接口来做。</p>\n<p><strong>补充</strong></p>\n<p>上面的几种方法，不好解决viewmodel嵌套情况下，listener的传递问题，因此，可以使用IOC的思想，参考ViewModelProvider的设计，或者用dagger2去解决这个问题</p>\n<h3 id=\"多个界面共同组件问题\"><a href=\"#多个界面共同组件问题\" class=\"headerlink\" title=\"多个界面共同组件问题\"></a>多个界面共同组件问题</h3><p>这也是一个很常见的场景，例如多个页面底部都有个评论框这种，这种业务场景下的话，我们会把评论框部分做成组件。用<include>去引用，这种情况下，我们就要考虑我们是使用组合还是继承了。更推荐继承。</p>\n<h3 id=\"同一组件，对应不同的Entity\"><a href=\"#同一组件，对应不同的Entity\" class=\"headerlink\" title=\"同一组件，对应不同的Entity\"></a>同一组件，对应不同的Entity</h3><p>这种场景应该不是特别多，但是还是会有的。那么，这种情况下，我们构建ViewModel的时候，就不能已Entity作为参数了，怎么办呢？我们可以声明一个接口，这个接口中，定义一些列我们这个组件需要的数据的get方法。对应不同的Entity，我们有不同的实现，而我们只需要传给ViewModel我们的实现即可。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Xposed简介以及小米去桌面广告的简单实现","date":"2017-11-18T11:18:02.000Z","_content":"<Excerpt in index | 首页摘要>\n\n提起Xposed，大多数Android开发者都听过或者用过，甚至有一些开发过比较炫酷的模块。这是我前段时间在公司的分享内容，分享给大家。\n\n<!-- more -->\n\n#最先发表于个人博客 https://guolei1130.github.io/\n\n\n### Xposed简介\n\nXposed框架是一款可以在不修改APK的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。项目地址：https://github.com/rovo89 包括以下几个部分：\n\n1. Xposed & android_art ，Xposed framework，核心\n2. XposedBridge java 部分的framework，我们开发模块要用到\n3. XposedInstaller 安装器，用去安装Xposed framework以及管理Xposed 模块\n\n那么，Xposed有什么应用场景么，就目前来说，我们耳熟能详的应用场景就是抢红包了，xposed的应用场景取决于我们的思维和想法。现在比较火的模块如抢红包之类的，消息防撤回、绿色守护、黑狱、小米去广告等等。\n\n\n### 如何使用Xposed\n\n就目前的国内情况来讲，要想用Xposed的话，我个人推荐小米手机。\n\n1. root\n2. 安装Xposed，要找对应手机RAM对应Android版本的Xposed framework，可以去小米论坛上找\n3. 从酷安市场或者Xposed installer里安装自己喜欢的模块，\n4. 勾选，重启生效\n\n### 如何开发自己的Xposed模块\n\n关于开发自己的Xposed模块，在Xposed项目的wiki中，有很详细的介绍，并且开发Xposed模块的话确实比较简单，难点在于找到你想实现功能的切入点，我们这里以去掉小米桌面的广告为例。关于如何开发Xposed模块，前往[Xposed Wiki 查看学习](https://github.com/rovo89/XposedBridge/wiki/Development-tutorial)\n\n要想实现去广告，首先我们需要想一些办法，我最初想到的办法是从广告的Api入手，替换掉url地址，经过试验，失败了。但是发现，小米桌面文件夹(就那个好几个app放在一起的地方)有个隐藏的功能，修改名称的时候，下面有个是否推荐那个，这里可以关掉广告，所以，从这里入手。\n\n第一步，我们需要拿到小米Home的代码，这个对于我们root了的手机，简单的很，不过，这里我们要对代码进行一些操作，因为我们能拿到的是odex文件，我们要将其转化为jar文件,转换过程odex->smail->dex->jar，这里我们借助两个开源项目可以轻松完成。https://github.com/JesusFreke/smali (https://bitbucket.org/JesusFreke/smali/downloads/)\n\nhttps://github.com/pxb1988/dex2jar\n\n\n第二步，找到对应点击文件夹图标的方法，我们直接在Launcher中搜索openF(older)，关于Launcher，这里不多说。我们能搜索到如下代码。\n\n```\n\n  public void openFolder(FolderInfo paramFolderInfo, View paramView)\n  {\n    this.mFolderClosingInNormalEdit = false;\n    this.mWorkspace.post(new Runnable(this, paramFolderInfo)\n    {\n      public void run()\n      {\n        if (Launcher.access$1100(this.this$0).isOpened())\n          return;\n        Launcher.access$3702(this.this$0, false);\n        ShortcutIcon.setEnableLoadingAnim(true);\n        Launcher.access$1100(this.this$0).bind(this.val$folderInfo);\n        Launcher.access$1100(this.this$0).open();\n        this.this$0.updateStatusBarClock();\n        Launcher.access$3800(this.this$0).cancel();\n        if ((this.this$0.isInNormalEditing()) || (this.this$0.isSceneShowing()))\n          Launcher.access$3800(this.this$0).setDuration(Folder.DEFAULT_FOLDER_BACKGROUND_SHORT_DURATION);\n        while (true)\n        {\n          do\n          {\n            Launcher.access$3800(this.this$0).setFloatValues(new float[] { 0F, 1F });\n            Launcher.access$3800(this.this$0).setInterpolator(new CubicEaseInOutInterpolater());\n            Launcher.access$3800(this.this$0).start();\n          }\n          while (this.this$0.isInEditing();\n          this.val$folderInfo.onLaunch();\n          LauncherModel.updateItemFlagAndLaunchCount(this.this$0, this.val$folderInfo);\n          return;\n          Launcher.access$3800(this.this$0).setDuration(Folder.DEFAULT_FOLDER_OPEN_DURATION);\n        }\n      }\n    });\n  }\n```\n\n我们这里，能发现FolderInfo这个类作为了一个参数，很明显，这是描述Folder的信息的，那么是否推荐这个属性，一定是在这里面了。我们进去看看。\n\n在这里搜索recommend，我们能发现这么一个变量。\n\n```\nprivate boolean mEnbaleRecommendAppsView = false;\n```\n\n细心的同学发现他这个变量名是不是手抖了。。。\n\nprivate？那么，我们不管三七二十一，直接干掉get方法，直接返回false是不是就可以实现呢？尝试一波，写下如下代码。\n\n\n```\npublic class XposedDemo implements IXposedHookLoadPackage {\n    private static final String TAG = \"myxposed\";\n\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {\n        Log.e(TAG, \"handleLoadPackage: \" + lpparam.packageName + \"----->\" + lpparam.appInfo.sourceDir);\n        if (lpparam.packageName.equals(\"com.miui.home\")) {\n            Log.e(TAG, \"handleLoadPackage: \" + \"miui.home \");\n\n            findAndHookMethod(\"com.miui.home.launcher.FolderInfo\", lpparam.classLoader, \"isRecommendAppsViewEnable\", Context.class, new XC_MethodReplacement() {\n                @Override\n                protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {\n                    Log.e(TAG, \"replaceHookedMethod: \" + \"被调用了\");\n                    return false;\n                }\n            });\n        }\n    }\n}\n```\n\n安装，勾选，重启。然后点开文件夹，发现，舒服的很，确实没了，在编辑文件夹属性，把这个推荐打开，哈，还是没有。果然，我们成功了。\n\n### 最后\n\n有没有学到呢？我把小米Home的jar包以及当时做的简陋的ppt放在了 [blog_resource这个仓库](https://github.com/Guolei1130/blog_resource)，有需要的可以去拿。\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Xposed简介以及小米去桌面广告的简单实现.md","raw":"---\ntitle: Xposed简介以及小米去桌面广告的简单实现\ndate: 2017-11-18 19:18:02\ncategories: Android\ntags: Xposed\n\n---\n<Excerpt in index | 首页摘要>\n\n提起Xposed，大多数Android开发者都听过或者用过，甚至有一些开发过比较炫酷的模块。这是我前段时间在公司的分享内容，分享给大家。\n\n<!-- more -->\n\n#最先发表于个人博客 https://guolei1130.github.io/\n\n\n### Xposed简介\n\nXposed框架是一款可以在不修改APK的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。项目地址：https://github.com/rovo89 包括以下几个部分：\n\n1. Xposed & android_art ，Xposed framework，核心\n2. XposedBridge java 部分的framework，我们开发模块要用到\n3. XposedInstaller 安装器，用去安装Xposed framework以及管理Xposed 模块\n\n那么，Xposed有什么应用场景么，就目前来说，我们耳熟能详的应用场景就是抢红包了，xposed的应用场景取决于我们的思维和想法。现在比较火的模块如抢红包之类的，消息防撤回、绿色守护、黑狱、小米去广告等等。\n\n\n### 如何使用Xposed\n\n就目前的国内情况来讲，要想用Xposed的话，我个人推荐小米手机。\n\n1. root\n2. 安装Xposed，要找对应手机RAM对应Android版本的Xposed framework，可以去小米论坛上找\n3. 从酷安市场或者Xposed installer里安装自己喜欢的模块，\n4. 勾选，重启生效\n\n### 如何开发自己的Xposed模块\n\n关于开发自己的Xposed模块，在Xposed项目的wiki中，有很详细的介绍，并且开发Xposed模块的话确实比较简单，难点在于找到你想实现功能的切入点，我们这里以去掉小米桌面的广告为例。关于如何开发Xposed模块，前往[Xposed Wiki 查看学习](https://github.com/rovo89/XposedBridge/wiki/Development-tutorial)\n\n要想实现去广告，首先我们需要想一些办法，我最初想到的办法是从广告的Api入手，替换掉url地址，经过试验，失败了。但是发现，小米桌面文件夹(就那个好几个app放在一起的地方)有个隐藏的功能，修改名称的时候，下面有个是否推荐那个，这里可以关掉广告，所以，从这里入手。\n\n第一步，我们需要拿到小米Home的代码，这个对于我们root了的手机，简单的很，不过，这里我们要对代码进行一些操作，因为我们能拿到的是odex文件，我们要将其转化为jar文件,转换过程odex->smail->dex->jar，这里我们借助两个开源项目可以轻松完成。https://github.com/JesusFreke/smali (https://bitbucket.org/JesusFreke/smali/downloads/)\n\nhttps://github.com/pxb1988/dex2jar\n\n\n第二步，找到对应点击文件夹图标的方法，我们直接在Launcher中搜索openF(older)，关于Launcher，这里不多说。我们能搜索到如下代码。\n\n```\n\n  public void openFolder(FolderInfo paramFolderInfo, View paramView)\n  {\n    this.mFolderClosingInNormalEdit = false;\n    this.mWorkspace.post(new Runnable(this, paramFolderInfo)\n    {\n      public void run()\n      {\n        if (Launcher.access$1100(this.this$0).isOpened())\n          return;\n        Launcher.access$3702(this.this$0, false);\n        ShortcutIcon.setEnableLoadingAnim(true);\n        Launcher.access$1100(this.this$0).bind(this.val$folderInfo);\n        Launcher.access$1100(this.this$0).open();\n        this.this$0.updateStatusBarClock();\n        Launcher.access$3800(this.this$0).cancel();\n        if ((this.this$0.isInNormalEditing()) || (this.this$0.isSceneShowing()))\n          Launcher.access$3800(this.this$0).setDuration(Folder.DEFAULT_FOLDER_BACKGROUND_SHORT_DURATION);\n        while (true)\n        {\n          do\n          {\n            Launcher.access$3800(this.this$0).setFloatValues(new float[] { 0F, 1F });\n            Launcher.access$3800(this.this$0).setInterpolator(new CubicEaseInOutInterpolater());\n            Launcher.access$3800(this.this$0).start();\n          }\n          while (this.this$0.isInEditing();\n          this.val$folderInfo.onLaunch();\n          LauncherModel.updateItemFlagAndLaunchCount(this.this$0, this.val$folderInfo);\n          return;\n          Launcher.access$3800(this.this$0).setDuration(Folder.DEFAULT_FOLDER_OPEN_DURATION);\n        }\n      }\n    });\n  }\n```\n\n我们这里，能发现FolderInfo这个类作为了一个参数，很明显，这是描述Folder的信息的，那么是否推荐这个属性，一定是在这里面了。我们进去看看。\n\n在这里搜索recommend，我们能发现这么一个变量。\n\n```\nprivate boolean mEnbaleRecommendAppsView = false;\n```\n\n细心的同学发现他这个变量名是不是手抖了。。。\n\nprivate？那么，我们不管三七二十一，直接干掉get方法，直接返回false是不是就可以实现呢？尝试一波，写下如下代码。\n\n\n```\npublic class XposedDemo implements IXposedHookLoadPackage {\n    private static final String TAG = \"myxposed\";\n\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {\n        Log.e(TAG, \"handleLoadPackage: \" + lpparam.packageName + \"----->\" + lpparam.appInfo.sourceDir);\n        if (lpparam.packageName.equals(\"com.miui.home\")) {\n            Log.e(TAG, \"handleLoadPackage: \" + \"miui.home \");\n\n            findAndHookMethod(\"com.miui.home.launcher.FolderInfo\", lpparam.classLoader, \"isRecommendAppsViewEnable\", Context.class, new XC_MethodReplacement() {\n                @Override\n                protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {\n                    Log.e(TAG, \"replaceHookedMethod: \" + \"被调用了\");\n                    return false;\n                }\n            });\n        }\n    }\n}\n```\n\n安装，勾选，重启。然后点开文件夹，发现，舒服的很，确实没了，在编辑文件夹属性，把这个推荐打开，哈，还是没有。果然，我们成功了。\n\n### 最后\n\n有没有学到呢？我把小米Home的jar包以及当时做的简陋的ppt放在了 [blog_resource这个仓库](https://github.com/Guolei1130/blog_resource)，有需要的可以去拿。\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Xposed简介以及小米去桌面广告的简单实现","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslya002b19fyvt3mcd6a","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<p>提起Xposed，大多数Android开发者都听过或者用过，甚至有一些开发过比较炫酷的模块。这是我前段时间在公司的分享内容，分享给大家。</p>\n<a id=\"more\"></a>\n<p>#最先发表于个人博客 <a href=\"https://guolei1130.github.io/\">https://guolei1130.github.io/</a></p>\n<h3 id=\"Xposed简介\"><a href=\"#Xposed简介\" class=\"headerlink\" title=\"Xposed简介\"></a>Xposed简介</h3><p>Xposed框架是一款可以在不修改APK的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。项目地址：<a href=\"https://github.com/rovo89\" target=\"_blank\" rel=\"external\">https://github.com/rovo89</a> 包括以下几个部分：</p>\n<ol>\n<li>Xposed &amp; android_art ，Xposed framework，核心</li>\n<li>XposedBridge java 部分的framework，我们开发模块要用到</li>\n<li>XposedInstaller 安装器，用去安装Xposed framework以及管理Xposed 模块</li>\n</ol>\n<p>那么，Xposed有什么应用场景么，就目前来说，我们耳熟能详的应用场景就是抢红包了，xposed的应用场景取决于我们的思维和想法。现在比较火的模块如抢红包之类的，消息防撤回、绿色守护、黑狱、小米去广告等等。</p>\n<h3 id=\"如何使用Xposed\"><a href=\"#如何使用Xposed\" class=\"headerlink\" title=\"如何使用Xposed\"></a>如何使用Xposed</h3><p>就目前的国内情况来讲，要想用Xposed的话，我个人推荐小米手机。</p>\n<ol>\n<li>root</li>\n<li>安装Xposed，要找对应手机RAM对应Android版本的Xposed framework，可以去小米论坛上找</li>\n<li>从酷安市场或者Xposed installer里安装自己喜欢的模块，</li>\n<li>勾选，重启生效</li>\n</ol>\n<h3 id=\"如何开发自己的Xposed模块\"><a href=\"#如何开发自己的Xposed模块\" class=\"headerlink\" title=\"如何开发自己的Xposed模块\"></a>如何开发自己的Xposed模块</h3><p>关于开发自己的Xposed模块，在Xposed项目的wiki中，有很详细的介绍，并且开发Xposed模块的话确实比较简单，难点在于找到你想实现功能的切入点，我们这里以去掉小米桌面的广告为例。关于如何开发Xposed模块，前往<a href=\"https://github.com/rovo89/XposedBridge/wiki/Development-tutorial\" target=\"_blank\" rel=\"external\">Xposed Wiki 查看学习</a></p>\n<p>要想实现去广告，首先我们需要想一些办法，我最初想到的办法是从广告的Api入手，替换掉url地址，经过试验，失败了。但是发现，小米桌面文件夹(就那个好几个app放在一起的地方)有个隐藏的功能，修改名称的时候，下面有个是否推荐那个，这里可以关掉广告，所以，从这里入手。</p>\n<p>第一步，我们需要拿到小米Home的代码，这个对于我们root了的手机，简单的很，不过，这里我们要对代码进行一些操作，因为我们能拿到的是odex文件，我们要将其转化为jar文件,转换过程odex-&gt;smail-&gt;dex-&gt;jar，这里我们借助两个开源项目可以轻松完成。<a href=\"https://github.com/JesusFreke/smali\" target=\"_blank\" rel=\"external\">https://github.com/JesusFreke/smali</a> (<a href=\"https://bitbucket.org/JesusFreke/smali/downloads/\" target=\"_blank\" rel=\"external\">https://bitbucket.org/JesusFreke/smali/downloads/</a>)</p>\n<p><a href=\"https://github.com/pxb1988/dex2jar\" target=\"_blank\" rel=\"external\">https://github.com/pxb1988/dex2jar</a></p>\n<p>第二步，找到对应点击文件夹图标的方法，我们直接在Launcher中搜索openF(older)，关于Launcher，这里不多说。我们能搜索到如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">public void openFolder(FolderInfo paramFolderInfo, View paramView)</div><div class=\"line\">&#123;</div><div class=\"line\">  this.mFolderClosingInNormalEdit = false;</div><div class=\"line\">  this.mWorkspace.post(new Runnable(this, paramFolderInfo)</div><div class=\"line\">  &#123;</div><div class=\"line\">    public void run()</div><div class=\"line\">    &#123;</div><div class=\"line\">      if (Launcher.access$1100(this.this$0).isOpened())</div><div class=\"line\">        return;</div><div class=\"line\">      Launcher.access$3702(this.this$0, false);</div><div class=\"line\">      ShortcutIcon.setEnableLoadingAnim(true);</div><div class=\"line\">      Launcher.access$1100(this.this$0).bind(this.val$folderInfo);</div><div class=\"line\">      Launcher.access$1100(this.this$0).open();</div><div class=\"line\">      this.this$0.updateStatusBarClock();</div><div class=\"line\">      Launcher.access$3800(this.this$0).cancel();</div><div class=\"line\">      if ((this.this$0.isInNormalEditing()) || (this.this$0.isSceneShowing()))</div><div class=\"line\">        Launcher.access$3800(this.this$0).setDuration(Folder.DEFAULT_FOLDER_BACKGROUND_SHORT_DURATION);</div><div class=\"line\">      while (true)</div><div class=\"line\">      &#123;</div><div class=\"line\">        do</div><div class=\"line\">        &#123;</div><div class=\"line\">          Launcher.access$3800(this.this$0).setFloatValues(new float[] &#123; 0F, 1F &#125;);</div><div class=\"line\">          Launcher.access$3800(this.this$0).setInterpolator(new CubicEaseInOutInterpolater());</div><div class=\"line\">          Launcher.access$3800(this.this$0).start();</div><div class=\"line\">        &#125;</div><div class=\"line\">        while (this.this$0.isInEditing();</div><div class=\"line\">        this.val$folderInfo.onLaunch();</div><div class=\"line\">        LauncherModel.updateItemFlagAndLaunchCount(this.this$0, this.val$folderInfo);</div><div class=\"line\">        return;</div><div class=\"line\">        Launcher.access$3800(this.this$0).setDuration(Folder.DEFAULT_FOLDER_OPEN_DURATION);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们这里，能发现FolderInfo这个类作为了一个参数，很明显，这是描述Folder的信息的，那么是否推荐这个属性，一定是在这里面了。我们进去看看。</p>\n<p>在这里搜索recommend，我们能发现这么一个变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean mEnbaleRecommendAppsView = false;</div></pre></td></tr></table></figure>\n<p>细心的同学发现他这个变量名是不是手抖了。。。</p>\n<p>private？那么，我们不管三七二十一，直接干掉get方法，直接返回false是不是就可以实现呢？尝试一波，写下如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class XposedDemo implements IXposedHookLoadPackage &#123;</div><div class=\"line\">    private static final String TAG = &quot;myxposed&quot;;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123;</div><div class=\"line\">        Log.e(TAG, &quot;handleLoadPackage: &quot; + lpparam.packageName + &quot;-----&gt;&quot; + lpparam.appInfo.sourceDir);</div><div class=\"line\">        if (lpparam.packageName.equals(&quot;com.miui.home&quot;)) &#123;</div><div class=\"line\">            Log.e(TAG, &quot;handleLoadPackage: &quot; + &quot;miui.home &quot;);</div><div class=\"line\"></div><div class=\"line\">            findAndHookMethod(&quot;com.miui.home.launcher.FolderInfo&quot;, lpparam.classLoader, &quot;isRecommendAppsViewEnable&quot;, Context.class, new XC_MethodReplacement() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123;</div><div class=\"line\">                    Log.e(TAG, &quot;replaceHookedMethod: &quot; + &quot;被调用了&quot;);</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装，勾选，重启。然后点开文件夹，发现，舒服的很，确实没了，在编辑文件夹属性，把这个推荐打开，哈，还是没有。果然，我们成功了。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>有没有学到呢？我把小米Home的jar包以及当时做的简陋的ppt放在了 <a href=\"https://github.com/Guolei1130/blog_resource\" target=\"_blank\" rel=\"external\">blog_resource这个仓库</a>，有需要的可以去拿。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<p>提起Xposed，大多数Android开发者都听过或者用过，甚至有一些开发过比较炫酷的模块。这是我前段时间在公司的分享内容，分享给大家。</p>","more":"<p>#最先发表于个人博客 <a href=\"https://guolei1130.github.io/\">https://guolei1130.github.io/</a></p>\n<h3 id=\"Xposed简介\"><a href=\"#Xposed简介\" class=\"headerlink\" title=\"Xposed简介\"></a>Xposed简介</h3><p>Xposed框架是一款可以在不修改APK的情况下影响程序运行(修改系统)的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。项目地址：<a href=\"https://github.com/rovo89\">https://github.com/rovo89</a> 包括以下几个部分：</p>\n<ol>\n<li>Xposed &amp; android_art ，Xposed framework，核心</li>\n<li>XposedBridge java 部分的framework，我们开发模块要用到</li>\n<li>XposedInstaller 安装器，用去安装Xposed framework以及管理Xposed 模块</li>\n</ol>\n<p>那么，Xposed有什么应用场景么，就目前来说，我们耳熟能详的应用场景就是抢红包了，xposed的应用场景取决于我们的思维和想法。现在比较火的模块如抢红包之类的，消息防撤回、绿色守护、黑狱、小米去广告等等。</p>\n<h3 id=\"如何使用Xposed\"><a href=\"#如何使用Xposed\" class=\"headerlink\" title=\"如何使用Xposed\"></a>如何使用Xposed</h3><p>就目前的国内情况来讲，要想用Xposed的话，我个人推荐小米手机。</p>\n<ol>\n<li>root</li>\n<li>安装Xposed，要找对应手机RAM对应Android版本的Xposed framework，可以去小米论坛上找</li>\n<li>从酷安市场或者Xposed installer里安装自己喜欢的模块，</li>\n<li>勾选，重启生效</li>\n</ol>\n<h3 id=\"如何开发自己的Xposed模块\"><a href=\"#如何开发自己的Xposed模块\" class=\"headerlink\" title=\"如何开发自己的Xposed模块\"></a>如何开发自己的Xposed模块</h3><p>关于开发自己的Xposed模块，在Xposed项目的wiki中，有很详细的介绍，并且开发Xposed模块的话确实比较简单，难点在于找到你想实现功能的切入点，我们这里以去掉小米桌面的广告为例。关于如何开发Xposed模块，前往<a href=\"https://github.com/rovo89/XposedBridge/wiki/Development-tutorial\">Xposed Wiki 查看学习</a></p>\n<p>要想实现去广告，首先我们需要想一些办法，我最初想到的办法是从广告的Api入手，替换掉url地址，经过试验，失败了。但是发现，小米桌面文件夹(就那个好几个app放在一起的地方)有个隐藏的功能，修改名称的时候，下面有个是否推荐那个，这里可以关掉广告，所以，从这里入手。</p>\n<p>第一步，我们需要拿到小米Home的代码，这个对于我们root了的手机，简单的很，不过，这里我们要对代码进行一些操作，因为我们能拿到的是odex文件，我们要将其转化为jar文件,转换过程odex-&gt;smail-&gt;dex-&gt;jar，这里我们借助两个开源项目可以轻松完成。<a href=\"https://github.com/JesusFreke/smali\">https://github.com/JesusFreke/smali</a> (<a href=\"https://bitbucket.org/JesusFreke/smali/downloads/\">https://bitbucket.org/JesusFreke/smali/downloads/</a>)</p>\n<p><a href=\"https://github.com/pxb1988/dex2jar\">https://github.com/pxb1988/dex2jar</a></p>\n<p>第二步，找到对应点击文件夹图标的方法，我们直接在Launcher中搜索openF(older)，关于Launcher，这里不多说。我们能搜索到如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">public void openFolder(FolderInfo paramFolderInfo, View paramView)</div><div class=\"line\">&#123;</div><div class=\"line\">  this.mFolderClosingInNormalEdit = false;</div><div class=\"line\">  this.mWorkspace.post(new Runnable(this, paramFolderInfo)</div><div class=\"line\">  &#123;</div><div class=\"line\">    public void run()</div><div class=\"line\">    &#123;</div><div class=\"line\">      if (Launcher.access$1100(this.this$0).isOpened())</div><div class=\"line\">        return;</div><div class=\"line\">      Launcher.access$3702(this.this$0, false);</div><div class=\"line\">      ShortcutIcon.setEnableLoadingAnim(true);</div><div class=\"line\">      Launcher.access$1100(this.this$0).bind(this.val$folderInfo);</div><div class=\"line\">      Launcher.access$1100(this.this$0).open();</div><div class=\"line\">      this.this$0.updateStatusBarClock();</div><div class=\"line\">      Launcher.access$3800(this.this$0).cancel();</div><div class=\"line\">      if ((this.this$0.isInNormalEditing()) || (this.this$0.isSceneShowing()))</div><div class=\"line\">        Launcher.access$3800(this.this$0).setDuration(Folder.DEFAULT_FOLDER_BACKGROUND_SHORT_DURATION);</div><div class=\"line\">      while (true)</div><div class=\"line\">      &#123;</div><div class=\"line\">        do</div><div class=\"line\">        &#123;</div><div class=\"line\">          Launcher.access$3800(this.this$0).setFloatValues(new float[] &#123; 0F, 1F &#125;);</div><div class=\"line\">          Launcher.access$3800(this.this$0).setInterpolator(new CubicEaseInOutInterpolater());</div><div class=\"line\">          Launcher.access$3800(this.this$0).start();</div><div class=\"line\">        &#125;</div><div class=\"line\">        while (this.this$0.isInEditing();</div><div class=\"line\">        this.val$folderInfo.onLaunch();</div><div class=\"line\">        LauncherModel.updateItemFlagAndLaunchCount(this.this$0, this.val$folderInfo);</div><div class=\"line\">        return;</div><div class=\"line\">        Launcher.access$3800(this.this$0).setDuration(Folder.DEFAULT_FOLDER_OPEN_DURATION);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们这里，能发现FolderInfo这个类作为了一个参数，很明显，这是描述Folder的信息的，那么是否推荐这个属性，一定是在这里面了。我们进去看看。</p>\n<p>在这里搜索recommend，我们能发现这么一个变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean mEnbaleRecommendAppsView = false;</div></pre></td></tr></table></figure>\n<p>细心的同学发现他这个变量名是不是手抖了。。。</p>\n<p>private？那么，我们不管三七二十一，直接干掉get方法，直接返回false是不是就可以实现呢？尝试一波，写下如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class XposedDemo implements IXposedHookLoadPackage &#123;</div><div class=\"line\">    private static final String TAG = &quot;myxposed&quot;;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123;</div><div class=\"line\">        Log.e(TAG, &quot;handleLoadPackage: &quot; + lpparam.packageName + &quot;-----&gt;&quot; + lpparam.appInfo.sourceDir);</div><div class=\"line\">        if (lpparam.packageName.equals(&quot;com.miui.home&quot;)) &#123;</div><div class=\"line\">            Log.e(TAG, &quot;handleLoadPackage: &quot; + &quot;miui.home &quot;);</div><div class=\"line\"></div><div class=\"line\">            findAndHookMethod(&quot;com.miui.home.launcher.FolderInfo&quot;, lpparam.classLoader, &quot;isRecommendAppsViewEnable&quot;, Context.class, new XC_MethodReplacement() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123;</div><div class=\"line\">                    Log.e(TAG, &quot;replaceHookedMethod: &quot; + &quot;被调用了&quot;);</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装，勾选，重启。然后点开文件夹，发现，舒服的很，确实没了，在编辑文件夹属性，把这个推荐打开，哈，还是没有。果然，我们成功了。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>有没有学到呢？我把小米Home的jar包以及当时做的简陋的ppt放在了 <a href=\"https://github.com/Guolei1130/blog_resource\">blog_resource这个仓库</a>，有需要的可以去拿。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"ZeusPlugin浅析","date":"2017-03-26T08:08:51.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n从去年开始，插件化和热修复技术就一直很火，本人对这些技术也很关注。虽然说这些技术可能在今年就会退热。但是其中的技术点，我们还是需要get到的。今天就来学习下，掌阅的[ZeusPlugin](https://github.com/iReaderAndroid/ZeusPlugin) \n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\nZeusPlugin中包含插件化和热修两部分，其中热修涉及到的原理以及gradle插件部分，这里就不说了，热修还是QQ空间的超级补丁方案。\n\n现在，开始单独说下插件部分的原理。\n\n\n### 插件的安装\n\n插件的安装过程分为三个步骤:\n\n* 将插件复制到指定文件夹中\n* 进行dex优化\n* 将dex文件添加到classloader中\n* 将资源添加到AssetManager中\n\n将插件复制到指定文件夹的过程有ZeusPlugin来完成。具体代码，这里不说了。\n\ndex优化过程，生成DexClassLoader即可。\n\n重点看下下面两步。其中添加dex文件的过程由PluginManager#loadPlugin方法来完成，代码如下：\n\n```\npublic static boolean loadPlugin(String pluginId, int version) {\n        synchronized (mLoadLock) {\n            if (getLoadedPlugin() != null && getLoadedPlugin().containsKey(pluginId) && getLoadedPlugin().get(pluginId) >= version) {\n                return true;\n            }\n            String pluginApkPath = PluginUtil.getAPKPath(pluginId);\n            ZeusPlugin plugin = getPlugin(pluginId);\n            if (!PluginUtil.exists(pluginApkPath)) {\n                if (getDefaultPlugin().containsKey(pluginId)) {\n                    if (!plugin.installAssetPlugin()) {\n                        return false;\n                    } else {\n                        pluginApkPath = PluginUtil.getAPKPath(pluginId);\n                    }\n                } else {\n                    return false;\n                }\n            }\n\n            PluginManifest meta = plugin.getPluginMeta();\n            if (meta == null || Integer.valueOf(meta.version) < version) return false;\n\n            ClassLoader cl = mNowClassLoader;\n            if (PluginUtil.isHotFix(pluginId)) {\n                loadHotfixPluginClassLoader(pluginId);\n            } else {\n                //如果一个老版本的插件已经被加载了，则需要先移除\n                if (getLoadedPlugin() != null && getLoadedPlugin().containsKey(pluginId)) {\n                    if (cl instanceof ZeusClassLoader) {\n                        ZeusClassLoader classLoader = (ZeusClassLoader) cl;\n                        //移除老版本的插件\n                        classLoader.removePlugin(pluginId);\n                        clearViewConstructorCache();\n                        //添加新版本的插件\n                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));\n                    }\n                } else {\n                    if (cl instanceof ZeusClassLoader) {\n                        ZeusClassLoader classLoader = (ZeusClassLoader) cl;\n                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));\n                    } else {\n                        ZeusClassLoader classLoader = new ZeusClassLoader(cl);\n                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));\n                        PluginUtil.setField(mPackageInfo, \"mClassLoader\", classLoader);\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        mNowClassLoader = classLoader;\n                    }\n                }\n                putLoadedPlugin(pluginId, Integer.valueOf(meta.version));\n            }\n            if (!PluginUtil.isHotfixWithoutResFile(pluginId)) {\n                reloadInstalledPluginResources();\n            }\n        }\n        return true;\n    }\n```\n\n代码虽然长，但是逻辑却很简单，调用ZeusClassLoader#addApkPath的方法，加入。这里的具体代码也不分析了，关于双亲委托机制，就不说了。\n\n这些做完之后，会调用reloadInstalledPluginResources，加载资源并清除掉之前的缓存。\n\n```\n   private static void reloadInstalledPluginResources() {\n        try {\n            AssetManager assetManager = AssetManager.class.newInstance();\n            Method addAssetPath = AssetManager.class.getMethod(\"addAssetPath\", String.class);\n            addAssetPath.invoke(assetManager, mBaseContext.getPackageResourcePath());\n            if (mLoadedPluginList != null && mLoadedPluginList.size() != 0) {\n                //每个插件的packageID都不能一样\n                for (String id : mLoadedPluginList.keySet()) {\n                    //只有带有资源的补丁才会执行添加到assetManager中\n                    if (!PluginUtil.isHotfixWithoutResFile(id)) {\n                        addAssetPath.invoke(assetManager, PluginUtil.getAPKPath(id));\n                    }\n                }\n            }\n            //这里提前创建一个resource是因为Resources的构造函数会对AssetManager进行一些变量的初始化\n            //还不能创建系统的Resources类，否则中兴系统会出现崩溃问题\n            PluginResources newResources = new PluginResources(assetManager,\n                    mBaseContext.getResources().getDisplayMetrics(),\n                    mBaseContext.getResources().getConfiguration());\n\n            PluginUtil.setField(mBaseContext, \"mResources\", newResources);\n            //这是最主要的需要替换的，如果不支持插件运行时更新，只留这一个就可以了\n            PluginUtil.setField(mPackageInfo, \"mResources\", newResources);\n\n            //清除一下之前的resource的数据，释放一些内存\n            //因为这个resource有可能还被系统持有着，内存都没被释放\n            clearResoucesDrawableCache(mNowResources);\n\n            mNowResources = newResources;\n            //需要清理mtheme对象，否则通过inflate方式加载资源会报错\n            //如果是activity动态加载插件，则需要把activity的mTheme对象也设置为null\n            PluginUtil.setField(mBaseContext, \"mTheme\", null);\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n同样是通过一系列反射调用。略。\n\n### 组件启动\n\n和其他一样，这里也是需要进行占桩，不过这里比DroidPlugin的处理要简单点，但是我们需要预先确定。这一点比较麻烦。关于如何占桩，这里不说了，感兴趣的看下weishu的文章。还有一点区别就是，我们这里调用通过Classloader根据类名去获取class信息的。所以我们不需要对Instrumentation进行特别大的修改。详情，看源码吧。\n\n### 资源冲突\n\n这里是通过修改aapt，通过固定资源id前几位的方式做的。关于aapt修改，github上有不少代码，感兴趣的可以看下，这里占个坑。我也没看~~~\n\n### 总结\n\nZeusPlugin很轻量，但是能满足我们的需求，个人感觉是一个不错的选择。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/ZeusPlugin浅析.md","raw":"---\ntitle: ZeusPlugin浅析\ndate: 2017-03-26 16:08:51\ncategories: Android\ntags: 插件化\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n从去年开始，插件化和热修复技术就一直很火，本人对这些技术也很关注。虽然说这些技术可能在今年就会退热。但是其中的技术点，我们还是需要get到的。今天就来学习下，掌阅的[ZeusPlugin](https://github.com/iReaderAndroid/ZeusPlugin) \n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\nZeusPlugin中包含插件化和热修两部分，其中热修涉及到的原理以及gradle插件部分，这里就不说了，热修还是QQ空间的超级补丁方案。\n\n现在，开始单独说下插件部分的原理。\n\n\n### 插件的安装\n\n插件的安装过程分为三个步骤:\n\n* 将插件复制到指定文件夹中\n* 进行dex优化\n* 将dex文件添加到classloader中\n* 将资源添加到AssetManager中\n\n将插件复制到指定文件夹的过程有ZeusPlugin来完成。具体代码，这里不说了。\n\ndex优化过程，生成DexClassLoader即可。\n\n重点看下下面两步。其中添加dex文件的过程由PluginManager#loadPlugin方法来完成，代码如下：\n\n```\npublic static boolean loadPlugin(String pluginId, int version) {\n        synchronized (mLoadLock) {\n            if (getLoadedPlugin() != null && getLoadedPlugin().containsKey(pluginId) && getLoadedPlugin().get(pluginId) >= version) {\n                return true;\n            }\n            String pluginApkPath = PluginUtil.getAPKPath(pluginId);\n            ZeusPlugin plugin = getPlugin(pluginId);\n            if (!PluginUtil.exists(pluginApkPath)) {\n                if (getDefaultPlugin().containsKey(pluginId)) {\n                    if (!plugin.installAssetPlugin()) {\n                        return false;\n                    } else {\n                        pluginApkPath = PluginUtil.getAPKPath(pluginId);\n                    }\n                } else {\n                    return false;\n                }\n            }\n\n            PluginManifest meta = plugin.getPluginMeta();\n            if (meta == null || Integer.valueOf(meta.version) < version) return false;\n\n            ClassLoader cl = mNowClassLoader;\n            if (PluginUtil.isHotFix(pluginId)) {\n                loadHotfixPluginClassLoader(pluginId);\n            } else {\n                //如果一个老版本的插件已经被加载了，则需要先移除\n                if (getLoadedPlugin() != null && getLoadedPlugin().containsKey(pluginId)) {\n                    if (cl instanceof ZeusClassLoader) {\n                        ZeusClassLoader classLoader = (ZeusClassLoader) cl;\n                        //移除老版本的插件\n                        classLoader.removePlugin(pluginId);\n                        clearViewConstructorCache();\n                        //添加新版本的插件\n                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));\n                    }\n                } else {\n                    if (cl instanceof ZeusClassLoader) {\n                        ZeusClassLoader classLoader = (ZeusClassLoader) cl;\n                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));\n                    } else {\n                        ZeusClassLoader classLoader = new ZeusClassLoader(cl);\n                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));\n                        PluginUtil.setField(mPackageInfo, \"mClassLoader\", classLoader);\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        mNowClassLoader = classLoader;\n                    }\n                }\n                putLoadedPlugin(pluginId, Integer.valueOf(meta.version));\n            }\n            if (!PluginUtil.isHotfixWithoutResFile(pluginId)) {\n                reloadInstalledPluginResources();\n            }\n        }\n        return true;\n    }\n```\n\n代码虽然长，但是逻辑却很简单，调用ZeusClassLoader#addApkPath的方法，加入。这里的具体代码也不分析了，关于双亲委托机制，就不说了。\n\n这些做完之后，会调用reloadInstalledPluginResources，加载资源并清除掉之前的缓存。\n\n```\n   private static void reloadInstalledPluginResources() {\n        try {\n            AssetManager assetManager = AssetManager.class.newInstance();\n            Method addAssetPath = AssetManager.class.getMethod(\"addAssetPath\", String.class);\n            addAssetPath.invoke(assetManager, mBaseContext.getPackageResourcePath());\n            if (mLoadedPluginList != null && mLoadedPluginList.size() != 0) {\n                //每个插件的packageID都不能一样\n                for (String id : mLoadedPluginList.keySet()) {\n                    //只有带有资源的补丁才会执行添加到assetManager中\n                    if (!PluginUtil.isHotfixWithoutResFile(id)) {\n                        addAssetPath.invoke(assetManager, PluginUtil.getAPKPath(id));\n                    }\n                }\n            }\n            //这里提前创建一个resource是因为Resources的构造函数会对AssetManager进行一些变量的初始化\n            //还不能创建系统的Resources类，否则中兴系统会出现崩溃问题\n            PluginResources newResources = new PluginResources(assetManager,\n                    mBaseContext.getResources().getDisplayMetrics(),\n                    mBaseContext.getResources().getConfiguration());\n\n            PluginUtil.setField(mBaseContext, \"mResources\", newResources);\n            //这是最主要的需要替换的，如果不支持插件运行时更新，只留这一个就可以了\n            PluginUtil.setField(mPackageInfo, \"mResources\", newResources);\n\n            //清除一下之前的resource的数据，释放一些内存\n            //因为这个resource有可能还被系统持有着，内存都没被释放\n            clearResoucesDrawableCache(mNowResources);\n\n            mNowResources = newResources;\n            //需要清理mtheme对象，否则通过inflate方式加载资源会报错\n            //如果是activity动态加载插件，则需要把activity的mTheme对象也设置为null\n            PluginUtil.setField(mBaseContext, \"mTheme\", null);\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n同样是通过一系列反射调用。略。\n\n### 组件启动\n\n和其他一样，这里也是需要进行占桩，不过这里比DroidPlugin的处理要简单点，但是我们需要预先确定。这一点比较麻烦。关于如何占桩，这里不说了，感兴趣的看下weishu的文章。还有一点区别就是，我们这里调用通过Classloader根据类名去获取class信息的。所以我们不需要对Instrumentation进行特别大的修改。详情，看源码吧。\n\n### 资源冲突\n\n这里是通过修改aapt，通过固定资源id前几位的方式做的。关于aapt修改，github上有不少代码，感兴趣的可以看下，这里占个坑。我也没看~~~\n\n### 总结\n\nZeusPlugin很轻量，但是能满足我们的需求，个人感觉是一个不错的选择。\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"ZeusPlugin浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyd002e19fy70r5vv2c","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从去年开始，插件化和热修复技术就一直很火，本人对这些技术也很关注。虽然说这些技术可能在今年就会退热。但是其中的技术点，我们还是需要get到的。今天就来学习下，掌阅的<a href=\"https://github.com/iReaderAndroid/ZeusPlugin\" target=\"_blank\" rel=\"external\">ZeusPlugin</a> </p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p>ZeusPlugin中包含插件化和热修两部分，其中热修涉及到的原理以及gradle插件部分，这里就不说了，热修还是QQ空间的超级补丁方案。</p>\n<p>现在，开始单独说下插件部分的原理。</p>\n<h3 id=\"插件的安装\"><a href=\"#插件的安装\" class=\"headerlink\" title=\"插件的安装\"></a>插件的安装</h3><p>插件的安装过程分为三个步骤:</p>\n<ul>\n<li>将插件复制到指定文件夹中</li>\n<li>进行dex优化</li>\n<li>将dex文件添加到classloader中</li>\n<li>将资源添加到AssetManager中</li>\n</ul>\n<p>将插件复制到指定文件夹的过程有ZeusPlugin来完成。具体代码，这里不说了。</p>\n<p>dex优化过程，生成DexClassLoader即可。</p>\n<p>重点看下下面两步。其中添加dex文件的过程由PluginManager#loadPlugin方法来完成，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static boolean loadPlugin(String pluginId, int version) &#123;</div><div class=\"line\">        synchronized (mLoadLock) &#123;</div><div class=\"line\">            if (getLoadedPlugin() != null &amp;&amp; getLoadedPlugin().containsKey(pluginId) &amp;&amp; getLoadedPlugin().get(pluginId) &gt;= version) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            String pluginApkPath = PluginUtil.getAPKPath(pluginId);</div><div class=\"line\">            ZeusPlugin plugin = getPlugin(pluginId);</div><div class=\"line\">            if (!PluginUtil.exists(pluginApkPath)) &#123;</div><div class=\"line\">                if (getDefaultPlugin().containsKey(pluginId)) &#123;</div><div class=\"line\">                    if (!plugin.installAssetPlugin()) &#123;</div><div class=\"line\">                        return false;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        pluginApkPath = PluginUtil.getAPKPath(pluginId);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            PluginManifest meta = plugin.getPluginMeta();</div><div class=\"line\">            if (meta == null || Integer.valueOf(meta.version) &lt; version) return false;</div><div class=\"line\"></div><div class=\"line\">            ClassLoader cl = mNowClassLoader;</div><div class=\"line\">            if (PluginUtil.isHotFix(pluginId)) &#123;</div><div class=\"line\">                loadHotfixPluginClassLoader(pluginId);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                //如果一个老版本的插件已经被加载了，则需要先移除</div><div class=\"line\">                if (getLoadedPlugin() != null &amp;&amp; getLoadedPlugin().containsKey(pluginId)) &#123;</div><div class=\"line\">                    if (cl instanceof ZeusClassLoader) &#123;</div><div class=\"line\">                        ZeusClassLoader classLoader = (ZeusClassLoader) cl;</div><div class=\"line\">                        //移除老版本的插件</div><div class=\"line\">                        classLoader.removePlugin(pluginId);</div><div class=\"line\">                        clearViewConstructorCache();</div><div class=\"line\">                        //添加新版本的插件</div><div class=\"line\">                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (cl instanceof ZeusClassLoader) &#123;</div><div class=\"line\">                        ZeusClassLoader classLoader = (ZeusClassLoader) cl;</div><div class=\"line\">                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        ZeusClassLoader classLoader = new ZeusClassLoader(cl);</div><div class=\"line\">                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));</div><div class=\"line\">                        PluginUtil.setField(mPackageInfo, &quot;mClassLoader&quot;, classLoader);</div><div class=\"line\">                        Thread.currentThread().setContextClassLoader(classLoader);</div><div class=\"line\">                        mNowClassLoader = classLoader;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                putLoadedPlugin(pluginId, Integer.valueOf(meta.version));</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!PluginUtil.isHotfixWithoutResFile(pluginId)) &#123;</div><div class=\"line\">                reloadInstalledPluginResources();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>代码虽然长，但是逻辑却很简单，调用ZeusClassLoader#addApkPath的方法，加入。这里的具体代码也不分析了，关于双亲委托机制，就不说了。</p>\n<p>这些做完之后，会调用reloadInstalledPluginResources，加载资源并清除掉之前的缓存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void reloadInstalledPluginResources() &#123;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         AssetManager assetManager = AssetManager.class.newInstance();</div><div class=\"line\">         Method addAssetPath = AssetManager.class.getMethod(&quot;addAssetPath&quot;, String.class);</div><div class=\"line\">         addAssetPath.invoke(assetManager, mBaseContext.getPackageResourcePath());</div><div class=\"line\">         if (mLoadedPluginList != null &amp;&amp; mLoadedPluginList.size() != 0) &#123;</div><div class=\"line\">             //每个插件的packageID都不能一样</div><div class=\"line\">             for (String id : mLoadedPluginList.keySet()) &#123;</div><div class=\"line\">                 //只有带有资源的补丁才会执行添加到assetManager中</div><div class=\"line\">                 if (!PluginUtil.isHotfixWithoutResFile(id)) &#123;</div><div class=\"line\">                     addAssetPath.invoke(assetManager, PluginUtil.getAPKPath(id));</div><div class=\"line\">                 &#125;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">         //这里提前创建一个resource是因为Resources的构造函数会对AssetManager进行一些变量的初始化</div><div class=\"line\">         //还不能创建系统的Resources类，否则中兴系统会出现崩溃问题</div><div class=\"line\">         PluginResources newResources = new PluginResources(assetManager,</div><div class=\"line\">                 mBaseContext.getResources().getDisplayMetrics(),</div><div class=\"line\">                 mBaseContext.getResources().getConfiguration());</div><div class=\"line\"></div><div class=\"line\">         PluginUtil.setField(mBaseContext, &quot;mResources&quot;, newResources);</div><div class=\"line\">         //这是最主要的需要替换的，如果不支持插件运行时更新，只留这一个就可以了</div><div class=\"line\">         PluginUtil.setField(mPackageInfo, &quot;mResources&quot;, newResources);</div><div class=\"line\"></div><div class=\"line\">         //清除一下之前的resource的数据，释放一些内存</div><div class=\"line\">         //因为这个resource有可能还被系统持有着，内存都没被释放</div><div class=\"line\">         clearResoucesDrawableCache(mNowResources);</div><div class=\"line\"></div><div class=\"line\">         mNowResources = newResources;</div><div class=\"line\">         //需要清理mtheme对象，否则通过inflate方式加载资源会报错</div><div class=\"line\">         //如果是activity动态加载插件，则需要把activity的mTheme对象也设置为null</div><div class=\"line\">         PluginUtil.setField(mBaseContext, &quot;mTheme&quot;, null);</div><div class=\"line\">     &#125; catch (Throwable e) &#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>同样是通过一系列反射调用。略。</p>\n<h3 id=\"组件启动\"><a href=\"#组件启动\" class=\"headerlink\" title=\"组件启动\"></a>组件启动</h3><p>和其他一样，这里也是需要进行占桩，不过这里比DroidPlugin的处理要简单点，但是我们需要预先确定。这一点比较麻烦。关于如何占桩，这里不说了，感兴趣的看下weishu的文章。还有一点区别就是，我们这里调用通过Classloader根据类名去获取class信息的。所以我们不需要对Instrumentation进行特别大的修改。详情，看源码吧。</p>\n<h3 id=\"资源冲突\"><a href=\"#资源冲突\" class=\"headerlink\" title=\"资源冲突\"></a>资源冲突</h3><p>这里是通过修改aapt，通过固定资源id前几位的方式做的。关于aapt修改，github上有不少代码，感兴趣的可以看下，这里占个坑。我也没看~~~</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ZeusPlugin很轻量，但是能满足我们的需求，个人感觉是一个不错的选择。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从去年开始，插件化和热修复技术就一直很火，本人对这些技术也很关注。虽然说这些技术可能在今年就会退热。但是其中的技术点，我们还是需要get到的。今天就来学习下，掌阅的<a href=\"https://github.com/iReaderAndroid/ZeusPlugin\">ZeusPlugin</a> </p>","more":"<The rest of contents | 余下全文>\n\n\n<p>ZeusPlugin中包含插件化和热修两部分，其中热修涉及到的原理以及gradle插件部分，这里就不说了，热修还是QQ空间的超级补丁方案。</p>\n<p>现在，开始单独说下插件部分的原理。</p>\n<h3 id=\"插件的安装\"><a href=\"#插件的安装\" class=\"headerlink\" title=\"插件的安装\"></a>插件的安装</h3><p>插件的安装过程分为三个步骤:</p>\n<ul>\n<li>将插件复制到指定文件夹中</li>\n<li>进行dex优化</li>\n<li>将dex文件添加到classloader中</li>\n<li>将资源添加到AssetManager中</li>\n</ul>\n<p>将插件复制到指定文件夹的过程有ZeusPlugin来完成。具体代码，这里不说了。</p>\n<p>dex优化过程，生成DexClassLoader即可。</p>\n<p>重点看下下面两步。其中添加dex文件的过程由PluginManager#loadPlugin方法来完成，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static boolean loadPlugin(String pluginId, int version) &#123;</div><div class=\"line\">        synchronized (mLoadLock) &#123;</div><div class=\"line\">            if (getLoadedPlugin() != null &amp;&amp; getLoadedPlugin().containsKey(pluginId) &amp;&amp; getLoadedPlugin().get(pluginId) &gt;= version) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            String pluginApkPath = PluginUtil.getAPKPath(pluginId);</div><div class=\"line\">            ZeusPlugin plugin = getPlugin(pluginId);</div><div class=\"line\">            if (!PluginUtil.exists(pluginApkPath)) &#123;</div><div class=\"line\">                if (getDefaultPlugin().containsKey(pluginId)) &#123;</div><div class=\"line\">                    if (!plugin.installAssetPlugin()) &#123;</div><div class=\"line\">                        return false;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        pluginApkPath = PluginUtil.getAPKPath(pluginId);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            PluginManifest meta = plugin.getPluginMeta();</div><div class=\"line\">            if (meta == null || Integer.valueOf(meta.version) &lt; version) return false;</div><div class=\"line\"></div><div class=\"line\">            ClassLoader cl = mNowClassLoader;</div><div class=\"line\">            if (PluginUtil.isHotFix(pluginId)) &#123;</div><div class=\"line\">                loadHotfixPluginClassLoader(pluginId);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                //如果一个老版本的插件已经被加载了，则需要先移除</div><div class=\"line\">                if (getLoadedPlugin() != null &amp;&amp; getLoadedPlugin().containsKey(pluginId)) &#123;</div><div class=\"line\">                    if (cl instanceof ZeusClassLoader) &#123;</div><div class=\"line\">                        ZeusClassLoader classLoader = (ZeusClassLoader) cl;</div><div class=\"line\">                        //移除老版本的插件</div><div class=\"line\">                        classLoader.removePlugin(pluginId);</div><div class=\"line\">                        clearViewConstructorCache();</div><div class=\"line\">                        //添加新版本的插件</div><div class=\"line\">                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (cl instanceof ZeusClassLoader) &#123;</div><div class=\"line\">                        ZeusClassLoader classLoader = (ZeusClassLoader) cl;</div><div class=\"line\">                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        ZeusClassLoader classLoader = new ZeusClassLoader(cl);</div><div class=\"line\">                        classLoader.addAPKPath(pluginId, pluginApkPath, PluginUtil.getLibFileInside(pluginId));</div><div class=\"line\">                        PluginUtil.setField(mPackageInfo, &quot;mClassLoader&quot;, classLoader);</div><div class=\"line\">                        Thread.currentThread().setContextClassLoader(classLoader);</div><div class=\"line\">                        mNowClassLoader = classLoader;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                putLoadedPlugin(pluginId, Integer.valueOf(meta.version));</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (!PluginUtil.isHotfixWithoutResFile(pluginId)) &#123;</div><div class=\"line\">                reloadInstalledPluginResources();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>代码虽然长，但是逻辑却很简单，调用ZeusClassLoader#addApkPath的方法，加入。这里的具体代码也不分析了，关于双亲委托机制，就不说了。</p>\n<p>这些做完之后，会调用reloadInstalledPluginResources，加载资源并清除掉之前的缓存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void reloadInstalledPluginResources() &#123;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         AssetManager assetManager = AssetManager.class.newInstance();</div><div class=\"line\">         Method addAssetPath = AssetManager.class.getMethod(&quot;addAssetPath&quot;, String.class);</div><div class=\"line\">         addAssetPath.invoke(assetManager, mBaseContext.getPackageResourcePath());</div><div class=\"line\">         if (mLoadedPluginList != null &amp;&amp; mLoadedPluginList.size() != 0) &#123;</div><div class=\"line\">             //每个插件的packageID都不能一样</div><div class=\"line\">             for (String id : mLoadedPluginList.keySet()) &#123;</div><div class=\"line\">                 //只有带有资源的补丁才会执行添加到assetManager中</div><div class=\"line\">                 if (!PluginUtil.isHotfixWithoutResFile(id)) &#123;</div><div class=\"line\">                     addAssetPath.invoke(assetManager, PluginUtil.getAPKPath(id));</div><div class=\"line\">                 &#125;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">         //这里提前创建一个resource是因为Resources的构造函数会对AssetManager进行一些变量的初始化</div><div class=\"line\">         //还不能创建系统的Resources类，否则中兴系统会出现崩溃问题</div><div class=\"line\">         PluginResources newResources = new PluginResources(assetManager,</div><div class=\"line\">                 mBaseContext.getResources().getDisplayMetrics(),</div><div class=\"line\">                 mBaseContext.getResources().getConfiguration());</div><div class=\"line\"></div><div class=\"line\">         PluginUtil.setField(mBaseContext, &quot;mResources&quot;, newResources);</div><div class=\"line\">         //这是最主要的需要替换的，如果不支持插件运行时更新，只留这一个就可以了</div><div class=\"line\">         PluginUtil.setField(mPackageInfo, &quot;mResources&quot;, newResources);</div><div class=\"line\"></div><div class=\"line\">         //清除一下之前的resource的数据，释放一些内存</div><div class=\"line\">         //因为这个resource有可能还被系统持有着，内存都没被释放</div><div class=\"line\">         clearResoucesDrawableCache(mNowResources);</div><div class=\"line\"></div><div class=\"line\">         mNowResources = newResources;</div><div class=\"line\">         //需要清理mtheme对象，否则通过inflate方式加载资源会报错</div><div class=\"line\">         //如果是activity动态加载插件，则需要把activity的mTheme对象也设置为null</div><div class=\"line\">         PluginUtil.setField(mBaseContext, &quot;mTheme&quot;, null);</div><div class=\"line\">     &#125; catch (Throwable e) &#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>同样是通过一系列反射调用。略。</p>\n<h3 id=\"组件启动\"><a href=\"#组件启动\" class=\"headerlink\" title=\"组件启动\"></a>组件启动</h3><p>和其他一样，这里也是需要进行占桩，不过这里比DroidPlugin的处理要简单点，但是我们需要预先确定。这一点比较麻烦。关于如何占桩，这里不说了，感兴趣的看下weishu的文章。还有一点区别就是，我们这里调用通过Classloader根据类名去获取class信息的。所以我们不需要对Instrumentation进行特别大的修改。详情，看源码吧。</p>\n<h3 id=\"资源冲突\"><a href=\"#资源冲突\" class=\"headerlink\" title=\"资源冲突\"></a>资源冲突</h3><p>这里是通过修改aapt，通过固定资源id前几位的方式做的。关于aapt修改，github上有不少代码，感兴趣的可以看下，这里占个坑。我也没看~~~</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ZeusPlugin很轻量，但是能满足我们的需求，个人感觉是一个不错的选择。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Zygote进程的初始化","date":"2017-01-07T06:49:32.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 前言\n\nZygote进程是Android进程中的核心进程，为啥呢？前面介绍过的进程启动篇中，我们知道，我们的应用进程都是在Zygote进程中fork出来的，这难道还不能证明他的重要性么。\n而Zygote进程是在init进程中，通过解析init.rc文件，启动的。我们看下init.rc中相关的部分。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\nimport /init.${ro.zygote}.rc\n```\n\n没错，就是这个，在Android5.0之后，开始支持64位编译，因为我看的源码是6.0的，那么就看下init.zygote64.rc文件吧。\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    socket zygote stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart media\n    onrestart restart netd\n```\n\n根据init.rc语法中service部分\n\n```\nservice <name> <pathname> [ <argument> ]*\n\t<option>\n\t<option>\n```\n可知，上面指定的路径为/system/bin/app_process64，参数为-Xzygote /system/bin --zygote --start-system-server\n\n而android启动中各种命令对应的在/framework/base/cmds下，而这个下面app_process下，只有app_main，一个cpp文件，因此，我么从这个cpp文件说起\n\n### app_main的main函数\n\n代码分段开赛\n\n```\n    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));\n    // Process command line arguments\n    // ignore argv[0]\n    argc--;\n    argv++;\n        int i;\n    for (i = 0; i < argc; i++) {\n        if (argv[i][0] != '-') {\n            break;\n        }\n        if (argv[i][1] == '-' && argv[i][2] == 0) {\n            ++i; // Skip --.\n            break;\n        }\n        runtime.addOption(strdup(argv[i]));\n    }\n```\n\n* 首先创建AppRuntime，也在该文件中，并且保存参数，添加option选项\n\n\n```\n    // Parse runtime arguments.  Stop at first unrecognized option.\n    bool zygote = false;\n    bool startSystemServer = false;\n    bool application = false;\n    String8 niceName;\n    String8 className;\n\n    ++i;  // Skip unused \"parent dir\" argument.\n    while (i < argc) {\n        const char* arg = argv[i++];\n        if (strcmp(arg, \"--zygote\") == 0) {\n            zygote = true;\n            niceName = ZYGOTE_NICE_NAME;\n        } else if (strcmp(arg, \"--start-system-server\") == 0) {\n            startSystemServer = true;\n        } else if (strcmp(arg, \"--application\") == 0) {\n            application = true;\n        } else if (strncmp(arg, \"--nice-name=\", 12) == 0) {\n            niceName.setTo(arg + 12);\n        } else if (strncmp(arg, \"--\", 2) != 0) {\n            className.setTo(arg);\n            break;\n        } else {\n            --i;\n            break;\n        }\n    }\n```\n\n* 对参数进行解析，解析完毕之后，如下\n* niceName ,zygote\n* startSystemServer为true\n* zygote为true\n\n```\n    Vector<String8> args;\n    if (!className.isEmpty()) {\n        // We're not in zygote mode, the only argument we need to pass\n        // to RuntimeInit is the application argument.\n        //\n        // The Remainder of args get passed to startup class main(). Make\n        // copies of them before we overwrite them with the process name.\n        args.add(application ? String8(\"application\") : String8(\"tool\"));\n        runtime.setClassNameAndArgs(className, argc - i, argv + i);\n    } else {\n        // We're in zygote mode.\n        maybeCreateDalvikCache();\n\n        if (startSystemServer) {\n            args.add(String8(\"start-system-server\"));\n        }\n\n        char prop[PROP_VALUE_MAX];\n        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {\n            LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\",\n                ABI_LIST_PROPERTY);\n            return 11;\n        }\n\n        String8 abiFlag(\"--abi-list=\");\n        abiFlag.append(prop);\n        args.add(abiFlag);\n\n        // In zygote mode, pass all remaining arguments to the zygote\n        // main() method.\n        for (; i < argc; ++i) {\n            args.add(String8(argv[i]));\n        }\n    }\n\n    if (!niceName.isEmpty()) {\n        runtime.setArgv0(niceName.string());\n        set_process_name(niceName.string());\n    }\n```\n\n* 准备参数\n* 设置进程nicename\n\n```\n    if (zygote) {\n        runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\n    } else if (className) {\n        runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote);\n    } else {\n        fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\n        app_usage();\n        LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\n        return 10;\n    }\n```\n\n最后，调用runtime.start方法。因为AppRuntime继承了AndroidRuntime,start方法的实现在AndroidRuntime中，因此，我们看AndroidRuntime。\n\n### AndroidRuntime#start 方法\n\n在这个方法中呢，做了很多事情，我们来看代码。\n\n```\n    for (size_t i = 0; i < options.size(); ++i) {\n        if (options[i] == startSystemServer) {\n           /* track our progress through the boot sequence */\n           const int LOG_BOOT_PROGRESS_START = 3000;\n           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));\n        }\n    }\n\n    const char* rootDir = getenv(\"ANDROID_ROOT\");\n    if (rootDir == NULL) {\n        rootDir = \"/system\";\n        if (!hasDir(\"/system\")) {\n            LOG_FATAL(\"No root directory specified, and /android does not exist.\");\n            return;\n        }\n        setenv(\"ANDROID_ROOT\", rootDir, 1);\n    }\n\n    //const char* kernelHack = getenv(\"LD_ASSUME_KERNEL\");\n    //ALOGD(\"Found LD_ASSUME_KERNEL='%s'\\n\", kernelHack);\n\n    /* start the virtual machine */\n    JniInvocation jni_invocation;\n    jni_invocation.Init(NULL);\n    JNIEnv* env;\n    if (startVm(&mJavaVM, &env, zygote) != 0) {\n        return;\n    }\n    onVmCreated(env);\n\n    /*\n     * Register android functions.\n     */\n    if (startReg(env) < 0) {\n        ALOGE(\"Unable to register all android natives\\n\");\n        return;\n    }\n\n    /*\n     * We want to call main() with a String array with arguments in it.\n     * At present we have two arguments, the class name and an option string.\n     * Create an array to hold them.\n     */\n    jclass stringClass;\n    jobjectArray strArray;\n    jstring classNameStr;\n\n    stringClass = env->FindClass(\"java/lang/String\");\n    assert(stringClass != NULL);\n    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);\n    assert(strArray != NULL);\n    classNameStr = env->NewStringUTF(className);\n    assert(classNameStr != NULL);\n    env->SetObjectArrayElement(strArray, 0, classNameStr);\n\n    for (size_t i = 0; i < options.size(); ++i) {\n        jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());\n        assert(optionsStr != NULL);\n        env->SetObjectArrayElement(strArray, i + 1, optionsStr);\n    }\n\n    /*\n     * Start VM.  This thread becomes the main thread of the VM, and will\n     * not return until the VM exits.\n     */\n    char* slashClassName = toSlashClassName(className);\n    jclass startClass = env->FindClass(slashClassName);\n    if (startClass == NULL) {\n        ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName);\n        /* keep going */\n    } else {\n        jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\",\n            \"([Ljava/lang/String;)V\");\n        if (startMeth == NULL) {\n            ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className);\n            /* keep going */\n        } else {\n            env->CallStaticVoidMethod(startClass, startMeth, strArray);\n\n#if 0\n            if (env->ExceptionCheck())\n                threadExitUncaughtException(env);\n#endif\n        }\n    }\n    free(slashClassName);\n```\n\n做了哪些事呢？\n\n* 获取系统目录，设置环境变量\n* startVm 启动虚拟机\n* 调用onVmCreated\n* startReg 注册系统的jni函数,如nativeZygoteInit等\n* 最后调用ZygoteInit的main方法\n\n### ZygoteInit#main\n\n改方法如下\n\n```\n    public static void main(String argv[]) {\n        try {\n            RuntimeInit.enableDdms();\n            // Start profiling the zygote initialization.\n            SamplingProfilerIntegration.start();\n\n            boolean startSystemServer = false;\n            String socketName = \"zygote\";\n            String abiList = null;\n            for (int i = 1; i < argv.length; i++) {\n                if (\"start-system-server\".equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n                }\n            }\n\n            if (abiList == null) {\n                throw new RuntimeException(\"No ABI list supplied.\");\n            }\n\n            registerZygoteSocket(socketName);\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,\n                SystemClock.uptimeMillis());\n            preload();\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,\n                SystemClock.uptimeMillis());\n\n            // Finish profiling the zygote initialization.\n            SamplingProfilerIntegration.writeZygoteSnapshot();\n\n            // Do an initial gc to clean up after startup\n            gcAndFinalize();\n\n            // Disable tracing so that forked processes do not inherit stale tracing tags from\n            // Zygote.\n            Trace.setTracingEnabled(false);\n\n            if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n            }\n\n            Log.i(TAG, \"Accepting command socket connections\");\n            runSelectLoop(abiList);\n\n            closeServerSocket();\n        } catch (MethodAndArgsCaller caller) {\n            caller.run();\n        } catch (RuntimeException ex) {\n            Log.e(TAG, \"Zygote died with exception\", ex);\n            closeServerSocket();\n            throw ex;\n        }\n    }\n```\n\n* 根据传入的参数初始化一些参数，\n* registerZygoteSocket 注册zygote socket\n* preload 预加载一些东西\n* startSystemServer 启动SystemServer进程\n* runSelectLoop进入循环，监听连接、入去参数，fork进程\n\n在registerZygoteSocket中，会创建本地socket 服务端。\n\n### ZygoteInit#preload\n\n```\n    static void preload() {\n        Log.d(TAG, \"begin preload\");\n        preloadClasses();\n        preloadResources();\n        preloadOpenGL();\n        preloadSharedLibraries();\n        preloadTextResources();\n        // Ask the WebViewFactory to do any initialization that must run in the zygote process,\n        // for memory sharing purposes.\n        WebViewFactory.prepareWebViewInZygote();\n        Log.d(TAG, \"end preload\");\n    }\n```\n\n* preloadClasses,加载/system/etc/preloaded-classes文件中的类\n* preloadResources家在系统资源，preloaded_drawables和preloaded_color_state_lists\n* preloadOpenGL 加载opengl\n* preloadSharedLibraries，加载android，compiler_rt，jnigraphics三个共享库\n* preloadTextResources 记载超文本链接符号，大概就是哪些标签吧，我们textview加载html.\n* 预加载webview用到的一些东西\n\n\n### ZygoteInit#runSelectLoop\n\n这个讲进程启动的时候，已经说到过了，这里就不细说了，就是不断监听socket客户端的接入，并且读取参数，进行fork进程。\n\n### 遗留\n\n关于SystemServer的启动，留在下篇吧。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Zygote进程的初始化.md","raw":"---\ntitle: Zygote进程的初始化\ndate: 2017-01-07 14:49:32\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n\n### 前言\n\nZygote进程是Android进程中的核心进程，为啥呢？前面介绍过的进程启动篇中，我们知道，我们的应用进程都是在Zygote进程中fork出来的，这难道还不能证明他的重要性么。\n而Zygote进程是在init进程中，通过解析init.rc文件，启动的。我们看下init.rc中相关的部分。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\nimport /init.${ro.zygote}.rc\n```\n\n没错，就是这个，在Android5.0之后，开始支持64位编译，因为我看的源码是6.0的，那么就看下init.zygote64.rc文件吧。\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    socket zygote stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart media\n    onrestart restart netd\n```\n\n根据init.rc语法中service部分\n\n```\nservice <name> <pathname> [ <argument> ]*\n\t<option>\n\t<option>\n```\n可知，上面指定的路径为/system/bin/app_process64，参数为-Xzygote /system/bin --zygote --start-system-server\n\n而android启动中各种命令对应的在/framework/base/cmds下，而这个下面app_process下，只有app_main，一个cpp文件，因此，我么从这个cpp文件说起\n\n### app_main的main函数\n\n代码分段开赛\n\n```\n    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));\n    // Process command line arguments\n    // ignore argv[0]\n    argc--;\n    argv++;\n        int i;\n    for (i = 0; i < argc; i++) {\n        if (argv[i][0] != '-') {\n            break;\n        }\n        if (argv[i][1] == '-' && argv[i][2] == 0) {\n            ++i; // Skip --.\n            break;\n        }\n        runtime.addOption(strdup(argv[i]));\n    }\n```\n\n* 首先创建AppRuntime，也在该文件中，并且保存参数，添加option选项\n\n\n```\n    // Parse runtime arguments.  Stop at first unrecognized option.\n    bool zygote = false;\n    bool startSystemServer = false;\n    bool application = false;\n    String8 niceName;\n    String8 className;\n\n    ++i;  // Skip unused \"parent dir\" argument.\n    while (i < argc) {\n        const char* arg = argv[i++];\n        if (strcmp(arg, \"--zygote\") == 0) {\n            zygote = true;\n            niceName = ZYGOTE_NICE_NAME;\n        } else if (strcmp(arg, \"--start-system-server\") == 0) {\n            startSystemServer = true;\n        } else if (strcmp(arg, \"--application\") == 0) {\n            application = true;\n        } else if (strncmp(arg, \"--nice-name=\", 12) == 0) {\n            niceName.setTo(arg + 12);\n        } else if (strncmp(arg, \"--\", 2) != 0) {\n            className.setTo(arg);\n            break;\n        } else {\n            --i;\n            break;\n        }\n    }\n```\n\n* 对参数进行解析，解析完毕之后，如下\n* niceName ,zygote\n* startSystemServer为true\n* zygote为true\n\n```\n    Vector<String8> args;\n    if (!className.isEmpty()) {\n        // We're not in zygote mode, the only argument we need to pass\n        // to RuntimeInit is the application argument.\n        //\n        // The Remainder of args get passed to startup class main(). Make\n        // copies of them before we overwrite them with the process name.\n        args.add(application ? String8(\"application\") : String8(\"tool\"));\n        runtime.setClassNameAndArgs(className, argc - i, argv + i);\n    } else {\n        // We're in zygote mode.\n        maybeCreateDalvikCache();\n\n        if (startSystemServer) {\n            args.add(String8(\"start-system-server\"));\n        }\n\n        char prop[PROP_VALUE_MAX];\n        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {\n            LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\",\n                ABI_LIST_PROPERTY);\n            return 11;\n        }\n\n        String8 abiFlag(\"--abi-list=\");\n        abiFlag.append(prop);\n        args.add(abiFlag);\n\n        // In zygote mode, pass all remaining arguments to the zygote\n        // main() method.\n        for (; i < argc; ++i) {\n            args.add(String8(argv[i]));\n        }\n    }\n\n    if (!niceName.isEmpty()) {\n        runtime.setArgv0(niceName.string());\n        set_process_name(niceName.string());\n    }\n```\n\n* 准备参数\n* 设置进程nicename\n\n```\n    if (zygote) {\n        runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\n    } else if (className) {\n        runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote);\n    } else {\n        fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\n        app_usage();\n        LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\n        return 10;\n    }\n```\n\n最后，调用runtime.start方法。因为AppRuntime继承了AndroidRuntime,start方法的实现在AndroidRuntime中，因此，我们看AndroidRuntime。\n\n### AndroidRuntime#start 方法\n\n在这个方法中呢，做了很多事情，我们来看代码。\n\n```\n    for (size_t i = 0; i < options.size(); ++i) {\n        if (options[i] == startSystemServer) {\n           /* track our progress through the boot sequence */\n           const int LOG_BOOT_PROGRESS_START = 3000;\n           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));\n        }\n    }\n\n    const char* rootDir = getenv(\"ANDROID_ROOT\");\n    if (rootDir == NULL) {\n        rootDir = \"/system\";\n        if (!hasDir(\"/system\")) {\n            LOG_FATAL(\"No root directory specified, and /android does not exist.\");\n            return;\n        }\n        setenv(\"ANDROID_ROOT\", rootDir, 1);\n    }\n\n    //const char* kernelHack = getenv(\"LD_ASSUME_KERNEL\");\n    //ALOGD(\"Found LD_ASSUME_KERNEL='%s'\\n\", kernelHack);\n\n    /* start the virtual machine */\n    JniInvocation jni_invocation;\n    jni_invocation.Init(NULL);\n    JNIEnv* env;\n    if (startVm(&mJavaVM, &env, zygote) != 0) {\n        return;\n    }\n    onVmCreated(env);\n\n    /*\n     * Register android functions.\n     */\n    if (startReg(env) < 0) {\n        ALOGE(\"Unable to register all android natives\\n\");\n        return;\n    }\n\n    /*\n     * We want to call main() with a String array with arguments in it.\n     * At present we have two arguments, the class name and an option string.\n     * Create an array to hold them.\n     */\n    jclass stringClass;\n    jobjectArray strArray;\n    jstring classNameStr;\n\n    stringClass = env->FindClass(\"java/lang/String\");\n    assert(stringClass != NULL);\n    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);\n    assert(strArray != NULL);\n    classNameStr = env->NewStringUTF(className);\n    assert(classNameStr != NULL);\n    env->SetObjectArrayElement(strArray, 0, classNameStr);\n\n    for (size_t i = 0; i < options.size(); ++i) {\n        jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());\n        assert(optionsStr != NULL);\n        env->SetObjectArrayElement(strArray, i + 1, optionsStr);\n    }\n\n    /*\n     * Start VM.  This thread becomes the main thread of the VM, and will\n     * not return until the VM exits.\n     */\n    char* slashClassName = toSlashClassName(className);\n    jclass startClass = env->FindClass(slashClassName);\n    if (startClass == NULL) {\n        ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName);\n        /* keep going */\n    } else {\n        jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\",\n            \"([Ljava/lang/String;)V\");\n        if (startMeth == NULL) {\n            ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className);\n            /* keep going */\n        } else {\n            env->CallStaticVoidMethod(startClass, startMeth, strArray);\n\n#if 0\n            if (env->ExceptionCheck())\n                threadExitUncaughtException(env);\n#endif\n        }\n    }\n    free(slashClassName);\n```\n\n做了哪些事呢？\n\n* 获取系统目录，设置环境变量\n* startVm 启动虚拟机\n* 调用onVmCreated\n* startReg 注册系统的jni函数,如nativeZygoteInit等\n* 最后调用ZygoteInit的main方法\n\n### ZygoteInit#main\n\n改方法如下\n\n```\n    public static void main(String argv[]) {\n        try {\n            RuntimeInit.enableDdms();\n            // Start profiling the zygote initialization.\n            SamplingProfilerIntegration.start();\n\n            boolean startSystemServer = false;\n            String socketName = \"zygote\";\n            String abiList = null;\n            for (int i = 1; i < argv.length; i++) {\n                if (\"start-system-server\".equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n                }\n            }\n\n            if (abiList == null) {\n                throw new RuntimeException(\"No ABI list supplied.\");\n            }\n\n            registerZygoteSocket(socketName);\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,\n                SystemClock.uptimeMillis());\n            preload();\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,\n                SystemClock.uptimeMillis());\n\n            // Finish profiling the zygote initialization.\n            SamplingProfilerIntegration.writeZygoteSnapshot();\n\n            // Do an initial gc to clean up after startup\n            gcAndFinalize();\n\n            // Disable tracing so that forked processes do not inherit stale tracing tags from\n            // Zygote.\n            Trace.setTracingEnabled(false);\n\n            if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n            }\n\n            Log.i(TAG, \"Accepting command socket connections\");\n            runSelectLoop(abiList);\n\n            closeServerSocket();\n        } catch (MethodAndArgsCaller caller) {\n            caller.run();\n        } catch (RuntimeException ex) {\n            Log.e(TAG, \"Zygote died with exception\", ex);\n            closeServerSocket();\n            throw ex;\n        }\n    }\n```\n\n* 根据传入的参数初始化一些参数，\n* registerZygoteSocket 注册zygote socket\n* preload 预加载一些东西\n* startSystemServer 启动SystemServer进程\n* runSelectLoop进入循环，监听连接、入去参数，fork进程\n\n在registerZygoteSocket中，会创建本地socket 服务端。\n\n### ZygoteInit#preload\n\n```\n    static void preload() {\n        Log.d(TAG, \"begin preload\");\n        preloadClasses();\n        preloadResources();\n        preloadOpenGL();\n        preloadSharedLibraries();\n        preloadTextResources();\n        // Ask the WebViewFactory to do any initialization that must run in the zygote process,\n        // for memory sharing purposes.\n        WebViewFactory.prepareWebViewInZygote();\n        Log.d(TAG, \"end preload\");\n    }\n```\n\n* preloadClasses,加载/system/etc/preloaded-classes文件中的类\n* preloadResources家在系统资源，preloaded_drawables和preloaded_color_state_lists\n* preloadOpenGL 加载opengl\n* preloadSharedLibraries，加载android，compiler_rt，jnigraphics三个共享库\n* preloadTextResources 记载超文本链接符号，大概就是哪些标签吧，我们textview加载html.\n* 预加载webview用到的一些东西\n\n\n### ZygoteInit#runSelectLoop\n\n这个讲进程启动的时候，已经说到过了，这里就不细说了，就是不断监听socket客户端的接入，并且读取参数，进行fork进程。\n\n### 遗留\n\n关于SystemServer的启动，留在下篇吧。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Zygote进程的初始化","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyh002i19fyst01z3iy","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Zygote进程是Android进程中的核心进程，为啥呢？前面介绍过的进程启动篇中，我们知道，我们的应用进程都是在Zygote进程中fork出来的，这难道还不能证明他的重要性么。<br>而Zygote进程是在init进程中，通过解析init.rc文件，启动的。我们看下init.rc中相关的部分。<br><a id=\"more\"></a></p>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import /init.$&#123;ro.zygote&#125;.rc</div></pre></td></tr></table></figure>\n<p>没错，就是这个，在Android5.0之后，开始支持64位编译，因为我看的源码是6.0的，那么就看下init.zygote64.rc文件吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</div><div class=\"line\">    class main</div><div class=\"line\">    socket zygote stream 660 root system</div><div class=\"line\">    onrestart write /sys/android_power/request_state wake</div><div class=\"line\">    onrestart write /sys/power/state on</div><div class=\"line\">    onrestart restart media</div><div class=\"line\">    onrestart restart netd</div></pre></td></tr></table></figure>\n<p>根据init.rc语法中service部分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</div><div class=\"line\">\t&lt;option&gt;</div><div class=\"line\">\t&lt;option&gt;</div></pre></td></tr></table></figure>\n<p>可知，上面指定的路径为/system/bin/app_process64，参数为-Xzygote /system/bin –zygote –start-system-server</p>\n<p>而android启动中各种命令对应的在/framework/base/cmds下，而这个下面app_process下，只有app_main，一个cpp文件，因此，我么从这个cpp文件说起</p>\n<h3 id=\"app-main的main函数\"><a href=\"#app-main的main函数\" class=\"headerlink\" title=\"app_main的main函数\"></a>app_main的main函数</h3><p>代码分段开赛</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</div><div class=\"line\">// Process command line arguments</div><div class=\"line\">// ignore argv[0]</div><div class=\"line\">argc--;</div><div class=\"line\">argv++;</div><div class=\"line\">    int i;</div><div class=\"line\">for (i = 0; i &lt; argc; i++) &#123;</div><div class=\"line\">    if (argv[i][0] != &apos;-&apos;) &#123;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (argv[i][1] == &apos;-&apos; &amp;&amp; argv[i][2] == 0) &#123;</div><div class=\"line\">        ++i; // Skip --.</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    runtime.addOption(strdup(argv[i]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先创建AppRuntime，也在该文件中，并且保存参数，添加option选项</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Parse runtime arguments.  Stop at first unrecognized option.</div><div class=\"line\">bool zygote = false;</div><div class=\"line\">bool startSystemServer = false;</div><div class=\"line\">bool application = false;</div><div class=\"line\">String8 niceName;</div><div class=\"line\">String8 className;</div><div class=\"line\"></div><div class=\"line\">++i;  // Skip unused &quot;parent dir&quot; argument.</div><div class=\"line\">while (i &lt; argc) &#123;</div><div class=\"line\">    const char* arg = argv[i++];</div><div class=\"line\">    if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;</div><div class=\"line\">        zygote = true;</div><div class=\"line\">        niceName = ZYGOTE_NICE_NAME;</div><div class=\"line\">    &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;</div><div class=\"line\">        startSystemServer = true;</div><div class=\"line\">    &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;</div><div class=\"line\">        application = true;</div><div class=\"line\">    &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;</div><div class=\"line\">        niceName.setTo(arg + 12);</div><div class=\"line\">    &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;</div><div class=\"line\">        className.setTo(arg);</div><div class=\"line\">        break;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        --i;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>对参数进行解析，解析完毕之后，如下</li>\n<li>niceName ,zygote</li>\n<li>startSystemServer为true</li>\n<li>zygote为true</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vector&lt;String8&gt; args;</div><div class=\"line\">if (!className.isEmpty()) &#123;</div><div class=\"line\">    // We&apos;re not in zygote mode, the only argument we need to pass</div><div class=\"line\">    // to RuntimeInit is the application argument.</div><div class=\"line\">    //</div><div class=\"line\">    // The Remainder of args get passed to startup class main(). Make</div><div class=\"line\">    // copies of them before we overwrite them with the process name.</div><div class=\"line\">    args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;));</div><div class=\"line\">    runtime.setClassNameAndArgs(className, argc - i, argv + i);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // We&apos;re in zygote mode.</div><div class=\"line\">    maybeCreateDalvikCache();</div><div class=\"line\"></div><div class=\"line\">    if (startSystemServer) &#123;</div><div class=\"line\">        args.add(String8(&quot;start-system-server&quot;));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    char prop[PROP_VALUE_MAX];</div><div class=\"line\">    if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123;</div><div class=\"line\">        LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;,</div><div class=\"line\">            ABI_LIST_PROPERTY);</div><div class=\"line\">        return 11;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    String8 abiFlag(&quot;--abi-list=&quot;);</div><div class=\"line\">    abiFlag.append(prop);</div><div class=\"line\">    args.add(abiFlag);</div><div class=\"line\"></div><div class=\"line\">    // In zygote mode, pass all remaining arguments to the zygote</div><div class=\"line\">    // main() method.</div><div class=\"line\">    for (; i &lt; argc; ++i) &#123;</div><div class=\"line\">        args.add(String8(argv[i]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!niceName.isEmpty()) &#123;</div><div class=\"line\">    runtime.setArgv0(niceName.string());</div><div class=\"line\">    set_process_name(niceName.string());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>准备参数</li>\n<li>设置进程nicename</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (zygote) &#123;</div><div class=\"line\">    runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</div><div class=\"line\">&#125; else if (className) &#123;</div><div class=\"line\">    runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;);</div><div class=\"line\">    app_usage();</div><div class=\"line\">    LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</div><div class=\"line\">    return 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，调用runtime.start方法。因为AppRuntime继承了AndroidRuntime,start方法的实现在AndroidRuntime中，因此，我们看AndroidRuntime。</p>\n<h3 id=\"AndroidRuntime-start-方法\"><a href=\"#AndroidRuntime-start-方法\" class=\"headerlink\" title=\"AndroidRuntime#start 方法\"></a>AndroidRuntime#start 方法</h3><p>在这个方法中呢，做了很多事情，我们来看代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</div><div class=\"line\">        if (options[i] == startSystemServer) &#123;</div><div class=\"line\">           /* track our progress through the boot sequence */</div><div class=\"line\">           const int LOG_BOOT_PROGRESS_START = 3000;</div><div class=\"line\">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);</div><div class=\"line\">    if (rootDir == NULL) &#123;</div><div class=\"line\">        rootDir = &quot;/system&quot;;</div><div class=\"line\">        if (!hasDir(&quot;/system&quot;)) &#123;</div><div class=\"line\">            LOG_FATAL(&quot;No root directory specified, and /android does not exist.&quot;);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</div><div class=\"line\">    //ALOGD(&quot;Found LD_ASSUME_KERNEL=&apos;%s&apos;\\n&quot;, kernelHack);</div><div class=\"line\"></div><div class=\"line\">    /* start the virtual machine */</div><div class=\"line\">    JniInvocation jni_invocation;</div><div class=\"line\">    jni_invocation.Init(NULL);</div><div class=\"line\">    JNIEnv* env;</div><div class=\"line\">    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    onVmCreated(env);</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Register android functions.</div><div class=\"line\">     */</div><div class=\"line\">    if (startReg(env) &lt; 0) &#123;</div><div class=\"line\">        ALOGE(&quot;Unable to register all android natives\\n&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * We want to call main() with a String array with arguments in it.</div><div class=\"line\">     * At present we have two arguments, the class name and an option string.</div><div class=\"line\">     * Create an array to hold them.</div><div class=\"line\">     */</div><div class=\"line\">    jclass stringClass;</div><div class=\"line\">    jobjectArray strArray;</div><div class=\"line\">    jstring classNameStr;</div><div class=\"line\"></div><div class=\"line\">    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);</div><div class=\"line\">    assert(stringClass != NULL);</div><div class=\"line\">    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);</div><div class=\"line\">    assert(strArray != NULL);</div><div class=\"line\">    classNameStr = env-&gt;NewStringUTF(className);</div><div class=\"line\">    assert(classNameStr != NULL);</div><div class=\"line\">    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</div><div class=\"line\">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());</div><div class=\"line\">        assert(optionsStr != NULL);</div><div class=\"line\">        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Start VM.  This thread becomes the main thread of the VM, and will</div><div class=\"line\">     * not return until the VM exits.</div><div class=\"line\">     */</div><div class=\"line\">    char* slashClassName = toSlashClassName(className);</div><div class=\"line\">    jclass startClass = env-&gt;FindClass(slashClassName);</div><div class=\"line\">    if (startClass == NULL) &#123;</div><div class=\"line\">        ALOGE(&quot;JavaVM unable to locate class &apos;%s&apos;\\n&quot;, slashClassName);</div><div class=\"line\">        /* keep going */</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</div><div class=\"line\">            &quot;([Ljava/lang/String;)V&quot;);</div><div class=\"line\">        if (startMeth == NULL) &#123;</div><div class=\"line\">            ALOGE(&quot;JavaVM unable to find main() in &apos;%s&apos;\\n&quot;, className);</div><div class=\"line\">            /* keep going */</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">            if (env-&gt;ExceptionCheck())</div><div class=\"line\">                threadExitUncaughtException(env);</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(slashClassName);</div></pre></td></tr></table></figure>\n<p>做了哪些事呢？</p>\n<ul>\n<li>获取系统目录，设置环境变量</li>\n<li>startVm 启动虚拟机</li>\n<li>调用onVmCreated</li>\n<li>startReg 注册系统的jni函数,如nativeZygoteInit等</li>\n<li>最后调用ZygoteInit的main方法</li>\n</ul>\n<h3 id=\"ZygoteInit-main\"><a href=\"#ZygoteInit-main\" class=\"headerlink\" title=\"ZygoteInit#main\"></a>ZygoteInit#main</h3><p>改方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String argv[]) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        RuntimeInit.enableDdms();</div><div class=\"line\">        // Start profiling the zygote initialization.</div><div class=\"line\">        SamplingProfilerIntegration.start();</div><div class=\"line\"></div><div class=\"line\">        boolean startSystemServer = false;</div><div class=\"line\">        String socketName = &quot;zygote&quot;;</div><div class=\"line\">        String abiList = null;</div><div class=\"line\">        for (int i = 1; i &lt; argv.length; i++) &#123;</div><div class=\"line\">            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</div><div class=\"line\">                startSystemServer = true;</div><div class=\"line\">            &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</div><div class=\"line\">                abiList = argv[i].substring(ABI_LIST_ARG.length());</div><div class=\"line\">            &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</div><div class=\"line\">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (abiList == null) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;No ABI list supplied.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        registerZygoteSocket(socketName);</div><div class=\"line\">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">        preload();</div><div class=\"line\">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\"></div><div class=\"line\">        // Finish profiling the zygote initialization.</div><div class=\"line\">        SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class=\"line\"></div><div class=\"line\">        // Do an initial gc to clean up after startup</div><div class=\"line\">        gcAndFinalize();</div><div class=\"line\"></div><div class=\"line\">        // Disable tracing so that forked processes do not inherit stale tracing tags from</div><div class=\"line\">        // Zygote.</div><div class=\"line\">        Trace.setTracingEnabled(false);</div><div class=\"line\"></div><div class=\"line\">        if (startSystemServer) &#123;</div><div class=\"line\">            startSystemServer(abiList, socketName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Log.i(TAG, &quot;Accepting command socket connections&quot;);</div><div class=\"line\">        runSelectLoop(abiList);</div><div class=\"line\"></div><div class=\"line\">        closeServerSocket();</div><div class=\"line\">    &#125; catch (MethodAndArgsCaller caller) &#123;</div><div class=\"line\">        caller.run();</div><div class=\"line\">    &#125; catch (RuntimeException ex) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</div><div class=\"line\">        closeServerSocket();</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据传入的参数初始化一些参数，</li>\n<li>registerZygoteSocket 注册zygote socket</li>\n<li>preload 预加载一些东西</li>\n<li>startSystemServer 启动SystemServer进程</li>\n<li>runSelectLoop进入循环，监听连接、入去参数，fork进程</li>\n</ul>\n<p>在registerZygoteSocket中，会创建本地socket 服务端。</p>\n<h3 id=\"ZygoteInit-preload\"><a href=\"#ZygoteInit-preload\" class=\"headerlink\" title=\"ZygoteInit#preload\"></a>ZygoteInit#preload</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void preload() &#123;</div><div class=\"line\">    Log.d(TAG, &quot;begin preload&quot;);</div><div class=\"line\">    preloadClasses();</div><div class=\"line\">    preloadResources();</div><div class=\"line\">    preloadOpenGL();</div><div class=\"line\">    preloadSharedLibraries();</div><div class=\"line\">    preloadTextResources();</div><div class=\"line\">    // Ask the WebViewFactory to do any initialization that must run in the zygote process,</div><div class=\"line\">    // for memory sharing purposes.</div><div class=\"line\">    WebViewFactory.prepareWebViewInZygote();</div><div class=\"line\">    Log.d(TAG, &quot;end preload&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>preloadClasses,加载/system/etc/preloaded-classes文件中的类</li>\n<li>preloadResources家在系统资源，preloaded_drawables和preloaded_color_state_lists</li>\n<li>preloadOpenGL 加载opengl</li>\n<li>preloadSharedLibraries，加载android，compiler_rt，jnigraphics三个共享库</li>\n<li>preloadTextResources 记载超文本链接符号，大概就是哪些标签吧，我们textview加载html.</li>\n<li>预加载webview用到的一些东西</li>\n</ul>\n<h3 id=\"ZygoteInit-runSelectLoop\"><a href=\"#ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"ZygoteInit#runSelectLoop\"></a>ZygoteInit#runSelectLoop</h3><p>这个讲进程启动的时候，已经说到过了，这里就不细说了，就是不断监听socket客户端的接入，并且读取参数，进行fork进程。</p>\n<h3 id=\"遗留\"><a href=\"#遗留\" class=\"headerlink\" title=\"遗留\"></a>遗留</h3><p>关于SystemServer的启动，留在下篇吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Zygote进程是Android进程中的核心进程，为啥呢？前面介绍过的进程启动篇中，我们知道，我们的应用进程都是在Zygote进程中fork出来的，这难道还不能证明他的重要性么。<br>而Zygote进程是在init进程中，通过解析init.rc文件，启动的。我们看下init.rc中相关的部分。<br>","more":"</p>\n<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import /init.$&#123;ro.zygote&#125;.rc</div></pre></td></tr></table></figure>\n<p>没错，就是这个，在Android5.0之后，开始支持64位编译，因为我看的源码是6.0的，那么就看下init.zygote64.rc文件吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</div><div class=\"line\">    class main</div><div class=\"line\">    socket zygote stream 660 root system</div><div class=\"line\">    onrestart write /sys/android_power/request_state wake</div><div class=\"line\">    onrestart write /sys/power/state on</div><div class=\"line\">    onrestart restart media</div><div class=\"line\">    onrestart restart netd</div></pre></td></tr></table></figure>\n<p>根据init.rc语法中service部分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</div><div class=\"line\">\t&lt;option&gt;</div><div class=\"line\">\t&lt;option&gt;</div></pre></td></tr></table></figure>\n<p>可知，上面指定的路径为/system/bin/app_process64，参数为-Xzygote /system/bin –zygote –start-system-server</p>\n<p>而android启动中各种命令对应的在/framework/base/cmds下，而这个下面app_process下，只有app_main，一个cpp文件，因此，我么从这个cpp文件说起</p>\n<h3 id=\"app-main的main函数\"><a href=\"#app-main的main函数\" class=\"headerlink\" title=\"app_main的main函数\"></a>app_main的main函数</h3><p>代码分段开赛</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</div><div class=\"line\">// Process command line arguments</div><div class=\"line\">// ignore argv[0]</div><div class=\"line\">argc--;</div><div class=\"line\">argv++;</div><div class=\"line\">    int i;</div><div class=\"line\">for (i = 0; i &lt; argc; i++) &#123;</div><div class=\"line\">    if (argv[i][0] != &apos;-&apos;) &#123;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (argv[i][1] == &apos;-&apos; &amp;&amp; argv[i][2] == 0) &#123;</div><div class=\"line\">        ++i; // Skip --.</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    runtime.addOption(strdup(argv[i]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先创建AppRuntime，也在该文件中，并且保存参数，添加option选项</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Parse runtime arguments.  Stop at first unrecognized option.</div><div class=\"line\">bool zygote = false;</div><div class=\"line\">bool startSystemServer = false;</div><div class=\"line\">bool application = false;</div><div class=\"line\">String8 niceName;</div><div class=\"line\">String8 className;</div><div class=\"line\"></div><div class=\"line\">++i;  // Skip unused &quot;parent dir&quot; argument.</div><div class=\"line\">while (i &lt; argc) &#123;</div><div class=\"line\">    const char* arg = argv[i++];</div><div class=\"line\">    if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;</div><div class=\"line\">        zygote = true;</div><div class=\"line\">        niceName = ZYGOTE_NICE_NAME;</div><div class=\"line\">    &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;</div><div class=\"line\">        startSystemServer = true;</div><div class=\"line\">    &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;</div><div class=\"line\">        application = true;</div><div class=\"line\">    &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;</div><div class=\"line\">        niceName.setTo(arg + 12);</div><div class=\"line\">    &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;</div><div class=\"line\">        className.setTo(arg);</div><div class=\"line\">        break;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        --i;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>对参数进行解析，解析完毕之后，如下</li>\n<li>niceName ,zygote</li>\n<li>startSystemServer为true</li>\n<li>zygote为true</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vector&lt;String8&gt; args;</div><div class=\"line\">if (!className.isEmpty()) &#123;</div><div class=\"line\">    // We&apos;re not in zygote mode, the only argument we need to pass</div><div class=\"line\">    // to RuntimeInit is the application argument.</div><div class=\"line\">    //</div><div class=\"line\">    // The Remainder of args get passed to startup class main(). Make</div><div class=\"line\">    // copies of them before we overwrite them with the process name.</div><div class=\"line\">    args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;));</div><div class=\"line\">    runtime.setClassNameAndArgs(className, argc - i, argv + i);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // We&apos;re in zygote mode.</div><div class=\"line\">    maybeCreateDalvikCache();</div><div class=\"line\"></div><div class=\"line\">    if (startSystemServer) &#123;</div><div class=\"line\">        args.add(String8(&quot;start-system-server&quot;));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    char prop[PROP_VALUE_MAX];</div><div class=\"line\">    if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123;</div><div class=\"line\">        LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;,</div><div class=\"line\">            ABI_LIST_PROPERTY);</div><div class=\"line\">        return 11;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    String8 abiFlag(&quot;--abi-list=&quot;);</div><div class=\"line\">    abiFlag.append(prop);</div><div class=\"line\">    args.add(abiFlag);</div><div class=\"line\"></div><div class=\"line\">    // In zygote mode, pass all remaining arguments to the zygote</div><div class=\"line\">    // main() method.</div><div class=\"line\">    for (; i &lt; argc; ++i) &#123;</div><div class=\"line\">        args.add(String8(argv[i]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!niceName.isEmpty()) &#123;</div><div class=\"line\">    runtime.setArgv0(niceName.string());</div><div class=\"line\">    set_process_name(niceName.string());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>准备参数</li>\n<li>设置进程nicename</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (zygote) &#123;</div><div class=\"line\">    runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</div><div class=\"line\">&#125; else if (className) &#123;</div><div class=\"line\">    runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;);</div><div class=\"line\">    app_usage();</div><div class=\"line\">    LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</div><div class=\"line\">    return 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，调用runtime.start方法。因为AppRuntime继承了AndroidRuntime,start方法的实现在AndroidRuntime中，因此，我们看AndroidRuntime。</p>\n<h3 id=\"AndroidRuntime-start-方法\"><a href=\"#AndroidRuntime-start-方法\" class=\"headerlink\" title=\"AndroidRuntime#start 方法\"></a>AndroidRuntime#start 方法</h3><p>在这个方法中呢，做了很多事情，我们来看代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</div><div class=\"line\">        if (options[i] == startSystemServer) &#123;</div><div class=\"line\">           /* track our progress through the boot sequence */</div><div class=\"line\">           const int LOG_BOOT_PROGRESS_START = 3000;</div><div class=\"line\">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);</div><div class=\"line\">    if (rootDir == NULL) &#123;</div><div class=\"line\">        rootDir = &quot;/system&quot;;</div><div class=\"line\">        if (!hasDir(&quot;/system&quot;)) &#123;</div><div class=\"line\">            LOG_FATAL(&quot;No root directory specified, and /android does not exist.&quot;);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</div><div class=\"line\">    //ALOGD(&quot;Found LD_ASSUME_KERNEL=&apos;%s&apos;\\n&quot;, kernelHack);</div><div class=\"line\"></div><div class=\"line\">    /* start the virtual machine */</div><div class=\"line\">    JniInvocation jni_invocation;</div><div class=\"line\">    jni_invocation.Init(NULL);</div><div class=\"line\">    JNIEnv* env;</div><div class=\"line\">    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    onVmCreated(env);</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Register android functions.</div><div class=\"line\">     */</div><div class=\"line\">    if (startReg(env) &lt; 0) &#123;</div><div class=\"line\">        ALOGE(&quot;Unable to register all android natives\\n&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * We want to call main() with a String array with arguments in it.</div><div class=\"line\">     * At present we have two arguments, the class name and an option string.</div><div class=\"line\">     * Create an array to hold them.</div><div class=\"line\">     */</div><div class=\"line\">    jclass stringClass;</div><div class=\"line\">    jobjectArray strArray;</div><div class=\"line\">    jstring classNameStr;</div><div class=\"line\"></div><div class=\"line\">    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);</div><div class=\"line\">    assert(stringClass != NULL);</div><div class=\"line\">    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);</div><div class=\"line\">    assert(strArray != NULL);</div><div class=\"line\">    classNameStr = env-&gt;NewStringUTF(className);</div><div class=\"line\">    assert(classNameStr != NULL);</div><div class=\"line\">    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</div><div class=\"line\">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());</div><div class=\"line\">        assert(optionsStr != NULL);</div><div class=\"line\">        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Start VM.  This thread becomes the main thread of the VM, and will</div><div class=\"line\">     * not return until the VM exits.</div><div class=\"line\">     */</div><div class=\"line\">    char* slashClassName = toSlashClassName(className);</div><div class=\"line\">    jclass startClass = env-&gt;FindClass(slashClassName);</div><div class=\"line\">    if (startClass == NULL) &#123;</div><div class=\"line\">        ALOGE(&quot;JavaVM unable to locate class &apos;%s&apos;\\n&quot;, slashClassName);</div><div class=\"line\">        /* keep going */</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</div><div class=\"line\">            &quot;([Ljava/lang/String;)V&quot;);</div><div class=\"line\">        if (startMeth == NULL) &#123;</div><div class=\"line\">            ALOGE(&quot;JavaVM unable to find main() in &apos;%s&apos;\\n&quot;, className);</div><div class=\"line\">            /* keep going */</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">            if (env-&gt;ExceptionCheck())</div><div class=\"line\">                threadExitUncaughtException(env);</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(slashClassName);</div></pre></td></tr></table></figure>\n<p>做了哪些事呢？</p>\n<ul>\n<li>获取系统目录，设置环境变量</li>\n<li>startVm 启动虚拟机</li>\n<li>调用onVmCreated</li>\n<li>startReg 注册系统的jni函数,如nativeZygoteInit等</li>\n<li>最后调用ZygoteInit的main方法</li>\n</ul>\n<h3 id=\"ZygoteInit-main\"><a href=\"#ZygoteInit-main\" class=\"headerlink\" title=\"ZygoteInit#main\"></a>ZygoteInit#main</h3><p>改方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String argv[]) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        RuntimeInit.enableDdms();</div><div class=\"line\">        // Start profiling the zygote initialization.</div><div class=\"line\">        SamplingProfilerIntegration.start();</div><div class=\"line\"></div><div class=\"line\">        boolean startSystemServer = false;</div><div class=\"line\">        String socketName = &quot;zygote&quot;;</div><div class=\"line\">        String abiList = null;</div><div class=\"line\">        for (int i = 1; i &lt; argv.length; i++) &#123;</div><div class=\"line\">            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</div><div class=\"line\">                startSystemServer = true;</div><div class=\"line\">            &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</div><div class=\"line\">                abiList = argv[i].substring(ABI_LIST_ARG.length());</div><div class=\"line\">            &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</div><div class=\"line\">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (abiList == null) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;No ABI list supplied.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        registerZygoteSocket(socketName);</div><div class=\"line\">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">        preload();</div><div class=\"line\">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\"></div><div class=\"line\">        // Finish profiling the zygote initialization.</div><div class=\"line\">        SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class=\"line\"></div><div class=\"line\">        // Do an initial gc to clean up after startup</div><div class=\"line\">        gcAndFinalize();</div><div class=\"line\"></div><div class=\"line\">        // Disable tracing so that forked processes do not inherit stale tracing tags from</div><div class=\"line\">        // Zygote.</div><div class=\"line\">        Trace.setTracingEnabled(false);</div><div class=\"line\"></div><div class=\"line\">        if (startSystemServer) &#123;</div><div class=\"line\">            startSystemServer(abiList, socketName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Log.i(TAG, &quot;Accepting command socket connections&quot;);</div><div class=\"line\">        runSelectLoop(abiList);</div><div class=\"line\"></div><div class=\"line\">        closeServerSocket();</div><div class=\"line\">    &#125; catch (MethodAndArgsCaller caller) &#123;</div><div class=\"line\">        caller.run();</div><div class=\"line\">    &#125; catch (RuntimeException ex) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</div><div class=\"line\">        closeServerSocket();</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据传入的参数初始化一些参数，</li>\n<li>registerZygoteSocket 注册zygote socket</li>\n<li>preload 预加载一些东西</li>\n<li>startSystemServer 启动SystemServer进程</li>\n<li>runSelectLoop进入循环，监听连接、入去参数，fork进程</li>\n</ul>\n<p>在registerZygoteSocket中，会创建本地socket 服务端。</p>\n<h3 id=\"ZygoteInit-preload\"><a href=\"#ZygoteInit-preload\" class=\"headerlink\" title=\"ZygoteInit#preload\"></a>ZygoteInit#preload</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void preload() &#123;</div><div class=\"line\">    Log.d(TAG, &quot;begin preload&quot;);</div><div class=\"line\">    preloadClasses();</div><div class=\"line\">    preloadResources();</div><div class=\"line\">    preloadOpenGL();</div><div class=\"line\">    preloadSharedLibraries();</div><div class=\"line\">    preloadTextResources();</div><div class=\"line\">    // Ask the WebViewFactory to do any initialization that must run in the zygote process,</div><div class=\"line\">    // for memory sharing purposes.</div><div class=\"line\">    WebViewFactory.prepareWebViewInZygote();</div><div class=\"line\">    Log.d(TAG, &quot;end preload&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>preloadClasses,加载/system/etc/preloaded-classes文件中的类</li>\n<li>preloadResources家在系统资源，preloaded_drawables和preloaded_color_state_lists</li>\n<li>preloadOpenGL 加载opengl</li>\n<li>preloadSharedLibraries，加载android，compiler_rt，jnigraphics三个共享库</li>\n<li>preloadTextResources 记载超文本链接符号，大概就是哪些标签吧，我们textview加载html.</li>\n<li>预加载webview用到的一些东西</li>\n</ul>\n<h3 id=\"ZygoteInit-runSelectLoop\"><a href=\"#ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"ZygoteInit#runSelectLoop\"></a>ZygoteInit#runSelectLoop</h3><p>这个讲进程启动的时候，已经说到过了，这里就不细说了，就是不断监听socket客户端的接入，并且读取参数，进行fork进程。</p>\n<h3 id=\"遗留\"><a href=\"#遗留\" class=\"headerlink\" title=\"遗留\"></a>遗留</h3><p>关于SystemServer的启动，留在下篇吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"activity从创建到显示的简单介绍","date":"2017-11-29T14:38:11.000Z","_content":"<Excerpt in index | 首页摘要>\nactivity是我们平常开发最常用的一个组件，我们有必要了解activity的创建以及显示的过程，这些应该作为我们的储备知识。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### Activity的创建\n\nActivity的创建以及初始化的过程是在ActivityThread#performLaunchActivity方法中，在这个方法中，有以下几个关键点，\n\n* 创建Activity\n* Activity#attach\n* Instrumentation#callActivityOnCreate\n* Activity#performStart\n* Instrumentation#callActivityOnPostCreate\n\n这个地方能看到Activity生命周期的一小部分。我们需要对其中一些点进行学习，在这些点里面都有一些非常重要的操作。\n\n创建Activity的过程就不说了，直接反射。我们重点说下attach方法，\n\n#### Activity#attach\n\nattach部分代码如下\n\n```\n        mWindow = new PhoneWindow(this, window);\n        mWindow.setWindowControllerCallback(this);\n        mWindow.setCallback(this);\n        mWindow.setOnWindowDismissedCallback(this);\n        mWindow.getLayoutInflater().setPrivateFactory(this);\n```\n\n在Activity的attach方法中，很关键的一点就是初始化Window，从这里就能看到，Window的实现类，是PhoneWindow。PhoneWindow的创建对于我们后面的操作很重要。\n\n#### Activity#onCreate\n\n```\n    public void callActivityOnCreate(Activity activity, Bundle icicle,\n            PersistableBundle persistentState) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle, persistentState);\n        postPerformCreate(activity);\n    }\n```\n\n在activity.performCreate中，会调用activity的onCreate方法，这个是我们平常开发中非常熟悉的，在onCreate中，我们调用setContentView去填充布局，并进行一些初始化操作\n\n#### setContentView\n\n到了我们相当熟悉的setContentView,在setContentView中，会调用PhoneWindow的setContentView方法。我们简单看下PhoneWindow的setContentView\n\n```\n    public void setContentView(int layoutResID) {\n        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window\n        // decor, when theme attributes and the like are crystalized. Do not check the feature\n        // before this happens.\n        if (mContentParent == null) {\n            installDecor();\n        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n            mContentParent.removeAllViews();\n        }\n\n        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                    getContext());\n            transitionTo(newScene);\n        } else {\n            mLayoutInflater.inflate(layoutResID, mContentParent);\n        }\n        mContentParent.requestApplyInsets();\n        final Callback cb = getCallback();\n        if (cb != null && !isDestroyed()) {\n            cb.onContentChanged();\n        }\n        mContentParentExplicitlySet = true;\n    }\n```\n\n在PhoneWindoe的setContentView方法中，会进行初始化DecorView，并将我们设置的布局加载到contentparent中。installDecor的具体逻辑我们这里就不多说了。\n\n\n### resume过程\n\n在ActivityThread#handleResumeActivity方法中，有两个关键点。\n\n* performResumeActivity\n* Window#addView\n\nperformResumeActivity中会调用activity的performResume，performResume中会调用onResume，然后进入onresume声明周期中\n\n我们重点说下addView以及后续的处理。\n\n#### addView\n\n\n```\nwm.addView(decor, l);\n```\n这里的wm是WindowManager，是在attach法法中，通过setWindowManager来实现初始化的，对应的实例为WindowManagerImpl的一个实例。那么，我们去看下WindoeManageImpl的addView方法,在这个方法中，直接调用WindowManagerGlobal的addView方法，我们关心的中点转移了。其中最关键的diam是如下几行。\n\n\n```\n            root = new ViewRootImpl(view.getContext(), display);\n\n            view.setLayoutParams(wparams);\n\n            mViews.add(view);\n            mRoots.add(root);\n            mParams.add(wparams);\n            root.setView(view, wparams, panelParentView);\n```\n\n首先创建一个ViewRootImpl，然后setView。ViewRootImpl#setView方法代码较长，我们能发现requestLayout这个方法，进去看下。\n\n\n```\n    @Override\n    public void requestLayout() {\n        if (!mHandlingLayoutInLayoutRequest) {\n            checkThread();\n            mLayoutRequested = true;\n            scheduleTraversals();\n        }\n    }\n```\n在这里，进行了首次线程检查。\n\n```\n    void scheduleTraversals() {\n        if (!mTraversalScheduled) {\n            mTraversalScheduled = true;\n            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n            mChoreographer.postCallback(\n                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n            if (!mUnbufferedInputDispatch) {\n                scheduleConsumeBatchedInput();\n            }\n            notifyRendererOfFramePending();\n            pokeDrawLockIfNeeded();\n        }\n    }\n```\nChoreographer,post了一个Callback，这个callback是view刷新的核心所在。我们看下TraversalRunnable的run方法，\n\n```\n    final class TraversalRunnable implements Runnable {\n        @Override\n        public void run() {\n            doTraversal();\n        }\n    }\n```\n\n```\n    void doTraversal() {\n        if (mTraversalScheduled) {\n            mTraversalScheduled = false;\n            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n\n            if (mProfile) {\n                Debug.startMethodTracing(\"ViewAncestor\");\n            }\n\n            performTraversals();\n\n            if (mProfile) {\n                Debug.stopMethodTracing();\n                mProfile = false;\n            }\n        }\n    }\n```\n\n\n在doTraversal中，又会调用performTraversals方法，我们看下performTraversals方法是干啥的。这个方法非常非常的长，但是在这个方法中，有非常关键的performMeasure，performLayout，performDraw等方法，至此，进入的View的的三大过程，，三大过程之后，就显示在我们面前了。\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/activity从创建到显示的简单介绍.md","raw":"---\ntitle: activity从创建到显示的简单介绍\ndate: 2017-11-29 22:38:11\ntags: Android源码\ncategories: Android\n\n---\n<Excerpt in index | 首页摘要>\nactivity是我们平常开发最常用的一个组件，我们有必要了解activity的创建以及显示的过程，这些应该作为我们的储备知识。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### Activity的创建\n\nActivity的创建以及初始化的过程是在ActivityThread#performLaunchActivity方法中，在这个方法中，有以下几个关键点，\n\n* 创建Activity\n* Activity#attach\n* Instrumentation#callActivityOnCreate\n* Activity#performStart\n* Instrumentation#callActivityOnPostCreate\n\n这个地方能看到Activity生命周期的一小部分。我们需要对其中一些点进行学习，在这些点里面都有一些非常重要的操作。\n\n创建Activity的过程就不说了，直接反射。我们重点说下attach方法，\n\n#### Activity#attach\n\nattach部分代码如下\n\n```\n        mWindow = new PhoneWindow(this, window);\n        mWindow.setWindowControllerCallback(this);\n        mWindow.setCallback(this);\n        mWindow.setOnWindowDismissedCallback(this);\n        mWindow.getLayoutInflater().setPrivateFactory(this);\n```\n\n在Activity的attach方法中，很关键的一点就是初始化Window，从这里就能看到，Window的实现类，是PhoneWindow。PhoneWindow的创建对于我们后面的操作很重要。\n\n#### Activity#onCreate\n\n```\n    public void callActivityOnCreate(Activity activity, Bundle icicle,\n            PersistableBundle persistentState) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle, persistentState);\n        postPerformCreate(activity);\n    }\n```\n\n在activity.performCreate中，会调用activity的onCreate方法，这个是我们平常开发中非常熟悉的，在onCreate中，我们调用setContentView去填充布局，并进行一些初始化操作\n\n#### setContentView\n\n到了我们相当熟悉的setContentView,在setContentView中，会调用PhoneWindow的setContentView方法。我们简单看下PhoneWindow的setContentView\n\n```\n    public void setContentView(int layoutResID) {\n        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window\n        // decor, when theme attributes and the like are crystalized. Do not check the feature\n        // before this happens.\n        if (mContentParent == null) {\n            installDecor();\n        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n            mContentParent.removeAllViews();\n        }\n\n        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                    getContext());\n            transitionTo(newScene);\n        } else {\n            mLayoutInflater.inflate(layoutResID, mContentParent);\n        }\n        mContentParent.requestApplyInsets();\n        final Callback cb = getCallback();\n        if (cb != null && !isDestroyed()) {\n            cb.onContentChanged();\n        }\n        mContentParentExplicitlySet = true;\n    }\n```\n\n在PhoneWindoe的setContentView方法中，会进行初始化DecorView，并将我们设置的布局加载到contentparent中。installDecor的具体逻辑我们这里就不多说了。\n\n\n### resume过程\n\n在ActivityThread#handleResumeActivity方法中，有两个关键点。\n\n* performResumeActivity\n* Window#addView\n\nperformResumeActivity中会调用activity的performResume，performResume中会调用onResume，然后进入onresume声明周期中\n\n我们重点说下addView以及后续的处理。\n\n#### addView\n\n\n```\nwm.addView(decor, l);\n```\n这里的wm是WindowManager，是在attach法法中，通过setWindowManager来实现初始化的，对应的实例为WindowManagerImpl的一个实例。那么，我们去看下WindoeManageImpl的addView方法,在这个方法中，直接调用WindowManagerGlobal的addView方法，我们关心的中点转移了。其中最关键的diam是如下几行。\n\n\n```\n            root = new ViewRootImpl(view.getContext(), display);\n\n            view.setLayoutParams(wparams);\n\n            mViews.add(view);\n            mRoots.add(root);\n            mParams.add(wparams);\n            root.setView(view, wparams, panelParentView);\n```\n\n首先创建一个ViewRootImpl，然后setView。ViewRootImpl#setView方法代码较长，我们能发现requestLayout这个方法，进去看下。\n\n\n```\n    @Override\n    public void requestLayout() {\n        if (!mHandlingLayoutInLayoutRequest) {\n            checkThread();\n            mLayoutRequested = true;\n            scheduleTraversals();\n        }\n    }\n```\n在这里，进行了首次线程检查。\n\n```\n    void scheduleTraversals() {\n        if (!mTraversalScheduled) {\n            mTraversalScheduled = true;\n            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n            mChoreographer.postCallback(\n                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n            if (!mUnbufferedInputDispatch) {\n                scheduleConsumeBatchedInput();\n            }\n            notifyRendererOfFramePending();\n            pokeDrawLockIfNeeded();\n        }\n    }\n```\nChoreographer,post了一个Callback，这个callback是view刷新的核心所在。我们看下TraversalRunnable的run方法，\n\n```\n    final class TraversalRunnable implements Runnable {\n        @Override\n        public void run() {\n            doTraversal();\n        }\n    }\n```\n\n```\n    void doTraversal() {\n        if (mTraversalScheduled) {\n            mTraversalScheduled = false;\n            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n\n            if (mProfile) {\n                Debug.startMethodTracing(\"ViewAncestor\");\n            }\n\n            performTraversals();\n\n            if (mProfile) {\n                Debug.stopMethodTracing();\n                mProfile = false;\n            }\n        }\n    }\n```\n\n\n在doTraversal中，又会调用performTraversals方法，我们看下performTraversals方法是干啥的。这个方法非常非常的长，但是在这个方法中，有非常关键的performMeasure，performLayout，performDraw等方法，至此，进入的View的的三大过程，，三大过程之后，就显示在我们面前了。\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"activity从创建到显示的简单介绍","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyk002l19fyjbg3xd8e","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br>activity是我们平常开发最常用的一个组件，我们有必要了解activity的创建以及显示的过程，这些应该作为我们的储备知识。</excerpt></p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"Activity的创建\"><a href=\"#Activity的创建\" class=\"headerlink\" title=\"Activity的创建\"></a>Activity的创建</h3><p>Activity的创建以及初始化的过程是在ActivityThread#performLaunchActivity方法中，在这个方法中，有以下几个关键点，</p>\n<ul>\n<li>创建Activity</li>\n<li>Activity#attach</li>\n<li>Instrumentation#callActivityOnCreate</li>\n<li>Activity#performStart</li>\n<li>Instrumentation#callActivityOnPostCreate</li>\n</ul>\n<p>这个地方能看到Activity生命周期的一小部分。我们需要对其中一些点进行学习，在这些点里面都有一些非常重要的操作。</p>\n<p>创建Activity的过程就不说了，直接反射。我们重点说下attach方法，</p>\n<h4 id=\"Activity-attach\"><a href=\"#Activity-attach\" class=\"headerlink\" title=\"Activity#attach\"></a>Activity#attach</h4><p>attach部分代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">mWindow = new PhoneWindow(this, window);</div><div class=\"line\">mWindow.setWindowControllerCallback(this);</div><div class=\"line\">mWindow.setCallback(this);</div><div class=\"line\">mWindow.setOnWindowDismissedCallback(this);</div><div class=\"line\">mWindow.getLayoutInflater().setPrivateFactory(this);</div></pre></td></tr></table></figure>\n<p>在Activity的attach方法中，很关键的一点就是初始化Window，从这里就能看到，Window的实现类，是PhoneWindow。PhoneWindow的创建对于我们后面的操作很重要。</p>\n<h4 id=\"Activity-onCreate\"><a href=\"#Activity-onCreate\" class=\"headerlink\" title=\"Activity#onCreate\"></a>Activity#onCreate</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void callActivityOnCreate(Activity activity, Bundle icicle,</div><div class=\"line\">        PersistableBundle persistentState) &#123;</div><div class=\"line\">    prePerformCreate(activity);</div><div class=\"line\">    activity.performCreate(icicle, persistentState);</div><div class=\"line\">    postPerformCreate(activity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在activity.performCreate中，会调用activity的onCreate方法，这个是我们平常开发中非常熟悉的，在onCreate中，我们调用setContentView去填充布局，并进行一些初始化操作</p>\n<h4 id=\"setContentView\"><a href=\"#setContentView\" class=\"headerlink\" title=\"setContentView\"></a>setContentView</h4><p>到了我们相当熟悉的setContentView,在setContentView中，会调用PhoneWindow的setContentView方法。我们简单看下PhoneWindow的setContentView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setContentView(int layoutResID) &#123;</div><div class=\"line\">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</div><div class=\"line\">    // decor, when theme attributes and the like are crystalized. Do not check the feature</div><div class=\"line\">    // before this happens.</div><div class=\"line\">    if (mContentParent == null) &#123;</div><div class=\"line\">        installDecor();</div><div class=\"line\">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class=\"line\">        mContentParent.removeAllViews();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class=\"line\">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class=\"line\">                getContext());</div><div class=\"line\">        transitionTo(newScene);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class=\"line\">    &#125;</div><div class=\"line\">    mContentParent.requestApplyInsets();</div><div class=\"line\">    final Callback cb = getCallback();</div><div class=\"line\">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class=\"line\">        cb.onContentChanged();</div><div class=\"line\">    &#125;</div><div class=\"line\">    mContentParentExplicitlySet = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在PhoneWindoe的setContentView方法中，会进行初始化DecorView，并将我们设置的布局加载到contentparent中。installDecor的具体逻辑我们这里就不多说了。</p>\n<h3 id=\"resume过程\"><a href=\"#resume过程\" class=\"headerlink\" title=\"resume过程\"></a>resume过程</h3><p>在ActivityThread#handleResumeActivity方法中，有两个关键点。</p>\n<ul>\n<li>performResumeActivity</li>\n<li>Window#addView</li>\n</ul>\n<p>performResumeActivity中会调用activity的performResume，performResume中会调用onResume，然后进入onresume声明周期中</p>\n<p>我们重点说下addView以及后续的处理。</p>\n<h4 id=\"addView\"><a href=\"#addView\" class=\"headerlink\" title=\"addView\"></a>addView</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wm.addView(decor, l);</div></pre></td></tr></table></figure>\n<p>这里的wm是WindowManager，是在attach法法中，通过setWindowManager来实现初始化的，对应的实例为WindowManagerImpl的一个实例。那么，我们去看下WindoeManageImpl的addView方法,在这个方法中，直接调用WindowManagerGlobal的addView方法，我们关心的中点转移了。其中最关键的diam是如下几行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">root = new ViewRootImpl(view.getContext(), display);</div><div class=\"line\"></div><div class=\"line\">view.setLayoutParams(wparams);</div><div class=\"line\"></div><div class=\"line\">mViews.add(view);</div><div class=\"line\">mRoots.add(root);</div><div class=\"line\">mParams.add(wparams);</div><div class=\"line\">root.setView(view, wparams, panelParentView);</div></pre></td></tr></table></figure>\n<p>首先创建一个ViewRootImpl，然后setView。ViewRootImpl#setView方法代码较长，我们能发现requestLayout这个方法，进去看下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void requestLayout() &#123;</div><div class=\"line\">    if (!mHandlingLayoutInLayoutRequest) &#123;</div><div class=\"line\">        checkThread();</div><div class=\"line\">        mLayoutRequested = true;</div><div class=\"line\">        scheduleTraversals();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，进行了首次线程检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">void scheduleTraversals() &#123;</div><div class=\"line\">    if (!mTraversalScheduled) &#123;</div><div class=\"line\">        mTraversalScheduled = true;</div><div class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</div><div class=\"line\">        mChoreographer.postCallback(</div><div class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</div><div class=\"line\">        if (!mUnbufferedInputDispatch) &#123;</div><div class=\"line\">            scheduleConsumeBatchedInput();</div><div class=\"line\">        &#125;</div><div class=\"line\">        notifyRendererOfFramePending();</div><div class=\"line\">        pokeDrawLockIfNeeded();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Choreographer,post了一个Callback，这个callback是view刷新的核心所在。我们看下TraversalRunnable的run方法，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">final class TraversalRunnable implements Runnable &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        doTraversal();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">void doTraversal() &#123;</div><div class=\"line\">    if (mTraversalScheduled) &#123;</div><div class=\"line\">        mTraversalScheduled = false;</div><div class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</div><div class=\"line\"></div><div class=\"line\">        if (mProfile) &#123;</div><div class=\"line\">            Debug.startMethodTracing(&quot;ViewAncestor&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        performTraversals();</div><div class=\"line\"></div><div class=\"line\">        if (mProfile) &#123;</div><div class=\"line\">            Debug.stopMethodTracing();</div><div class=\"line\">            mProfile = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在doTraversal中，又会调用performTraversals方法，我们看下performTraversals方法是干啥的。这个方法非常非常的长，但是在这个方法中，有非常关键的performMeasure，performLayout，performDraw等方法，至此，进入的View的的三大过程，，三大过程之后，就显示在我们面前了。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要><br>activity是我们平常开发最常用的一个组件，我们有必要了解activity的创建以及显示的过程，这些应该作为我们的储备知识。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"Activity的创建\"><a href=\"#Activity的创建\" class=\"headerlink\" title=\"Activity的创建\"></a>Activity的创建</h3><p>Activity的创建以及初始化的过程是在ActivityThread#performLaunchActivity方法中，在这个方法中，有以下几个关键点，</p>\n<ul>\n<li>创建Activity</li>\n<li>Activity#attach</li>\n<li>Instrumentation#callActivityOnCreate</li>\n<li>Activity#performStart</li>\n<li>Instrumentation#callActivityOnPostCreate</li>\n</ul>\n<p>这个地方能看到Activity生命周期的一小部分。我们需要对其中一些点进行学习，在这些点里面都有一些非常重要的操作。</p>\n<p>创建Activity的过程就不说了，直接反射。我们重点说下attach方法，</p>\n<h4 id=\"Activity-attach\"><a href=\"#Activity-attach\" class=\"headerlink\" title=\"Activity#attach\"></a>Activity#attach</h4><p>attach部分代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">mWindow = new PhoneWindow(this, window);</div><div class=\"line\">mWindow.setWindowControllerCallback(this);</div><div class=\"line\">mWindow.setCallback(this);</div><div class=\"line\">mWindow.setOnWindowDismissedCallback(this);</div><div class=\"line\">mWindow.getLayoutInflater().setPrivateFactory(this);</div></pre></td></tr></table></figure>\n<p>在Activity的attach方法中，很关键的一点就是初始化Window，从这里就能看到，Window的实现类，是PhoneWindow。PhoneWindow的创建对于我们后面的操作很重要。</p>\n<h4 id=\"Activity-onCreate\"><a href=\"#Activity-onCreate\" class=\"headerlink\" title=\"Activity#onCreate\"></a>Activity#onCreate</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void callActivityOnCreate(Activity activity, Bundle icicle,</div><div class=\"line\">        PersistableBundle persistentState) &#123;</div><div class=\"line\">    prePerformCreate(activity);</div><div class=\"line\">    activity.performCreate(icicle, persistentState);</div><div class=\"line\">    postPerformCreate(activity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在activity.performCreate中，会调用activity的onCreate方法，这个是我们平常开发中非常熟悉的，在onCreate中，我们调用setContentView去填充布局，并进行一些初始化操作</p>\n<h4 id=\"setContentView\"><a href=\"#setContentView\" class=\"headerlink\" title=\"setContentView\"></a>setContentView</h4><p>到了我们相当熟悉的setContentView,在setContentView中，会调用PhoneWindow的setContentView方法。我们简单看下PhoneWindow的setContentView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setContentView(int layoutResID) &#123;</div><div class=\"line\">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</div><div class=\"line\">    // decor, when theme attributes and the like are crystalized. Do not check the feature</div><div class=\"line\">    // before this happens.</div><div class=\"line\">    if (mContentParent == null) &#123;</div><div class=\"line\">        installDecor();</div><div class=\"line\">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class=\"line\">        mContentParent.removeAllViews();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class=\"line\">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class=\"line\">                getContext());</div><div class=\"line\">        transitionTo(newScene);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class=\"line\">    &#125;</div><div class=\"line\">    mContentParent.requestApplyInsets();</div><div class=\"line\">    final Callback cb = getCallback();</div><div class=\"line\">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class=\"line\">        cb.onContentChanged();</div><div class=\"line\">    &#125;</div><div class=\"line\">    mContentParentExplicitlySet = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在PhoneWindoe的setContentView方法中，会进行初始化DecorView，并将我们设置的布局加载到contentparent中。installDecor的具体逻辑我们这里就不多说了。</p>\n<h3 id=\"resume过程\"><a href=\"#resume过程\" class=\"headerlink\" title=\"resume过程\"></a>resume过程</h3><p>在ActivityThread#handleResumeActivity方法中，有两个关键点。</p>\n<ul>\n<li>performResumeActivity</li>\n<li>Window#addView</li>\n</ul>\n<p>performResumeActivity中会调用activity的performResume，performResume中会调用onResume，然后进入onresume声明周期中</p>\n<p>我们重点说下addView以及后续的处理。</p>\n<h4 id=\"addView\"><a href=\"#addView\" class=\"headerlink\" title=\"addView\"></a>addView</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wm.addView(decor, l);</div></pre></td></tr></table></figure>\n<p>这里的wm是WindowManager，是在attach法法中，通过setWindowManager来实现初始化的，对应的实例为WindowManagerImpl的一个实例。那么，我们去看下WindoeManageImpl的addView方法,在这个方法中，直接调用WindowManagerGlobal的addView方法，我们关心的中点转移了。其中最关键的diam是如下几行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">root = new ViewRootImpl(view.getContext(), display);</div><div class=\"line\"></div><div class=\"line\">view.setLayoutParams(wparams);</div><div class=\"line\"></div><div class=\"line\">mViews.add(view);</div><div class=\"line\">mRoots.add(root);</div><div class=\"line\">mParams.add(wparams);</div><div class=\"line\">root.setView(view, wparams, panelParentView);</div></pre></td></tr></table></figure>\n<p>首先创建一个ViewRootImpl，然后setView。ViewRootImpl#setView方法代码较长，我们能发现requestLayout这个方法，进去看下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void requestLayout() &#123;</div><div class=\"line\">    if (!mHandlingLayoutInLayoutRequest) &#123;</div><div class=\"line\">        checkThread();</div><div class=\"line\">        mLayoutRequested = true;</div><div class=\"line\">        scheduleTraversals();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，进行了首次线程检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">void scheduleTraversals() &#123;</div><div class=\"line\">    if (!mTraversalScheduled) &#123;</div><div class=\"line\">        mTraversalScheduled = true;</div><div class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</div><div class=\"line\">        mChoreographer.postCallback(</div><div class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</div><div class=\"line\">        if (!mUnbufferedInputDispatch) &#123;</div><div class=\"line\">            scheduleConsumeBatchedInput();</div><div class=\"line\">        &#125;</div><div class=\"line\">        notifyRendererOfFramePending();</div><div class=\"line\">        pokeDrawLockIfNeeded();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Choreographer,post了一个Callback，这个callback是view刷新的核心所在。我们看下TraversalRunnable的run方法，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">final class TraversalRunnable implements Runnable &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        doTraversal();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">void doTraversal() &#123;</div><div class=\"line\">    if (mTraversalScheduled) &#123;</div><div class=\"line\">        mTraversalScheduled = false;</div><div class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</div><div class=\"line\"></div><div class=\"line\">        if (mProfile) &#123;</div><div class=\"line\">            Debug.startMethodTracing(&quot;ViewAncestor&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        performTraversals();</div><div class=\"line\"></div><div class=\"line\">        if (mProfile) &#123;</div><div class=\"line\">            Debug.stopMethodTracing();</div><div class=\"line\">            mProfile = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在doTraversal中，又会调用performTraversals方法，我们看下performTraversals方法是干啥的。这个方法非常非常的长，但是在这个方法中，有非常关键的performMeasure，performLayout，performDraw等方法，至此，进入的View的的三大过程，，三大过程之后，就显示在我们面前了。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"android应用进程是如何启动的","date":"2017-01-01T16:55:08.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n            if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                    app.processName);\n            checkTime(startTime, \"startProcess: asking zygote to start proc\");\n            Process.ProcessStartResult startResult = Process.start(entryPoint,\n                    app.processName, uid, uid, gids, debugFlags, mountExternal,\n                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                    app.info.dataDir, entryPointArgs);\n```\n\n* 其中entryPoint是进程的运行入口\n\n\n### 2.Process#start\n\n在start方法中，会调用startViaZygote方法。\n\n```\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                  final String niceName,\n                                  final int uid, final int gid,\n                                  final int[] gids,\n                                  int debugFlags, int mountExternal,\n                                  int targetSdkVersion,\n                                  String seInfo,\n                                  String abi,\n                                  String instructionSet,\n                                  String appDataDir,\n                                  String[] extraArgs)\n                                  throws ZygoteStartFailedEx {\n        synchronized(Process.class) {\n            ArrayList<String> argsForZygote = new ArrayList<String>();\n\n            // --runtime-args, --setuid=, --setgid=,\n            // and --setgroups= must go first\n            argsForZygote.add(\"--runtime-args\");\n            argsForZygote.add(\"--setuid=\" + uid);\n            argsForZygote.add(\"--setgid=\" + gid);\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {\n                argsForZygote.add(\"--enable-jni-logging\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {\n                argsForZygote.add(\"--enable-safemode\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {\n                argsForZygote.add(\"--enable-debugger\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {\n                argsForZygote.add(\"--enable-checkjni\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JIT) != 0) {\n                argsForZygote.add(\"--enable-jit\");\n            }\n            if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {\n                argsForZygote.add(\"--generate-debug-info\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {\n                argsForZygote.add(\"--enable-assert\");\n            }\n            if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {\n                argsForZygote.add(\"--mount-external-default\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {\n                argsForZygote.add(\"--mount-external-read\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {\n                argsForZygote.add(\"--mount-external-write\");\n            }\n            argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion);\n\n            //TODO optionally enable debuger\n            //argsForZygote.add(\"--enable-debugger\");\n\n            // --setgroups is a comma-separated list\n            if (gids != null && gids.length > 0) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(\"--setgroups=\");\n\n                int sz = gids.length;\n                for (int i = 0; i < sz; i++) {\n                    if (i != 0) {\n                        sb.append(',');\n                    }\n                    sb.append(gids[i]);\n                }\n\n                argsForZygote.add(sb.toString());\n            }\n\n            if (niceName != null) {\n                argsForZygote.add(\"--nice-name=\" + niceName);\n            }\n\n            if (seInfo != null) {\n                argsForZygote.add(\"--seinfo=\" + seInfo);\n            }\n\n            if (instructionSet != null) {\n                argsForZygote.add(\"--instruction-set=\" + instructionSet);\n            }\n\n            if (appDataDir != null) {\n                argsForZygote.add(\"--app-data-dir=\" + appDataDir);\n            }\n\n            argsForZygote.add(processClass);\n\n            if (extraArgs != null) {\n                for (String arg : extraArgs) {\n                    argsForZygote.add(arg);\n                }\n            }\n\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n        }\n    }\n```\n在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？\n\n### 3.Process#openZygoteSocketIfNeeded\n\n ```\n     private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n            try {\n                primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n            }\n        }\n\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        // The primary zygote didn't match. Try the secondary.\n        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n            try {\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n            }\n        }\n\n        if (secondaryZygoteState.matches(abi)) {\n            return secondaryZygoteState;\n        }\n\n        throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n    }\n ```\n \n 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。\n \n### 4. Process#zygoteSendArgsAndGetResult\n\n```\n            final BufferedWriter writer = zygoteState.writer;\n            final DataInputStream inputStream = zygoteState.inputStream;\n\n            writer.write(Integer.toString(args.size()));\n            writer.newLine();\n\n            int sz = args.size();\n            for (int i = 0; i < sz; i++) {\n                String arg = args.get(i);\n                if (arg.indexOf('\\n') >= 0) {\n                    throw new ZygoteStartFailedEx(\n                            \"embedded newlines not allowed\");\n                }\n                writer.write(arg);\n                writer.newLine();\n            }\n\n            writer.flush();\n\n            // Should there be a timeout on this?\n            ProcessStartResult result = new ProcessStartResult();\n            result.pid = inputStream.readInt();\n            if (result.pid < 0) {\n                throw new ZygoteStartFailedEx(\"fork() failed\");\n            }\n            result.usingWrapper = inputStream.readBoolean();\n            return result;\n```\n\n在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。\n\n那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。\n\n### 5. ZygoteInit#runSelectLoop\n\n```\n    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(sServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    boolean done = peers.get(i).runOnce();\n                    if (done) {\n                        peers.remove(i);\n                        fds.remove(i);\n                    }\n                }\n            }\n        }\n    }\n```\n\n首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。\n\n### 6.ZygoteConnection#runOnce\n\n```\n   boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n\n        String args[];\n        Arguments parsedArgs = null;\n        FileDescriptor[] descriptors;\n\n        try {\n            args = readArgumentList();\n            descriptors = mSocket.getAncillaryFileDescriptors();\n        } catch (IOException ex) {\n            Log.w(TAG, \"IOException on command socket \" + ex.getMessage());\n            closeSocket();\n            return true;\n        }\n\n        if (args == null) {\n            // EOF reached.\n            closeSocket();\n            return true;\n        }\n\n        /** the stderr of the most recent request, if avail */\n        PrintStream newStderr = null;\n\n        if (descriptors != null && descriptors.length >= 3) {\n            newStderr = new PrintStream(\n                    new FileOutputStream(descriptors[2]));\n        }\n\n        int pid = -1;\n        FileDescriptor childPipeFd = null;\n        FileDescriptor serverPipeFd = null;\n\n        try {\n            parsedArgs = new Arguments(args);\n\n            if (parsedArgs.abiListQuery) {\n                return handleAbiListQuery();\n            }\n\n            if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {\n                throw new ZygoteSecurityException(\"Client may not specify capabilities: \" +\n                        \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) +\n                        \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities));\n            }\n\n            applyUidSecurityPolicy(parsedArgs, peer);\n            applyInvokeWithSecurityPolicy(parsedArgs, peer);\n\n            applyDebuggerSystemProperty(parsedArgs);\n            applyInvokeWithSystemProperty(parsedArgs);\n\n            int[][] rlimits = null;\n\n            if (parsedArgs.rlimits != null) {\n                rlimits = parsedArgs.rlimits.toArray(intArray2d);\n            }\n\n            if (parsedArgs.invokeWith != null) {\n                FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);\n                childPipeFd = pipeFds[1];\n                serverPipeFd = pipeFds[0];\n                Os.fcntlInt(childPipeFd, F_SETFD, 0);\n            }\n\n            /**\n             * In order to avoid leaking descriptors to the Zygote child,\n             * the native code must close the two Zygote socket descriptors\n             * in the child process before it switches from Zygote-root to\n             * the UID and privileges of the application being launched.\n             *\n             * In order to avoid \"bad file descriptor\" errors when the\n             * two LocalSocket objects are closed, the Posix file\n             * descriptors are released via a dup2() call which closes\n             * the socket and substitutes an open descriptor to /dev/null.\n             */\n\n            int [] fdsToClose = { -1, -1 };\n\n            FileDescriptor fd = mSocket.getFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[0] = fd.getInt$();\n            }\n\n            fd = ZygoteInit.getServerSocketFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[1] = fd.getInt$();\n            }\n\n            fd = null;\n\n            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                    parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                    parsedArgs.appDataDir);\n        } catch (ErrnoException ex) {\n            logAndPrintError(newStderr, \"Exception creating pipe\", ex);\n        } catch (IllegalArgumentException ex) {\n            logAndPrintError(newStderr, \"Invalid zygote arguments\", ex);\n        } catch (ZygoteSecurityException ex) {\n            logAndPrintError(newStderr,\n                    \"Zygote security policy prevents request: \", ex);\n        }\n\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n```\n\n* readArgumentList读区启动参数\n* 构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数\n* 随后进行参数检查和配置\n* 调用Zygote.forkAndSpecialize进行fork进程，返回进程id\n\n\n### 7.Zygote#forkAndSpecialize\n\n```\n    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n```\n\n* VM_HOOKS是ZygoteHooks\n* 在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下\n\n\t```\nstatic JNINativeMethod gMethods[] = {\n  NATIVE_METHOD(ZygoteHooks, nativePreFork, \"()J\"),\n  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, \"(JILjava/lang/String;)V\"),\n};\n\t```\n* 然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。\n* 调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。\n\n\n### 8. nativePreFork\n\n```\nstatic jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {\n  Runtime* runtime = Runtime::Current();\n  CHECK(runtime->IsZygote()) << \"runtime instance not started with -Xzygote\";\n\n  runtime->PreZygoteFork();\n\n  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) {\n    // Tracing active, pause it.\n    Trace::Pause();\n  }\n\n  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.\n  return reinterpret_cast<jlong>(ThreadForEnv(env));\n}\n```\n这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略\n\n### 9. nativeForkAndSpecialize\n\n在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。\n\n```\nstatic pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,\n                                     jint debug_flags, jobjectArray javaRlimits,\n                                     jlong permittedCapabilities, jlong effectiveCapabilities,\n                                     jint mount_external,\n                                     jstring java_se_info, jstring java_se_name,\n                                     bool is_system_server, jintArray fdsToClose,\n                                     jstring instructionSet, jstring dataDir) {\n  SetSigChldHandler();\n\n  pid_t pid = fork();\n\n  if (pid == 0) {\n    // The child process.\n    gMallocLeakZygoteChild = 1;\n\n    // Clean up any descriptors which must be closed immediately\n    DetachDescriptors(env, fdsToClose);\n\n    // Keep capabilities across UID change, unless we're staying root.\n    if (uid != 0) {\n      EnableKeepCapabilities(env);\n    }\n\n    DropCapabilitiesBoundingSet(env);\n\n    bool use_native_bridge = !is_system_server && (instructionSet != NULL)\n        && android::NativeBridgeAvailable();\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());\n    }\n    if (use_native_bridge && dataDir == NULL) {\n      // dataDir should never be null if we need to use a native bridge.\n      // In general, dataDir will never be null for normal applications. It can only happen in\n      // special cases (for isolated processes which are not associated with any app). These are\n      // launched by the framework and should not be emulated anyway.\n      use_native_bridge = false;\n      ALOGW(\"Native bridge will not be used because dataDir == NULL.\");\n    }\n\n    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) {\n      ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno));\n      if (errno == ENOTCONN || errno == EROFS) {\n        // When device is actively encrypting, we get ENOTCONN here\n        // since FUSE was mounted before the framework restarted.\n        // When encrypted device is booting, we get EROFS since\n        // FUSE hasn't been created yet by init.\n        // In either case, continue without external storage.\n      } else {\n        ALOGE(\"Cannot continue without emulated storage\");\n        RuntimeAbort(env);\n      }\n    }\n\n    if (!is_system_server) {\n        int rc = createProcessGroup(uid, getpid());\n        if (rc != 0) {\n            if (rc == -EROFS) {\n                ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\");\n            } else {\n                ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc));\n            }\n        }\n    }\n\n    SetGids(env, javaGids);\n\n    SetRLimits(env, javaRlimits);\n\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      ScopedUtfChars data_dir(env, dataDir);\n      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());\n    }\n\n    int rc = setresgid(gid, gid, gid);\n    if (rc == -1) {\n      ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    rc = setresuid(uid, uid, uid);\n    if (rc == -1) {\n      ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    if (NeedsNoRandomizeWorkaround()) {\n        // Work around ARM kernel ASLR lossage (http://b/5817320).\n        int old_personality = personality(0xffffffff);\n        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);\n        if (new_personality == -1) {\n            ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno));\n        }\n    }\n\n    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);\n\n    SetSchedulerPolicy(env);\n\n    const char* se_info_c_str = NULL;\n    ScopedUtfChars* se_info = NULL;\n    if (java_se_info != NULL) {\n        se_info = new ScopedUtfChars(env, java_se_info);\n        se_info_c_str = se_info->c_str();\n        if (se_info_c_str == NULL) {\n          ALOGE(\"se_info_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    const char* se_name_c_str = NULL;\n    ScopedUtfChars* se_name = NULL;\n    if (java_se_name != NULL) {\n        se_name = new ScopedUtfChars(env, java_se_name);\n        se_name_c_str = se_name->c_str();\n        if (se_name_c_str == NULL) {\n          ALOGE(\"se_name_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);\n    if (rc == -1) {\n      ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid,\n            is_system_server, se_info_c_str, se_name_c_str);\n      RuntimeAbort(env);\n    }\n\n    // Make it easier to debug audit logs by setting the main thread's name to the\n    // nice name rather than \"app_process\".\n    if (se_info_c_str == NULL && is_system_server) {\n      se_name_c_str = \"system_server\";\n    }\n    if (se_info_c_str != NULL) {\n      SetThreadName(se_name_c_str);\n    }\n\n    delete se_info;\n    delete se_name;\n\n    UnsetSigChldHandler();\n\n    env->CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,\n                              is_system_server ? NULL : instructionSet);\n    if (env->ExceptionCheck()) {\n      ALOGE(\"Error calling post fork hooks.\");\n      RuntimeAbort(env);\n    }\n  } else if (pid > 0) {\n    // the parent process\n  }\n  return pid;\n}\n```\n\n* 设置子进程的signal信号处理函数 SetSigChldHandler函数\n* fork进程，fork函数\n* pid为0，进入子进程\n\t* DetachDescriptors 关闭清理文件描述符\n\t* SetGids 设置group\n\t* SetRLimits 设置资源限制\n\t* 进行其他的初始化设置\n\t* CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。\n\t* ...\n* 父进程分支，啥也不做\n* 返回pid\t \n当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作\n\n```\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n\n```\n\n我们重点看handleChildProc。\n\n### 10.ZygoteConnection#handleChildProc\n\n在这个方法中，有如下代码。\n\n```\n        if (parsedArgs.invokeWith != null) {\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(),\n                    pipeFd, parsedArgs.remainingArgs);\n        } else {\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                    parsedArgs.remainingArgs, null /* classLoader */);\n        }\n```\n\n大部分情况下，invokeWith为null，所以我们看下面的分支。\n\n\n### 11.RuntimeInit.zygoteInit\n\n```\n    public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n        redirectLogStreams();\n\n        commonInit();\n        nativeZygoteInit();\n        applicationInit(targetSdkVersion, argv, classLoader);\n    }\n```\n\n* 重定向log输出\n* commonInit,进行通用的一些设置如时区。\n* zygote初始化\n* 应用初始化\n\n### 12.nativeZygoteInit\n\n该函数的实现在AndroidRuntime.cpp中，\n\n```\nstatic void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)\n{\n    gCurRuntime->onZygoteInit();\n}\n```\n\n这里onZygoteInit在app_main.cpp中，这里就不多说了。\n\n### 13.RuntimeInit.applicationInit\n\n```\n    private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        // If the application calls System.exit(), terminate the process\n        // immediately without running any shutdown hooks.  It is not possible to\n        // shutdown an Android application gracefully.  Among other things, the\n        // Android runtime shutdown hooks close the Binder driver, which can cause\n        // leftover running threads to crash before the process actually exits.\n        nativeSetExitWithoutCleanup(true);\n\n        // We want to be fairly aggressive about heap utilization, to avoid\n        // holding on to a lot of memory that isn't needed.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);\n        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);\n\n        final Arguments args;\n        try {\n            args = new Arguments(argv);\n        } catch (IllegalArgumentException ex) {\n            Slog.e(TAG, ex.getMessage());\n            // let the process exit\n            return;\n        }\n\n        // The end of of the RuntimeInit event (see #zygoteInit).\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n        // Remaining arguments are passed to the start class's static main\n        invokeStaticMain(args.startClass, args.startArgs, classLoader);\n    }\n```\n\n这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。\n\n```\n    private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        Class<?> cl;\n\n        try {\n            cl = Class.forName(className, true, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(\n                    \"Missing class when invoking static main \" + className,\n                    ex);\n        }\n\n        Method m;\n        try {\n            m = cl.getMethod(\"main\", new Class[] { String[].class });\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(\n                    \"Missing static main on \" + className, ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(\n                    \"Problem getting static main on \" + className, ex);\n        }\n\n        int modifiers = m.getModifiers();\n        if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n            throw new RuntimeException(\n                    \"Main method is not public and static on \" + className);\n        }\n\n        /*\n         * This throw gets caught in ZygoteInit.main(), which responds\n         * by invoking the exception's run() method. This arrangement\n         * clears up all the stack frames that were required in setting\n         * up the process.\n         */\n        throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n    }\n```\n\n注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。\n\n```\n        public void run() {\n            try {\n                mMethod.invoke(null, new Object[] { mArgs });\n            } catch (IllegalAccessException ex) {\n                throw new RuntimeException(ex);\n            } catch (InvocationTargetException ex) {\n                Throwable cause = ex.getCause();\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                } else if (cause instanceof Error) {\n                    throw (Error) cause;\n                }\n                throw new RuntimeException(ex);\n            }\n        }\n```\n\n就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：\n\n在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/android应用进程是如何启动的.md","raw":"---\ntitle: android应用进程是如何启动的\ndate: 2017-01-02 00:55:08\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n            if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                    app.processName);\n            checkTime(startTime, \"startProcess: asking zygote to start proc\");\n            Process.ProcessStartResult startResult = Process.start(entryPoint,\n                    app.processName, uid, uid, gids, debugFlags, mountExternal,\n                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                    app.info.dataDir, entryPointArgs);\n```\n\n* 其中entryPoint是进程的运行入口\n\n\n### 2.Process#start\n\n在start方法中，会调用startViaZygote方法。\n\n```\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                  final String niceName,\n                                  final int uid, final int gid,\n                                  final int[] gids,\n                                  int debugFlags, int mountExternal,\n                                  int targetSdkVersion,\n                                  String seInfo,\n                                  String abi,\n                                  String instructionSet,\n                                  String appDataDir,\n                                  String[] extraArgs)\n                                  throws ZygoteStartFailedEx {\n        synchronized(Process.class) {\n            ArrayList<String> argsForZygote = new ArrayList<String>();\n\n            // --runtime-args, --setuid=, --setgid=,\n            // and --setgroups= must go first\n            argsForZygote.add(\"--runtime-args\");\n            argsForZygote.add(\"--setuid=\" + uid);\n            argsForZygote.add(\"--setgid=\" + gid);\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {\n                argsForZygote.add(\"--enable-jni-logging\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {\n                argsForZygote.add(\"--enable-safemode\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {\n                argsForZygote.add(\"--enable-debugger\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {\n                argsForZygote.add(\"--enable-checkjni\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JIT) != 0) {\n                argsForZygote.add(\"--enable-jit\");\n            }\n            if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {\n                argsForZygote.add(\"--generate-debug-info\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {\n                argsForZygote.add(\"--enable-assert\");\n            }\n            if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {\n                argsForZygote.add(\"--mount-external-default\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {\n                argsForZygote.add(\"--mount-external-read\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {\n                argsForZygote.add(\"--mount-external-write\");\n            }\n            argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion);\n\n            //TODO optionally enable debuger\n            //argsForZygote.add(\"--enable-debugger\");\n\n            // --setgroups is a comma-separated list\n            if (gids != null && gids.length > 0) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(\"--setgroups=\");\n\n                int sz = gids.length;\n                for (int i = 0; i < sz; i++) {\n                    if (i != 0) {\n                        sb.append(',');\n                    }\n                    sb.append(gids[i]);\n                }\n\n                argsForZygote.add(sb.toString());\n            }\n\n            if (niceName != null) {\n                argsForZygote.add(\"--nice-name=\" + niceName);\n            }\n\n            if (seInfo != null) {\n                argsForZygote.add(\"--seinfo=\" + seInfo);\n            }\n\n            if (instructionSet != null) {\n                argsForZygote.add(\"--instruction-set=\" + instructionSet);\n            }\n\n            if (appDataDir != null) {\n                argsForZygote.add(\"--app-data-dir=\" + appDataDir);\n            }\n\n            argsForZygote.add(processClass);\n\n            if (extraArgs != null) {\n                for (String arg : extraArgs) {\n                    argsForZygote.add(arg);\n                }\n            }\n\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n        }\n    }\n```\n在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？\n\n### 3.Process#openZygoteSocketIfNeeded\n\n ```\n     private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n            try {\n                primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n            }\n        }\n\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        // The primary zygote didn't match. Try the secondary.\n        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n            try {\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n            }\n        }\n\n        if (secondaryZygoteState.matches(abi)) {\n            return secondaryZygoteState;\n        }\n\n        throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n    }\n ```\n \n 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。\n \n### 4. Process#zygoteSendArgsAndGetResult\n\n```\n            final BufferedWriter writer = zygoteState.writer;\n            final DataInputStream inputStream = zygoteState.inputStream;\n\n            writer.write(Integer.toString(args.size()));\n            writer.newLine();\n\n            int sz = args.size();\n            for (int i = 0; i < sz; i++) {\n                String arg = args.get(i);\n                if (arg.indexOf('\\n') >= 0) {\n                    throw new ZygoteStartFailedEx(\n                            \"embedded newlines not allowed\");\n                }\n                writer.write(arg);\n                writer.newLine();\n            }\n\n            writer.flush();\n\n            // Should there be a timeout on this?\n            ProcessStartResult result = new ProcessStartResult();\n            result.pid = inputStream.readInt();\n            if (result.pid < 0) {\n                throw new ZygoteStartFailedEx(\"fork() failed\");\n            }\n            result.usingWrapper = inputStream.readBoolean();\n            return result;\n```\n\n在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。\n\n那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。\n\n### 5. ZygoteInit#runSelectLoop\n\n```\n    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(sServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    boolean done = peers.get(i).runOnce();\n                    if (done) {\n                        peers.remove(i);\n                        fds.remove(i);\n                    }\n                }\n            }\n        }\n    }\n```\n\n首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。\n\n### 6.ZygoteConnection#runOnce\n\n```\n   boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n\n        String args[];\n        Arguments parsedArgs = null;\n        FileDescriptor[] descriptors;\n\n        try {\n            args = readArgumentList();\n            descriptors = mSocket.getAncillaryFileDescriptors();\n        } catch (IOException ex) {\n            Log.w(TAG, \"IOException on command socket \" + ex.getMessage());\n            closeSocket();\n            return true;\n        }\n\n        if (args == null) {\n            // EOF reached.\n            closeSocket();\n            return true;\n        }\n\n        /** the stderr of the most recent request, if avail */\n        PrintStream newStderr = null;\n\n        if (descriptors != null && descriptors.length >= 3) {\n            newStderr = new PrintStream(\n                    new FileOutputStream(descriptors[2]));\n        }\n\n        int pid = -1;\n        FileDescriptor childPipeFd = null;\n        FileDescriptor serverPipeFd = null;\n\n        try {\n            parsedArgs = new Arguments(args);\n\n            if (parsedArgs.abiListQuery) {\n                return handleAbiListQuery();\n            }\n\n            if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {\n                throw new ZygoteSecurityException(\"Client may not specify capabilities: \" +\n                        \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) +\n                        \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities));\n            }\n\n            applyUidSecurityPolicy(parsedArgs, peer);\n            applyInvokeWithSecurityPolicy(parsedArgs, peer);\n\n            applyDebuggerSystemProperty(parsedArgs);\n            applyInvokeWithSystemProperty(parsedArgs);\n\n            int[][] rlimits = null;\n\n            if (parsedArgs.rlimits != null) {\n                rlimits = parsedArgs.rlimits.toArray(intArray2d);\n            }\n\n            if (parsedArgs.invokeWith != null) {\n                FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);\n                childPipeFd = pipeFds[1];\n                serverPipeFd = pipeFds[0];\n                Os.fcntlInt(childPipeFd, F_SETFD, 0);\n            }\n\n            /**\n             * In order to avoid leaking descriptors to the Zygote child,\n             * the native code must close the two Zygote socket descriptors\n             * in the child process before it switches from Zygote-root to\n             * the UID and privileges of the application being launched.\n             *\n             * In order to avoid \"bad file descriptor\" errors when the\n             * two LocalSocket objects are closed, the Posix file\n             * descriptors are released via a dup2() call which closes\n             * the socket and substitutes an open descriptor to /dev/null.\n             */\n\n            int [] fdsToClose = { -1, -1 };\n\n            FileDescriptor fd = mSocket.getFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[0] = fd.getInt$();\n            }\n\n            fd = ZygoteInit.getServerSocketFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[1] = fd.getInt$();\n            }\n\n            fd = null;\n\n            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                    parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                    parsedArgs.appDataDir);\n        } catch (ErrnoException ex) {\n            logAndPrintError(newStderr, \"Exception creating pipe\", ex);\n        } catch (IllegalArgumentException ex) {\n            logAndPrintError(newStderr, \"Invalid zygote arguments\", ex);\n        } catch (ZygoteSecurityException ex) {\n            logAndPrintError(newStderr,\n                    \"Zygote security policy prevents request: \", ex);\n        }\n\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n```\n\n* readArgumentList读区启动参数\n* 构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数\n* 随后进行参数检查和配置\n* 调用Zygote.forkAndSpecialize进行fork进程，返回进程id\n\n\n### 7.Zygote#forkAndSpecialize\n\n```\n    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n```\n\n* VM_HOOKS是ZygoteHooks\n* 在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下\n\n\t```\nstatic JNINativeMethod gMethods[] = {\n  NATIVE_METHOD(ZygoteHooks, nativePreFork, \"()J\"),\n  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, \"(JILjava/lang/String;)V\"),\n};\n\t```\n* 然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。\n* 调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。\n\n\n### 8. nativePreFork\n\n```\nstatic jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {\n  Runtime* runtime = Runtime::Current();\n  CHECK(runtime->IsZygote()) << \"runtime instance not started with -Xzygote\";\n\n  runtime->PreZygoteFork();\n\n  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) {\n    // Tracing active, pause it.\n    Trace::Pause();\n  }\n\n  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.\n  return reinterpret_cast<jlong>(ThreadForEnv(env));\n}\n```\n这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略\n\n### 9. nativeForkAndSpecialize\n\n在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。\n\n```\nstatic pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,\n                                     jint debug_flags, jobjectArray javaRlimits,\n                                     jlong permittedCapabilities, jlong effectiveCapabilities,\n                                     jint mount_external,\n                                     jstring java_se_info, jstring java_se_name,\n                                     bool is_system_server, jintArray fdsToClose,\n                                     jstring instructionSet, jstring dataDir) {\n  SetSigChldHandler();\n\n  pid_t pid = fork();\n\n  if (pid == 0) {\n    // The child process.\n    gMallocLeakZygoteChild = 1;\n\n    // Clean up any descriptors which must be closed immediately\n    DetachDescriptors(env, fdsToClose);\n\n    // Keep capabilities across UID change, unless we're staying root.\n    if (uid != 0) {\n      EnableKeepCapabilities(env);\n    }\n\n    DropCapabilitiesBoundingSet(env);\n\n    bool use_native_bridge = !is_system_server && (instructionSet != NULL)\n        && android::NativeBridgeAvailable();\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());\n    }\n    if (use_native_bridge && dataDir == NULL) {\n      // dataDir should never be null if we need to use a native bridge.\n      // In general, dataDir will never be null for normal applications. It can only happen in\n      // special cases (for isolated processes which are not associated with any app). These are\n      // launched by the framework and should not be emulated anyway.\n      use_native_bridge = false;\n      ALOGW(\"Native bridge will not be used because dataDir == NULL.\");\n    }\n\n    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) {\n      ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno));\n      if (errno == ENOTCONN || errno == EROFS) {\n        // When device is actively encrypting, we get ENOTCONN here\n        // since FUSE was mounted before the framework restarted.\n        // When encrypted device is booting, we get EROFS since\n        // FUSE hasn't been created yet by init.\n        // In either case, continue without external storage.\n      } else {\n        ALOGE(\"Cannot continue without emulated storage\");\n        RuntimeAbort(env);\n      }\n    }\n\n    if (!is_system_server) {\n        int rc = createProcessGroup(uid, getpid());\n        if (rc != 0) {\n            if (rc == -EROFS) {\n                ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\");\n            } else {\n                ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc));\n            }\n        }\n    }\n\n    SetGids(env, javaGids);\n\n    SetRLimits(env, javaRlimits);\n\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      ScopedUtfChars data_dir(env, dataDir);\n      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());\n    }\n\n    int rc = setresgid(gid, gid, gid);\n    if (rc == -1) {\n      ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    rc = setresuid(uid, uid, uid);\n    if (rc == -1) {\n      ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    if (NeedsNoRandomizeWorkaround()) {\n        // Work around ARM kernel ASLR lossage (http://b/5817320).\n        int old_personality = personality(0xffffffff);\n        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);\n        if (new_personality == -1) {\n            ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno));\n        }\n    }\n\n    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);\n\n    SetSchedulerPolicy(env);\n\n    const char* se_info_c_str = NULL;\n    ScopedUtfChars* se_info = NULL;\n    if (java_se_info != NULL) {\n        se_info = new ScopedUtfChars(env, java_se_info);\n        se_info_c_str = se_info->c_str();\n        if (se_info_c_str == NULL) {\n          ALOGE(\"se_info_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    const char* se_name_c_str = NULL;\n    ScopedUtfChars* se_name = NULL;\n    if (java_se_name != NULL) {\n        se_name = new ScopedUtfChars(env, java_se_name);\n        se_name_c_str = se_name->c_str();\n        if (se_name_c_str == NULL) {\n          ALOGE(\"se_name_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);\n    if (rc == -1) {\n      ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid,\n            is_system_server, se_info_c_str, se_name_c_str);\n      RuntimeAbort(env);\n    }\n\n    // Make it easier to debug audit logs by setting the main thread's name to the\n    // nice name rather than \"app_process\".\n    if (se_info_c_str == NULL && is_system_server) {\n      se_name_c_str = \"system_server\";\n    }\n    if (se_info_c_str != NULL) {\n      SetThreadName(se_name_c_str);\n    }\n\n    delete se_info;\n    delete se_name;\n\n    UnsetSigChldHandler();\n\n    env->CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,\n                              is_system_server ? NULL : instructionSet);\n    if (env->ExceptionCheck()) {\n      ALOGE(\"Error calling post fork hooks.\");\n      RuntimeAbort(env);\n    }\n  } else if (pid > 0) {\n    // the parent process\n  }\n  return pid;\n}\n```\n\n* 设置子进程的signal信号处理函数 SetSigChldHandler函数\n* fork进程，fork函数\n* pid为0，进入子进程\n\t* DetachDescriptors 关闭清理文件描述符\n\t* SetGids 设置group\n\t* SetRLimits 设置资源限制\n\t* 进行其他的初始化设置\n\t* CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。\n\t* ...\n* 父进程分支，啥也不做\n* 返回pid\t \n当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作\n\n```\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n\n```\n\n我们重点看handleChildProc。\n\n### 10.ZygoteConnection#handleChildProc\n\n在这个方法中，有如下代码。\n\n```\n        if (parsedArgs.invokeWith != null) {\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(),\n                    pipeFd, parsedArgs.remainingArgs);\n        } else {\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                    parsedArgs.remainingArgs, null /* classLoader */);\n        }\n```\n\n大部分情况下，invokeWith为null，所以我们看下面的分支。\n\n\n### 11.RuntimeInit.zygoteInit\n\n```\n    public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n        redirectLogStreams();\n\n        commonInit();\n        nativeZygoteInit();\n        applicationInit(targetSdkVersion, argv, classLoader);\n    }\n```\n\n* 重定向log输出\n* commonInit,进行通用的一些设置如时区。\n* zygote初始化\n* 应用初始化\n\n### 12.nativeZygoteInit\n\n该函数的实现在AndroidRuntime.cpp中，\n\n```\nstatic void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)\n{\n    gCurRuntime->onZygoteInit();\n}\n```\n\n这里onZygoteInit在app_main.cpp中，这里就不多说了。\n\n### 13.RuntimeInit.applicationInit\n\n```\n    private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        // If the application calls System.exit(), terminate the process\n        // immediately without running any shutdown hooks.  It is not possible to\n        // shutdown an Android application gracefully.  Among other things, the\n        // Android runtime shutdown hooks close the Binder driver, which can cause\n        // leftover running threads to crash before the process actually exits.\n        nativeSetExitWithoutCleanup(true);\n\n        // We want to be fairly aggressive about heap utilization, to avoid\n        // holding on to a lot of memory that isn't needed.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);\n        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);\n\n        final Arguments args;\n        try {\n            args = new Arguments(argv);\n        } catch (IllegalArgumentException ex) {\n            Slog.e(TAG, ex.getMessage());\n            // let the process exit\n            return;\n        }\n\n        // The end of of the RuntimeInit event (see #zygoteInit).\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n        // Remaining arguments are passed to the start class's static main\n        invokeStaticMain(args.startClass, args.startArgs, classLoader);\n    }\n```\n\n这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。\n\n```\n    private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        Class<?> cl;\n\n        try {\n            cl = Class.forName(className, true, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(\n                    \"Missing class when invoking static main \" + className,\n                    ex);\n        }\n\n        Method m;\n        try {\n            m = cl.getMethod(\"main\", new Class[] { String[].class });\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(\n                    \"Missing static main on \" + className, ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(\n                    \"Problem getting static main on \" + className, ex);\n        }\n\n        int modifiers = m.getModifiers();\n        if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n            throw new RuntimeException(\n                    \"Main method is not public and static on \" + className);\n        }\n\n        /*\n         * This throw gets caught in ZygoteInit.main(), which responds\n         * by invoking the exception's run() method. This arrangement\n         * clears up all the stack frames that were required in setting\n         * up the process.\n         */\n        throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n    }\n```\n\n注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。\n\n```\n        public void run() {\n            try {\n                mMethod.invoke(null, new Object[] { mArgs });\n            } catch (IllegalAccessException ex) {\n                throw new RuntimeException(ex);\n            } catch (InvocationTargetException ex) {\n                Throwable cause = ex.getCause();\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                } else if (cause instanceof Error) {\n                    throw (Error) cause;\n                }\n                throw new RuntimeException(ex);\n            }\n        }\n```\n\n就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：\n\n在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"android应用进程是如何启动的","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslym002p19fyihgnlu3k","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</div><div class=\"line\">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</div><div class=\"line\">        app.processName);</div><div class=\"line\">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</div><div class=\"line\">Process.ProcessStartResult startResult = Process.start(entryPoint,</div><div class=\"line\">        app.processName, uid, uid, gids, debugFlags, mountExternal,</div><div class=\"line\">        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</div><div class=\"line\">        app.info.dataDir, entryPointArgs);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中entryPoint是进程的运行入口</li>\n</ul>\n<h3 id=\"2-Process-start\"><a href=\"#2-Process-start\" class=\"headerlink\" title=\"2.Process#start\"></a>2.Process#start</h3><p>在start方法中，会调用startViaZygote方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static ProcessStartResult startViaZygote(final String processClass,</div><div class=\"line\">                              final String niceName,</div><div class=\"line\">                              final int uid, final int gid,</div><div class=\"line\">                              final int[] gids,</div><div class=\"line\">                              int debugFlags, int mountExternal,</div><div class=\"line\">                              int targetSdkVersion,</div><div class=\"line\">                              String seInfo,</div><div class=\"line\">                              String abi,</div><div class=\"line\">                              String instructionSet,</div><div class=\"line\">                              String appDataDir,</div><div class=\"line\">                              String[] extraArgs)</div><div class=\"line\">                              throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    synchronized(Process.class) &#123;</div><div class=\"line\">        ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\">        // --runtime-args, --setuid=, --setgid=,</div><div class=\"line\">        // and --setgroups= must go first</div><div class=\"line\">        argsForZygote.add(&quot;--runtime-args&quot;);</div><div class=\"line\">        argsForZygote.add(&quot;--setuid=&quot; + uid);</div><div class=\"line\">        argsForZygote.add(&quot;--setgid=&quot; + gid);</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jni-logging&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-safemode&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-checkjni&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jit&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--generate-debug-info&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-assert&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-default&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-read&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-write&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">        //TODO optionally enable debuger</div><div class=\"line\">        //argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\"></div><div class=\"line\">        // --setgroups is a comma-separated list</div><div class=\"line\">        if (gids != null &amp;&amp; gids.length &gt; 0) &#123;</div><div class=\"line\">            StringBuilder sb = new StringBuilder();</div><div class=\"line\">            sb.append(&quot;--setgroups=&quot;);</div><div class=\"line\"></div><div class=\"line\">            int sz = gids.length;</div><div class=\"line\">            for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">                if (i != 0) &#123;</div><div class=\"line\">                    sb.append(&apos;,&apos;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                sb.append(gids[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            argsForZygote.add(sb.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (niceName != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--nice-name=&quot; + niceName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (seInfo != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--seinfo=&quot; + seInfo);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (instructionSet != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--instruction-set=&quot; + instructionSet);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (appDataDir != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        argsForZygote.add(processClass);</div><div class=\"line\"></div><div class=\"line\">        if (extraArgs != null) &#123;</div><div class=\"line\">            for (String arg : extraArgs) &#123;</div><div class=\"line\">                argsForZygote.add(arg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？</p>\n<h3 id=\"3-Process-openZygoteSocketIfNeeded\"><a href=\"#3-Process-openZygoteSocketIfNeeded\" class=\"headerlink\" title=\"3.Process#openZygoteSocketIfNeeded\"></a>3.Process#openZygoteSocketIfNeeded</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (primaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return primaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The primary zygote didn&apos;t match. Try the secondary.</div><div class=\"line\">    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (secondaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return secondaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。</p>\n<h3 id=\"4-Process-zygoteSendArgsAndGetResult\"><a href=\"#4-Process-zygoteSendArgsAndGetResult\" class=\"headerlink\" title=\"4. Process#zygoteSendArgsAndGetResult\"></a>4. Process#zygoteSendArgsAndGetResult</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">final BufferedWriter writer = zygoteState.writer;</div><div class=\"line\">final DataInputStream inputStream = zygoteState.inputStream;</div><div class=\"line\"></div><div class=\"line\">writer.write(Integer.toString(args.size()));</div><div class=\"line\">writer.newLine();</div><div class=\"line\"></div><div class=\"line\">int sz = args.size();</div><div class=\"line\">for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">    String arg = args.get(i);</div><div class=\"line\">    if (arg.indexOf(&apos;\\n&apos;) &gt;= 0) &#123;</div><div class=\"line\">        throw new ZygoteStartFailedEx(</div><div class=\"line\">                &quot;embedded newlines not allowed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    writer.write(arg);</div><div class=\"line\">    writer.newLine();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">writer.flush();</div><div class=\"line\"></div><div class=\"line\">// Should there be a timeout on this?</div><div class=\"line\">ProcessStartResult result = new ProcessStartResult();</div><div class=\"line\">result.pid = inputStream.readInt();</div><div class=\"line\">if (result.pid &lt; 0) &#123;</div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">result.usingWrapper = inputStream.readBoolean();</div><div class=\"line\">return result;</div></pre></td></tr></table></figure>\n<p>在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。</p>\n<p>那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。</p>\n<h3 id=\"5-ZygoteInit-runSelectLoop\"><a href=\"#5-ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"5. ZygoteInit#runSelectLoop\"></a>5. ZygoteInit#runSelectLoop</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</div><div class=\"line\">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</div><div class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</div><div class=\"line\"></div><div class=\"line\">    fds.add(sServerSocket.getFileDescriptor());</div><div class=\"line\">    peers.add(null);</div><div class=\"line\"></div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</div><div class=\"line\">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</div><div class=\"line\">            pollFds[i] = new StructPollfd();</div><div class=\"line\">            pollFds[i].fd = fds.get(i);</div><div class=\"line\">            pollFds[i].events = (short) POLLIN;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.poll(pollFds, -1);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;poll failed&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class=\"line\">                peers.add(newPeer);</div><div class=\"line\">                fds.add(newPeer.getFileDesciptor());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                boolean done = peers.get(i).runOnce();</div><div class=\"line\">                if (done) &#123;</div><div class=\"line\">                    peers.remove(i);</div><div class=\"line\">                    fds.remove(i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。</p>\n<h3 id=\"6-ZygoteConnection-runOnce\"><a href=\"#6-ZygoteConnection-runOnce\" class=\"headerlink\" title=\"6.ZygoteConnection#runOnce\"></a>6.ZygoteConnection#runOnce</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">     String args[];</div><div class=\"line\">     Arguments parsedArgs = null;</div><div class=\"line\">     FileDescriptor[] descriptors;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         args = readArgumentList();</div><div class=\"line\">         descriptors = mSocket.getAncillaryFileDescriptors();</div><div class=\"line\">     &#125; catch (IOException ex) &#123;</div><div class=\"line\">         Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage());</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     if (args == null) &#123;</div><div class=\"line\">         // EOF reached.</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     /** the stderr of the most recent request, if avail */</div><div class=\"line\">     PrintStream newStderr = null;</div><div class=\"line\"></div><div class=\"line\">     if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123;</div><div class=\"line\">         newStderr = new PrintStream(</div><div class=\"line\">                 new FileOutputStream(descriptors[2]));</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     int pid = -1;</div><div class=\"line\">     FileDescriptor childPipeFd = null;</div><div class=\"line\">     FileDescriptor serverPipeFd = null;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         parsedArgs = new Arguments(args);</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.abiListQuery) &#123;</div><div class=\"line\">             return handleAbiListQuery();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123;</div><div class=\"line\">             throw new ZygoteSecurityException(&quot;Client may not specify capabilities: &quot; +</div><div class=\"line\">                     &quot;permitted=0x&quot; + Long.toHexString(parsedArgs.permittedCapabilities) +</div><div class=\"line\">                     &quot;, effective=0x&quot; + Long.toHexString(parsedArgs.effectiveCapabilities));</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         applyUidSecurityPolicy(parsedArgs, peer);</div><div class=\"line\">         applyInvokeWithSecurityPolicy(parsedArgs, peer);</div><div class=\"line\"></div><div class=\"line\">         applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">         applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">         int[][] rlimits = null;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.rlimits != null) &#123;</div><div class=\"line\">             rlimits = parsedArgs.rlimits.toArray(intArray2d);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">             FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</div><div class=\"line\">             childPipeFd = pipeFds[1];</div><div class=\"line\">             serverPipeFd = pipeFds[0];</div><div class=\"line\">             Os.fcntlInt(childPipeFd, F_SETFD, 0);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         /**</div><div class=\"line\">          * In order to avoid leaking descriptors to the Zygote child,</div><div class=\"line\">          * the native code must close the two Zygote socket descriptors</div><div class=\"line\">          * in the child process before it switches from Zygote-root to</div><div class=\"line\">          * the UID and privileges of the application being launched.</div><div class=\"line\">          *</div><div class=\"line\">          * In order to avoid &quot;bad file descriptor&quot; errors when the</div><div class=\"line\">          * two LocalSocket objects are closed, the Posix file</div><div class=\"line\">          * descriptors are released via a dup2() call which closes</div><div class=\"line\">          * the socket and substitutes an open descriptor to /dev/null.</div><div class=\"line\">          */</div><div class=\"line\"></div><div class=\"line\">         int [] fdsToClose = &#123; -1, -1 &#125;;</div><div class=\"line\"></div><div class=\"line\">         FileDescriptor fd = mSocket.getFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[0] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = ZygoteInit.getServerSocketFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[1] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = null;</div><div class=\"line\"></div><div class=\"line\">         pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class=\"line\">                 parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class=\"line\">                 parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class=\"line\">                 parsedArgs.appDataDir);</div><div class=\"line\">     &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex);</div><div class=\"line\">     &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex);</div><div class=\"line\">     &#125; catch (ZygoteSecurityException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr,</div><div class=\"line\">                 &quot;Zygote security policy prevents request: &quot;, ex);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (pid == 0) &#123;</div><div class=\"line\">             // in child</div><div class=\"line\">             IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">             serverPipeFd = null;</div><div class=\"line\">             handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">             // should never get here, the child is expected to either</div><div class=\"line\">             // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">             return true;</div><div class=\"line\">         &#125; else &#123;</div><div class=\"line\">             // in parent...pid of &lt; 0 means failure</div><div class=\"line\">             IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">             childPipeFd = null;</div><div class=\"line\">             return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">         IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>readArgumentList读区启动参数</li>\n<li>构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数</li>\n<li>随后进行参数检查和配置</li>\n<li>调用Zygote.forkAndSpecialize进行fork进程，返回进程id</li>\n</ul>\n<h3 id=\"7-Zygote-forkAndSpecialize\"><a href=\"#7-Zygote-forkAndSpecialize\" class=\"headerlink\" title=\"7.Zygote#forkAndSpecialize\"></a>7.Zygote#forkAndSpecialize</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();</div><div class=\"line\">    int pid = nativeForkAndSpecialize(</div><div class=\"line\">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class=\"line\">              instructionSet, appDataDir);</div><div class=\"line\">    // Enable tracing as soon as possible for the child process.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\"></div><div class=\"line\">        // Note that this event ends at the end of handleChildProc,</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon();</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>VM_HOOKS是ZygoteHooks</li>\n<li><p>在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePreFork, &quot;()J&quot;),</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, &quot;(JILjava/lang/String;)V&quot;),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。</p>\n</li>\n<li>调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。</li>\n</ul>\n<h3 id=\"8-nativePreFork\"><a href=\"#8-nativePreFork\" class=\"headerlink\" title=\"8. nativePreFork\"></a>8. nativePreFork</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</div><div class=\"line\">  Runtime* runtime = Runtime::Current();</div><div class=\"line\">  CHECK(runtime-&gt;IsZygote()) &lt;&lt; &quot;runtime instance not started with -Xzygote&quot;;</div><div class=\"line\"></div><div class=\"line\">  runtime-&gt;PreZygoteFork();</div><div class=\"line\"></div><div class=\"line\">  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</div><div class=\"line\">    // Tracing active, pause it.</div><div class=\"line\">    Trace::Pause();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.</div><div class=\"line\">  return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略</p>\n<h3 id=\"9-nativeForkAndSpecialize\"><a href=\"#9-nativeForkAndSpecialize\" class=\"headerlink\" title=\"9. nativeForkAndSpecialize\"></a>9. nativeForkAndSpecialize</h3><p>在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div></pre></td><td class=\"code\"><pre><div class=\"line\">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</div><div class=\"line\">                                     jint debug_flags, jobjectArray javaRlimits,</div><div class=\"line\">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</div><div class=\"line\">                                     jint mount_external,</div><div class=\"line\">                                     jstring java_se_info, jstring java_se_name,</div><div class=\"line\">                                     bool is_system_server, jintArray fdsToClose,</div><div class=\"line\">                                     jstring instructionSet, jstring dataDir) &#123;</div><div class=\"line\">  SetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">  pid_t pid = fork();</div><div class=\"line\"></div><div class=\"line\">  if (pid == 0) &#123;</div><div class=\"line\">    // The child process.</div><div class=\"line\">    gMallocLeakZygoteChild = 1;</div><div class=\"line\"></div><div class=\"line\">    // Clean up any descriptors which must be closed immediately</div><div class=\"line\">    DetachDescriptors(env, fdsToClose);</div><div class=\"line\"></div><div class=\"line\">    // Keep capabilities across UID change, unless we&apos;re staying root.</div><div class=\"line\">    if (uid != 0) &#123;</div><div class=\"line\">      EnableKeepCapabilities(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    DropCapabilitiesBoundingSet(env);</div><div class=\"line\"></div><div class=\"line\">    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)</div><div class=\"line\">        &amp;&amp; android::NativeBridgeAvailable();</div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (use_native_bridge &amp;&amp; dataDir == NULL) &#123;</div><div class=\"line\">      // dataDir should never be null if we need to use a native bridge.</div><div class=\"line\">      // In general, dataDir will never be null for normal applications. It can only happen in</div><div class=\"line\">      // special cases (for isolated processes which are not associated with any app). These are</div><div class=\"line\">      // launched by the framework and should not be emulated anyway.</div><div class=\"line\">      use_native_bridge = false;</div><div class=\"line\">      ALOGW(&quot;Native bridge will not be used because dataDir == NULL.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</div><div class=\"line\">      ALOGW(&quot;Failed to mount emulated storage: %s&quot;, strerror(errno));</div><div class=\"line\">      if (errno == ENOTCONN || errno == EROFS) &#123;</div><div class=\"line\">        // When device is actively encrypting, we get ENOTCONN here</div><div class=\"line\">        // since FUSE was mounted before the framework restarted.</div><div class=\"line\">        // When encrypted device is booting, we get EROFS since</div><div class=\"line\">        // FUSE hasn&apos;t been created yet by init.</div><div class=\"line\">        // In either case, continue without external storage.</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        ALOGE(&quot;Cannot continue without emulated storage&quot;);</div><div class=\"line\">        RuntimeAbort(env);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!is_system_server) &#123;</div><div class=\"line\">        int rc = createProcessGroup(uid, getpid());</div><div class=\"line\">        if (rc != 0) &#123;</div><div class=\"line\">            if (rc == -EROFS) &#123;</div><div class=\"line\">                ALOGW(&quot;createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                ALOGE(&quot;createProcessGroup(%d, %d) failed: %s&quot;, uid, pid, strerror(-rc));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetGids(env, javaGids);</div><div class=\"line\"></div><div class=\"line\">    SetRLimits(env, javaRlimits);</div><div class=\"line\"></div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      ScopedUtfChars data_dir(env, dataDir);</div><div class=\"line\">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int rc = setresgid(gid, gid, gid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresgid(%d) failed: %s&quot;, gid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    rc = setresuid(uid, uid, uid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresuid(%d) failed: %s&quot;, uid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (NeedsNoRandomizeWorkaround()) &#123;</div><div class=\"line\">        // Work around ARM kernel ASLR lossage (http://b/5817320).</div><div class=\"line\">        int old_personality = personality(0xffffffff);</div><div class=\"line\">        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</div><div class=\"line\">        if (new_personality == -1) &#123;</div><div class=\"line\">            ALOGW(&quot;personality(%d) failed: %s&quot;, new_personality, strerror(errno));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</div><div class=\"line\"></div><div class=\"line\">    SetSchedulerPolicy(env);</div><div class=\"line\"></div><div class=\"line\">    const char* se_info_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_info = NULL;</div><div class=\"line\">    if (java_se_info != NULL) &#123;</div><div class=\"line\">        se_info = new ScopedUtfChars(env, java_se_info);</div><div class=\"line\">        se_info_c_str = se_info-&gt;c_str();</div><div class=\"line\">        if (se_info_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_info_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const char* se_name_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_name = NULL;</div><div class=\"line\">    if (java_se_name != NULL) &#123;</div><div class=\"line\">        se_name = new ScopedUtfChars(env, java_se_name);</div><div class=\"line\">        se_name_c_str = se_name-&gt;c_str();</div><div class=\"line\">        if (se_name_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_name_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;selinux_android_setcontext(%d, %d, \\&quot;%s\\&quot;, \\&quot;%s\\&quot;) failed&quot;, uid,</div><div class=\"line\">            is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Make it easier to debug audit logs by setting the main thread&apos;s name to the</div><div class=\"line\">    // nice name rather than &quot;app_process&quot;.</div><div class=\"line\">    if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</div><div class=\"line\">      se_name_c_str = &quot;system_server&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (se_info_c_str != NULL) &#123;</div><div class=\"line\">      SetThreadName(se_name_c_str);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    delete se_info;</div><div class=\"line\">    delete se_name;</div><div class=\"line\"></div><div class=\"line\">    UnsetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</div><div class=\"line\">                              is_system_server ? NULL : instructionSet);</div><div class=\"line\">    if (env-&gt;ExceptionCheck()) &#123;</div><div class=\"line\">      ALOGE(&quot;Error calling post fork hooks.&quot;);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else if (pid &gt; 0) &#123;</div><div class=\"line\">    // the parent process</div><div class=\"line\">  &#125;</div><div class=\"line\">  return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>设置子进程的signal信号处理函数 SetSigChldHandler函数</li>\n<li>fork进程，fork函数</li>\n<li>pid为0，进入子进程<ul>\n<li>DetachDescriptors 关闭清理文件描述符</li>\n<li>SetGids 设置group</li>\n<li>SetRLimits 设置资源限制</li>\n<li>进行其他的初始化设置</li>\n<li>CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。</li>\n<li>…</li>\n</ul>\n</li>\n<li>父进程分支，啥也不做</li>\n<li>返回pid<br>当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        // in child</div><div class=\"line\">        IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">        serverPipeFd = null;</div><div class=\"line\">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">        // should never get here, the child is expected to either</div><div class=\"line\">        // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // in parent...pid of &lt; 0 means failure</div><div class=\"line\">        IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">        childPipeFd = null;</div><div class=\"line\">        return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">    IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们重点看handleChildProc。</p>\n<h3 id=\"10-ZygoteConnection-handleChildProc\"><a href=\"#10-ZygoteConnection-handleChildProc\" class=\"headerlink\" title=\"10.ZygoteConnection#handleChildProc\"></a>10.ZygoteConnection#handleChildProc</h3><p>在这个方法中，有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">    WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">            parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">            VMRuntime.getCurrentInstructionSet(),</div><div class=\"line\">            pipeFd, parsedArgs.remainingArgs);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</div><div class=\"line\">            parsedArgs.remainingArgs, null /* classLoader */);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大部分情况下，invokeWith为null，所以我们看下面的分支。</p>\n<h3 id=\"11-RuntimeInit-zygoteInit\"><a href=\"#11-RuntimeInit-zygoteInit\" class=\"headerlink\" title=\"11.RuntimeInit.zygoteInit\"></a>11.RuntimeInit.zygoteInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</div><div class=\"line\"></div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</div><div class=\"line\">    redirectLogStreams();</div><div class=\"line\"></div><div class=\"line\">    commonInit();</div><div class=\"line\">    nativeZygoteInit();</div><div class=\"line\">    applicationInit(targetSdkVersion, argv, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>重定向log输出</li>\n<li>commonInit,进行通用的一些设置如时区。</li>\n<li>zygote初始化</li>\n<li>应用初始化</li>\n</ul>\n<h3 id=\"12-nativeZygoteInit\"><a href=\"#12-nativeZygoteInit\" class=\"headerlink\" title=\"12.nativeZygoteInit\"></a>12.nativeZygoteInit</h3><p>该函数的实现在AndroidRuntime.cpp中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</div><div class=\"line\">&#123;</div><div class=\"line\">    gCurRuntime-&gt;onZygoteInit();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里onZygoteInit在app_main.cpp中，这里就不多说了。</p>\n<h3 id=\"13-RuntimeInit-applicationInit\"><a href=\"#13-RuntimeInit-applicationInit\" class=\"headerlink\" title=\"13.RuntimeInit.applicationInit\"></a>13.RuntimeInit.applicationInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    // If the application calls System.exit(), terminate the process</div><div class=\"line\">    // immediately without running any shutdown hooks.  It is not possible to</div><div class=\"line\">    // shutdown an Android application gracefully.  Among other things, the</div><div class=\"line\">    // Android runtime shutdown hooks close the Binder driver, which can cause</div><div class=\"line\">    // leftover running threads to crash before the process actually exits.</div><div class=\"line\">    nativeSetExitWithoutCleanup(true);</div><div class=\"line\"></div><div class=\"line\">    // We want to be fairly aggressive about heap utilization, to avoid</div><div class=\"line\">    // holding on to a lot of memory that isn&apos;t needed.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</div><div class=\"line\">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">    final Arguments args;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        args = new Arguments(argv);</div><div class=\"line\">    &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">        Slog.e(TAG, ex.getMessage());</div><div class=\"line\">        // let the process exit</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The end of of the RuntimeInit event (see #zygoteInit).</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class=\"line\"></div><div class=\"line\">    // Remaining arguments are passed to the start class&apos;s static main</div><div class=\"line\">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    Class&lt;?&gt; cl;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        cl = Class.forName(className, true, classLoader);</div><div class=\"line\">    &#125; catch (ClassNotFoundException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing class when invoking static main &quot; + className,</div><div class=\"line\">                ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Method m;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</div><div class=\"line\">    &#125; catch (NoSuchMethodException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing static main on &quot; + className, ex);</div><div class=\"line\">    &#125; catch (SecurityException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Problem getting static main on &quot; + className, ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int modifiers = m.getModifiers();</div><div class=\"line\">    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Main method is not public and static on &quot; + className);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * This throw gets caught in ZygoteInit.main(), which responds</div><div class=\"line\">     * by invoking the exception&apos;s run() method. This arrangement</div><div class=\"line\">     * clears up all the stack frames that were required in setting</div><div class=\"line\">     * up the process.</div><div class=\"line\">     */</div><div class=\"line\">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</div><div class=\"line\">    &#125; catch (IllegalAccessException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125; catch (InvocationTargetException ex) &#123;</div><div class=\"line\">        Throwable cause = ex.getCause();</div><div class=\"line\">        if (cause instanceof RuntimeException) &#123;</div><div class=\"line\">            throw (RuntimeException) cause;</div><div class=\"line\">        &#125; else if (cause instanceof Error) &#123;</div><div class=\"line\">            throw (Error) cause;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：</p>\n<p>在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。</p>","more":"<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</div><div class=\"line\">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</div><div class=\"line\">        app.processName);</div><div class=\"line\">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</div><div class=\"line\">Process.ProcessStartResult startResult = Process.start(entryPoint,</div><div class=\"line\">        app.processName, uid, uid, gids, debugFlags, mountExternal,</div><div class=\"line\">        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</div><div class=\"line\">        app.info.dataDir, entryPointArgs);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中entryPoint是进程的运行入口</li>\n</ul>\n<h3 id=\"2-Process-start\"><a href=\"#2-Process-start\" class=\"headerlink\" title=\"2.Process#start\"></a>2.Process#start</h3><p>在start方法中，会调用startViaZygote方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static ProcessStartResult startViaZygote(final String processClass,</div><div class=\"line\">                              final String niceName,</div><div class=\"line\">                              final int uid, final int gid,</div><div class=\"line\">                              final int[] gids,</div><div class=\"line\">                              int debugFlags, int mountExternal,</div><div class=\"line\">                              int targetSdkVersion,</div><div class=\"line\">                              String seInfo,</div><div class=\"line\">                              String abi,</div><div class=\"line\">                              String instructionSet,</div><div class=\"line\">                              String appDataDir,</div><div class=\"line\">                              String[] extraArgs)</div><div class=\"line\">                              throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    synchronized(Process.class) &#123;</div><div class=\"line\">        ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\">        // --runtime-args, --setuid=, --setgid=,</div><div class=\"line\">        // and --setgroups= must go first</div><div class=\"line\">        argsForZygote.add(&quot;--runtime-args&quot;);</div><div class=\"line\">        argsForZygote.add(&quot;--setuid=&quot; + uid);</div><div class=\"line\">        argsForZygote.add(&quot;--setgid=&quot; + gid);</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jni-logging&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-safemode&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-checkjni&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jit&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--generate-debug-info&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-assert&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-default&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-read&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-write&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">        //TODO optionally enable debuger</div><div class=\"line\">        //argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\"></div><div class=\"line\">        // --setgroups is a comma-separated list</div><div class=\"line\">        if (gids != null &amp;&amp; gids.length &gt; 0) &#123;</div><div class=\"line\">            StringBuilder sb = new StringBuilder();</div><div class=\"line\">            sb.append(&quot;--setgroups=&quot;);</div><div class=\"line\"></div><div class=\"line\">            int sz = gids.length;</div><div class=\"line\">            for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">                if (i != 0) &#123;</div><div class=\"line\">                    sb.append(&apos;,&apos;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                sb.append(gids[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            argsForZygote.add(sb.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (niceName != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--nice-name=&quot; + niceName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (seInfo != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--seinfo=&quot; + seInfo);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (instructionSet != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--instruction-set=&quot; + instructionSet);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (appDataDir != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        argsForZygote.add(processClass);</div><div class=\"line\"></div><div class=\"line\">        if (extraArgs != null) &#123;</div><div class=\"line\">            for (String arg : extraArgs) &#123;</div><div class=\"line\">                argsForZygote.add(arg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？</p>\n<h3 id=\"3-Process-openZygoteSocketIfNeeded\"><a href=\"#3-Process-openZygoteSocketIfNeeded\" class=\"headerlink\" title=\"3.Process#openZygoteSocketIfNeeded\"></a>3.Process#openZygoteSocketIfNeeded</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (primaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return primaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The primary zygote didn&apos;t match. Try the secondary.</div><div class=\"line\">    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (secondaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return secondaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。</p>\n<h3 id=\"4-Process-zygoteSendArgsAndGetResult\"><a href=\"#4-Process-zygoteSendArgsAndGetResult\" class=\"headerlink\" title=\"4. Process#zygoteSendArgsAndGetResult\"></a>4. Process#zygoteSendArgsAndGetResult</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">final BufferedWriter writer = zygoteState.writer;</div><div class=\"line\">final DataInputStream inputStream = zygoteState.inputStream;</div><div class=\"line\"></div><div class=\"line\">writer.write(Integer.toString(args.size()));</div><div class=\"line\">writer.newLine();</div><div class=\"line\"></div><div class=\"line\">int sz = args.size();</div><div class=\"line\">for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">    String arg = args.get(i);</div><div class=\"line\">    if (arg.indexOf(&apos;\\n&apos;) &gt;= 0) &#123;</div><div class=\"line\">        throw new ZygoteStartFailedEx(</div><div class=\"line\">                &quot;embedded newlines not allowed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    writer.write(arg);</div><div class=\"line\">    writer.newLine();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">writer.flush();</div><div class=\"line\"></div><div class=\"line\">// Should there be a timeout on this?</div><div class=\"line\">ProcessStartResult result = new ProcessStartResult();</div><div class=\"line\">result.pid = inputStream.readInt();</div><div class=\"line\">if (result.pid &lt; 0) &#123;</div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">result.usingWrapper = inputStream.readBoolean();</div><div class=\"line\">return result;</div></pre></td></tr></table></figure>\n<p>在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。</p>\n<p>那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。</p>\n<h3 id=\"5-ZygoteInit-runSelectLoop\"><a href=\"#5-ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"5. ZygoteInit#runSelectLoop\"></a>5. ZygoteInit#runSelectLoop</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</div><div class=\"line\">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</div><div class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</div><div class=\"line\"></div><div class=\"line\">    fds.add(sServerSocket.getFileDescriptor());</div><div class=\"line\">    peers.add(null);</div><div class=\"line\"></div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</div><div class=\"line\">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</div><div class=\"line\">            pollFds[i] = new StructPollfd();</div><div class=\"line\">            pollFds[i].fd = fds.get(i);</div><div class=\"line\">            pollFds[i].events = (short) POLLIN;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.poll(pollFds, -1);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;poll failed&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class=\"line\">                peers.add(newPeer);</div><div class=\"line\">                fds.add(newPeer.getFileDesciptor());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                boolean done = peers.get(i).runOnce();</div><div class=\"line\">                if (done) &#123;</div><div class=\"line\">                    peers.remove(i);</div><div class=\"line\">                    fds.remove(i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。</p>\n<h3 id=\"6-ZygoteConnection-runOnce\"><a href=\"#6-ZygoteConnection-runOnce\" class=\"headerlink\" title=\"6.ZygoteConnection#runOnce\"></a>6.ZygoteConnection#runOnce</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">     String args[];</div><div class=\"line\">     Arguments parsedArgs = null;</div><div class=\"line\">     FileDescriptor[] descriptors;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         args = readArgumentList();</div><div class=\"line\">         descriptors = mSocket.getAncillaryFileDescriptors();</div><div class=\"line\">     &#125; catch (IOException ex) &#123;</div><div class=\"line\">         Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage());</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     if (args == null) &#123;</div><div class=\"line\">         // EOF reached.</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     /** the stderr of the most recent request, if avail */</div><div class=\"line\">     PrintStream newStderr = null;</div><div class=\"line\"></div><div class=\"line\">     if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123;</div><div class=\"line\">         newStderr = new PrintStream(</div><div class=\"line\">                 new FileOutputStream(descriptors[2]));</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     int pid = -1;</div><div class=\"line\">     FileDescriptor childPipeFd = null;</div><div class=\"line\">     FileDescriptor serverPipeFd = null;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         parsedArgs = new Arguments(args);</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.abiListQuery) &#123;</div><div class=\"line\">             return handleAbiListQuery();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123;</div><div class=\"line\">             throw new ZygoteSecurityException(&quot;Client may not specify capabilities: &quot; +</div><div class=\"line\">                     &quot;permitted=0x&quot; + Long.toHexString(parsedArgs.permittedCapabilities) +</div><div class=\"line\">                     &quot;, effective=0x&quot; + Long.toHexString(parsedArgs.effectiveCapabilities));</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         applyUidSecurityPolicy(parsedArgs, peer);</div><div class=\"line\">         applyInvokeWithSecurityPolicy(parsedArgs, peer);</div><div class=\"line\"></div><div class=\"line\">         applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">         applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">         int[][] rlimits = null;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.rlimits != null) &#123;</div><div class=\"line\">             rlimits = parsedArgs.rlimits.toArray(intArray2d);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">             FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</div><div class=\"line\">             childPipeFd = pipeFds[1];</div><div class=\"line\">             serverPipeFd = pipeFds[0];</div><div class=\"line\">             Os.fcntlInt(childPipeFd, F_SETFD, 0);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         /**</div><div class=\"line\">          * In order to avoid leaking descriptors to the Zygote child,</div><div class=\"line\">          * the native code must close the two Zygote socket descriptors</div><div class=\"line\">          * in the child process before it switches from Zygote-root to</div><div class=\"line\">          * the UID and privileges of the application being launched.</div><div class=\"line\">          *</div><div class=\"line\">          * In order to avoid &quot;bad file descriptor&quot; errors when the</div><div class=\"line\">          * two LocalSocket objects are closed, the Posix file</div><div class=\"line\">          * descriptors are released via a dup2() call which closes</div><div class=\"line\">          * the socket and substitutes an open descriptor to /dev/null.</div><div class=\"line\">          */</div><div class=\"line\"></div><div class=\"line\">         int [] fdsToClose = &#123; -1, -1 &#125;;</div><div class=\"line\"></div><div class=\"line\">         FileDescriptor fd = mSocket.getFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[0] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = ZygoteInit.getServerSocketFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[1] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = null;</div><div class=\"line\"></div><div class=\"line\">         pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class=\"line\">                 parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class=\"line\">                 parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class=\"line\">                 parsedArgs.appDataDir);</div><div class=\"line\">     &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex);</div><div class=\"line\">     &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex);</div><div class=\"line\">     &#125; catch (ZygoteSecurityException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr,</div><div class=\"line\">                 &quot;Zygote security policy prevents request: &quot;, ex);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (pid == 0) &#123;</div><div class=\"line\">             // in child</div><div class=\"line\">             IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">             serverPipeFd = null;</div><div class=\"line\">             handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">             // should never get here, the child is expected to either</div><div class=\"line\">             // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">             return true;</div><div class=\"line\">         &#125; else &#123;</div><div class=\"line\">             // in parent...pid of &lt; 0 means failure</div><div class=\"line\">             IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">             childPipeFd = null;</div><div class=\"line\">             return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">         IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>readArgumentList读区启动参数</li>\n<li>构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数</li>\n<li>随后进行参数检查和配置</li>\n<li>调用Zygote.forkAndSpecialize进行fork进程，返回进程id</li>\n</ul>\n<h3 id=\"7-Zygote-forkAndSpecialize\"><a href=\"#7-Zygote-forkAndSpecialize\" class=\"headerlink\" title=\"7.Zygote#forkAndSpecialize\"></a>7.Zygote#forkAndSpecialize</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();</div><div class=\"line\">    int pid = nativeForkAndSpecialize(</div><div class=\"line\">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class=\"line\">              instructionSet, appDataDir);</div><div class=\"line\">    // Enable tracing as soon as possible for the child process.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\"></div><div class=\"line\">        // Note that this event ends at the end of handleChildProc,</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon();</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>VM_HOOKS是ZygoteHooks</li>\n<li><p>在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePreFork, &quot;()J&quot;),</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, &quot;(JILjava/lang/String;)V&quot;),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。</p>\n</li>\n<li>调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。</li>\n</ul>\n<h3 id=\"8-nativePreFork\"><a href=\"#8-nativePreFork\" class=\"headerlink\" title=\"8. nativePreFork\"></a>8. nativePreFork</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</div><div class=\"line\">  Runtime* runtime = Runtime::Current();</div><div class=\"line\">  CHECK(runtime-&gt;IsZygote()) &lt;&lt; &quot;runtime instance not started with -Xzygote&quot;;</div><div class=\"line\"></div><div class=\"line\">  runtime-&gt;PreZygoteFork();</div><div class=\"line\"></div><div class=\"line\">  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</div><div class=\"line\">    // Tracing active, pause it.</div><div class=\"line\">    Trace::Pause();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.</div><div class=\"line\">  return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略</p>\n<h3 id=\"9-nativeForkAndSpecialize\"><a href=\"#9-nativeForkAndSpecialize\" class=\"headerlink\" title=\"9. nativeForkAndSpecialize\"></a>9. nativeForkAndSpecialize</h3><p>在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div></pre></td><td class=\"code\"><pre><div class=\"line\">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</div><div class=\"line\">                                     jint debug_flags, jobjectArray javaRlimits,</div><div class=\"line\">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</div><div class=\"line\">                                     jint mount_external,</div><div class=\"line\">                                     jstring java_se_info, jstring java_se_name,</div><div class=\"line\">                                     bool is_system_server, jintArray fdsToClose,</div><div class=\"line\">                                     jstring instructionSet, jstring dataDir) &#123;</div><div class=\"line\">  SetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">  pid_t pid = fork();</div><div class=\"line\"></div><div class=\"line\">  if (pid == 0) &#123;</div><div class=\"line\">    // The child process.</div><div class=\"line\">    gMallocLeakZygoteChild = 1;</div><div class=\"line\"></div><div class=\"line\">    // Clean up any descriptors which must be closed immediately</div><div class=\"line\">    DetachDescriptors(env, fdsToClose);</div><div class=\"line\"></div><div class=\"line\">    // Keep capabilities across UID change, unless we&apos;re staying root.</div><div class=\"line\">    if (uid != 0) &#123;</div><div class=\"line\">      EnableKeepCapabilities(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    DropCapabilitiesBoundingSet(env);</div><div class=\"line\"></div><div class=\"line\">    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)</div><div class=\"line\">        &amp;&amp; android::NativeBridgeAvailable();</div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (use_native_bridge &amp;&amp; dataDir == NULL) &#123;</div><div class=\"line\">      // dataDir should never be null if we need to use a native bridge.</div><div class=\"line\">      // In general, dataDir will never be null for normal applications. It can only happen in</div><div class=\"line\">      // special cases (for isolated processes which are not associated with any app). These are</div><div class=\"line\">      // launched by the framework and should not be emulated anyway.</div><div class=\"line\">      use_native_bridge = false;</div><div class=\"line\">      ALOGW(&quot;Native bridge will not be used because dataDir == NULL.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</div><div class=\"line\">      ALOGW(&quot;Failed to mount emulated storage: %s&quot;, strerror(errno));</div><div class=\"line\">      if (errno == ENOTCONN || errno == EROFS) &#123;</div><div class=\"line\">        // When device is actively encrypting, we get ENOTCONN here</div><div class=\"line\">        // since FUSE was mounted before the framework restarted.</div><div class=\"line\">        // When encrypted device is booting, we get EROFS since</div><div class=\"line\">        // FUSE hasn&apos;t been created yet by init.</div><div class=\"line\">        // In either case, continue without external storage.</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        ALOGE(&quot;Cannot continue without emulated storage&quot;);</div><div class=\"line\">        RuntimeAbort(env);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!is_system_server) &#123;</div><div class=\"line\">        int rc = createProcessGroup(uid, getpid());</div><div class=\"line\">        if (rc != 0) &#123;</div><div class=\"line\">            if (rc == -EROFS) &#123;</div><div class=\"line\">                ALOGW(&quot;createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                ALOGE(&quot;createProcessGroup(%d, %d) failed: %s&quot;, uid, pid, strerror(-rc));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetGids(env, javaGids);</div><div class=\"line\"></div><div class=\"line\">    SetRLimits(env, javaRlimits);</div><div class=\"line\"></div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      ScopedUtfChars data_dir(env, dataDir);</div><div class=\"line\">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int rc = setresgid(gid, gid, gid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresgid(%d) failed: %s&quot;, gid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    rc = setresuid(uid, uid, uid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresuid(%d) failed: %s&quot;, uid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (NeedsNoRandomizeWorkaround()) &#123;</div><div class=\"line\">        // Work around ARM kernel ASLR lossage (http://b/5817320).</div><div class=\"line\">        int old_personality = personality(0xffffffff);</div><div class=\"line\">        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</div><div class=\"line\">        if (new_personality == -1) &#123;</div><div class=\"line\">            ALOGW(&quot;personality(%d) failed: %s&quot;, new_personality, strerror(errno));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</div><div class=\"line\"></div><div class=\"line\">    SetSchedulerPolicy(env);</div><div class=\"line\"></div><div class=\"line\">    const char* se_info_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_info = NULL;</div><div class=\"line\">    if (java_se_info != NULL) &#123;</div><div class=\"line\">        se_info = new ScopedUtfChars(env, java_se_info);</div><div class=\"line\">        se_info_c_str = se_info-&gt;c_str();</div><div class=\"line\">        if (se_info_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_info_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const char* se_name_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_name = NULL;</div><div class=\"line\">    if (java_se_name != NULL) &#123;</div><div class=\"line\">        se_name = new ScopedUtfChars(env, java_se_name);</div><div class=\"line\">        se_name_c_str = se_name-&gt;c_str();</div><div class=\"line\">        if (se_name_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_name_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;selinux_android_setcontext(%d, %d, \\&quot;%s\\&quot;, \\&quot;%s\\&quot;) failed&quot;, uid,</div><div class=\"line\">            is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Make it easier to debug audit logs by setting the main thread&apos;s name to the</div><div class=\"line\">    // nice name rather than &quot;app_process&quot;.</div><div class=\"line\">    if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</div><div class=\"line\">      se_name_c_str = &quot;system_server&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (se_info_c_str != NULL) &#123;</div><div class=\"line\">      SetThreadName(se_name_c_str);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    delete se_info;</div><div class=\"line\">    delete se_name;</div><div class=\"line\"></div><div class=\"line\">    UnsetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</div><div class=\"line\">                              is_system_server ? NULL : instructionSet);</div><div class=\"line\">    if (env-&gt;ExceptionCheck()) &#123;</div><div class=\"line\">      ALOGE(&quot;Error calling post fork hooks.&quot;);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else if (pid &gt; 0) &#123;</div><div class=\"line\">    // the parent process</div><div class=\"line\">  &#125;</div><div class=\"line\">  return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>设置子进程的signal信号处理函数 SetSigChldHandler函数</li>\n<li>fork进程，fork函数</li>\n<li>pid为0，进入子进程<ul>\n<li>DetachDescriptors 关闭清理文件描述符</li>\n<li>SetGids 设置group</li>\n<li>SetRLimits 设置资源限制</li>\n<li>进行其他的初始化设置</li>\n<li>CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。</li>\n<li>…</li>\n</ul>\n</li>\n<li>父进程分支，啥也不做</li>\n<li>返回pid<br>当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        // in child</div><div class=\"line\">        IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">        serverPipeFd = null;</div><div class=\"line\">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">        // should never get here, the child is expected to either</div><div class=\"line\">        // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // in parent...pid of &lt; 0 means failure</div><div class=\"line\">        IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">        childPipeFd = null;</div><div class=\"line\">        return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">    IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们重点看handleChildProc。</p>\n<h3 id=\"10-ZygoteConnection-handleChildProc\"><a href=\"#10-ZygoteConnection-handleChildProc\" class=\"headerlink\" title=\"10.ZygoteConnection#handleChildProc\"></a>10.ZygoteConnection#handleChildProc</h3><p>在这个方法中，有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">    WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">            parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">            VMRuntime.getCurrentInstructionSet(),</div><div class=\"line\">            pipeFd, parsedArgs.remainingArgs);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</div><div class=\"line\">            parsedArgs.remainingArgs, null /* classLoader */);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大部分情况下，invokeWith为null，所以我们看下面的分支。</p>\n<h3 id=\"11-RuntimeInit-zygoteInit\"><a href=\"#11-RuntimeInit-zygoteInit\" class=\"headerlink\" title=\"11.RuntimeInit.zygoteInit\"></a>11.RuntimeInit.zygoteInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</div><div class=\"line\"></div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</div><div class=\"line\">    redirectLogStreams();</div><div class=\"line\"></div><div class=\"line\">    commonInit();</div><div class=\"line\">    nativeZygoteInit();</div><div class=\"line\">    applicationInit(targetSdkVersion, argv, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>重定向log输出</li>\n<li>commonInit,进行通用的一些设置如时区。</li>\n<li>zygote初始化</li>\n<li>应用初始化</li>\n</ul>\n<h3 id=\"12-nativeZygoteInit\"><a href=\"#12-nativeZygoteInit\" class=\"headerlink\" title=\"12.nativeZygoteInit\"></a>12.nativeZygoteInit</h3><p>该函数的实现在AndroidRuntime.cpp中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</div><div class=\"line\">&#123;</div><div class=\"line\">    gCurRuntime-&gt;onZygoteInit();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里onZygoteInit在app_main.cpp中，这里就不多说了。</p>\n<h3 id=\"13-RuntimeInit-applicationInit\"><a href=\"#13-RuntimeInit-applicationInit\" class=\"headerlink\" title=\"13.RuntimeInit.applicationInit\"></a>13.RuntimeInit.applicationInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    // If the application calls System.exit(), terminate the process</div><div class=\"line\">    // immediately without running any shutdown hooks.  It is not possible to</div><div class=\"line\">    // shutdown an Android application gracefully.  Among other things, the</div><div class=\"line\">    // Android runtime shutdown hooks close the Binder driver, which can cause</div><div class=\"line\">    // leftover running threads to crash before the process actually exits.</div><div class=\"line\">    nativeSetExitWithoutCleanup(true);</div><div class=\"line\"></div><div class=\"line\">    // We want to be fairly aggressive about heap utilization, to avoid</div><div class=\"line\">    // holding on to a lot of memory that isn&apos;t needed.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</div><div class=\"line\">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">    final Arguments args;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        args = new Arguments(argv);</div><div class=\"line\">    &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">        Slog.e(TAG, ex.getMessage());</div><div class=\"line\">        // let the process exit</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The end of of the RuntimeInit event (see #zygoteInit).</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class=\"line\"></div><div class=\"line\">    // Remaining arguments are passed to the start class&apos;s static main</div><div class=\"line\">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    Class&lt;?&gt; cl;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        cl = Class.forName(className, true, classLoader);</div><div class=\"line\">    &#125; catch (ClassNotFoundException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing class when invoking static main &quot; + className,</div><div class=\"line\">                ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Method m;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</div><div class=\"line\">    &#125; catch (NoSuchMethodException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing static main on &quot; + className, ex);</div><div class=\"line\">    &#125; catch (SecurityException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Problem getting static main on &quot; + className, ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int modifiers = m.getModifiers();</div><div class=\"line\">    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Main method is not public and static on &quot; + className);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * This throw gets caught in ZygoteInit.main(), which responds</div><div class=\"line\">     * by invoking the exception&apos;s run() method. This arrangement</div><div class=\"line\">     * clears up all the stack frames that were required in setting</div><div class=\"line\">     * up the process.</div><div class=\"line\">     */</div><div class=\"line\">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</div><div class=\"line\">    &#125; catch (IllegalAccessException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125; catch (InvocationTargetException ex) &#123;</div><div class=\"line\">        Throwable cause = ex.getCause();</div><div class=\"line\">        if (cause instanceof RuntimeException) &#123;</div><div class=\"line\">            throw (RuntimeException) cause;</div><div class=\"line\">        &#125; else if (cause instanceof Error) &#123;</div><div class=\"line\">            throw (Error) cause;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：</p>\n<p>在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"broadcast流程浅析","date":"2016-12-27T07:45:50.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n个人看法。\n\n前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 静态广播\n* 动态广播\n* 发送广播\n* 动态注册广播接收者对广播的处理\n\n\n### 2. 静态广播的注册过程\n\n系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。\n\n在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。\n\n```\n        for (File file : files) {\n            final boolean isPackage = (isApkFile(file) || file.isDirectory())\n                    && !PackageInstallerService.isStageName(file.getName());\n            if (!isPackage) {\n                // Ignore entries which are not packages\n                continue;\n            }\n            try {\n                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,\n                        scanFlags, currentTime, null);\n            } catch (PackageManagerException e) {\n                                \n            }\n        }\n```\n\n如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用\n\n```\nprivate Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,\n            String[] outError) \n```\n\n方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到\n\n```\nowner.receivers.add(a);\n```\n\nPackage对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用\n\n```\nprivate PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  \n        int scanFlags, long currentTime, UserHandle user)\n```\n\n这个方法将其保存在ams里。这里就不多说了。\n\n### 3. 动态广播注册\n\n我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，\n\n```\n    private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,\n            IntentFilter filter, String broadcastPermission,\n            Handler scheduler, Context context) {\n        IIntentReceiver rd = null;\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n        try {\n            return ActivityManagerNative.getDefault().registerReceiver(\n                    mMainThread.getApplicationThread(), mBasePackageName,\n                    rd, filter, broadcastPermission, userId);\n        } catch (RemoteException e) {\n            return null;\n        }\n    }\n```\n\n* 注意这里的rd，\n* 看到，注册的过程和其他一样，也是交给了ams来完成。\n\n我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。\n\n* 收集粘性广播\n* 将我们这个广播接收者加入到mRegisteredReceivers中，\n* 插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。\n\n### 4. 发送广播\n\n不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,\n在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。\n\n```\nintent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);\n```\n\n这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。\n解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过\n\n```\nreceivers = collectReceiverComponents(intent, resolvedType, callingUid, users);\n```\n找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。\n\n```\n        if (!ordered && NR > 0) {\n            // If we are not serializing this broadcast, then send the\n            // registered receivers separately so they don't wait for the\n            // components to be launched.\n            final BroadcastQueue queue = broadcastQueueForIntent(intent);\n            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n                    callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,\n                    appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,\n                    resultExtras, ordered, sticky, false, userId);\n            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing parallel broadcast \" + r);\n            final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n            if (!replaced) {\n                queue.enqueueParallelBroadcastLocked(r);\n                queue.scheduleBroadcastsLocked();\n            }\n            registeredReceivers = null;\n            NR = 0;\n        }\n```\n\n解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。\n\n这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。\n\n```\n    public void scheduleBroadcastsLocked() {\n        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\"\n                + mQueueName + \"]: current=\"\n                + mBroadcastsScheduled);\n\n        if (mBroadcastsScheduled) {\n            return;\n        }\n        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n        mBroadcastsScheduled = true;\n    }\n```\n\n这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。\n\n在这个方法中，首先会处理普通广播代码如下。\n\n```\n            while (mParallelBroadcasts.size() > 0) {\n                r = mParallelBroadcasts.remove(0);\n                r.dispatchTime = SystemClock.uptimeMillis();\n                r.dispatchClockTime = System.currentTimeMillis();\n                final int N = r.receivers.size();\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n                for (int i=0; i<N; i++) {\n                    Object target = r.receivers.get(i);\n                    if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,\n                            \"Delivering non-ordered on [\" + mQueueName + \"] to registered \"\n                            + target + \": \" + r);\n                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n                }\n                addBroadcastToHistoryLocked(r);\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Done with parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n            }\n```\n\n可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。\n\n### 5. 动态注册广播接收者对广播的处理\n\ndeliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked\n\n```\n    private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n            Intent intent, int resultCode, String data, Bundle extras,\n            boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n        // Send the intent to the receiver asynchronously using one-way binder calls.\n        if (app != null) {\n            if (app.thread != null) {\n                // If we have an app thread, do the call through that so it is\n                // correctly ordered with other one-way calls.\n                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n            } else {\n                // Application has died. Receiver doesn't exist.\n                throw new RemoteException(\"app.thread must not be null\");\n            }\n        } else {\n            receiver.performReceive(intent, resultCode, data, extras, ordered,\n                    sticky, sendingUser);\n        }\n    }\n```\n\n* 如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，\n* 否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。\n\n```\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n```\n\n其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。\n\n而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。\n\n```\n        public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,\n                int resultCode, String dataStr, Bundle extras, boolean ordered,\n                boolean sticky, int sendingUser, int processState) throws RemoteException {\n            updateProcessState(processState, false);\n            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,\n                    sticky, sendingUser);\n        }\n\n```\nreceiver的performReceive方法中，调用ReceiverDispatcher的performReceive。\n\n```\n                if (rd != null) {\n                    rd.performReceive(intent, resultCode, data, extras,\n                            ordered, sticky, sendingUser);\n                }\n```\n\nReceiverDispatcher的performReceive中，通过handler，post一个runable消息。\n\n```\n\nmActivityThread.post(args)\n\n```\n在这个方法中，有如下代码\n\n```\nClassLoader cl =  mReceiver.getClass().getClassLoader();\nintent.setExtrasClassLoader(cl);\nsetExtrasClassLoader(cl);\nreceiver.setPendingResult(this);\nreceiver.onReceive(mContext, intent);\n```\n\n这样，BroadcastReceiver就创建并调用了onReceive方法。\n\n\n### 6. 上图\n\n![](/images/framework/broadcast/broadcast流程.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","source":"_posts/broadcast流程浅析.md","raw":"---\ntitle: broadcast流程浅析\ndate: 2016-12-27 15:45:50\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n个人看法。\n\n前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 静态广播\n* 动态广播\n* 发送广播\n* 动态注册广播接收者对广播的处理\n\n\n### 2. 静态广播的注册过程\n\n系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。\n\n在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。\n\n```\n        for (File file : files) {\n            final boolean isPackage = (isApkFile(file) || file.isDirectory())\n                    && !PackageInstallerService.isStageName(file.getName());\n            if (!isPackage) {\n                // Ignore entries which are not packages\n                continue;\n            }\n            try {\n                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,\n                        scanFlags, currentTime, null);\n            } catch (PackageManagerException e) {\n                                \n            }\n        }\n```\n\n如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用\n\n```\nprivate Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,\n            String[] outError) \n```\n\n方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到\n\n```\nowner.receivers.add(a);\n```\n\nPackage对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用\n\n```\nprivate PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  \n        int scanFlags, long currentTime, UserHandle user)\n```\n\n这个方法将其保存在ams里。这里就不多说了。\n\n### 3. 动态广播注册\n\n我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，\n\n```\n    private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,\n            IntentFilter filter, String broadcastPermission,\n            Handler scheduler, Context context) {\n        IIntentReceiver rd = null;\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n        try {\n            return ActivityManagerNative.getDefault().registerReceiver(\n                    mMainThread.getApplicationThread(), mBasePackageName,\n                    rd, filter, broadcastPermission, userId);\n        } catch (RemoteException e) {\n            return null;\n        }\n    }\n```\n\n* 注意这里的rd，\n* 看到，注册的过程和其他一样，也是交给了ams来完成。\n\n我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。\n\n* 收集粘性广播\n* 将我们这个广播接收者加入到mRegisteredReceivers中，\n* 插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。\n\n### 4. 发送广播\n\n不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,\n在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。\n\n```\nintent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);\n```\n\n这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。\n解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过\n\n```\nreceivers = collectReceiverComponents(intent, resolvedType, callingUid, users);\n```\n找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。\n\n```\n        if (!ordered && NR > 0) {\n            // If we are not serializing this broadcast, then send the\n            // registered receivers separately so they don't wait for the\n            // components to be launched.\n            final BroadcastQueue queue = broadcastQueueForIntent(intent);\n            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n                    callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,\n                    appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,\n                    resultExtras, ordered, sticky, false, userId);\n            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing parallel broadcast \" + r);\n            final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n            if (!replaced) {\n                queue.enqueueParallelBroadcastLocked(r);\n                queue.scheduleBroadcastsLocked();\n            }\n            registeredReceivers = null;\n            NR = 0;\n        }\n```\n\n解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。\n\n这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。\n\n```\n    public void scheduleBroadcastsLocked() {\n        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\"\n                + mQueueName + \"]: current=\"\n                + mBroadcastsScheduled);\n\n        if (mBroadcastsScheduled) {\n            return;\n        }\n        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n        mBroadcastsScheduled = true;\n    }\n```\n\n这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。\n\n在这个方法中，首先会处理普通广播代码如下。\n\n```\n            while (mParallelBroadcasts.size() > 0) {\n                r = mParallelBroadcasts.remove(0);\n                r.dispatchTime = SystemClock.uptimeMillis();\n                r.dispatchClockTime = System.currentTimeMillis();\n                final int N = r.receivers.size();\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n                for (int i=0; i<N; i++) {\n                    Object target = r.receivers.get(i);\n                    if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,\n                            \"Delivering non-ordered on [\" + mQueueName + \"] to registered \"\n                            + target + \": \" + r);\n                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n                }\n                addBroadcastToHistoryLocked(r);\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Done with parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n            }\n```\n\n可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。\n\n### 5. 动态注册广播接收者对广播的处理\n\ndeliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked\n\n```\n    private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n            Intent intent, int resultCode, String data, Bundle extras,\n            boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n        // Send the intent to the receiver asynchronously using one-way binder calls.\n        if (app != null) {\n            if (app.thread != null) {\n                // If we have an app thread, do the call through that so it is\n                // correctly ordered with other one-way calls.\n                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n            } else {\n                // Application has died. Receiver doesn't exist.\n                throw new RemoteException(\"app.thread must not be null\");\n            }\n        } else {\n            receiver.performReceive(intent, resultCode, data, extras, ordered,\n                    sticky, sendingUser);\n        }\n    }\n```\n\n* 如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，\n* 否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。\n\n```\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n```\n\n其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。\n\n而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。\n\n```\n        public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,\n                int resultCode, String dataStr, Bundle extras, boolean ordered,\n                boolean sticky, int sendingUser, int processState) throws RemoteException {\n            updateProcessState(processState, false);\n            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,\n                    sticky, sendingUser);\n        }\n\n```\nreceiver的performReceive方法中，调用ReceiverDispatcher的performReceive。\n\n```\n                if (rd != null) {\n                    rd.performReceive(intent, resultCode, data, extras,\n                            ordered, sticky, sendingUser);\n                }\n```\n\nReceiverDispatcher的performReceive中，通过handler，post一个runable消息。\n\n```\n\nmActivityThread.post(args)\n\n```\n在这个方法中，有如下代码\n\n```\nClassLoader cl =  mReceiver.getClass().getClassLoader();\nintent.setExtrasClassLoader(cl);\nsetExtrasClassLoader(cl);\nreceiver.setPendingResult(this);\nreceiver.onReceive(mContext, intent);\n```\n\n这样，BroadcastReceiver就创建并调用了onReceive方法。\n\n\n### 6. 上图\n\n![](/images/framework/broadcast/broadcast流程.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","slug":"broadcast流程浅析","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyn002s19fy5anmbtlj","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>个人看法。</p>\n<p>前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<ul>\n<li>静态广播</li>\n<li>动态广播</li>\n<li>发送广播</li>\n<li>动态注册广播接收者对广播的处理</li>\n</ul>\n<h3 id=\"2-静态广播的注册过程\"><a href=\"#2-静态广播的注册过程\" class=\"headerlink\" title=\"2. 静态广播的注册过程\"></a>2. 静态广播的注册过程</h3><p>系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。</p>\n<p>在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (File file : files) &#123;</div><div class=\"line\">    final boolean isPackage = (isApkFile(file) || file.isDirectory())</div><div class=\"line\">            &amp;&amp; !PackageInstallerService.isStageName(file.getName());</div><div class=\"line\">    if (!isPackage) &#123;</div><div class=\"line\">        // Ignore entries which are not packages</div><div class=\"line\">        continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</div><div class=\"line\">                scanFlags, currentTime, null);</div><div class=\"line\">    &#125; catch (PackageManagerException e) &#123;</div><div class=\"line\">                        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,</div><div class=\"line\">            String[] outError)</div></pre></td></tr></table></figure>\n<p>方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">owner.receivers.add(a);</div></pre></td></tr></table></figure>\n<p>Package对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  </div><div class=\"line\">        int scanFlags, long currentTime, UserHandle user)</div></pre></td></tr></table></figure>\n<p>这个方法将其保存在ams里。这里就不多说了。</p>\n<h3 id=\"3-动态广播注册\"><a href=\"#3-动态广播注册\" class=\"headerlink\" title=\"3. 动态广播注册\"></a>3. 动态广播注册</h3><p>我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</div><div class=\"line\">        IntentFilter filter, String broadcastPermission,</div><div class=\"line\">        Handler scheduler, Context context) &#123;</div><div class=\"line\">    IIntentReceiver rd = null;</div><div class=\"line\">    if (receiver != null) &#123;</div><div class=\"line\">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler,</div><div class=\"line\">                mMainThread.getInstrumentation(), true);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                    receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        return ActivityManagerNative.getDefault().registerReceiver(</div><div class=\"line\">                mMainThread.getApplicationThread(), mBasePackageName,</div><div class=\"line\">                rd, filter, broadcastPermission, userId);</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意这里的rd，</li>\n<li>看到，注册的过程和其他一样，也是交给了ams来完成。</li>\n</ul>\n<p>我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。</p>\n<ul>\n<li>收集粘性广播</li>\n<li>将我们这个广播接收者加入到mRegisteredReceivers中，</li>\n<li>插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。</li>\n</ul>\n<h3 id=\"4-发送广播\"><a href=\"#4-发送广播\" class=\"headerlink\" title=\"4. 发送广播\"></a>4. 发送广播</h3><p>不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,<br>在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div></pre></td></tr></table></figure>\n<p>这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。<br>解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</div></pre></td></tr></table></figure>\n<p>找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!ordered &amp;&amp; NR &gt; 0) &#123;</div><div class=\"line\">    // If we are not serializing this broadcast, then send the</div><div class=\"line\">    // registered receivers separately so they don&apos;t wait for the</div><div class=\"line\">    // components to be launched.</div><div class=\"line\">    final BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class=\"line\">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</div><div class=\"line\">            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</div><div class=\"line\">            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</div><div class=\"line\">            resultExtras, ordered, sticky, false, userId);</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</div><div class=\"line\">    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</div><div class=\"line\">    if (!replaced) &#123;</div><div class=\"line\">        queue.enqueueParallelBroadcastLocked(r);</div><div class=\"line\">        queue.scheduleBroadcastsLocked();</div><div class=\"line\">    &#125;</div><div class=\"line\">    registeredReceivers = null;</div><div class=\"line\">    NR = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。</p>\n<p>这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleBroadcastsLocked() &#123;</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</div><div class=\"line\">            + mQueueName + &quot;]: current=&quot;</div><div class=\"line\">            + mBroadcastsScheduled);</div><div class=\"line\"></div><div class=\"line\">    if (mBroadcastsScheduled) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</div><div class=\"line\">    mBroadcastsScheduled = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。</p>\n<p>在这个方法中，首先会处理普通广播代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (mParallelBroadcasts.size() &gt; 0) &#123;</div><div class=\"line\">    r = mParallelBroadcasts.remove(0);</div><div class=\"line\">    r.dispatchTime = SystemClock.uptimeMillis();</div><div class=\"line\">    r.dispatchClockTime = System.currentTimeMillis();</div><div class=\"line\">    final int N = r.receivers.size();</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        Object target = r.receivers.get(i);</div><div class=\"line\">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</div><div class=\"line\">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</div><div class=\"line\">                + target + &quot;: &quot; + r);</div><div class=\"line\">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">    addBroadcastToHistoryLocked(r);</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。</p>\n<h3 id=\"5-动态注册广播接收者对广播的处理\"><a href=\"#5-动态注册广播接收者对广播的处理\" class=\"headerlink\" title=\"5. 动态注册广播接收者对广播的处理\"></a>5. 动态注册广播接收者对广播的处理</h3><p>deliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</div><div class=\"line\">        Intent intent, int resultCode, String data, Bundle extras,</div><div class=\"line\">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</div><div class=\"line\">    // Send the intent to the receiver asynchronously using one-way binder calls.</div><div class=\"line\">    if (app != null) &#123;</div><div class=\"line\">        if (app.thread != null) &#123;</div><div class=\"line\">            // If we have an app thread, do the call through that so it is</div><div class=\"line\">            // correctly ordered with other one-way calls.</div><div class=\"line\">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class=\"line\">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Application has died. Receiver doesn&apos;t exist.</div><div class=\"line\">            throw new RemoteException(&quot;app.thread must not be null&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class=\"line\">                sticky, sendingUser);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，</li>\n<li>否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (receiver != null) &#123;</div><div class=\"line\">    if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">            receiver, context, scheduler,</div><div class=\"line\">            mMainThread.getInstrumentation(), true);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。</p>\n<p>而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</div><div class=\"line\">        int resultCode, String dataStr, Bundle extras, boolean ordered,</div><div class=\"line\">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</div><div class=\"line\">    updateProcessState(processState, false);</div><div class=\"line\">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</div><div class=\"line\">            sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>receiver的performReceive方法中，调用ReceiverDispatcher的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (rd != null) &#123;</div><div class=\"line\">    rd.performReceive(intent, resultCode, data, extras,</div><div class=\"line\">            ordered, sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ReceiverDispatcher的performReceive中，通过handler，post一个runable消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">mActivityThread.post(args)</div></pre></td></tr></table></figure>\n<p>在这个方法中，有如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class=\"line\">intent.setExtrasClassLoader(cl);</div><div class=\"line\">setExtrasClassLoader(cl);</div><div class=\"line\">receiver.setPendingResult(this);</div><div class=\"line\">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>\n<p>这样，BroadcastReceiver就创建并调用了onReceive方法。</p>\n<h3 id=\"6-上图\"><a href=\"#6-上图\" class=\"headerlink\" title=\"6. 上图\"></a>6. 上图</h3><p><img src=\"/images/framework/broadcast/broadcast流程.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>个人看法。</p>\n<p>前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括</p>","more":"<The rest of contents | 余下全文>\n\n\n<ul>\n<li>静态广播</li>\n<li>动态广播</li>\n<li>发送广播</li>\n<li>动态注册广播接收者对广播的处理</li>\n</ul>\n<h3 id=\"2-静态广播的注册过程\"><a href=\"#2-静态广播的注册过程\" class=\"headerlink\" title=\"2. 静态广播的注册过程\"></a>2. 静态广播的注册过程</h3><p>系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。</p>\n<p>在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (File file : files) &#123;</div><div class=\"line\">    final boolean isPackage = (isApkFile(file) || file.isDirectory())</div><div class=\"line\">            &amp;&amp; !PackageInstallerService.isStageName(file.getName());</div><div class=\"line\">    if (!isPackage) &#123;</div><div class=\"line\">        // Ignore entries which are not packages</div><div class=\"line\">        continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</div><div class=\"line\">                scanFlags, currentTime, null);</div><div class=\"line\">    &#125; catch (PackageManagerException e) &#123;</div><div class=\"line\">                        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,</div><div class=\"line\">            String[] outError)</div></pre></td></tr></table></figure>\n<p>方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">owner.receivers.add(a);</div></pre></td></tr></table></figure>\n<p>Package对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  </div><div class=\"line\">        int scanFlags, long currentTime, UserHandle user)</div></pre></td></tr></table></figure>\n<p>这个方法将其保存在ams里。这里就不多说了。</p>\n<h3 id=\"3-动态广播注册\"><a href=\"#3-动态广播注册\" class=\"headerlink\" title=\"3. 动态广播注册\"></a>3. 动态广播注册</h3><p>我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</div><div class=\"line\">        IntentFilter filter, String broadcastPermission,</div><div class=\"line\">        Handler scheduler, Context context) &#123;</div><div class=\"line\">    IIntentReceiver rd = null;</div><div class=\"line\">    if (receiver != null) &#123;</div><div class=\"line\">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler,</div><div class=\"line\">                mMainThread.getInstrumentation(), true);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                    receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        return ActivityManagerNative.getDefault().registerReceiver(</div><div class=\"line\">                mMainThread.getApplicationThread(), mBasePackageName,</div><div class=\"line\">                rd, filter, broadcastPermission, userId);</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意这里的rd，</li>\n<li>看到，注册的过程和其他一样，也是交给了ams来完成。</li>\n</ul>\n<p>我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。</p>\n<ul>\n<li>收集粘性广播</li>\n<li>将我们这个广播接收者加入到mRegisteredReceivers中，</li>\n<li>插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。</li>\n</ul>\n<h3 id=\"4-发送广播\"><a href=\"#4-发送广播\" class=\"headerlink\" title=\"4. 发送广播\"></a>4. 发送广播</h3><p>不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,<br>在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div></pre></td></tr></table></figure>\n<p>这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。<br>解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</div></pre></td></tr></table></figure>\n<p>找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!ordered &amp;&amp; NR &gt; 0) &#123;</div><div class=\"line\">    // If we are not serializing this broadcast, then send the</div><div class=\"line\">    // registered receivers separately so they don&apos;t wait for the</div><div class=\"line\">    // components to be launched.</div><div class=\"line\">    final BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class=\"line\">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</div><div class=\"line\">            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</div><div class=\"line\">            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</div><div class=\"line\">            resultExtras, ordered, sticky, false, userId);</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</div><div class=\"line\">    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</div><div class=\"line\">    if (!replaced) &#123;</div><div class=\"line\">        queue.enqueueParallelBroadcastLocked(r);</div><div class=\"line\">        queue.scheduleBroadcastsLocked();</div><div class=\"line\">    &#125;</div><div class=\"line\">    registeredReceivers = null;</div><div class=\"line\">    NR = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。</p>\n<p>这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleBroadcastsLocked() &#123;</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</div><div class=\"line\">            + mQueueName + &quot;]: current=&quot;</div><div class=\"line\">            + mBroadcastsScheduled);</div><div class=\"line\"></div><div class=\"line\">    if (mBroadcastsScheduled) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</div><div class=\"line\">    mBroadcastsScheduled = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。</p>\n<p>在这个方法中，首先会处理普通广播代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (mParallelBroadcasts.size() &gt; 0) &#123;</div><div class=\"line\">    r = mParallelBroadcasts.remove(0);</div><div class=\"line\">    r.dispatchTime = SystemClock.uptimeMillis();</div><div class=\"line\">    r.dispatchClockTime = System.currentTimeMillis();</div><div class=\"line\">    final int N = r.receivers.size();</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        Object target = r.receivers.get(i);</div><div class=\"line\">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</div><div class=\"line\">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</div><div class=\"line\">                + target + &quot;: &quot; + r);</div><div class=\"line\">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">    addBroadcastToHistoryLocked(r);</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。</p>\n<h3 id=\"5-动态注册广播接收者对广播的处理\"><a href=\"#5-动态注册广播接收者对广播的处理\" class=\"headerlink\" title=\"5. 动态注册广播接收者对广播的处理\"></a>5. 动态注册广播接收者对广播的处理</h3><p>deliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</div><div class=\"line\">        Intent intent, int resultCode, String data, Bundle extras,</div><div class=\"line\">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</div><div class=\"line\">    // Send the intent to the receiver asynchronously using one-way binder calls.</div><div class=\"line\">    if (app != null) &#123;</div><div class=\"line\">        if (app.thread != null) &#123;</div><div class=\"line\">            // If we have an app thread, do the call through that so it is</div><div class=\"line\">            // correctly ordered with other one-way calls.</div><div class=\"line\">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class=\"line\">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Application has died. Receiver doesn&apos;t exist.</div><div class=\"line\">            throw new RemoteException(&quot;app.thread must not be null&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class=\"line\">                sticky, sendingUser);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，</li>\n<li>否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (receiver != null) &#123;</div><div class=\"line\">    if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">            receiver, context, scheduler,</div><div class=\"line\">            mMainThread.getInstrumentation(), true);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。</p>\n<p>而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</div><div class=\"line\">        int resultCode, String dataStr, Bundle extras, boolean ordered,</div><div class=\"line\">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</div><div class=\"line\">    updateProcessState(processState, false);</div><div class=\"line\">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</div><div class=\"line\">            sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>receiver的performReceive方法中，调用ReceiverDispatcher的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (rd != null) &#123;</div><div class=\"line\">    rd.performReceive(intent, resultCode, data, extras,</div><div class=\"line\">            ordered, sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ReceiverDispatcher的performReceive中，通过handler，post一个runable消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">mActivityThread.post(args)</div></pre></td></tr></table></figure>\n<p>在这个方法中，有如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class=\"line\">intent.setExtrasClassLoader(cl);</div><div class=\"line\">setExtrasClassLoader(cl);</div><div class=\"line\">receiver.setPendingResult(this);</div><div class=\"line\">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>\n<p>这样，BroadcastReceiver就创建并调用了onReceive方法。</p>\n<h3 id=\"6-上图\"><a href=\"#6-上图\" class=\"headerlink\" title=\"6. 上图\"></a>6. 上图</h3><p><img src=\"/images/framework/broadcast/broadcast流程.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"databinding基础知识","date":"2017-08-26T12:44:45.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\ngoogle出的databinding库，相信很多人都已经使用了，经过这么长时间的发展，是时候放到项目里使用了。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 基本用法\n\n#### 开启databiding\n\n```\nandroid {\n    ....\n    dataBinding {\n        enabled = true\n    }\n}\n```\n\n注意：建议使用最新版的Android studio，我在使用的过程中发现as 2.2版本，databinding的双向绑定有点小问题。\n\n将我们的布局文件做稍许的修改。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n   <data>\n       \n   </data>\n   \n   <LinearLayout>\n   \n   </LinearLayout>\n</layout>\n```\n\n分为两部分，data数据部分以及原先的布局两部分。\n\n\n#### 绑定数据\n\n要向绑定数据，我们要准备好bean，这里我准备一个Student，有name和age两个属性。\n\n```\npublic class Student {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n然后，我们在布局中，使用。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout>\n\n    <data>\n        <import type=\"String\"/>\n        <variable\n            name=\"student\"\n            type=\"com.guolei.baseuse.Student\"/>\n    </data>\n\n    <android.support.constraint.ConstraintLayout\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        tools:context=\"com.guolei.baseuse.BaseUseActivity\">\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\"\n            >\n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"50dp\"\n                android:text=\"@{student.name}\"\n                android:gravity=\"center\"\n                />\n\n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"50dp\"\n                android:text=\"@{String.valueOf(student.age)}\"\n                android:gravity=\"center\"\n                />\n        </LinearLayout>\n    </android.support.constraint.ConstraintLayout>\n</layout>\n\n\n```\n\n注意 ：\n\n* 我们在data下用variable声明了一个类型为Student的变量student，\n* 我们用import将String 这个类导进来，然后我们就可以在这里使用String的一些静态方法了\n* 我们用@{}语法来使用变量的属性，如name，age等\n\n完成这些之后，我们需要make一些module，这个过程会生成我们后面需要使用的一些中间文件和类。\n\n最后，在Activity中，生成binding并且绑定变量。如下\n\n```\n        ActivityBaseUseBinding binding = DataBindingUtil.setContentView(this,R.layout.activity_base_use);\n        Student student = new Student();\n        student.setName(\"_StriveG\");\n        student.setAge(22);\n        binding.setStudent(student);\n```\n\n这样，数据就绑定在了布局上。\n\n#### 生成的binding类\n\n生成的binding类中，包含我们布局的很多信息。那么，我们如何构造一个binding对象呢。有下面几种办法\n\n* DataBindingUtil中提供了一些方法，如setcontentview，inflate,bind,getbind等等一些办法，\n* 同样，生成的具体binding类，如上面的ActivityBaseUseBinding中，也有inflate、bind等办法，不过，推荐使用DataBindingUtil的\n\n生成的databinding类中，还顺带生成了，我们在布局文件中，指定了id的控件，我们可以通过这个类去操作view，省去了我们findviewbyid。\n\n#### 绑定事件\n\n绑定事件有两种方法，方法引用和监听器绑定，分别来说下。\n\n1. 方法引用\n\n\t首先声明一个类，\n\t\n\t```\n\t    public static class MethodRef{\n        public void onClick(View view) {\n            Log.e(TAG, \"onClick: \" );\n        }\n    }\n\t\n\t```\n\t\n\t其次，我们需要在布局文件中加入这个变量，并且为onclick属性绑定这个方法。\n\t\n\t```\n  <variable\n            name=\"methodRef\"\n            type=\"com.guolei.baseuse.EventHandling.MethodRef\"/>\n            \n      <Button\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"50dp\"\n            android:onClick=\"@{methodRef::onClick}\"\n            />\n\t```\n\t\n\t最后，给这个绑定变量，binding.setMethodRef(new MethodRef())\n\n\t但是，这里有一个缺点，就是以这种方式绑定的方法，只能有view属性，不能有其他参数，有其他参数的情况下，编译会报错。怎么办呢？监听器绑定\n\t\n2. 监听器绑定\n\n与方法绑定类似，不同的是在onclick属性中，我们使用的是如下表达式\n\n```\n@{(it)->listener.onClick(student)} 或者@{()->listener.onClick(it,student)}\n\n```\n\n上面只是OnClickListener的形式，其他的listener类似。\n\n#### 包含include标签的情况\n\n包含include标签的情况下我们如何给include的布局绑定呢\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:bind=\"http://schemas.android.com/apk/res-auto\">\n   <data>\n       <variable name=\"user\" type=\"com.example.User\"/>\n   </data>\n   <LinearLayout\n       android:orientation=\"vertical\"\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\">\n       <include layout=\"@layout/name\"\n           bind:user=\"@{user}\"/>\n       <include layout=\"@layout/contact\"\n           bind:user=\"@{user}\"/>\n   </LinearLayout>\n</layout>\n```\n\n官方例子，懒得自己写了。\n\n#### set属性\n\nset属性的方法就很简单了，这里分为三种情况。\n\n1. android:xxx属性，通过@{}绑定即可\n2. 若为自定义控件，则app:xxx ，通过@{}绑定\n3. 如对应的属性没有提供setXXX方法的话，就需要通过@BindingAdapter自定义，举个例子\n\n```\n    @android.databinding.BindingAdapter(\"app:progress\")\n    public static void setProgress(View view,int progress) {\n        view.setPreogress(progress);\n    }\n```\n\n* 注意，方法一定要是static的\n* 这样，我们就能在不居中通过app:progress来指定属性了\n\n\n### 总结\n\n这篇只说明了一些很简单很简单的基础用法，下篇会出一些比较高级的用法。当然，这篇中很多基础用法也没介绍完，个人感觉没啥输的，官方文档中很全很详细了。\n\n[官方文档，要翻墙！](https://developer.android.com/topic/libraries/data-binding/index.html)\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/databinding基础知识.md","raw":"---\ntitle: databinding基础知识\ndate: 2017-08-26 20:44:45\ncategory: Android\ntags: Android\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\ngoogle出的databinding库，相信很多人都已经使用了，经过这么长时间的发展，是时候放到项目里使用了。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 基本用法\n\n#### 开启databiding\n\n```\nandroid {\n    ....\n    dataBinding {\n        enabled = true\n    }\n}\n```\n\n注意：建议使用最新版的Android studio，我在使用的过程中发现as 2.2版本，databinding的双向绑定有点小问题。\n\n将我们的布局文件做稍许的修改。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n   <data>\n       \n   </data>\n   \n   <LinearLayout>\n   \n   </LinearLayout>\n</layout>\n```\n\n分为两部分，data数据部分以及原先的布局两部分。\n\n\n#### 绑定数据\n\n要向绑定数据，我们要准备好bean，这里我准备一个Student，有name和age两个属性。\n\n```\npublic class Student {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n然后，我们在布局中，使用。\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout>\n\n    <data>\n        <import type=\"String\"/>\n        <variable\n            name=\"student\"\n            type=\"com.guolei.baseuse.Student\"/>\n    </data>\n\n    <android.support.constraint.ConstraintLayout\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        tools:context=\"com.guolei.baseuse.BaseUseActivity\">\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\"\n            >\n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"50dp\"\n                android:text=\"@{student.name}\"\n                android:gravity=\"center\"\n                />\n\n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"50dp\"\n                android:text=\"@{String.valueOf(student.age)}\"\n                android:gravity=\"center\"\n                />\n        </LinearLayout>\n    </android.support.constraint.ConstraintLayout>\n</layout>\n\n\n```\n\n注意 ：\n\n* 我们在data下用variable声明了一个类型为Student的变量student，\n* 我们用import将String 这个类导进来，然后我们就可以在这里使用String的一些静态方法了\n* 我们用@{}语法来使用变量的属性，如name，age等\n\n完成这些之后，我们需要make一些module，这个过程会生成我们后面需要使用的一些中间文件和类。\n\n最后，在Activity中，生成binding并且绑定变量。如下\n\n```\n        ActivityBaseUseBinding binding = DataBindingUtil.setContentView(this,R.layout.activity_base_use);\n        Student student = new Student();\n        student.setName(\"_StriveG\");\n        student.setAge(22);\n        binding.setStudent(student);\n```\n\n这样，数据就绑定在了布局上。\n\n#### 生成的binding类\n\n生成的binding类中，包含我们布局的很多信息。那么，我们如何构造一个binding对象呢。有下面几种办法\n\n* DataBindingUtil中提供了一些方法，如setcontentview，inflate,bind,getbind等等一些办法，\n* 同样，生成的具体binding类，如上面的ActivityBaseUseBinding中，也有inflate、bind等办法，不过，推荐使用DataBindingUtil的\n\n生成的databinding类中，还顺带生成了，我们在布局文件中，指定了id的控件，我们可以通过这个类去操作view，省去了我们findviewbyid。\n\n#### 绑定事件\n\n绑定事件有两种方法，方法引用和监听器绑定，分别来说下。\n\n1. 方法引用\n\n\t首先声明一个类，\n\t\n\t```\n\t    public static class MethodRef{\n        public void onClick(View view) {\n            Log.e(TAG, \"onClick: \" );\n        }\n    }\n\t\n\t```\n\t\n\t其次，我们需要在布局文件中加入这个变量，并且为onclick属性绑定这个方法。\n\t\n\t```\n  <variable\n            name=\"methodRef\"\n            type=\"com.guolei.baseuse.EventHandling.MethodRef\"/>\n            \n      <Button\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"50dp\"\n            android:onClick=\"@{methodRef::onClick}\"\n            />\n\t```\n\t\n\t最后，给这个绑定变量，binding.setMethodRef(new MethodRef())\n\n\t但是，这里有一个缺点，就是以这种方式绑定的方法，只能有view属性，不能有其他参数，有其他参数的情况下，编译会报错。怎么办呢？监听器绑定\n\t\n2. 监听器绑定\n\n与方法绑定类似，不同的是在onclick属性中，我们使用的是如下表达式\n\n```\n@{(it)->listener.onClick(student)} 或者@{()->listener.onClick(it,student)}\n\n```\n\n上面只是OnClickListener的形式，其他的listener类似。\n\n#### 包含include标签的情况\n\n包含include标签的情况下我们如何给include的布局绑定呢\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:bind=\"http://schemas.android.com/apk/res-auto\">\n   <data>\n       <variable name=\"user\" type=\"com.example.User\"/>\n   </data>\n   <LinearLayout\n       android:orientation=\"vertical\"\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\">\n       <include layout=\"@layout/name\"\n           bind:user=\"@{user}\"/>\n       <include layout=\"@layout/contact\"\n           bind:user=\"@{user}\"/>\n   </LinearLayout>\n</layout>\n```\n\n官方例子，懒得自己写了。\n\n#### set属性\n\nset属性的方法就很简单了，这里分为三种情况。\n\n1. android:xxx属性，通过@{}绑定即可\n2. 若为自定义控件，则app:xxx ，通过@{}绑定\n3. 如对应的属性没有提供setXXX方法的话，就需要通过@BindingAdapter自定义，举个例子\n\n```\n    @android.databinding.BindingAdapter(\"app:progress\")\n    public static void setProgress(View view,int progress) {\n        view.setPreogress(progress);\n    }\n```\n\n* 注意，方法一定要是static的\n* 这样，我们就能在不居中通过app:progress来指定属性了\n\n\n### 总结\n\n这篇只说明了一些很简单很简单的基础用法，下篇会出一些比较高级的用法。当然，这篇中很多基础用法也没介绍完，个人感觉没啥输的，官方文档中很全很详细了。\n\n[官方文档，要翻墙！](https://developer.android.com/topic/libraries/data-binding/index.html)\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"databinding基础知识","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyo002w19fyutmbr8ch","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>google出的databinding库，相信很多人都已经使用了，经过这么长时间的发展，是时候放到项目里使用了。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><h4 id=\"开启databiding\"><a href=\"#开启databiding\" class=\"headerlink\" title=\"开启databiding\"></a>开启databiding</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ....</div><div class=\"line\">    dataBinding &#123;</div><div class=\"line\">        enabled = true</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意：建议使用最新版的Android studio，我在使用的过程中发现as 2.2版本，databinding的双向绑定有点小问题。</p>\n<p>将我们的布局文件做稍许的修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class=\"line\">   &lt;data&gt;</div><div class=\"line\">       </div><div class=\"line\">   &lt;/data&gt;</div><div class=\"line\">   </div><div class=\"line\">   &lt;LinearLayout&gt;</div><div class=\"line\">   </div><div class=\"line\">   &lt;/LinearLayout&gt;</div><div class=\"line\">&lt;/layout&gt;</div></pre></td></tr></table></figure>\n<p>分为两部分，data数据部分以及原先的布局两部分。</p>\n<h4 id=\"绑定数据\"><a href=\"#绑定数据\" class=\"headerlink\" title=\"绑定数据\"></a>绑定数据</h4><p>要向绑定数据，我们要准备好bean，这里我准备一个Student，有name和age两个属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Student &#123;</div><div class=\"line\">    private String name;</div><div class=\"line\">    private int age;</div><div class=\"line\"></div><div class=\"line\">    public String getName() &#123;</div><div class=\"line\">        return name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void setName(String name) &#123;</div><div class=\"line\">        this.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getAge() &#123;</div><div class=\"line\">        return age;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void setAge(int age) &#123;</div><div class=\"line\">        this.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，我们在布局中，使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;layout&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;data&gt;</div><div class=\"line\">        &lt;import type=&quot;String&quot;/&gt;</div><div class=\"line\">        &lt;variable</div><div class=\"line\">            name=&quot;student&quot;</div><div class=\"line\">            type=&quot;com.guolei.baseuse.Student&quot;/&gt;</div><div class=\"line\">    &lt;/data&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;android.support.constraint.ConstraintLayout</div><div class=\"line\">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class=\"line\">        xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class=\"line\">        android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">        android:layout_height=&quot;match_parent&quot;</div><div class=\"line\">        tools:context=&quot;com.guolei.baseuse.BaseUseActivity&quot;&gt;</div><div class=\"line\">        &lt;LinearLayout</div><div class=\"line\">            android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">            android:layout_height=&quot;wrap_content&quot;</div><div class=\"line\">            android:orientation=&quot;vertical&quot;</div><div class=\"line\">            &gt;</div><div class=\"line\">            &lt;TextView</div><div class=\"line\">                android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">                android:layout_height=&quot;50dp&quot;</div><div class=\"line\">                android:text=&quot;@&#123;student.name&#125;&quot;</div><div class=\"line\">                android:gravity=&quot;center&quot;</div><div class=\"line\">                /&gt;</div><div class=\"line\"></div><div class=\"line\">            &lt;TextView</div><div class=\"line\">                android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">                android:layout_height=&quot;50dp&quot;</div><div class=\"line\">                android:text=&quot;@&#123;String.valueOf(student.age)&#125;&quot;</div><div class=\"line\">                android:gravity=&quot;center&quot;</div><div class=\"line\">                /&gt;</div><div class=\"line\">        &lt;/LinearLayout&gt;</div><div class=\"line\">    &lt;/android.support.constraint.ConstraintLayout&gt;</div><div class=\"line\">&lt;/layout&gt;</div></pre></td></tr></table></figure>\n<p>注意 ：</p>\n<ul>\n<li>我们在data下用variable声明了一个类型为Student的变量student，</li>\n<li>我们用import将String 这个类导进来，然后我们就可以在这里使用String的一些静态方法了</li>\n<li>我们用@{}语法来使用变量的属性，如name，age等</li>\n</ul>\n<p>完成这些之后，我们需要make一些module，这个过程会生成我们后面需要使用的一些中间文件和类。</p>\n<p>最后，在Activity中，生成binding并且绑定变量。如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityBaseUseBinding binding = DataBindingUtil.setContentView(this,R.layout.activity_base_use);</div><div class=\"line\">Student student = new Student();</div><div class=\"line\">student.setName(&quot;_StriveG&quot;);</div><div class=\"line\">student.setAge(22);</div><div class=\"line\">binding.setStudent(student);</div></pre></td></tr></table></figure>\n<p>这样，数据就绑定在了布局上。</p>\n<h4 id=\"生成的binding类\"><a href=\"#生成的binding类\" class=\"headerlink\" title=\"生成的binding类\"></a>生成的binding类</h4><p>生成的binding类中，包含我们布局的很多信息。那么，我们如何构造一个binding对象呢。有下面几种办法</p>\n<ul>\n<li>DataBindingUtil中提供了一些方法，如setcontentview，inflate,bind,getbind等等一些办法，</li>\n<li>同样，生成的具体binding类，如上面的ActivityBaseUseBinding中，也有inflate、bind等办法，不过，推荐使用DataBindingUtil的</li>\n</ul>\n<p>生成的databinding类中，还顺带生成了，我们在布局文件中，指定了id的控件，我们可以通过这个类去操作view，省去了我们findviewbyid。</p>\n<h4 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h4><p>绑定事件有两种方法，方法引用和监听器绑定，分别来说下。</p>\n<ol>\n<li><p>方法引用</p>\n<p> 首先声明一个类，</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public static class MethodRef&#123;</div><div class=\"line\">    public void onClick(View view) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;onClick: &quot; );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>其次，我们需要在布局文件中加入这个变量，并且为onclick属性绑定这个方法。\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;variable</div><div class=\"line\">          name=&quot;methodRef&quot;</div><div class=\"line\">          type=&quot;com.guolei.baseuse.EventHandling.MethodRef&quot;/&gt;</div><div class=\"line\">          </div><div class=\"line\">    &lt;Button</div><div class=\"line\">          android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">          android:layout_height=&quot;50dp&quot;</div><div class=\"line\">          android:onClick=&quot;@&#123;methodRef::onClick&#125;&quot;</div><div class=\"line\">          /&gt;</div></pre></td></tr></table></figure>\n\n\n最后，给这个绑定变量，binding.setMethodRef(new MethodRef())\n\n但是，这里有一个缺点，就是以这种方式绑定的方法，只能有view属性，不能有其他参数，有其他参数的情况下，编译会报错。怎么办呢？监听器绑定\n</code></pre><ol>\n<li>监听器绑定</li>\n</ol>\n<p>与方法绑定类似，不同的是在onclick属性中，我们使用的是如下表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@&#123;(it)-&gt;listener.onClick(student)&#125; 或者@&#123;()-&gt;listener.onClick(it,student)&#125;</div></pre></td></tr></table></figure>\n<p>上面只是OnClickListener的形式，其他的listener类似。</p>\n<h4 id=\"包含include标签的情况\"><a href=\"#包含include标签的情况\" class=\"headerlink\" title=\"包含include标签的情况\"></a>包含include标签的情况</h4><p>包含include标签的情况下我们如何给include的布局绑定呢</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</div><div class=\"line\">   &lt;data&gt;</div><div class=\"line\">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</div><div class=\"line\">   &lt;/data&gt;</div><div class=\"line\">   &lt;LinearLayout</div><div class=\"line\">       android:orientation=&quot;vertical&quot;</div><div class=\"line\">       android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">       android:layout_height=&quot;match_parent&quot;&gt;</div><div class=\"line\">       &lt;include layout=&quot;@layout/name&quot;</div><div class=\"line\">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</div><div class=\"line\">       &lt;include layout=&quot;@layout/contact&quot;</div><div class=\"line\">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</div><div class=\"line\">   &lt;/LinearLayout&gt;</div><div class=\"line\">&lt;/layout&gt;</div></pre></td></tr></table></figure>\n<p>官方例子，懒得自己写了。</p>\n<h4 id=\"set属性\"><a href=\"#set属性\" class=\"headerlink\" title=\"set属性\"></a>set属性</h4><p>set属性的方法就很简单了，这里分为三种情况。</p>\n<ol>\n<li>android:xxx属性，通过@{}绑定即可</li>\n<li>若为自定义控件，则app:xxx ，通过@{}绑定</li>\n<li>如对应的属性没有提供setXXX方法的话，就需要通过@BindingAdapter自定义，举个例子</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@android.databinding.BindingAdapter(&quot;app:progress&quot;)</div><div class=\"line\">public static void setProgress(View view,int progress) &#123;</div><div class=\"line\">    view.setPreogress(progress);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意，方法一定要是static的</li>\n<li>这样，我们就能在不居中通过app:progress来指定属性了</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇只说明了一些很简单很简单的基础用法，下篇会出一些比较高级的用法。当然，这篇中很多基础用法也没介绍完，个人感觉没啥输的，官方文档中很全很详细了。</p>\n<p><a href=\"https://developer.android.com/topic/libraries/data-binding/index.html\" target=\"_blank\" rel=\"external\">官方文档，要翻墙！</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>google出的databinding库，相信很多人都已经使用了，经过这么长时间的发展，是时候放到项目里使用了。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><h4 id=\"开启databiding\"><a href=\"#开启databiding\" class=\"headerlink\" title=\"开启databiding\"></a>开启databiding</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ....</div><div class=\"line\">    dataBinding &#123;</div><div class=\"line\">        enabled = true</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意：建议使用最新版的Android studio，我在使用的过程中发现as 2.2版本，databinding的双向绑定有点小问题。</p>\n<p>将我们的布局文件做稍许的修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class=\"line\">   &lt;data&gt;</div><div class=\"line\">       </div><div class=\"line\">   &lt;/data&gt;</div><div class=\"line\">   </div><div class=\"line\">   &lt;LinearLayout&gt;</div><div class=\"line\">   </div><div class=\"line\">   &lt;/LinearLayout&gt;</div><div class=\"line\">&lt;/layout&gt;</div></pre></td></tr></table></figure>\n<p>分为两部分，data数据部分以及原先的布局两部分。</p>\n<h4 id=\"绑定数据\"><a href=\"#绑定数据\" class=\"headerlink\" title=\"绑定数据\"></a>绑定数据</h4><p>要向绑定数据，我们要准备好bean，这里我准备一个Student，有name和age两个属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Student &#123;</div><div class=\"line\">    private String name;</div><div class=\"line\">    private int age;</div><div class=\"line\"></div><div class=\"line\">    public String getName() &#123;</div><div class=\"line\">        return name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void setName(String name) &#123;</div><div class=\"line\">        this.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getAge() &#123;</div><div class=\"line\">        return age;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void setAge(int age) &#123;</div><div class=\"line\">        this.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，我们在布局中，使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;layout&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;data&gt;</div><div class=\"line\">        &lt;import type=&quot;String&quot;/&gt;</div><div class=\"line\">        &lt;variable</div><div class=\"line\">            name=&quot;student&quot;</div><div class=\"line\">            type=&quot;com.guolei.baseuse.Student&quot;/&gt;</div><div class=\"line\">    &lt;/data&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;android.support.constraint.ConstraintLayout</div><div class=\"line\">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class=\"line\">        xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class=\"line\">        android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">        android:layout_height=&quot;match_parent&quot;</div><div class=\"line\">        tools:context=&quot;com.guolei.baseuse.BaseUseActivity&quot;&gt;</div><div class=\"line\">        &lt;LinearLayout</div><div class=\"line\">            android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">            android:layout_height=&quot;wrap_content&quot;</div><div class=\"line\">            android:orientation=&quot;vertical&quot;</div><div class=\"line\">            &gt;</div><div class=\"line\">            &lt;TextView</div><div class=\"line\">                android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">                android:layout_height=&quot;50dp&quot;</div><div class=\"line\">                android:text=&quot;@&#123;student.name&#125;&quot;</div><div class=\"line\">                android:gravity=&quot;center&quot;</div><div class=\"line\">                /&gt;</div><div class=\"line\"></div><div class=\"line\">            &lt;TextView</div><div class=\"line\">                android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">                android:layout_height=&quot;50dp&quot;</div><div class=\"line\">                android:text=&quot;@&#123;String.valueOf(student.age)&#125;&quot;</div><div class=\"line\">                android:gravity=&quot;center&quot;</div><div class=\"line\">                /&gt;</div><div class=\"line\">        &lt;/LinearLayout&gt;</div><div class=\"line\">    &lt;/android.support.constraint.ConstraintLayout&gt;</div><div class=\"line\">&lt;/layout&gt;</div></pre></td></tr></table></figure>\n<p>注意 ：</p>\n<ul>\n<li>我们在data下用variable声明了一个类型为Student的变量student，</li>\n<li>我们用import将String 这个类导进来，然后我们就可以在这里使用String的一些静态方法了</li>\n<li>我们用@{}语法来使用变量的属性，如name，age等</li>\n</ul>\n<p>完成这些之后，我们需要make一些module，这个过程会生成我们后面需要使用的一些中间文件和类。</p>\n<p>最后，在Activity中，生成binding并且绑定变量。如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityBaseUseBinding binding = DataBindingUtil.setContentView(this,R.layout.activity_base_use);</div><div class=\"line\">Student student = new Student();</div><div class=\"line\">student.setName(&quot;_StriveG&quot;);</div><div class=\"line\">student.setAge(22);</div><div class=\"line\">binding.setStudent(student);</div></pre></td></tr></table></figure>\n<p>这样，数据就绑定在了布局上。</p>\n<h4 id=\"生成的binding类\"><a href=\"#生成的binding类\" class=\"headerlink\" title=\"生成的binding类\"></a>生成的binding类</h4><p>生成的binding类中，包含我们布局的很多信息。那么，我们如何构造一个binding对象呢。有下面几种办法</p>\n<ul>\n<li>DataBindingUtil中提供了一些方法，如setcontentview，inflate,bind,getbind等等一些办法，</li>\n<li>同样，生成的具体binding类，如上面的ActivityBaseUseBinding中，也有inflate、bind等办法，不过，推荐使用DataBindingUtil的</li>\n</ul>\n<p>生成的databinding类中，还顺带生成了，我们在布局文件中，指定了id的控件，我们可以通过这个类去操作view，省去了我们findviewbyid。</p>\n<h4 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h4><p>绑定事件有两种方法，方法引用和监听器绑定，分别来说下。</p>\n<ol>\n<li><p>方法引用</p>\n<p> 首先声明一个类，</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public static class MethodRef&#123;</div><div class=\"line\">    public void onClick(View view) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;onClick: &quot; );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>其次，我们需要在布局文件中加入这个变量，并且为onclick属性绑定这个方法。\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;variable</div><div class=\"line\">          name=&quot;methodRef&quot;</div><div class=\"line\">          type=&quot;com.guolei.baseuse.EventHandling.MethodRef&quot;/&gt;</div><div class=\"line\">          </div><div class=\"line\">    &lt;Button</div><div class=\"line\">          android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">          android:layout_height=&quot;50dp&quot;</div><div class=\"line\">          android:onClick=&quot;@&#123;methodRef::onClick&#125;&quot;</div><div class=\"line\">          /&gt;</div></pre></td></tr></table></figure>\n\n\n最后，给这个绑定变量，binding.setMethodRef(new MethodRef())\n\n但是，这里有一个缺点，就是以这种方式绑定的方法，只能有view属性，不能有其他参数，有其他参数的情况下，编译会报错。怎么办呢？监听器绑定\n</code></pre><ol>\n<li>监听器绑定</li>\n</ol>\n<p>与方法绑定类似，不同的是在onclick属性中，我们使用的是如下表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@&#123;(it)-&gt;listener.onClick(student)&#125; 或者@&#123;()-&gt;listener.onClick(it,student)&#125;</div></pre></td></tr></table></figure>\n<p>上面只是OnClickListener的形式，其他的listener类似。</p>\n<h4 id=\"包含include标签的情况\"><a href=\"#包含include标签的情况\" class=\"headerlink\" title=\"包含include标签的情况\"></a>包含include标签的情况</h4><p>包含include标签的情况下我们如何给include的布局绑定呢</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class=\"line\">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</div><div class=\"line\">   &lt;data&gt;</div><div class=\"line\">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</div><div class=\"line\">   &lt;/data&gt;</div><div class=\"line\">   &lt;LinearLayout</div><div class=\"line\">       android:orientation=&quot;vertical&quot;</div><div class=\"line\">       android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">       android:layout_height=&quot;match_parent&quot;&gt;</div><div class=\"line\">       &lt;include layout=&quot;@layout/name&quot;</div><div class=\"line\">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</div><div class=\"line\">       &lt;include layout=&quot;@layout/contact&quot;</div><div class=\"line\">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</div><div class=\"line\">   &lt;/LinearLayout&gt;</div><div class=\"line\">&lt;/layout&gt;</div></pre></td></tr></table></figure>\n<p>官方例子，懒得自己写了。</p>\n<h4 id=\"set属性\"><a href=\"#set属性\" class=\"headerlink\" title=\"set属性\"></a>set属性</h4><p>set属性的方法就很简单了，这里分为三种情况。</p>\n<ol>\n<li>android:xxx属性，通过@{}绑定即可</li>\n<li>若为自定义控件，则app:xxx ，通过@{}绑定</li>\n<li>如对应的属性没有提供setXXX方法的话，就需要通过@BindingAdapter自定义，举个例子</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@android.databinding.BindingAdapter(&quot;app:progress&quot;)</div><div class=\"line\">public static void setProgress(View view,int progress) &#123;</div><div class=\"line\">    view.setPreogress(progress);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意，方法一定要是static的</li>\n<li>这样，我们就能在不居中通过app:progress来指定属性了</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇只说明了一些很简单很简单的基础用法，下篇会出一些比较高级的用法。当然，这篇中很多基础用法也没介绍完，个人感觉没啥输的，官方文档中很全很详细了。</p>\n<p><a href=\"https://developer.android.com/topic/libraries/data-binding/index.html\">官方文档，要翻墙！</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"databinding高级用法","date":"2017-08-26T15:48:29.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n上篇说了Databinding的基础用法，这次，来点别的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 双向绑定\n\n什么是双向绑定呢，上篇的绑定中，data的数据变化能反应到ui上，但是ui的变化却反应不到我们的data。以EditText为例，双向绑定会使输入框中数据的变化也反映到data上，能够省去我们很多事情。那么，如何开启双向绑定呢？我们只需要将@{}，变为@={}即可。我在使用的过程中，发现as2.2版本编译不过，升级到最新版本之后裁编译通过。\n\n双向绑定最常用的场景就是EditText了。这里就不举例了。\n\n### 属性监听\n\n这个又是什么呢？哦，说道这个，上篇貌似漏了个东西，要想使我们的数据变化能反应在ui上，那么我们的数据必须是可观察的，我们有两种方式实现，一种是继承BaseObservable，这种方式有个缺点，就是我们要显示的使用notifyPropertyChanged方法去通知属性变化，另外一种就是ObservableFields了。\n\n那么属性监听是个什么鬼。当我们使用mvvm的时候，严格来讲，vm层和view层是隔离的，在google的android-architecture中，有这么一句话。\n>In the MVVM architecture, Views react to changes in the ViewModel without being explicitly called. \n\n也就是说，viewmodel这一层中，并不能有显示的view调用，那么，有一些viewmodel无法反应到UI变化的业务场景怎么办，比如Toast、Snackbar之类的。这时候就需要用属性监听了。\n\nviewmodel这一层声明一个变量。\n\n```\npublic final ObservableField<Student> toastStr = new ObservableField<>();\n```\n\n然后，在Activity中。\n\n```\n        mViewModel.toastStr.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() {\n            @Override\n            public void onPropertyChanged(Observable sender, int propertyId) {\n                Toast.makeText(MainActivity.this, mViewModel.toastStr.get(), Toast.LENGTH_SHORT).show();\n            }\n        });\n```\n\n\n### RecyclerView中使用\n\n举个例子\n\n```\npublic class RecyclerViewAdapter extends android.support.v7.widget.RecyclerView.Adapter<RecyclerViewAdapter.ViewHolder> {\n\n    private Context context;\n    private ObservableArrayList<User> users;\n\n    public RecyclerViewAdapter(Context context, ObservableArrayList<User> users) {\n        this.context = context;\n        this.users = users;\n    }\n\n    @Override\n    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        ItemRecyclerBinding binding = DataBindingUtil.inflate(LayoutInflater.from(context),\n                R.layout.item_recycler, parent, false);\n        return new ViewHolder(binding);\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n        holder.dataBinding.setVariable(BR.user, users.get(position));\n        holder.dataBinding.executePendingBindings();\n    }\n\n    @Override\n    public int getItemCount() {\n        return users.size();\n    }\n\n    public class ViewHolder<T extends ViewDataBinding> extends RecyclerView.ViewHolder {\n        private T dataBinding;\n\n        public ViewHolder(T dataBinding) {\n            super(dataBinding.getRoot());\n            this.dataBinding = dataBinding;\n        }\n    }\n}\n```\n\n并不是有很大的难度，大家都看得明白。这里就不做过多解释。说下如何绑定数据把。\n\n```\n    @BindingAdapter(\"data\")\n    public void setData(final RecyclerView recyclerView, ObservableArrayList<Object> objects) {\n        objects.addOnListChangedCallback(new ObservableList.OnListChangedCallback<ObservableList<Object>>() {\n            @Override\n            public void onChanged(ObservableList<Object> sender) {\n                recyclerView.getAdapter().notifyDataSetChanged();\n            }\n\n            @Override\n            public void onItemRangeChanged(ObservableList<Object> sender, int positionStart, int itemCount) {\n                recyclerView.getAdapter().notifyItemRangeChanged(positionStart, itemCount);\n            }\n\n            @Override\n            public void onItemRangeInserted(ObservableList<Object> sender, int positionStart, int itemCount) {\n                recyclerView.getAdapter().notifyItemRangeInserted(positionStart, itemCount);\n            }\n\n            @Override\n            public void onItemRangeMoved(ObservableList<Object> sender, int fromPosition, int toPosition, int itemCount) {\n                recyclerView.getAdapter().notifyItemMoved(fromPosition, toPosition);\n            }\n\n            @Override\n            public void onItemRangeRemoved(ObservableList<Object> sender, int positionStart, int itemCount) {\n                recyclerView.getAdapter().notifyItemRangeRemoved(positionStart, itemCount);\n            }\n        });\n    }\n```\n\n像这样，就能够绑定数据了，这样，我们的数据变化，我们也不需要显示的调用相应的notify方法，但是这里还有个问题就是，我用了OnListChangedCallback之后，clear数据，再添加，recyclerview会闪烁，原因，还没找出来，惭愧。\n\n更新：闪烁原因找到，clear,的时候notify，add的时候又notify，原则上应该clear之后，add完成之后在notify，可以更改ObservableArrayList来实现。\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/databinding高级用法.md","raw":"---\ntitle: databinding高级用法\ndate: 2017-08-26 23:48:29\ntags: Android\ncategory: Android\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n上篇说了Databinding的基础用法，这次，来点别的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 双向绑定\n\n什么是双向绑定呢，上篇的绑定中，data的数据变化能反应到ui上，但是ui的变化却反应不到我们的data。以EditText为例，双向绑定会使输入框中数据的变化也反映到data上，能够省去我们很多事情。那么，如何开启双向绑定呢？我们只需要将@{}，变为@={}即可。我在使用的过程中，发现as2.2版本编译不过，升级到最新版本之后裁编译通过。\n\n双向绑定最常用的场景就是EditText了。这里就不举例了。\n\n### 属性监听\n\n这个又是什么呢？哦，说道这个，上篇貌似漏了个东西，要想使我们的数据变化能反应在ui上，那么我们的数据必须是可观察的，我们有两种方式实现，一种是继承BaseObservable，这种方式有个缺点，就是我们要显示的使用notifyPropertyChanged方法去通知属性变化，另外一种就是ObservableFields了。\n\n那么属性监听是个什么鬼。当我们使用mvvm的时候，严格来讲，vm层和view层是隔离的，在google的android-architecture中，有这么一句话。\n>In the MVVM architecture, Views react to changes in the ViewModel without being explicitly called. \n\n也就是说，viewmodel这一层中，并不能有显示的view调用，那么，有一些viewmodel无法反应到UI变化的业务场景怎么办，比如Toast、Snackbar之类的。这时候就需要用属性监听了。\n\nviewmodel这一层声明一个变量。\n\n```\npublic final ObservableField<Student> toastStr = new ObservableField<>();\n```\n\n然后，在Activity中。\n\n```\n        mViewModel.toastStr.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() {\n            @Override\n            public void onPropertyChanged(Observable sender, int propertyId) {\n                Toast.makeText(MainActivity.this, mViewModel.toastStr.get(), Toast.LENGTH_SHORT).show();\n            }\n        });\n```\n\n\n### RecyclerView中使用\n\n举个例子\n\n```\npublic class RecyclerViewAdapter extends android.support.v7.widget.RecyclerView.Adapter<RecyclerViewAdapter.ViewHolder> {\n\n    private Context context;\n    private ObservableArrayList<User> users;\n\n    public RecyclerViewAdapter(Context context, ObservableArrayList<User> users) {\n        this.context = context;\n        this.users = users;\n    }\n\n    @Override\n    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        ItemRecyclerBinding binding = DataBindingUtil.inflate(LayoutInflater.from(context),\n                R.layout.item_recycler, parent, false);\n        return new ViewHolder(binding);\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n        holder.dataBinding.setVariable(BR.user, users.get(position));\n        holder.dataBinding.executePendingBindings();\n    }\n\n    @Override\n    public int getItemCount() {\n        return users.size();\n    }\n\n    public class ViewHolder<T extends ViewDataBinding> extends RecyclerView.ViewHolder {\n        private T dataBinding;\n\n        public ViewHolder(T dataBinding) {\n            super(dataBinding.getRoot());\n            this.dataBinding = dataBinding;\n        }\n    }\n}\n```\n\n并不是有很大的难度，大家都看得明白。这里就不做过多解释。说下如何绑定数据把。\n\n```\n    @BindingAdapter(\"data\")\n    public void setData(final RecyclerView recyclerView, ObservableArrayList<Object> objects) {\n        objects.addOnListChangedCallback(new ObservableList.OnListChangedCallback<ObservableList<Object>>() {\n            @Override\n            public void onChanged(ObservableList<Object> sender) {\n                recyclerView.getAdapter().notifyDataSetChanged();\n            }\n\n            @Override\n            public void onItemRangeChanged(ObservableList<Object> sender, int positionStart, int itemCount) {\n                recyclerView.getAdapter().notifyItemRangeChanged(positionStart, itemCount);\n            }\n\n            @Override\n            public void onItemRangeInserted(ObservableList<Object> sender, int positionStart, int itemCount) {\n                recyclerView.getAdapter().notifyItemRangeInserted(positionStart, itemCount);\n            }\n\n            @Override\n            public void onItemRangeMoved(ObservableList<Object> sender, int fromPosition, int toPosition, int itemCount) {\n                recyclerView.getAdapter().notifyItemMoved(fromPosition, toPosition);\n            }\n\n            @Override\n            public void onItemRangeRemoved(ObservableList<Object> sender, int positionStart, int itemCount) {\n                recyclerView.getAdapter().notifyItemRangeRemoved(positionStart, itemCount);\n            }\n        });\n    }\n```\n\n像这样，就能够绑定数据了，这样，我们的数据变化，我们也不需要显示的调用相应的notify方法，但是这里还有个问题就是，我用了OnListChangedCallback之后，clear数据，再添加，recyclerview会闪烁，原因，还没找出来，惭愧。\n\n更新：闪烁原因找到，clear,的时候notify，add的时候又notify，原则上应该clear之后，add完成之后在notify，可以更改ObservableArrayList来实现。\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"databinding高级用法","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyp002z19fy5l9dt38d","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>上篇说了Databinding的基础用法，这次，来点别的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n<h3 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h3><p>什么是双向绑定呢，上篇的绑定中，data的数据变化能反应到ui上，但是ui的变化却反应不到我们的data。以EditText为例，双向绑定会使输入框中数据的变化也反映到data上，能够省去我们很多事情。那么，如何开启双向绑定呢？我们只需要将@{}，变为@={}即可。我在使用的过程中，发现as2.2版本编译不过，升级到最新版本之后裁编译通过。</p>\n<p>双向绑定最常用的场景就是EditText了。这里就不举例了。</p>\n<h3 id=\"属性监听\"><a href=\"#属性监听\" class=\"headerlink\" title=\"属性监听\"></a>属性监听</h3><p>这个又是什么呢？哦，说道这个，上篇貌似漏了个东西，要想使我们的数据变化能反应在ui上，那么我们的数据必须是可观察的，我们有两种方式实现，一种是继承BaseObservable，这种方式有个缺点，就是我们要显示的使用notifyPropertyChanged方法去通知属性变化，另外一种就是ObservableFields了。</p>\n<p>那么属性监听是个什么鬼。当我们使用mvvm的时候，严格来讲，vm层和view层是隔离的，在google的android-architecture中，有这么一句话。</p>\n<blockquote>\n<p>In the MVVM architecture, Views react to changes in the ViewModel without being explicitly called. </p>\n</blockquote>\n<p>也就是说，viewmodel这一层中，并不能有显示的view调用，那么，有一些viewmodel无法反应到UI变化的业务场景怎么办，比如Toast、Snackbar之类的。这时候就需要用属性监听了。</p>\n<p>viewmodel这一层声明一个变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final ObservableField&lt;Student&gt; toastStr = new ObservableField&lt;&gt;();</div></pre></td></tr></table></figure>\n<p>然后，在Activity中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">mViewModel.toastStr.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onPropertyChanged(Observable sender, int propertyId) &#123;</div><div class=\"line\">        Toast.makeText(MainActivity.this, mViewModel.toastStr.get(), Toast.LENGTH_SHORT).show();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"RecyclerView中使用\"><a href=\"#RecyclerView中使用\" class=\"headerlink\" title=\"RecyclerView中使用\"></a>RecyclerView中使用</h3><p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class RecyclerViewAdapter extends android.support.v7.widget.RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">    private Context context;</div><div class=\"line\">    private ObservableArrayList&lt;User&gt; users;</div><div class=\"line\"></div><div class=\"line\">    public RecyclerViewAdapter(Context context, ObservableArrayList&lt;User&gt; users) &#123;</div><div class=\"line\">        this.context = context;</div><div class=\"line\">        this.users = users;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class=\"line\">        ItemRecyclerBinding binding = DataBindingUtil.inflate(LayoutInflater.from(context),</div><div class=\"line\">                R.layout.item_recycler, parent, false);</div><div class=\"line\">        return new ViewHolder(binding);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onBindViewHolder(ViewHolder holder, int position) &#123;</div><div class=\"line\">        holder.dataBinding.setVariable(BR.user, users.get(position));</div><div class=\"line\">        holder.dataBinding.executePendingBindings();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public int getItemCount() &#123;</div><div class=\"line\">        return users.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public class ViewHolder&lt;T extends ViewDataBinding&gt; extends RecyclerView.ViewHolder &#123;</div><div class=\"line\">        private T dataBinding;</div><div class=\"line\"></div><div class=\"line\">        public ViewHolder(T dataBinding) &#123;</div><div class=\"line\">            super(dataBinding.getRoot());</div><div class=\"line\">            this.dataBinding = dataBinding;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并不是有很大的难度，大家都看得明白。这里就不做过多解释。说下如何绑定数据把。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">@BindingAdapter(&quot;data&quot;)</div><div class=\"line\">public void setData(final RecyclerView recyclerView, ObservableArrayList&lt;Object&gt; objects) &#123;</div><div class=\"line\">    objects.addOnListChangedCallback(new ObservableList.OnListChangedCallback&lt;ObservableList&lt;Object&gt;&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void onChanged(ObservableList&lt;Object&gt; sender) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyDataSetChanged();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onItemRangeChanged(ObservableList&lt;Object&gt; sender, int positionStart, int itemCount) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyItemRangeChanged(positionStart, itemCount);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onItemRangeInserted(ObservableList&lt;Object&gt; sender, int positionStart, int itemCount) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyItemRangeInserted(positionStart, itemCount);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onItemRangeMoved(ObservableList&lt;Object&gt; sender, int fromPosition, int toPosition, int itemCount) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyItemMoved(fromPosition, toPosition);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onItemRangeRemoved(ObservableList&lt;Object&gt; sender, int positionStart, int itemCount) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyItemRangeRemoved(positionStart, itemCount);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像这样，就能够绑定数据了，这样，我们的数据变化，我们也不需要显示的调用相应的notify方法，但是这里还有个问题就是，我用了OnListChangedCallback之后，clear数据，再添加，recyclerview会闪烁，原因，还没找出来，惭愧。</p>\n<p>更新：闪烁原因找到，clear,的时候notify，add的时候又notify，原则上应该clear之后，add完成之后在notify，可以更改ObservableArrayList来实现。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>上篇说了Databinding的基础用法，这次，来点别的。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n\n<h3 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h3><p>什么是双向绑定呢，上篇的绑定中，data的数据变化能反应到ui上，但是ui的变化却反应不到我们的data。以EditText为例，双向绑定会使输入框中数据的变化也反映到data上，能够省去我们很多事情。那么，如何开启双向绑定呢？我们只需要将@{}，变为@={}即可。我在使用的过程中，发现as2.2版本编译不过，升级到最新版本之后裁编译通过。</p>\n<p>双向绑定最常用的场景就是EditText了。这里就不举例了。</p>\n<h3 id=\"属性监听\"><a href=\"#属性监听\" class=\"headerlink\" title=\"属性监听\"></a>属性监听</h3><p>这个又是什么呢？哦，说道这个，上篇貌似漏了个东西，要想使我们的数据变化能反应在ui上，那么我们的数据必须是可观察的，我们有两种方式实现，一种是继承BaseObservable，这种方式有个缺点，就是我们要显示的使用notifyPropertyChanged方法去通知属性变化，另外一种就是ObservableFields了。</p>\n<p>那么属性监听是个什么鬼。当我们使用mvvm的时候，严格来讲，vm层和view层是隔离的，在google的android-architecture中，有这么一句话。</p>\n<blockquote>\n<p>In the MVVM architecture, Views react to changes in the ViewModel without being explicitly called. </p>\n</blockquote>\n<p>也就是说，viewmodel这一层中，并不能有显示的view调用，那么，有一些viewmodel无法反应到UI变化的业务场景怎么办，比如Toast、Snackbar之类的。这时候就需要用属性监听了。</p>\n<p>viewmodel这一层声明一个变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final ObservableField&lt;Student&gt; toastStr = new ObservableField&lt;&gt;();</div></pre></td></tr></table></figure>\n<p>然后，在Activity中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">mViewModel.toastStr.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onPropertyChanged(Observable sender, int propertyId) &#123;</div><div class=\"line\">        Toast.makeText(MainActivity.this, mViewModel.toastStr.get(), Toast.LENGTH_SHORT).show();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"RecyclerView中使用\"><a href=\"#RecyclerView中使用\" class=\"headerlink\" title=\"RecyclerView中使用\"></a>RecyclerView中使用</h3><p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class RecyclerViewAdapter extends android.support.v7.widget.RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">    private Context context;</div><div class=\"line\">    private ObservableArrayList&lt;User&gt; users;</div><div class=\"line\"></div><div class=\"line\">    public RecyclerViewAdapter(Context context, ObservableArrayList&lt;User&gt; users) &#123;</div><div class=\"line\">        this.context = context;</div><div class=\"line\">        this.users = users;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class=\"line\">        ItemRecyclerBinding binding = DataBindingUtil.inflate(LayoutInflater.from(context),</div><div class=\"line\">                R.layout.item_recycler, parent, false);</div><div class=\"line\">        return new ViewHolder(binding);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onBindViewHolder(ViewHolder holder, int position) &#123;</div><div class=\"line\">        holder.dataBinding.setVariable(BR.user, users.get(position));</div><div class=\"line\">        holder.dataBinding.executePendingBindings();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public int getItemCount() &#123;</div><div class=\"line\">        return users.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public class ViewHolder&lt;T extends ViewDataBinding&gt; extends RecyclerView.ViewHolder &#123;</div><div class=\"line\">        private T dataBinding;</div><div class=\"line\"></div><div class=\"line\">        public ViewHolder(T dataBinding) &#123;</div><div class=\"line\">            super(dataBinding.getRoot());</div><div class=\"line\">            this.dataBinding = dataBinding;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并不是有很大的难度，大家都看得明白。这里就不做过多解释。说下如何绑定数据把。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">@BindingAdapter(&quot;data&quot;)</div><div class=\"line\">public void setData(final RecyclerView recyclerView, ObservableArrayList&lt;Object&gt; objects) &#123;</div><div class=\"line\">    objects.addOnListChangedCallback(new ObservableList.OnListChangedCallback&lt;ObservableList&lt;Object&gt;&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void onChanged(ObservableList&lt;Object&gt; sender) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyDataSetChanged();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onItemRangeChanged(ObservableList&lt;Object&gt; sender, int positionStart, int itemCount) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyItemRangeChanged(positionStart, itemCount);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onItemRangeInserted(ObservableList&lt;Object&gt; sender, int positionStart, int itemCount) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyItemRangeInserted(positionStart, itemCount);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onItemRangeMoved(ObservableList&lt;Object&gt; sender, int fromPosition, int toPosition, int itemCount) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyItemMoved(fromPosition, toPosition);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onItemRangeRemoved(ObservableList&lt;Object&gt; sender, int positionStart, int itemCount) &#123;</div><div class=\"line\">            recyclerView.getAdapter().notifyItemRangeRemoved(positionStart, itemCount);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像这样，就能够绑定数据了，这样，我们的数据变化，我们也不需要显示的调用相应的notify方法，但是这里还有个问题就是，我用了OnListChangedCallback之后，clear数据，再添加，recyclerview会闪烁，原因，还没找出来，惭愧。</p>\n<p>更新：闪烁原因找到，clear,的时候notify，add的时候又notify，原则上应该clear之后，add完成之后在notify，可以更改ObservableArrayList来实现。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco初始化过程","date":"2016-12-12T06:27:31.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1.初始化相关\n\n* ImagePipelineFactory\n* PipelineDraweeControllerBuilderSupplier\n* SimpleDraweeView\n\n在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n* AnimatedImageFactory 负责解析 动态图，gif和webp\n* Bitmap.Config 图片质量\n* Supplier<MemoryCacheParams> 内存cache的配置参数\n* CacheKeyFactory 生成cachekey的工厂\n* Context\n* mDownsampleEnabled \n* mDecodeMemoryFileEnabled \n* FileCacheFactory 文件缓存的工厂\n* mEncodedMemoryCacheParamsSupplier \n* mExecutorSupplier 线程池集\n* ImageCacheStatsTracker 图片缓存状态跟踪器\n* ImageDecoder 图片解析\n* mIsPrefetchEnabledSupplier\n* mMainDiskCacheConfig disk磁盘缓存配置\n* mMemoryTrimmableRegistry 内存检测注入\n* NetworkFetcher 网络访问，用于封装网络\n* PlatformBitmapFactory 配置bitmap 平台信息\n* PoolFactory poolfactory\n* ProgressiveJpegConfig \n* mRequestListeners 请求监听器\n* mResizeAndRotateEnabledForNetwork 是否允许调整和旋转\n* mSmallImageDiskCacheConfig small disk config\n* ImagePipelineExperiments.Builder\n\n\n其中，大部分我们并不需要配置。\n\n#### 1.1 MemoryCacheParams\n\n内部含有五个成员\n\n* maxCacheSize cache 最大容量\n* maxCacheEntries cache中 最多呢个存多少个item（块）\n* maxEvictionQueueSize 准备回收 但是还没回收的 容量\n* maxEvictionQueueEntries 每个块的最大回收数\n* maxCacheEntrySize 每个块的最大的数\n\n从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，\n\n#### 1.2 CacheKeyFactory\n\n生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。\n\n\n默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。\n\n\n#### 1.3 FileCacheFactory中的DiskCacheConfig\n\n配置版本，cache路径，大小，error log等\n\n#### 1.4 ImageCacheStatsTracker\n\ncache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，\n\n#### 1.5 ImageDecoder\n\n图片解码的入口类。\n\n#### 1.6 NetworkFetcher\n\n网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的\n\n#### 1.7 PlatformBitmapFactory\n\n用于createbitmap，并且添加引用信息有三个实现类。\n\n* GingerbreadBitmapFactory\n* HoneycombBitmapFactory 对应kikat\n* ArtBitmapFactory 对应arm\n\n\n具体的实现这里暂时忽略。\n\n\n\n#### 1.8 PoolFactory\n根据PoolConfig，配置PoolFactory。\n\n```\n   private final PoolParams mBitmapPoolParams;\n  private final PoolStatsTracker mBitmapPoolStatsTracker;\n  private final PoolParams mFlexByteArrayPoolParams;\n  private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;\n  private final PoolParams mNativeMemoryChunkPoolParams;\n  private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;\n  private final PoolParams mSmallByteArrayPoolParams;\n  private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;\n  \n```\n\npoolparams负责配置各种参数，内含三种参数类型。\n\n* PoolParams\n\t* maxSizeSoftCap 最大软 size\n\t* maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存\n\t* bucketSizes 每个桶及其对应的容量\n\t* minBucketSize 桶最小size\n\t* maxBucketSize 桶最大size\n* PoolStatsTracker 状态监测，包括释放 申请内存等\n* MemoryTrimmableRegistry\n\n\n#### 1.9 ProgressiveJpegConfig\n\n渐近式jpeg，\n\n#### 1.10 DiskCacheConfig\n\n磁盘配置。略\n\n### 2. PipelineDraweeControllerBuilderSupplier\n\n\n构造出PipelineDraweeControllerBuilder。\n\n```\n  public PipelineDraweeControllerBuilderSupplier(\n      Context context,\n      ImagePipelineFactory imagePipelineFactory,\n      Set<ControllerListener> boundControllerListeners) {\n    mContext = context;\n    mImagePipeline = imagePipelineFactory.getImagePipeline();\n\n    final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();\n    AnimatedDrawableFactory animatedDrawableFactory = null;\n    if (animatedFactory != null) {\n      animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);\n    }\n\n    mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(\n        context.getResources(),\n        DeferredReleaser.getInstance(),\n        animatedDrawableFactory,\n        UiThreadImmediateExecutorService.getInstance(),\n        mImagePipeline.getBitmapMemoryCache());\n    mBoundControllerListeners = boundControllerListeners;\n  }\n```\n\n* imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。\n* mPipelineDraweeControllerFactory\n* mBoundControllerListeners 默认为null\n\n#### 2.1 ImagePipelineFactory\n\n内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。\n\n#### 2.2 PipelineDraweeControllerFactory\n\n负责构造PipelineDraweeController。有几个默认的参数。\n\n* Resources\n* DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。\n* AnimatedDrawableFactory\n* Executor\n* MemoryCache<CacheKey, CloseableImage>\n\n\n### 3 SimpleDraweeView#initialize\n\n只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/fresco初始化过程.md","raw":"---\ntitle: fresco初始化过程\ndate: 2016-12-12 14:27:31\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1.初始化相关\n\n* ImagePipelineFactory\n* PipelineDraweeControllerBuilderSupplier\n* SimpleDraweeView\n\n在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n* AnimatedImageFactory 负责解析 动态图，gif和webp\n* Bitmap.Config 图片质量\n* Supplier<MemoryCacheParams> 内存cache的配置参数\n* CacheKeyFactory 生成cachekey的工厂\n* Context\n* mDownsampleEnabled \n* mDecodeMemoryFileEnabled \n* FileCacheFactory 文件缓存的工厂\n* mEncodedMemoryCacheParamsSupplier \n* mExecutorSupplier 线程池集\n* ImageCacheStatsTracker 图片缓存状态跟踪器\n* ImageDecoder 图片解析\n* mIsPrefetchEnabledSupplier\n* mMainDiskCacheConfig disk磁盘缓存配置\n* mMemoryTrimmableRegistry 内存检测注入\n* NetworkFetcher 网络访问，用于封装网络\n* PlatformBitmapFactory 配置bitmap 平台信息\n* PoolFactory poolfactory\n* ProgressiveJpegConfig \n* mRequestListeners 请求监听器\n* mResizeAndRotateEnabledForNetwork 是否允许调整和旋转\n* mSmallImageDiskCacheConfig small disk config\n* ImagePipelineExperiments.Builder\n\n\n其中，大部分我们并不需要配置。\n\n#### 1.1 MemoryCacheParams\n\n内部含有五个成员\n\n* maxCacheSize cache 最大容量\n* maxCacheEntries cache中 最多呢个存多少个item（块）\n* maxEvictionQueueSize 准备回收 但是还没回收的 容量\n* maxEvictionQueueEntries 每个块的最大回收数\n* maxCacheEntrySize 每个块的最大的数\n\n从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，\n\n#### 1.2 CacheKeyFactory\n\n生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。\n\n\n默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。\n\n\n#### 1.3 FileCacheFactory中的DiskCacheConfig\n\n配置版本，cache路径，大小，error log等\n\n#### 1.4 ImageCacheStatsTracker\n\ncache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，\n\n#### 1.5 ImageDecoder\n\n图片解码的入口类。\n\n#### 1.6 NetworkFetcher\n\n网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的\n\n#### 1.7 PlatformBitmapFactory\n\n用于createbitmap，并且添加引用信息有三个实现类。\n\n* GingerbreadBitmapFactory\n* HoneycombBitmapFactory 对应kikat\n* ArtBitmapFactory 对应arm\n\n\n具体的实现这里暂时忽略。\n\n\n\n#### 1.8 PoolFactory\n根据PoolConfig，配置PoolFactory。\n\n```\n   private final PoolParams mBitmapPoolParams;\n  private final PoolStatsTracker mBitmapPoolStatsTracker;\n  private final PoolParams mFlexByteArrayPoolParams;\n  private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;\n  private final PoolParams mNativeMemoryChunkPoolParams;\n  private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;\n  private final PoolParams mSmallByteArrayPoolParams;\n  private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;\n  \n```\n\npoolparams负责配置各种参数，内含三种参数类型。\n\n* PoolParams\n\t* maxSizeSoftCap 最大软 size\n\t* maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存\n\t* bucketSizes 每个桶及其对应的容量\n\t* minBucketSize 桶最小size\n\t* maxBucketSize 桶最大size\n* PoolStatsTracker 状态监测，包括释放 申请内存等\n* MemoryTrimmableRegistry\n\n\n#### 1.9 ProgressiveJpegConfig\n\n渐近式jpeg，\n\n#### 1.10 DiskCacheConfig\n\n磁盘配置。略\n\n### 2. PipelineDraweeControllerBuilderSupplier\n\n\n构造出PipelineDraweeControllerBuilder。\n\n```\n  public PipelineDraweeControllerBuilderSupplier(\n      Context context,\n      ImagePipelineFactory imagePipelineFactory,\n      Set<ControllerListener> boundControllerListeners) {\n    mContext = context;\n    mImagePipeline = imagePipelineFactory.getImagePipeline();\n\n    final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();\n    AnimatedDrawableFactory animatedDrawableFactory = null;\n    if (animatedFactory != null) {\n      animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);\n    }\n\n    mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(\n        context.getResources(),\n        DeferredReleaser.getInstance(),\n        animatedDrawableFactory,\n        UiThreadImmediateExecutorService.getInstance(),\n        mImagePipeline.getBitmapMemoryCache());\n    mBoundControllerListeners = boundControllerListeners;\n  }\n```\n\n* imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。\n* mPipelineDraweeControllerFactory\n* mBoundControllerListeners 默认为null\n\n#### 2.1 ImagePipelineFactory\n\n内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。\n\n#### 2.2 PipelineDraweeControllerFactory\n\n负责构造PipelineDraweeController。有几个默认的参数。\n\n* Resources\n* DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。\n* AnimatedDrawableFactory\n* Executor\n* MemoryCache<CacheKey, CloseableImage>\n\n\n### 3 SimpleDraweeView#initialize\n\n只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"fresco初始化过程","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyr003219fyqw72e2z3","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-初始化相关\"><a href=\"#1-初始化相关\" class=\"headerlink\" title=\"1.初始化相关\"></a>1.初始化相关</h3><ul>\n<li>ImagePipelineFactory</li>\n<li>PipelineDraweeControllerBuilderSupplier</li>\n<li>SimpleDraweeView</li>\n</ul>\n<p>在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n<ul>\n<li>AnimatedImageFactory 负责解析 动态图，gif和webp</li>\n<li>Bitmap.Config 图片质量</li>\n<li>Supplier<memorycacheparams> 内存cache的配置参数</memorycacheparams></li>\n<li>CacheKeyFactory 生成cachekey的工厂</li>\n<li>Context</li>\n<li>mDownsampleEnabled </li>\n<li>mDecodeMemoryFileEnabled </li>\n<li>FileCacheFactory 文件缓存的工厂</li>\n<li>mEncodedMemoryCacheParamsSupplier </li>\n<li>mExecutorSupplier 线程池集</li>\n<li>ImageCacheStatsTracker 图片缓存状态跟踪器</li>\n<li>ImageDecoder 图片解析</li>\n<li>mIsPrefetchEnabledSupplier</li>\n<li>mMainDiskCacheConfig disk磁盘缓存配置</li>\n<li>mMemoryTrimmableRegistry 内存检测注入</li>\n<li>NetworkFetcher 网络访问，用于封装网络</li>\n<li>PlatformBitmapFactory 配置bitmap 平台信息</li>\n<li>PoolFactory poolfactory</li>\n<li>ProgressiveJpegConfig </li>\n<li>mRequestListeners 请求监听器</li>\n<li>mResizeAndRotateEnabledForNetwork 是否允许调整和旋转</li>\n<li>mSmallImageDiskCacheConfig small disk config</li>\n<li>ImagePipelineExperiments.Builder</li>\n</ul>\n<p>其中，大部分我们并不需要配置。</p>\n<h4 id=\"1-1-MemoryCacheParams\"><a href=\"#1-1-MemoryCacheParams\" class=\"headerlink\" title=\"1.1 MemoryCacheParams\"></a>1.1 MemoryCacheParams</h4><p>内部含有五个成员</p>\n<ul>\n<li>maxCacheSize cache 最大容量</li>\n<li>maxCacheEntries cache中 最多呢个存多少个item（块）</li>\n<li>maxEvictionQueueSize 准备回收 但是还没回收的 容量</li>\n<li>maxEvictionQueueEntries 每个块的最大回收数</li>\n<li>maxCacheEntrySize 每个块的最大的数</li>\n</ul>\n<p>从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，</p>\n<h4 id=\"1-2-CacheKeyFactory\"><a href=\"#1-2-CacheKeyFactory\" class=\"headerlink\" title=\"1.2 CacheKeyFactory\"></a>1.2 CacheKeyFactory</h4><p>生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。</p>\n<p>默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。</p>\n<h4 id=\"1-3-FileCacheFactory中的DiskCacheConfig\"><a href=\"#1-3-FileCacheFactory中的DiskCacheConfig\" class=\"headerlink\" title=\"1.3 FileCacheFactory中的DiskCacheConfig\"></a>1.3 FileCacheFactory中的DiskCacheConfig</h4><p>配置版本，cache路径，大小，error log等</p>\n<h4 id=\"1-4-ImageCacheStatsTracker\"><a href=\"#1-4-ImageCacheStatsTracker\" class=\"headerlink\" title=\"1.4 ImageCacheStatsTracker\"></a>1.4 ImageCacheStatsTracker</h4><p>cache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，</p>\n<h4 id=\"1-5-ImageDecoder\"><a href=\"#1-5-ImageDecoder\" class=\"headerlink\" title=\"1.5 ImageDecoder\"></a>1.5 ImageDecoder</h4><p>图片解码的入口类。</p>\n<h4 id=\"1-6-NetworkFetcher\"><a href=\"#1-6-NetworkFetcher\" class=\"headerlink\" title=\"1.6 NetworkFetcher\"></a>1.6 NetworkFetcher</h4><p>网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的</p>\n<h4 id=\"1-7-PlatformBitmapFactory\"><a href=\"#1-7-PlatformBitmapFactory\" class=\"headerlink\" title=\"1.7 PlatformBitmapFactory\"></a>1.7 PlatformBitmapFactory</h4><p>用于createbitmap，并且添加引用信息有三个实现类。</p>\n<ul>\n<li>GingerbreadBitmapFactory</li>\n<li>HoneycombBitmapFactory 对应kikat</li>\n<li>ArtBitmapFactory 对应arm</li>\n</ul>\n<p>具体的实现这里暂时忽略。</p>\n<h4 id=\"1-8-PoolFactory\"><a href=\"#1-8-PoolFactory\" class=\"headerlink\" title=\"1.8 PoolFactory\"></a>1.8 PoolFactory</h4><p>根据PoolConfig，配置PoolFactory。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private final PoolParams mBitmapPoolParams;</div><div class=\"line\">private final PoolStatsTracker mBitmapPoolStatsTracker;</div><div class=\"line\">private final PoolParams mFlexByteArrayPoolParams;</div><div class=\"line\">private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;</div><div class=\"line\">private final PoolParams mNativeMemoryChunkPoolParams;</div><div class=\"line\">private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;</div><div class=\"line\">private final PoolParams mSmallByteArrayPoolParams;</div><div class=\"line\">private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;</div></pre></td></tr></table></figure>\n<p>poolparams负责配置各种参数，内含三种参数类型。</p>\n<ul>\n<li>PoolParams<ul>\n<li>maxSizeSoftCap 最大软 size</li>\n<li>maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存</li>\n<li>bucketSizes 每个桶及其对应的容量</li>\n<li>minBucketSize 桶最小size</li>\n<li>maxBucketSize 桶最大size</li>\n</ul>\n</li>\n<li>PoolStatsTracker 状态监测，包括释放 申请内存等</li>\n<li>MemoryTrimmableRegistry</li>\n</ul>\n<h4 id=\"1-9-ProgressiveJpegConfig\"><a href=\"#1-9-ProgressiveJpegConfig\" class=\"headerlink\" title=\"1.9 ProgressiveJpegConfig\"></a>1.9 ProgressiveJpegConfig</h4><p>渐近式jpeg，</p>\n<h4 id=\"1-10-DiskCacheConfig\"><a href=\"#1-10-DiskCacheConfig\" class=\"headerlink\" title=\"1.10 DiskCacheConfig\"></a>1.10 DiskCacheConfig</h4><p>磁盘配置。略</p>\n<h3 id=\"2-PipelineDraweeControllerBuilderSupplier\"><a href=\"#2-PipelineDraweeControllerBuilderSupplier\" class=\"headerlink\" title=\"2. PipelineDraweeControllerBuilderSupplier\"></a>2. PipelineDraweeControllerBuilderSupplier</h3><p>构造出PipelineDraweeControllerBuilder。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public PipelineDraweeControllerBuilderSupplier(</div><div class=\"line\">    Context context,</div><div class=\"line\">    ImagePipelineFactory imagePipelineFactory,</div><div class=\"line\">    Set&lt;ControllerListener&gt; boundControllerListeners) &#123;</div><div class=\"line\">  mContext = context;</div><div class=\"line\">  mImagePipeline = imagePipelineFactory.getImagePipeline();</div><div class=\"line\"></div><div class=\"line\">  final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();</div><div class=\"line\">  AnimatedDrawableFactory animatedDrawableFactory = null;</div><div class=\"line\">  if (animatedFactory != null) &#123;</div><div class=\"line\">    animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(</div><div class=\"line\">      context.getResources(),</div><div class=\"line\">      DeferredReleaser.getInstance(),</div><div class=\"line\">      animatedDrawableFactory,</div><div class=\"line\">      UiThreadImmediateExecutorService.getInstance(),</div><div class=\"line\">      mImagePipeline.getBitmapMemoryCache());</div><div class=\"line\">  mBoundControllerListeners = boundControllerListeners;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。</li>\n<li>mPipelineDraweeControllerFactory</li>\n<li>mBoundControllerListeners 默认为null</li>\n</ul>\n<h4 id=\"2-1-ImagePipelineFactory\"><a href=\"#2-1-ImagePipelineFactory\" class=\"headerlink\" title=\"2.1 ImagePipelineFactory\"></a>2.1 ImagePipelineFactory</h4><p>内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。</p>\n<h4 id=\"2-2-PipelineDraweeControllerFactory\"><a href=\"#2-2-PipelineDraweeControllerFactory\" class=\"headerlink\" title=\"2.2 PipelineDraweeControllerFactory\"></a>2.2 PipelineDraweeControllerFactory</h4><p>负责构造PipelineDraweeController。有几个默认的参数。</p>\n<ul>\n<li>Resources</li>\n<li>DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。</li>\n<li>AnimatedDrawableFactory</li>\n<li>Executor</li>\n<li>MemoryCache<cachekey, closeableimage=\"\"></cachekey,></li>\n</ul>\n<h3 id=\"3-SimpleDraweeView-initialize\"><a href=\"#3-SimpleDraweeView-initialize\" class=\"headerlink\" title=\"3 SimpleDraweeView#initialize\"></a>3 SimpleDraweeView#initialize</h3><p>只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-初始化相关\"><a href=\"#1-初始化相关\" class=\"headerlink\" title=\"1.初始化相关\"></a>1.初始化相关</h3><ul>\n<li>ImagePipelineFactory</li>\n<li>PipelineDraweeControllerBuilderSupplier</li>\n<li>SimpleDraweeView</li>\n</ul>\n<p>在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：</p>","more":"<The rest of contents | 余下全文>\n\n\n\n\n<ul>\n<li>AnimatedImageFactory 负责解析 动态图，gif和webp</li>\n<li>Bitmap.Config 图片质量</li>\n<li>Supplier<MemoryCacheParams> 内存cache的配置参数</li>\n<li>CacheKeyFactory 生成cachekey的工厂</li>\n<li>Context</li>\n<li>mDownsampleEnabled </li>\n<li>mDecodeMemoryFileEnabled </li>\n<li>FileCacheFactory 文件缓存的工厂</li>\n<li>mEncodedMemoryCacheParamsSupplier </li>\n<li>mExecutorSupplier 线程池集</li>\n<li>ImageCacheStatsTracker 图片缓存状态跟踪器</li>\n<li>ImageDecoder 图片解析</li>\n<li>mIsPrefetchEnabledSupplier</li>\n<li>mMainDiskCacheConfig disk磁盘缓存配置</li>\n<li>mMemoryTrimmableRegistry 内存检测注入</li>\n<li>NetworkFetcher 网络访问，用于封装网络</li>\n<li>PlatformBitmapFactory 配置bitmap 平台信息</li>\n<li>PoolFactory poolfactory</li>\n<li>ProgressiveJpegConfig </li>\n<li>mRequestListeners 请求监听器</li>\n<li>mResizeAndRotateEnabledForNetwork 是否允许调整和旋转</li>\n<li>mSmallImageDiskCacheConfig small disk config</li>\n<li>ImagePipelineExperiments.Builder</li>\n</ul>\n<p>其中，大部分我们并不需要配置。</p>\n<h4 id=\"1-1-MemoryCacheParams\"><a href=\"#1-1-MemoryCacheParams\" class=\"headerlink\" title=\"1.1 MemoryCacheParams\"></a>1.1 MemoryCacheParams</h4><p>内部含有五个成员</p>\n<ul>\n<li>maxCacheSize cache 最大容量</li>\n<li>maxCacheEntries cache中 最多呢个存多少个item（块）</li>\n<li>maxEvictionQueueSize 准备回收 但是还没回收的 容量</li>\n<li>maxEvictionQueueEntries 每个块的最大回收数</li>\n<li>maxCacheEntrySize 每个块的最大的数</li>\n</ul>\n<p>从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，</p>\n<h4 id=\"1-2-CacheKeyFactory\"><a href=\"#1-2-CacheKeyFactory\" class=\"headerlink\" title=\"1.2 CacheKeyFactory\"></a>1.2 CacheKeyFactory</h4><p>生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。</p>\n<p>默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。</p>\n<h4 id=\"1-3-FileCacheFactory中的DiskCacheConfig\"><a href=\"#1-3-FileCacheFactory中的DiskCacheConfig\" class=\"headerlink\" title=\"1.3 FileCacheFactory中的DiskCacheConfig\"></a>1.3 FileCacheFactory中的DiskCacheConfig</h4><p>配置版本，cache路径，大小，error log等</p>\n<h4 id=\"1-4-ImageCacheStatsTracker\"><a href=\"#1-4-ImageCacheStatsTracker\" class=\"headerlink\" title=\"1.4 ImageCacheStatsTracker\"></a>1.4 ImageCacheStatsTracker</h4><p>cache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，</p>\n<h4 id=\"1-5-ImageDecoder\"><a href=\"#1-5-ImageDecoder\" class=\"headerlink\" title=\"1.5 ImageDecoder\"></a>1.5 ImageDecoder</h4><p>图片解码的入口类。</p>\n<h4 id=\"1-6-NetworkFetcher\"><a href=\"#1-6-NetworkFetcher\" class=\"headerlink\" title=\"1.6 NetworkFetcher\"></a>1.6 NetworkFetcher</h4><p>网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的</p>\n<h4 id=\"1-7-PlatformBitmapFactory\"><a href=\"#1-7-PlatformBitmapFactory\" class=\"headerlink\" title=\"1.7 PlatformBitmapFactory\"></a>1.7 PlatformBitmapFactory</h4><p>用于createbitmap，并且添加引用信息有三个实现类。</p>\n<ul>\n<li>GingerbreadBitmapFactory</li>\n<li>HoneycombBitmapFactory 对应kikat</li>\n<li>ArtBitmapFactory 对应arm</li>\n</ul>\n<p>具体的实现这里暂时忽略。</p>\n<h4 id=\"1-8-PoolFactory\"><a href=\"#1-8-PoolFactory\" class=\"headerlink\" title=\"1.8 PoolFactory\"></a>1.8 PoolFactory</h4><p>根据PoolConfig，配置PoolFactory。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private final PoolParams mBitmapPoolParams;</div><div class=\"line\">private final PoolStatsTracker mBitmapPoolStatsTracker;</div><div class=\"line\">private final PoolParams mFlexByteArrayPoolParams;</div><div class=\"line\">private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;</div><div class=\"line\">private final PoolParams mNativeMemoryChunkPoolParams;</div><div class=\"line\">private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;</div><div class=\"line\">private final PoolParams mSmallByteArrayPoolParams;</div><div class=\"line\">private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;</div></pre></td></tr></table></figure>\n<p>poolparams负责配置各种参数，内含三种参数类型。</p>\n<ul>\n<li>PoolParams<ul>\n<li>maxSizeSoftCap 最大软 size</li>\n<li>maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存</li>\n<li>bucketSizes 每个桶及其对应的容量</li>\n<li>minBucketSize 桶最小size</li>\n<li>maxBucketSize 桶最大size</li>\n</ul>\n</li>\n<li>PoolStatsTracker 状态监测，包括释放 申请内存等</li>\n<li>MemoryTrimmableRegistry</li>\n</ul>\n<h4 id=\"1-9-ProgressiveJpegConfig\"><a href=\"#1-9-ProgressiveJpegConfig\" class=\"headerlink\" title=\"1.9 ProgressiveJpegConfig\"></a>1.9 ProgressiveJpegConfig</h4><p>渐近式jpeg，</p>\n<h4 id=\"1-10-DiskCacheConfig\"><a href=\"#1-10-DiskCacheConfig\" class=\"headerlink\" title=\"1.10 DiskCacheConfig\"></a>1.10 DiskCacheConfig</h4><p>磁盘配置。略</p>\n<h3 id=\"2-PipelineDraweeControllerBuilderSupplier\"><a href=\"#2-PipelineDraweeControllerBuilderSupplier\" class=\"headerlink\" title=\"2. PipelineDraweeControllerBuilderSupplier\"></a>2. PipelineDraweeControllerBuilderSupplier</h3><p>构造出PipelineDraweeControllerBuilder。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public PipelineDraweeControllerBuilderSupplier(</div><div class=\"line\">    Context context,</div><div class=\"line\">    ImagePipelineFactory imagePipelineFactory,</div><div class=\"line\">    Set&lt;ControllerListener&gt; boundControllerListeners) &#123;</div><div class=\"line\">  mContext = context;</div><div class=\"line\">  mImagePipeline = imagePipelineFactory.getImagePipeline();</div><div class=\"line\"></div><div class=\"line\">  final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();</div><div class=\"line\">  AnimatedDrawableFactory animatedDrawableFactory = null;</div><div class=\"line\">  if (animatedFactory != null) &#123;</div><div class=\"line\">    animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(</div><div class=\"line\">      context.getResources(),</div><div class=\"line\">      DeferredReleaser.getInstance(),</div><div class=\"line\">      animatedDrawableFactory,</div><div class=\"line\">      UiThreadImmediateExecutorService.getInstance(),</div><div class=\"line\">      mImagePipeline.getBitmapMemoryCache());</div><div class=\"line\">  mBoundControllerListeners = boundControllerListeners;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。</li>\n<li>mPipelineDraweeControllerFactory</li>\n<li>mBoundControllerListeners 默认为null</li>\n</ul>\n<h4 id=\"2-1-ImagePipelineFactory\"><a href=\"#2-1-ImagePipelineFactory\" class=\"headerlink\" title=\"2.1 ImagePipelineFactory\"></a>2.1 ImagePipelineFactory</h4><p>内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。</p>\n<h4 id=\"2-2-PipelineDraweeControllerFactory\"><a href=\"#2-2-PipelineDraweeControllerFactory\" class=\"headerlink\" title=\"2.2 PipelineDraweeControllerFactory\"></a>2.2 PipelineDraweeControllerFactory</h4><p>负责构造PipelineDraweeController。有几个默认的参数。</p>\n<ul>\n<li>Resources</li>\n<li>DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。</li>\n<li>AnimatedDrawableFactory</li>\n<li>Executor</li>\n<li>MemoryCache<CacheKey, CloseableImage></li>\n</ul>\n<h3 id=\"3-SimpleDraweeView-initialize\"><a href=\"#3-SimpleDraweeView-initialize\" class=\"headerlink\" title=\"3 SimpleDraweeView#initialize\"></a>3 SimpleDraweeView#initialize</h3><p>只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco图片decode的大体流程","date":"2016-12-13T08:10:51.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 从DecodeProducer说fresco的解码过程\n\nDecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n  @Override\n  public void produceResults(\n      final Consumer<CloseableReference<CloseableImage>> consumer,\n      final ProducerContext producerContext) {\n    final ImageRequest imageRequest = producerContext.getImageRequest();\n    ProgressiveDecoder progressiveDecoder;\n    if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {\n      progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);\n    } else {\n      ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);\n      progressiveDecoder = new NetworkImagesProgressiveDecoder(\n          consumer,\n          producerContext,\n          jpegParser,\n          mProgressiveJpegConfig);\n    }\n    mInputProducer.produceResults(progressiveDecoder, producerContext);\n  }\n```\n\n* 通过判断uri的类型 选择不同的渐近式解释器\n* local和network都继承自ProgressiveDecoder\n\n在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。\n\n### 2. ImageDecoder\n\n这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。\n\n```\n  public CloseableImage decodeImage(\n      final EncodedImage encodedImage,\n      final int length,\n      final QualityInfo qualityInfo,\n      final ImageDecodeOptions options) {\n    ImageFormat imageFormat = encodedImage.getImageFormat();\n    if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) {\n      imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(\n          encodedImage.getInputStream());\n      encodedImage.setImageFormat(imageFormat);\n    }\n    if (imageFormat == DefaultImageFormats.JPEG) {\n      return decodeJpeg(encodedImage, length, qualityInfo);\n    } else if (imageFormat == DefaultImageFormats.GIF) {\n      return decodeGif(encodedImage, options);\n    } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {\n      return decodeAnimatedWebp(encodedImage, options);\n    } else if (imageFormat == ImageFormat.UNKNOWN) {\n      throw new IllegalArgumentException(\"unknown image format\");\n    }\n    return decodeStaticImage(encodedImage);\n  }\n```\n\n* 先判断未解码的图片类型\n* 根据不同的图片类型选择不同的解码方式\n\n#### 2.1 ImageFormatChecker\n\n这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为\n\n```\n  private static final byte[] PNG_HEADER = new byte[] {\n      (byte) 0x89,\n      'P', 'N', 'G',\n      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};\n```\n\n如果不熟ascll表的话，可以去查阅'P''N''G'在ascll表中对应的16进制。\n\n\n#### 2.2 解析种类\n\n根据代码能看出，这里分为几种。\n\n* JPEG\n* GIF\n* WEBP_ANIMATED\n* 其他\n\n从是否静态图上来看，为两种，\n\n* 可动 ，用AnimatedImageFactory进行解析\n* 不可动，用PlatformDecoder进行解析\n\n\n### 3. AnimatedImageFactory\n\n\nAnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。\n\n在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。\n\n```\n  private static AnimatedImageDecoder loadIfPresent(final String className) {\n    try {\n      Class<?> clazz = Class.forName(className);\n      return (AnimatedImageDecoder) clazz.newInstance();\n    } catch (Throwable e) {\n      return null;\n    }\n  }\n\n  static {\n    sGifAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.gif.GifImage\");\n    sWebpAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.webp.WebPImage\");\n  }\n```\n\n解析分为两个步骤。\n\n* 通过AnimatedImageDecoder解析出AnimatedImage\n* 利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。\n\n关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。\n\ngetCloseableImage的逻辑如下：\n\n* 用decodeAllFrames解析出所有帧\n* 用createPreviewBitmap构造预览的bitmap\n* 构造AnimatedImageResult对象\n* 用AnimatedImageResult构造CloseableAnimatedImage对象。\n\n这里就不再多说了，等到后面学习webp和gif的时候再说。\n\n### 4.PlatformDecoder\n\nPlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。\n\n![](/images/fresco/fresco_3.png)\n\n从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。\n\n* 在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的\n* 5.0以下，则是存在Ashmem匿名共享内存中。\n\n\n5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，\n\n```\n  @Override\n  public CloseableReference<Bitmap> decodeFromEncodedImage(\n      final EncodedImage encodedImage,\n      Bitmap.Config bitmapConfig) {\n    BitmapFactory.Options options = getBitmapFactoryOptions(\n        encodedImage.getSampleSize(),\n        bitmapConfig);\n    CloseableReference<PooledByteBuffer> bytesRef = encodedImage.getByteBufferRef();\n    Preconditions.checkNotNull(bytesRef);\n    try {\n      Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);\n      return pinBitmap(bitmap);\n    } finally {\n      CloseableReference.closeSafely(bytesRef);\n    }\n  }\n```\n\n* getBitmapFactoryOptions 获取BitmapFactory.Options\n* decodeByteArrayAsPurgeable 获取bitmap\n* pinBitmap 真正的decode\n\n我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。\n\n而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","source":"_posts/fresco图片decode的大体流程.md","raw":"---\ntitle: fresco图片decode的大体流程\ndate: 2016-12-13 16:10:51\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 从DecodeProducer说fresco的解码过程\n\nDecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n  @Override\n  public void produceResults(\n      final Consumer<CloseableReference<CloseableImage>> consumer,\n      final ProducerContext producerContext) {\n    final ImageRequest imageRequest = producerContext.getImageRequest();\n    ProgressiveDecoder progressiveDecoder;\n    if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {\n      progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);\n    } else {\n      ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);\n      progressiveDecoder = new NetworkImagesProgressiveDecoder(\n          consumer,\n          producerContext,\n          jpegParser,\n          mProgressiveJpegConfig);\n    }\n    mInputProducer.produceResults(progressiveDecoder, producerContext);\n  }\n```\n\n* 通过判断uri的类型 选择不同的渐近式解释器\n* local和network都继承自ProgressiveDecoder\n\n在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。\n\n### 2. ImageDecoder\n\n这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。\n\n```\n  public CloseableImage decodeImage(\n      final EncodedImage encodedImage,\n      final int length,\n      final QualityInfo qualityInfo,\n      final ImageDecodeOptions options) {\n    ImageFormat imageFormat = encodedImage.getImageFormat();\n    if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) {\n      imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(\n          encodedImage.getInputStream());\n      encodedImage.setImageFormat(imageFormat);\n    }\n    if (imageFormat == DefaultImageFormats.JPEG) {\n      return decodeJpeg(encodedImage, length, qualityInfo);\n    } else if (imageFormat == DefaultImageFormats.GIF) {\n      return decodeGif(encodedImage, options);\n    } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {\n      return decodeAnimatedWebp(encodedImage, options);\n    } else if (imageFormat == ImageFormat.UNKNOWN) {\n      throw new IllegalArgumentException(\"unknown image format\");\n    }\n    return decodeStaticImage(encodedImage);\n  }\n```\n\n* 先判断未解码的图片类型\n* 根据不同的图片类型选择不同的解码方式\n\n#### 2.1 ImageFormatChecker\n\n这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为\n\n```\n  private static final byte[] PNG_HEADER = new byte[] {\n      (byte) 0x89,\n      'P', 'N', 'G',\n      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};\n```\n\n如果不熟ascll表的话，可以去查阅'P''N''G'在ascll表中对应的16进制。\n\n\n#### 2.2 解析种类\n\n根据代码能看出，这里分为几种。\n\n* JPEG\n* GIF\n* WEBP_ANIMATED\n* 其他\n\n从是否静态图上来看，为两种，\n\n* 可动 ，用AnimatedImageFactory进行解析\n* 不可动，用PlatformDecoder进行解析\n\n\n### 3. AnimatedImageFactory\n\n\nAnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。\n\n在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。\n\n```\n  private static AnimatedImageDecoder loadIfPresent(final String className) {\n    try {\n      Class<?> clazz = Class.forName(className);\n      return (AnimatedImageDecoder) clazz.newInstance();\n    } catch (Throwable e) {\n      return null;\n    }\n  }\n\n  static {\n    sGifAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.gif.GifImage\");\n    sWebpAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.webp.WebPImage\");\n  }\n```\n\n解析分为两个步骤。\n\n* 通过AnimatedImageDecoder解析出AnimatedImage\n* 利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。\n\n关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。\n\ngetCloseableImage的逻辑如下：\n\n* 用decodeAllFrames解析出所有帧\n* 用createPreviewBitmap构造预览的bitmap\n* 构造AnimatedImageResult对象\n* 用AnimatedImageResult构造CloseableAnimatedImage对象。\n\n这里就不再多说了，等到后面学习webp和gif的时候再说。\n\n### 4.PlatformDecoder\n\nPlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。\n\n![](/images/fresco/fresco_3.png)\n\n从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。\n\n* 在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的\n* 5.0以下，则是存在Ashmem匿名共享内存中。\n\n\n5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，\n\n```\n  @Override\n  public CloseableReference<Bitmap> decodeFromEncodedImage(\n      final EncodedImage encodedImage,\n      Bitmap.Config bitmapConfig) {\n    BitmapFactory.Options options = getBitmapFactoryOptions(\n        encodedImage.getSampleSize(),\n        bitmapConfig);\n    CloseableReference<PooledByteBuffer> bytesRef = encodedImage.getByteBufferRef();\n    Preconditions.checkNotNull(bytesRef);\n    try {\n      Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);\n      return pinBitmap(bitmap);\n    } finally {\n      CloseableReference.closeSafely(bytesRef);\n    }\n  }\n```\n\n* getBitmapFactoryOptions 获取BitmapFactory.Options\n* decodeByteArrayAsPurgeable 获取bitmap\n* pinBitmap 真正的decode\n\n我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。\n\n而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","slug":"fresco图片decode的大体流程","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyu003619fy80ts6pj8","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-从DecodeProducer说fresco的解码过程\"><a href=\"#1-从DecodeProducer说fresco的解码过程\" class=\"headerlink\" title=\"1. 从DecodeProducer说fresco的解码过程\"></a>1. 从DecodeProducer说fresco的解码过程</h3><p>DecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void produceResults(</div><div class=\"line\">    final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,</div><div class=\"line\">    final ProducerContext producerContext) &#123;</div><div class=\"line\">  final ImageRequest imageRequest = producerContext.getImageRequest();</div><div class=\"line\">  ProgressiveDecoder progressiveDecoder;</div><div class=\"line\">  if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) &#123;</div><div class=\"line\">    progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);</div><div class=\"line\">    progressiveDecoder = new NetworkImagesProgressiveDecoder(</div><div class=\"line\">        consumer,</div><div class=\"line\">        producerContext,</div><div class=\"line\">        jpegParser,</div><div class=\"line\">        mProgressiveJpegConfig);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mInputProducer.produceResults(progressiveDecoder, producerContext);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过判断uri的类型 选择不同的渐近式解释器</li>\n<li>local和network都继承自ProgressiveDecoder</li>\n</ul>\n<p>在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。</p>\n<h3 id=\"2-ImageDecoder\"><a href=\"#2-ImageDecoder\" class=\"headerlink\" title=\"2. ImageDecoder\"></a>2. ImageDecoder</h3><p>这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public CloseableImage decodeImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    final int length,</div><div class=\"line\">    final QualityInfo qualityInfo,</div><div class=\"line\">    final ImageDecodeOptions options) &#123;</div><div class=\"line\">  ImageFormat imageFormat = encodedImage.getImageFormat();</div><div class=\"line\">  if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(</div><div class=\"line\">        encodedImage.getInputStream());</div><div class=\"line\">    encodedImage.setImageFormat(imageFormat);</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (imageFormat == DefaultImageFormats.JPEG) &#123;</div><div class=\"line\">    return decodeJpeg(encodedImage, length, qualityInfo);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.GIF) &#123;</div><div class=\"line\">    return decodeGif(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) &#123;</div><div class=\"line\">    return decodeAnimatedWebp(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    throw new IllegalArgumentException(&quot;unknown image format&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return decodeStaticImage(encodedImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先判断未解码的图片类型</li>\n<li>根据不同的图片类型选择不同的解码方式</li>\n</ul>\n<h4 id=\"2-1-ImageFormatChecker\"><a href=\"#2-1-ImageFormatChecker\" class=\"headerlink\" title=\"2.1 ImageFormatChecker\"></a>2.1 ImageFormatChecker</h4><p>这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final byte[] PNG_HEADER = new byte[] &#123;</div><div class=\"line\">    (byte) 0x89,</div><div class=\"line\">    &apos;P&apos;, &apos;N&apos;, &apos;G&apos;,</div><div class=\"line\">    (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A&#125;;</div></pre></td></tr></table></figure>\n<p>如果不熟ascll表的话，可以去查阅’P’’N’’G’在ascll表中对应的16进制。</p>\n<h4 id=\"2-2-解析种类\"><a href=\"#2-2-解析种类\" class=\"headerlink\" title=\"2.2 解析种类\"></a>2.2 解析种类</h4><p>根据代码能看出，这里分为几种。</p>\n<ul>\n<li>JPEG</li>\n<li>GIF</li>\n<li>WEBP_ANIMATED</li>\n<li>其他</li>\n</ul>\n<p>从是否静态图上来看，为两种，</p>\n<ul>\n<li>可动 ，用AnimatedImageFactory进行解析</li>\n<li>不可动，用PlatformDecoder进行解析</li>\n</ul>\n<h3 id=\"3-AnimatedImageFactory\"><a href=\"#3-AnimatedImageFactory\" class=\"headerlink\" title=\"3. AnimatedImageFactory\"></a>3. AnimatedImageFactory</h3><p>AnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。</p>\n<p>在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static AnimatedImageDecoder loadIfPresent(final String className) &#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Class&lt;?&gt; clazz = Class.forName(className);</div><div class=\"line\">    return (AnimatedImageDecoder) clazz.newInstance();</div><div class=\"line\">  &#125; catch (Throwable e) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">  sGifAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.gif.GifImage&quot;);</div><div class=\"line\">  sWebpAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.webp.WebPImage&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析分为两个步骤。</p>\n<ul>\n<li>通过AnimatedImageDecoder解析出AnimatedImage</li>\n<li>利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。</li>\n</ul>\n<p>关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。</p>\n<p>getCloseableImage的逻辑如下：</p>\n<ul>\n<li>用decodeAllFrames解析出所有帧</li>\n<li>用createPreviewBitmap构造预览的bitmap</li>\n<li>构造AnimatedImageResult对象</li>\n<li>用AnimatedImageResult构造CloseableAnimatedImage对象。</li>\n</ul>\n<p>这里就不再多说了，等到后面学习webp和gif的时候再说。</p>\n<h3 id=\"4-PlatformDecoder\"><a href=\"#4-PlatformDecoder\" class=\"headerlink\" title=\"4.PlatformDecoder\"></a>4.PlatformDecoder</h3><p>PlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。</p>\n<p><img src=\"/images/fresco/fresco_3.png\" alt=\"\"></p>\n<p>从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。</p>\n<ul>\n<li>在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的</li>\n<li>5.0以下，则是存在Ashmem匿名共享内存中。</li>\n</ul>\n<p>5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    Bitmap.Config bitmapConfig) &#123;</div><div class=\"line\">  BitmapFactory.Options options = getBitmapFactoryOptions(</div><div class=\"line\">      encodedImage.getSampleSize(),</div><div class=\"line\">      bitmapConfig);</div><div class=\"line\">  CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef();</div><div class=\"line\">  Preconditions.checkNotNull(bytesRef);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);</div><div class=\"line\">    return pinBitmap(bitmap);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    CloseableReference.closeSafely(bytesRef);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getBitmapFactoryOptions 获取BitmapFactory.Options</li>\n<li>decodeByteArrayAsPurgeable 获取bitmap</li>\n<li>pinBitmap 真正的decode</li>\n</ul>\n<p>我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。</p>\n<p>而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-从DecodeProducer说fresco的解码过程\"><a href=\"#1-从DecodeProducer说fresco的解码过程\" class=\"headerlink\" title=\"1. 从DecodeProducer说fresco的解码过程\"></a>1. 从DecodeProducer说fresco的解码过程</h3><p>DecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。</p>","more":"<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void produceResults(</div><div class=\"line\">    final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,</div><div class=\"line\">    final ProducerContext producerContext) &#123;</div><div class=\"line\">  final ImageRequest imageRequest = producerContext.getImageRequest();</div><div class=\"line\">  ProgressiveDecoder progressiveDecoder;</div><div class=\"line\">  if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) &#123;</div><div class=\"line\">    progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);</div><div class=\"line\">    progressiveDecoder = new NetworkImagesProgressiveDecoder(</div><div class=\"line\">        consumer,</div><div class=\"line\">        producerContext,</div><div class=\"line\">        jpegParser,</div><div class=\"line\">        mProgressiveJpegConfig);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mInputProducer.produceResults(progressiveDecoder, producerContext);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过判断uri的类型 选择不同的渐近式解释器</li>\n<li>local和network都继承自ProgressiveDecoder</li>\n</ul>\n<p>在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。</p>\n<h3 id=\"2-ImageDecoder\"><a href=\"#2-ImageDecoder\" class=\"headerlink\" title=\"2. ImageDecoder\"></a>2. ImageDecoder</h3><p>这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public CloseableImage decodeImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    final int length,</div><div class=\"line\">    final QualityInfo qualityInfo,</div><div class=\"line\">    final ImageDecodeOptions options) &#123;</div><div class=\"line\">  ImageFormat imageFormat = encodedImage.getImageFormat();</div><div class=\"line\">  if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(</div><div class=\"line\">        encodedImage.getInputStream());</div><div class=\"line\">    encodedImage.setImageFormat(imageFormat);</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (imageFormat == DefaultImageFormats.JPEG) &#123;</div><div class=\"line\">    return decodeJpeg(encodedImage, length, qualityInfo);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.GIF) &#123;</div><div class=\"line\">    return decodeGif(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) &#123;</div><div class=\"line\">    return decodeAnimatedWebp(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    throw new IllegalArgumentException(&quot;unknown image format&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return decodeStaticImage(encodedImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先判断未解码的图片类型</li>\n<li>根据不同的图片类型选择不同的解码方式</li>\n</ul>\n<h4 id=\"2-1-ImageFormatChecker\"><a href=\"#2-1-ImageFormatChecker\" class=\"headerlink\" title=\"2.1 ImageFormatChecker\"></a>2.1 ImageFormatChecker</h4><p>这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final byte[] PNG_HEADER = new byte[] &#123;</div><div class=\"line\">    (byte) 0x89,</div><div class=\"line\">    &apos;P&apos;, &apos;N&apos;, &apos;G&apos;,</div><div class=\"line\">    (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A&#125;;</div></pre></td></tr></table></figure>\n<p>如果不熟ascll表的话，可以去查阅’P’’N’’G’在ascll表中对应的16进制。</p>\n<h4 id=\"2-2-解析种类\"><a href=\"#2-2-解析种类\" class=\"headerlink\" title=\"2.2 解析种类\"></a>2.2 解析种类</h4><p>根据代码能看出，这里分为几种。</p>\n<ul>\n<li>JPEG</li>\n<li>GIF</li>\n<li>WEBP_ANIMATED</li>\n<li>其他</li>\n</ul>\n<p>从是否静态图上来看，为两种，</p>\n<ul>\n<li>可动 ，用AnimatedImageFactory进行解析</li>\n<li>不可动，用PlatformDecoder进行解析</li>\n</ul>\n<h3 id=\"3-AnimatedImageFactory\"><a href=\"#3-AnimatedImageFactory\" class=\"headerlink\" title=\"3. AnimatedImageFactory\"></a>3. AnimatedImageFactory</h3><p>AnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。</p>\n<p>在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static AnimatedImageDecoder loadIfPresent(final String className) &#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Class&lt;?&gt; clazz = Class.forName(className);</div><div class=\"line\">    return (AnimatedImageDecoder) clazz.newInstance();</div><div class=\"line\">  &#125; catch (Throwable e) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">  sGifAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.gif.GifImage&quot;);</div><div class=\"line\">  sWebpAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.webp.WebPImage&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析分为两个步骤。</p>\n<ul>\n<li>通过AnimatedImageDecoder解析出AnimatedImage</li>\n<li>利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。</li>\n</ul>\n<p>关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。</p>\n<p>getCloseableImage的逻辑如下：</p>\n<ul>\n<li>用decodeAllFrames解析出所有帧</li>\n<li>用createPreviewBitmap构造预览的bitmap</li>\n<li>构造AnimatedImageResult对象</li>\n<li>用AnimatedImageResult构造CloseableAnimatedImage对象。</li>\n</ul>\n<p>这里就不再多说了，等到后面学习webp和gif的时候再说。</p>\n<h3 id=\"4-PlatformDecoder\"><a href=\"#4-PlatformDecoder\" class=\"headerlink\" title=\"4.PlatformDecoder\"></a>4.PlatformDecoder</h3><p>PlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。</p>\n<p><img src=\"/images/fresco/fresco_3.png\" alt=\"\"></p>\n<p>从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。</p>\n<ul>\n<li>在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的</li>\n<li>5.0以下，则是存在Ashmem匿名共享内存中。</li>\n</ul>\n<p>5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    Bitmap.Config bitmapConfig) &#123;</div><div class=\"line\">  BitmapFactory.Options options = getBitmapFactoryOptions(</div><div class=\"line\">      encodedImage.getSampleSize(),</div><div class=\"line\">      bitmapConfig);</div><div class=\"line\">  CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef();</div><div class=\"line\">  Preconditions.checkNotNull(bytesRef);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);</div><div class=\"line\">    return pinBitmap(bitmap);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    CloseableReference.closeSafely(bytesRef);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getBitmapFactoryOptions 获取BitmapFactory.Options</li>\n<li>decodeByteArrayAsPurgeable 获取bitmap</li>\n<li>pinBitmap 真正的decode</li>\n</ul>\n<p>我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。</p>\n<p>而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco生产者Producer","date":"2016-12-13T03:26:58.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 从ImagePipeline#submitFetchRequest说起\n\n上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：\n\n* 从未解码的memory cache中获取\n* 从disk cache中获取\n* 从net中获取\n\n```\n      return CloseableProducerToDataSourceAdapter.create(\n          producerSequence,\n          settableProducerContext,\n          requestListener);\n```\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。\n\n\n### 2. Producer 生产者\n\n先看下相关的结构。\n\n![](/images/fresco/fresco_2.png)\n\n可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。\n\n\n### 3. 从已解码的内存中获取－BitmapMemoryCacheProducer\n\n\n这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。\n\n### 4. 从未解码的内存中获取－EncodedMemoryCacheProducer\n\n\n在这里要说明下\n\n* EncodedImage 未解码的载体\n* PooledByteBuffer 存储的字节码\n* CloseableBitmap 已解码的载体\n\n\n先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。\n\n### 5. 从本地文件获取－DiskCacheProducer\n\n文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。\n\n### 6. 从网络中获取－NetworkFetchProducer\n\n略，思路一致。\n\n\n_ _ _\n\n* [参考资料](https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/fresco生产者Producer.md","raw":"---\ntitle: fresco生产者Producer\ndate: 2016-12-13 11:26:58\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 从ImagePipeline#submitFetchRequest说起\n\n上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：\n\n* 从未解码的memory cache中获取\n* 从disk cache中获取\n* 从net中获取\n\n```\n      return CloseableProducerToDataSourceAdapter.create(\n          producerSequence,\n          settableProducerContext,\n          requestListener);\n```\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。\n\n\n### 2. Producer 生产者\n\n先看下相关的结构。\n\n![](/images/fresco/fresco_2.png)\n\n可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。\n\n\n### 3. 从已解码的内存中获取－BitmapMemoryCacheProducer\n\n\n这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。\n\n### 4. 从未解码的内存中获取－EncodedMemoryCacheProducer\n\n\n在这里要说明下\n\n* EncodedImage 未解码的载体\n* PooledByteBuffer 存储的字节码\n* CloseableBitmap 已解码的载体\n\n\n先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。\n\n### 5. 从本地文件获取－DiskCacheProducer\n\n文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。\n\n### 6. 从网络中获取－NetworkFetchProducer\n\n略，思路一致。\n\n\n_ _ _\n\n* [参考资料](https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"fresco生产者Producer","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyv003919fy99k30i5i","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-从ImagePipeline-submitFetchRequest说起\"><a href=\"#1-从ImagePipeline-submitFetchRequest说起\" class=\"headerlink\" title=\"1. 从ImagePipeline#submitFetchRequest说起\"></a>1. 从ImagePipeline#submitFetchRequest说起</h3><p>上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：</p>\n<ul>\n<li>从未解码的memory cache中获取</li>\n<li>从disk cache中获取</li>\n<li>从net中获取</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">return CloseableProducerToDataSourceAdapter.create(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    settableProducerContext,</div><div class=\"line\">    requestListener);</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p>在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。</p>\n<h3 id=\"2-Producer-生产者\"><a href=\"#2-Producer-生产者\" class=\"headerlink\" title=\"2. Producer 生产者\"></a>2. Producer 生产者</h3><p>先看下相关的结构。</p>\n<p><img src=\"/images/fresco/fresco_2.png\" alt=\"\"></p>\n<p>可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。</p>\n<h3 id=\"3-从已解码的内存中获取－BitmapMemoryCacheProducer\"><a href=\"#3-从已解码的内存中获取－BitmapMemoryCacheProducer\" class=\"headerlink\" title=\"3. 从已解码的内存中获取－BitmapMemoryCacheProducer\"></a>3. 从已解码的内存中获取－BitmapMemoryCacheProducer</h3><p>这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。</p>\n<h3 id=\"4-从未解码的内存中获取－EncodedMemoryCacheProducer\"><a href=\"#4-从未解码的内存中获取－EncodedMemoryCacheProducer\" class=\"headerlink\" title=\"4. 从未解码的内存中获取－EncodedMemoryCacheProducer\"></a>4. 从未解码的内存中获取－EncodedMemoryCacheProducer</h3><p>在这里要说明下</p>\n<ul>\n<li>EncodedImage 未解码的载体</li>\n<li>PooledByteBuffer 存储的字节码</li>\n<li>CloseableBitmap 已解码的载体</li>\n</ul>\n<p>先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。</p>\n<h3 id=\"5-从本地文件获取－DiskCacheProducer\"><a href=\"#5-从本地文件获取－DiskCacheProducer\" class=\"headerlink\" title=\"5. 从本地文件获取－DiskCacheProducer\"></a>5. 从本地文件获取－DiskCacheProducer</h3><p>文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。</p>\n<h3 id=\"6-从网络中获取－NetworkFetchProducer\"><a href=\"#6-从网络中获取－NetworkFetchProducer\" class=\"headerlink\" title=\"6. 从网络中获取－NetworkFetchProducer\"></a>6. 从网络中获取－NetworkFetchProducer</h3><p>略，思路一致。</p>\n<hr>\n<ul>\n<li><a href=\"https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5\" target=\"_blank\" rel=\"external\">参考资料</a>%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-从ImagePipeline-submitFetchRequest说起\"><a href=\"#1-从ImagePipeline-submitFetchRequest说起\" class=\"headerlink\" title=\"1. 从ImagePipeline#submitFetchRequest说起\"></a>1. 从ImagePipeline#submitFetchRequest说起</h3><p>上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：</p>\n<ul>\n<li>从未解码的memory cache中获取</li>\n<li>从disk cache中获取</li>\n<li>从net中获取</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">return CloseableProducerToDataSourceAdapter.create(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    settableProducerContext,</div><div class=\"line\">    requestListener);</div></pre></td></tr></table></figure>","more":"<The rest of contents | 余下全文>\n\n\n<p>在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。</p>\n<h3 id=\"2-Producer-生产者\"><a href=\"#2-Producer-生产者\" class=\"headerlink\" title=\"2. Producer 生产者\"></a>2. Producer 生产者</h3><p>先看下相关的结构。</p>\n<p><img src=\"/images/fresco/fresco_2.png\" alt=\"\"></p>\n<p>可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。</p>\n<h3 id=\"3-从已解码的内存中获取－BitmapMemoryCacheProducer\"><a href=\"#3-从已解码的内存中获取－BitmapMemoryCacheProducer\" class=\"headerlink\" title=\"3. 从已解码的内存中获取－BitmapMemoryCacheProducer\"></a>3. 从已解码的内存中获取－BitmapMemoryCacheProducer</h3><p>这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。</p>\n<h3 id=\"4-从未解码的内存中获取－EncodedMemoryCacheProducer\"><a href=\"#4-从未解码的内存中获取－EncodedMemoryCacheProducer\" class=\"headerlink\" title=\"4. 从未解码的内存中获取－EncodedMemoryCacheProducer\"></a>4. 从未解码的内存中获取－EncodedMemoryCacheProducer</h3><p>在这里要说明下</p>\n<ul>\n<li>EncodedImage 未解码的载体</li>\n<li>PooledByteBuffer 存储的字节码</li>\n<li>CloseableBitmap 已解码的载体</li>\n</ul>\n<p>先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。</p>\n<h3 id=\"5-从本地文件获取－DiskCacheProducer\"><a href=\"#5-从本地文件获取－DiskCacheProducer\" class=\"headerlink\" title=\"5. 从本地文件获取－DiskCacheProducer\"></a>5. 从本地文件获取－DiskCacheProducer</h3><p>文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。</p>\n<h3 id=\"6-从网络中获取－NetworkFetchProducer\"><a href=\"#6-从网络中获取－NetworkFetchProducer\" class=\"headerlink\" title=\"6. 从网络中获取－NetworkFetchProducer\"></a>6. 从网络中获取－NetworkFetchProducer</h3><p>略，思路一致。</p>\n<hr>\n<ul>\n<li><a href=\"https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5\">参考资料</a>%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco内存管理","date":"2016-12-14T06:24:25.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. Fresco中的内存管理模块\n\nfresco中的内存分为两个部分，\n\n* 解码的\n\t* 在5.0之上存在java堆中\n\t* 在5.0之下位于Ashmem中 \t\n* 未解码的\n\t* 位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。\n\t\n而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2. 匿名共享内存部分\n\n这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。\n\n光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。\n\n\n```\nAndroidBitmap_lockPixels\nAndroidBitmap_unlockPixels\n\n```\n\npin和release实现的部分在Bitmaps.c部分。\n\n\n### 3. 从NetworkFetchProducer开始谈 native heap的管理\n\n\nNetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：\n\n```\n  private void onResponse(\n      FetchState fetchState,\n      InputStream responseData,\n      int responseContentLength)\n      throws IOException {\n    final PooledByteBufferOutputStream pooledOutputStream;\n    if (responseContentLength > 0) {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);\n    } else {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();\n    }\n    final byte[] ioArray = mByteArrayPool.get(READ_SIZE);\n    try {\n      int length;\n      while ((length = responseData.read(ioArray)) >= 0) {\n        if (length > 0) {\n          pooledOutputStream.write(ioArray, 0, length);\n          maybeHandleIntermediateResult(pooledOutputStream, fetchState);\n          float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);\n          fetchState.getConsumer().onProgressUpdate(progress);\n        }\n      }\n      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());\n      handleFinalResult(pooledOutputStream, fetchState);\n    } finally {\n      mByteArrayPool.release(ioArray);\n      pooledOutputStream.close();\n    }\n  }\n```\n\n* 通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流\n* 将内容输入\n* 通知上层处理\n\n我们分段来看\n\n#### 3.1 构造输出流\n\nPooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。\n\n这样就构造出一个输出流。\n\n#### 3.2 输出数据\n\n上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。\n\n\n```\n    ensureValid();\n    realloc(mCount + count);\n    mBufRef.get().write(mCount, buffer, offset, count);\n    mCount += count;\n```\n\n* 校验有效性\n* 重新申请内存\n* 将原来来写入到内存中的数据加上现在数据，复制到新的native内存中\n\n```\n    NativeMemoryChunk newbuf = mPool.get(newLength);\n    mBufRef.get().copy(0, newbuf, 0, mCount);\n    mBufRef.close();\n    mBufRef = CloseableReference.of(newbuf, mPool);\n```\n\nmPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。\n\n然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。\n\n\n最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。\n\n### 4. 对应的native操作。\n\n上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。\n\n![](/images/fresco/fresco_4.png)\n\n下面就来对其中一些进行说明。\n\n#### 4.1 NativeMemoryChunk_nativeAllocate\n\n这个是用来申请内存的。\n\n```\nstatic jlong NativeMemoryChunk_nativeAllocate(\n    JNIEnv* env,\n    jclass clzz,\n    jint size) {\n  UNUSED(clzz);\n  void* pointer = malloc(size);\n  if (!pointer) {\n    (*env)->ThrowNew(env, jRuntimeException_class, \"could not allocate memory\");\n    return 0;\n  }\n  return PTR_TO_JLONG(pointer);\n}\n```\n\n* 通过malloc申请size大小的一块内存\n* 通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。\n\n因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型\n\n#### 4.2 NativeMemoryChunk_nativeMemcpy\n\n这个方法很简单。\n\n```\nmemcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);\n```\n* 这里的参数，分别对应java中的两个NativeMemoryChunk，和大小\n* 首先用JLONG_TO_PTR这个宏，将long专为指针\n* 用memcpy函数，进行复制操作，\n\n\n#### 4.3 NativeMemoryChunk_nativeFree\n\n\n```\nfree(JLONG_TO_PTR(lpointer));\n```\n\n调用free函数将指针对应位置的内存释放掉。\n\n其他的几个函数 这里就不说了。\n\n\n\n需要注意的是，native内存管理实对应NativeMemoryChunkPool。\n\n\n### 5 以native内存为例，了解fresco内存池\n\n我们需要先来了解几个东西。\n\n* 池 负责存储某类型的数据\n* 桶 将池分为若干大小的块，每一个块就是一个桶\n* 每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。\n\n那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。\n\n![](/images/fresco/fresco_5.png)\n\n\n了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。\n\n#### 5.1 BasePool#get\n\n这个方法比较长，分段来看。\n\n```\n    int bucketedSize = getBucketedSize(size);\n    int sizeInBytes = -1;\n\n    synchronized (this) {\n      Bucket<V> bucket = getBucket(bucketedSize);\n\n      if (bucket != null) {\n        // find an existing value that we can reuse\n        V value = bucket.get();\n        if (value != null) {\n          Preconditions.checkState(mInUseValues.add(value));\n\n          // It is possible that we got a 'larger' value than we asked for.\n          // lets recompute size in bytes here\n          bucketedSize = getBucketedSizeForValue(value);\n          sizeInBytes = getSizeInBytes(bucketedSize);\n          mUsed.increment(sizeInBytes);\n          mFree.decrement(sizeInBytes);\n          mPoolStatsTracker.onValueReuse(sizeInBytes);\n          logStats();\n          if (FLog.isLoggable(FLog.VERBOSE)) {\n            FLog.v(\n                TAG,\n                \"get (reuse) (object, size) = (%x, %s)\",\n                System.identityHashCode(value),\n                bucketedSize);\n          }\n          return value;\n        }\n        // fall through\n      }\n      // check to see if we can allocate a value of the given size without exceeding the hard cap\n      sizeInBytes = getSizeInBytes(bucketedSize);\n      if (!canAllocate(sizeInBytes)) {\n        throw new PoolSizeViolationException(\n            mPoolParams.maxSizeHardCap,\n            mUsed.mNumBytes,\n            mFree.mNumBytes,\n            sizeInBytes);\n      }\n\n      // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes\n      mUsed.increment(sizeInBytes);\n      if (bucket != null) {\n        bucket.incrementInUseCount();\n      }\n    }\n```\n\n* 首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小\n* 通过getBucket方法获取对应桶容量的桶\n\t* 如果没有找到，就创建一个新的桶 \n* 如果桶不为null\n\t* 通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能\n\t* Counter 纪录使用容量和空闲容量\n\t* 状态追踪以及其他操作\n\t* 返回\n\n```\n    V value = null;\n    try {\n      // allocate the value outside the synchronized block, because it can be pretty expensive\n      // we could have done the allocation inside the synchronized block,\n      // but that would have blocked out other operations on the pool\n      value = alloc(bucketedSize);\n    } catch (Throwable e) {\n      // Assumption we made previously is not valid - allocation failed. We need to fix internal\n      // counters.\n      synchronized (this) {\n        mUsed.decrement(sizeInBytes);\n        Bucket<V> bucket = getBucket(bucketedSize);\n        if (bucket != null) {\n          bucket.decrementInUseCount();\n        }\n      }\n      Throwables.propagateIfPossible(e);\n    }\n        synchronized(this) {\n      Preconditions.checkState(mInUseValues.add(value));\n      // If we're over the pool's max size, try to trim the pool appropriately\n      trimToSoftCap();\n      mPoolStatsTracker.onAlloc(sizeInBytes);\n      logStats();\n      if (FLog.isLoggable(FLog.VERBOSE)) {\n        FLog.v(\n            TAG,\n            \"get (alloc) (object, size) = (%x, %s)\",\n            System.identityHashCode(value),\n            bucketedSize);\n      }\n    }\n\n    return value;\n```\n\n* 没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有\n* 如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。\n\n#### 5.2 BasePool#release\n\n这个方法是我们主动释放一个对象所占用的内存。\n\n实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/fresco内存管理.md","raw":"---\ntitle: fresco内存管理\ndate: 2016-12-14 14:24:25\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. Fresco中的内存管理模块\n\nfresco中的内存分为两个部分，\n\n* 解码的\n\t* 在5.0之上存在java堆中\n\t* 在5.0之下位于Ashmem中 \t\n* 未解码的\n\t* 位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。\n\t\n而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2. 匿名共享内存部分\n\n这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。\n\n光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。\n\n\n```\nAndroidBitmap_lockPixels\nAndroidBitmap_unlockPixels\n\n```\n\npin和release实现的部分在Bitmaps.c部分。\n\n\n### 3. 从NetworkFetchProducer开始谈 native heap的管理\n\n\nNetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：\n\n```\n  private void onResponse(\n      FetchState fetchState,\n      InputStream responseData,\n      int responseContentLength)\n      throws IOException {\n    final PooledByteBufferOutputStream pooledOutputStream;\n    if (responseContentLength > 0) {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);\n    } else {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();\n    }\n    final byte[] ioArray = mByteArrayPool.get(READ_SIZE);\n    try {\n      int length;\n      while ((length = responseData.read(ioArray)) >= 0) {\n        if (length > 0) {\n          pooledOutputStream.write(ioArray, 0, length);\n          maybeHandleIntermediateResult(pooledOutputStream, fetchState);\n          float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);\n          fetchState.getConsumer().onProgressUpdate(progress);\n        }\n      }\n      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());\n      handleFinalResult(pooledOutputStream, fetchState);\n    } finally {\n      mByteArrayPool.release(ioArray);\n      pooledOutputStream.close();\n    }\n  }\n```\n\n* 通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流\n* 将内容输入\n* 通知上层处理\n\n我们分段来看\n\n#### 3.1 构造输出流\n\nPooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。\n\n这样就构造出一个输出流。\n\n#### 3.2 输出数据\n\n上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。\n\n\n```\n    ensureValid();\n    realloc(mCount + count);\n    mBufRef.get().write(mCount, buffer, offset, count);\n    mCount += count;\n```\n\n* 校验有效性\n* 重新申请内存\n* 将原来来写入到内存中的数据加上现在数据，复制到新的native内存中\n\n```\n    NativeMemoryChunk newbuf = mPool.get(newLength);\n    mBufRef.get().copy(0, newbuf, 0, mCount);\n    mBufRef.close();\n    mBufRef = CloseableReference.of(newbuf, mPool);\n```\n\nmPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。\n\n然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。\n\n\n最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。\n\n### 4. 对应的native操作。\n\n上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。\n\n![](/images/fresco/fresco_4.png)\n\n下面就来对其中一些进行说明。\n\n#### 4.1 NativeMemoryChunk_nativeAllocate\n\n这个是用来申请内存的。\n\n```\nstatic jlong NativeMemoryChunk_nativeAllocate(\n    JNIEnv* env,\n    jclass clzz,\n    jint size) {\n  UNUSED(clzz);\n  void* pointer = malloc(size);\n  if (!pointer) {\n    (*env)->ThrowNew(env, jRuntimeException_class, \"could not allocate memory\");\n    return 0;\n  }\n  return PTR_TO_JLONG(pointer);\n}\n```\n\n* 通过malloc申请size大小的一块内存\n* 通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。\n\n因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型\n\n#### 4.2 NativeMemoryChunk_nativeMemcpy\n\n这个方法很简单。\n\n```\nmemcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);\n```\n* 这里的参数，分别对应java中的两个NativeMemoryChunk，和大小\n* 首先用JLONG_TO_PTR这个宏，将long专为指针\n* 用memcpy函数，进行复制操作，\n\n\n#### 4.3 NativeMemoryChunk_nativeFree\n\n\n```\nfree(JLONG_TO_PTR(lpointer));\n```\n\n调用free函数将指针对应位置的内存释放掉。\n\n其他的几个函数 这里就不说了。\n\n\n\n需要注意的是，native内存管理实对应NativeMemoryChunkPool。\n\n\n### 5 以native内存为例，了解fresco内存池\n\n我们需要先来了解几个东西。\n\n* 池 负责存储某类型的数据\n* 桶 将池分为若干大小的块，每一个块就是一个桶\n* 每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。\n\n那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。\n\n![](/images/fresco/fresco_5.png)\n\n\n了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。\n\n#### 5.1 BasePool#get\n\n这个方法比较长，分段来看。\n\n```\n    int bucketedSize = getBucketedSize(size);\n    int sizeInBytes = -1;\n\n    synchronized (this) {\n      Bucket<V> bucket = getBucket(bucketedSize);\n\n      if (bucket != null) {\n        // find an existing value that we can reuse\n        V value = bucket.get();\n        if (value != null) {\n          Preconditions.checkState(mInUseValues.add(value));\n\n          // It is possible that we got a 'larger' value than we asked for.\n          // lets recompute size in bytes here\n          bucketedSize = getBucketedSizeForValue(value);\n          sizeInBytes = getSizeInBytes(bucketedSize);\n          mUsed.increment(sizeInBytes);\n          mFree.decrement(sizeInBytes);\n          mPoolStatsTracker.onValueReuse(sizeInBytes);\n          logStats();\n          if (FLog.isLoggable(FLog.VERBOSE)) {\n            FLog.v(\n                TAG,\n                \"get (reuse) (object, size) = (%x, %s)\",\n                System.identityHashCode(value),\n                bucketedSize);\n          }\n          return value;\n        }\n        // fall through\n      }\n      // check to see if we can allocate a value of the given size without exceeding the hard cap\n      sizeInBytes = getSizeInBytes(bucketedSize);\n      if (!canAllocate(sizeInBytes)) {\n        throw new PoolSizeViolationException(\n            mPoolParams.maxSizeHardCap,\n            mUsed.mNumBytes,\n            mFree.mNumBytes,\n            sizeInBytes);\n      }\n\n      // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes\n      mUsed.increment(sizeInBytes);\n      if (bucket != null) {\n        bucket.incrementInUseCount();\n      }\n    }\n```\n\n* 首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小\n* 通过getBucket方法获取对应桶容量的桶\n\t* 如果没有找到，就创建一个新的桶 \n* 如果桶不为null\n\t* 通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能\n\t* Counter 纪录使用容量和空闲容量\n\t* 状态追踪以及其他操作\n\t* 返回\n\n```\n    V value = null;\n    try {\n      // allocate the value outside the synchronized block, because it can be pretty expensive\n      // we could have done the allocation inside the synchronized block,\n      // but that would have blocked out other operations on the pool\n      value = alloc(bucketedSize);\n    } catch (Throwable e) {\n      // Assumption we made previously is not valid - allocation failed. We need to fix internal\n      // counters.\n      synchronized (this) {\n        mUsed.decrement(sizeInBytes);\n        Bucket<V> bucket = getBucket(bucketedSize);\n        if (bucket != null) {\n          bucket.decrementInUseCount();\n        }\n      }\n      Throwables.propagateIfPossible(e);\n    }\n        synchronized(this) {\n      Preconditions.checkState(mInUseValues.add(value));\n      // If we're over the pool's max size, try to trim the pool appropriately\n      trimToSoftCap();\n      mPoolStatsTracker.onAlloc(sizeInBytes);\n      logStats();\n      if (FLog.isLoggable(FLog.VERBOSE)) {\n        FLog.v(\n            TAG,\n            \"get (alloc) (object, size) = (%x, %s)\",\n            System.identityHashCode(value),\n            bucketedSize);\n      }\n    }\n\n    return value;\n```\n\n* 没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有\n* 如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。\n\n#### 5.2 BasePool#release\n\n这个方法是我们主动释放一个对象所占用的内存。\n\n实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"fresco内存管理","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyx003d19fy9rukjkjs","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-Fresco中的内存管理模块\"><a href=\"#1-Fresco中的内存管理模块\" class=\"headerlink\" title=\"1. Fresco中的内存管理模块\"></a>1. Fresco中的内存管理模块</h3><p>fresco中的内存分为两个部分，</p>\n<ul>\n<li>解码的<ul>\n<li>在5.0之上存在java堆中</li>\n<li>在5.0之下位于Ashmem中     </li>\n</ul>\n</li>\n<li>未解码的<ul>\n<li>位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。</li>\n</ul>\n</li>\n</ul>\n<p>而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n<h3 id=\"2-匿名共享内存部分\"><a href=\"#2-匿名共享内存部分\" class=\"headerlink\" title=\"2. 匿名共享内存部分\"></a>2. 匿名共享内存部分</h3><p>这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。</p>\n<p>光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AndroidBitmap_lockPixels</div><div class=\"line\">AndroidBitmap_unlockPixels</div></pre></td></tr></table></figure>\n<p>pin和release实现的部分在Bitmaps.c部分。</p>\n<h3 id=\"3-从NetworkFetchProducer开始谈-native-heap的管理\"><a href=\"#3-从NetworkFetchProducer开始谈-native-heap的管理\" class=\"headerlink\" title=\"3. 从NetworkFetchProducer开始谈 native heap的管理\"></a>3. 从NetworkFetchProducer开始谈 native heap的管理</h3><p>NetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onResponse(</div><div class=\"line\">    FetchState fetchState,</div><div class=\"line\">    InputStream responseData,</div><div class=\"line\">    int responseContentLength)</div><div class=\"line\">    throws IOException &#123;</div><div class=\"line\">  final PooledByteBufferOutputStream pooledOutputStream;</div><div class=\"line\">  if (responseContentLength &gt; 0) &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream();</div><div class=\"line\">  &#125;</div><div class=\"line\">  final byte[] ioArray = mByteArrayPool.get(READ_SIZE);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    int length;</div><div class=\"line\">    while ((length = responseData.read(ioArray)) &gt;= 0) &#123;</div><div class=\"line\">      if (length &gt; 0) &#123;</div><div class=\"line\">        pooledOutputStream.write(ioArray, 0, length);</div><div class=\"line\">        maybeHandleIntermediateResult(pooledOutputStream, fetchState);</div><div class=\"line\">        float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);</div><div class=\"line\">        fetchState.getConsumer().onProgressUpdate(progress);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());</div><div class=\"line\">    handleFinalResult(pooledOutputStream, fetchState);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    mByteArrayPool.release(ioArray);</div><div class=\"line\">    pooledOutputStream.close();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流</li>\n<li>将内容输入</li>\n<li>通知上层处理</li>\n</ul>\n<p>我们分段来看</p>\n<h4 id=\"3-1-构造输出流\"><a href=\"#3-1-构造输出流\" class=\"headerlink\" title=\"3.1 构造输出流\"></a>3.1 构造输出流</h4><p>PooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。</p>\n<p>这样就构造出一个输出流。</p>\n<h4 id=\"3-2-输出数据\"><a href=\"#3-2-输出数据\" class=\"headerlink\" title=\"3.2 输出数据\"></a>3.2 输出数据</h4><p>上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ensureValid();</div><div class=\"line\">realloc(mCount + count);</div><div class=\"line\">mBufRef.get().write(mCount, buffer, offset, count);</div><div class=\"line\">mCount += count;</div></pre></td></tr></table></figure>\n<ul>\n<li>校验有效性</li>\n<li>重新申请内存</li>\n<li>将原来来写入到内存中的数据加上现在数据，复制到新的native内存中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMemoryChunk newbuf = mPool.get(newLength);</div><div class=\"line\">mBufRef.get().copy(0, newbuf, 0, mCount);</div><div class=\"line\">mBufRef.close();</div><div class=\"line\">mBufRef = CloseableReference.of(newbuf, mPool);</div></pre></td></tr></table></figure>\n<p>mPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。</p>\n<p>然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。</p>\n<p>最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。</p>\n<h3 id=\"4-对应的native操作。\"><a href=\"#4-对应的native操作。\" class=\"headerlink\" title=\"4. 对应的native操作。\"></a>4. 对应的native操作。</h3><p>上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。</p>\n<p><img src=\"/images/fresco/fresco_4.png\" alt=\"\"></p>\n<p>下面就来对其中一些进行说明。</p>\n<h4 id=\"4-1-NativeMemoryChunk-nativeAllocate\"><a href=\"#4-1-NativeMemoryChunk-nativeAllocate\" class=\"headerlink\" title=\"4.1 NativeMemoryChunk_nativeAllocate\"></a>4.1 NativeMemoryChunk_nativeAllocate</h4><p>这个是用来申请内存的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong NativeMemoryChunk_nativeAllocate(</div><div class=\"line\">    JNIEnv* env,</div><div class=\"line\">    jclass clzz,</div><div class=\"line\">    jint size) &#123;</div><div class=\"line\">  UNUSED(clzz);</div><div class=\"line\">  void* pointer = malloc(size);</div><div class=\"line\">  if (!pointer) &#123;</div><div class=\"line\">    (*env)-&gt;ThrowNew(env, jRuntimeException_class, &quot;could not allocate memory&quot;);</div><div class=\"line\">    return 0;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return PTR_TO_JLONG(pointer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过malloc申请size大小的一块内存</li>\n<li>通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。</li>\n</ul>\n<p>因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型</p>\n<h4 id=\"4-2-NativeMemoryChunk-nativeMemcpy\"><a href=\"#4-2-NativeMemoryChunk-nativeMemcpy\" class=\"headerlink\" title=\"4.2 NativeMemoryChunk_nativeMemcpy\"></a>4.2 NativeMemoryChunk_nativeMemcpy</h4><p>这个方法很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">memcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);</div></pre></td></tr></table></figure>\n<ul>\n<li>这里的参数，分别对应java中的两个NativeMemoryChunk，和大小</li>\n<li>首先用JLONG_TO_PTR这个宏，将long专为指针</li>\n<li>用memcpy函数，进行复制操作，</li>\n</ul>\n<h4 id=\"4-3-NativeMemoryChunk-nativeFree\"><a href=\"#4-3-NativeMemoryChunk-nativeFree\" class=\"headerlink\" title=\"4.3 NativeMemoryChunk_nativeFree\"></a>4.3 NativeMemoryChunk_nativeFree</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">free(JLONG_TO_PTR(lpointer));</div></pre></td></tr></table></figure>\n<p>调用free函数将指针对应位置的内存释放掉。</p>\n<p>其他的几个函数 这里就不说了。</p>\n<p>需要注意的是，native内存管理实对应NativeMemoryChunkPool。</p>\n<h3 id=\"5-以native内存为例，了解fresco内存池\"><a href=\"#5-以native内存为例，了解fresco内存池\" class=\"headerlink\" title=\"5 以native内存为例，了解fresco内存池\"></a>5 以native内存为例，了解fresco内存池</h3><p>我们需要先来了解几个东西。</p>\n<ul>\n<li>池 负责存储某类型的数据</li>\n<li>桶 将池分为若干大小的块，每一个块就是一个桶</li>\n<li>每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。</li>\n</ul>\n<p>那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。</p>\n<p><img src=\"/images/fresco/fresco_5.png\" alt=\"\"></p>\n<p>了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。</p>\n<h4 id=\"5-1-BasePool-get\"><a href=\"#5-1-BasePool-get\" class=\"headerlink\" title=\"5.1 BasePool#get\"></a>5.1 BasePool#get</h4><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">int bucketedSize = getBucketedSize(size);</div><div class=\"line\">int sizeInBytes = -1;</div><div class=\"line\"></div><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">  Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\"></div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    // find an existing value that we can reuse</div><div class=\"line\">    V value = bucket.get();</div><div class=\"line\">    if (value != null) &#123;</div><div class=\"line\">      Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\"></div><div class=\"line\">      // It is possible that we got a &apos;larger&apos; value than we asked for.</div><div class=\"line\">      // lets recompute size in bytes here</div><div class=\"line\">      bucketedSize = getBucketedSizeForValue(value);</div><div class=\"line\">      sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">      mUsed.increment(sizeInBytes);</div><div class=\"line\">      mFree.decrement(sizeInBytes);</div><div class=\"line\">      mPoolStatsTracker.onValueReuse(sizeInBytes);</div><div class=\"line\">      logStats();</div><div class=\"line\">      if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">        FLog.v(</div><div class=\"line\">            TAG,</div><div class=\"line\">            &quot;get (reuse) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">            System.identityHashCode(value),</div><div class=\"line\">            bucketedSize);</div><div class=\"line\">      &#125;</div><div class=\"line\">      return value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // fall through</div><div class=\"line\">  &#125;</div><div class=\"line\">  // check to see if we can allocate a value of the given size without exceeding the hard cap</div><div class=\"line\">  sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">  if (!canAllocate(sizeInBytes)) &#123;</div><div class=\"line\">    throw new PoolSizeViolationException(</div><div class=\"line\">        mPoolParams.maxSizeHardCap,</div><div class=\"line\">        mUsed.mNumBytes,</div><div class=\"line\">        mFree.mNumBytes,</div><div class=\"line\">        sizeInBytes);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes</div><div class=\"line\">  mUsed.increment(sizeInBytes);</div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    bucket.incrementInUseCount();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小</li>\n<li>通过getBucket方法获取对应桶容量的桶<ul>\n<li>如果没有找到，就创建一个新的桶 </li>\n</ul>\n</li>\n<li>如果桶不为null<ul>\n<li>通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能</li>\n<li>Counter 纪录使用容量和空闲容量</li>\n<li>状态追踪以及其他操作</li>\n<li>返回</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">V value = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">  // allocate the value outside the synchronized block, because it can be pretty expensive</div><div class=\"line\">  // we could have done the allocation inside the synchronized block,</div><div class=\"line\">  // but that would have blocked out other operations on the pool</div><div class=\"line\">  value = alloc(bucketedSize);</div><div class=\"line\">&#125; catch (Throwable e) &#123;</div><div class=\"line\">  // Assumption we made previously is not valid - allocation failed. We need to fix internal</div><div class=\"line\">  // counters.</div><div class=\"line\">  synchronized (this) &#123;</div><div class=\"line\">    mUsed.decrement(sizeInBytes);</div><div class=\"line\">    Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\">    if (bucket != null) &#123;</div><div class=\"line\">      bucket.decrementInUseCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Throwables.propagateIfPossible(e);</div><div class=\"line\">&#125;</div><div class=\"line\">    synchronized(this) &#123;</div><div class=\"line\">  Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\">  // If we&apos;re over the pool&apos;s max size, try to trim the pool appropriately</div><div class=\"line\">  trimToSoftCap();</div><div class=\"line\">  mPoolStatsTracker.onAlloc(sizeInBytes);</div><div class=\"line\">  logStats();</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;get (alloc) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">        System.identityHashCode(value),</div><div class=\"line\">        bucketedSize);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return value;</div></pre></td></tr></table></figure>\n<ul>\n<li>没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有</li>\n<li>如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。</li>\n</ul>\n<h4 id=\"5-2-BasePool-release\"><a href=\"#5-2-BasePool-release\" class=\"headerlink\" title=\"5.2 BasePool#release\"></a>5.2 BasePool#release</h4><p>这个方法是我们主动释放一个对象所占用的内存。</p>\n<p>实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-Fresco中的内存管理模块\"><a href=\"#1-Fresco中的内存管理模块\" class=\"headerlink\" title=\"1. Fresco中的内存管理模块\"></a>1. Fresco中的内存管理模块</h3><p>fresco中的内存分为两个部分，</p>\n<ul>\n<li>解码的<ul>\n<li>在5.0之上存在java堆中</li>\n<li>在5.0之下位于Ashmem中     </li>\n</ul>\n</li>\n<li>未解码的<ul>\n<li>位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。</li>\n</ul>\n</li>\n</ul>\n<p>而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n\n<h3 id=\"2-匿名共享内存部分\"><a href=\"#2-匿名共享内存部分\" class=\"headerlink\" title=\"2. 匿名共享内存部分\"></a>2. 匿名共享内存部分</h3><p>这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。</p>\n<p>光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AndroidBitmap_lockPixels</div><div class=\"line\">AndroidBitmap_unlockPixels</div></pre></td></tr></table></figure>\n<p>pin和release实现的部分在Bitmaps.c部分。</p>\n<h3 id=\"3-从NetworkFetchProducer开始谈-native-heap的管理\"><a href=\"#3-从NetworkFetchProducer开始谈-native-heap的管理\" class=\"headerlink\" title=\"3. 从NetworkFetchProducer开始谈 native heap的管理\"></a>3. 从NetworkFetchProducer开始谈 native heap的管理</h3><p>NetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onResponse(</div><div class=\"line\">    FetchState fetchState,</div><div class=\"line\">    InputStream responseData,</div><div class=\"line\">    int responseContentLength)</div><div class=\"line\">    throws IOException &#123;</div><div class=\"line\">  final PooledByteBufferOutputStream pooledOutputStream;</div><div class=\"line\">  if (responseContentLength &gt; 0) &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream();</div><div class=\"line\">  &#125;</div><div class=\"line\">  final byte[] ioArray = mByteArrayPool.get(READ_SIZE);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    int length;</div><div class=\"line\">    while ((length = responseData.read(ioArray)) &gt;= 0) &#123;</div><div class=\"line\">      if (length &gt; 0) &#123;</div><div class=\"line\">        pooledOutputStream.write(ioArray, 0, length);</div><div class=\"line\">        maybeHandleIntermediateResult(pooledOutputStream, fetchState);</div><div class=\"line\">        float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);</div><div class=\"line\">        fetchState.getConsumer().onProgressUpdate(progress);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());</div><div class=\"line\">    handleFinalResult(pooledOutputStream, fetchState);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    mByteArrayPool.release(ioArray);</div><div class=\"line\">    pooledOutputStream.close();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流</li>\n<li>将内容输入</li>\n<li>通知上层处理</li>\n</ul>\n<p>我们分段来看</p>\n<h4 id=\"3-1-构造输出流\"><a href=\"#3-1-构造输出流\" class=\"headerlink\" title=\"3.1 构造输出流\"></a>3.1 构造输出流</h4><p>PooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。</p>\n<p>这样就构造出一个输出流。</p>\n<h4 id=\"3-2-输出数据\"><a href=\"#3-2-输出数据\" class=\"headerlink\" title=\"3.2 输出数据\"></a>3.2 输出数据</h4><p>上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ensureValid();</div><div class=\"line\">realloc(mCount + count);</div><div class=\"line\">mBufRef.get().write(mCount, buffer, offset, count);</div><div class=\"line\">mCount += count;</div></pre></td></tr></table></figure>\n<ul>\n<li>校验有效性</li>\n<li>重新申请内存</li>\n<li>将原来来写入到内存中的数据加上现在数据，复制到新的native内存中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMemoryChunk newbuf = mPool.get(newLength);</div><div class=\"line\">mBufRef.get().copy(0, newbuf, 0, mCount);</div><div class=\"line\">mBufRef.close();</div><div class=\"line\">mBufRef = CloseableReference.of(newbuf, mPool);</div></pre></td></tr></table></figure>\n<p>mPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。</p>\n<p>然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。</p>\n<p>最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。</p>\n<h3 id=\"4-对应的native操作。\"><a href=\"#4-对应的native操作。\" class=\"headerlink\" title=\"4. 对应的native操作。\"></a>4. 对应的native操作。</h3><p>上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。</p>\n<p><img src=\"/images/fresco/fresco_4.png\" alt=\"\"></p>\n<p>下面就来对其中一些进行说明。</p>\n<h4 id=\"4-1-NativeMemoryChunk-nativeAllocate\"><a href=\"#4-1-NativeMemoryChunk-nativeAllocate\" class=\"headerlink\" title=\"4.1 NativeMemoryChunk_nativeAllocate\"></a>4.1 NativeMemoryChunk_nativeAllocate</h4><p>这个是用来申请内存的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong NativeMemoryChunk_nativeAllocate(</div><div class=\"line\">    JNIEnv* env,</div><div class=\"line\">    jclass clzz,</div><div class=\"line\">    jint size) &#123;</div><div class=\"line\">  UNUSED(clzz);</div><div class=\"line\">  void* pointer = malloc(size);</div><div class=\"line\">  if (!pointer) &#123;</div><div class=\"line\">    (*env)-&gt;ThrowNew(env, jRuntimeException_class, &quot;could not allocate memory&quot;);</div><div class=\"line\">    return 0;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return PTR_TO_JLONG(pointer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过malloc申请size大小的一块内存</li>\n<li>通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。</li>\n</ul>\n<p>因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型</p>\n<h4 id=\"4-2-NativeMemoryChunk-nativeMemcpy\"><a href=\"#4-2-NativeMemoryChunk-nativeMemcpy\" class=\"headerlink\" title=\"4.2 NativeMemoryChunk_nativeMemcpy\"></a>4.2 NativeMemoryChunk_nativeMemcpy</h4><p>这个方法很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">memcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);</div></pre></td></tr></table></figure>\n<ul>\n<li>这里的参数，分别对应java中的两个NativeMemoryChunk，和大小</li>\n<li>首先用JLONG_TO_PTR这个宏，将long专为指针</li>\n<li>用memcpy函数，进行复制操作，</li>\n</ul>\n<h4 id=\"4-3-NativeMemoryChunk-nativeFree\"><a href=\"#4-3-NativeMemoryChunk-nativeFree\" class=\"headerlink\" title=\"4.3 NativeMemoryChunk_nativeFree\"></a>4.3 NativeMemoryChunk_nativeFree</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">free(JLONG_TO_PTR(lpointer));</div></pre></td></tr></table></figure>\n<p>调用free函数将指针对应位置的内存释放掉。</p>\n<p>其他的几个函数 这里就不说了。</p>\n<p>需要注意的是，native内存管理实对应NativeMemoryChunkPool。</p>\n<h3 id=\"5-以native内存为例，了解fresco内存池\"><a href=\"#5-以native内存为例，了解fresco内存池\" class=\"headerlink\" title=\"5 以native内存为例，了解fresco内存池\"></a>5 以native内存为例，了解fresco内存池</h3><p>我们需要先来了解几个东西。</p>\n<ul>\n<li>池 负责存储某类型的数据</li>\n<li>桶 将池分为若干大小的块，每一个块就是一个桶</li>\n<li>每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。</li>\n</ul>\n<p>那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。</p>\n<p><img src=\"/images/fresco/fresco_5.png\" alt=\"\"></p>\n<p>了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。</p>\n<h4 id=\"5-1-BasePool-get\"><a href=\"#5-1-BasePool-get\" class=\"headerlink\" title=\"5.1 BasePool#get\"></a>5.1 BasePool#get</h4><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">int bucketedSize = getBucketedSize(size);</div><div class=\"line\">int sizeInBytes = -1;</div><div class=\"line\"></div><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">  Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\"></div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    // find an existing value that we can reuse</div><div class=\"line\">    V value = bucket.get();</div><div class=\"line\">    if (value != null) &#123;</div><div class=\"line\">      Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\"></div><div class=\"line\">      // It is possible that we got a &apos;larger&apos; value than we asked for.</div><div class=\"line\">      // lets recompute size in bytes here</div><div class=\"line\">      bucketedSize = getBucketedSizeForValue(value);</div><div class=\"line\">      sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">      mUsed.increment(sizeInBytes);</div><div class=\"line\">      mFree.decrement(sizeInBytes);</div><div class=\"line\">      mPoolStatsTracker.onValueReuse(sizeInBytes);</div><div class=\"line\">      logStats();</div><div class=\"line\">      if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">        FLog.v(</div><div class=\"line\">            TAG,</div><div class=\"line\">            &quot;get (reuse) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">            System.identityHashCode(value),</div><div class=\"line\">            bucketedSize);</div><div class=\"line\">      &#125;</div><div class=\"line\">      return value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // fall through</div><div class=\"line\">  &#125;</div><div class=\"line\">  // check to see if we can allocate a value of the given size without exceeding the hard cap</div><div class=\"line\">  sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">  if (!canAllocate(sizeInBytes)) &#123;</div><div class=\"line\">    throw new PoolSizeViolationException(</div><div class=\"line\">        mPoolParams.maxSizeHardCap,</div><div class=\"line\">        mUsed.mNumBytes,</div><div class=\"line\">        mFree.mNumBytes,</div><div class=\"line\">        sizeInBytes);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes</div><div class=\"line\">  mUsed.increment(sizeInBytes);</div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    bucket.incrementInUseCount();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小</li>\n<li>通过getBucket方法获取对应桶容量的桶<ul>\n<li>如果没有找到，就创建一个新的桶 </li>\n</ul>\n</li>\n<li>如果桶不为null<ul>\n<li>通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能</li>\n<li>Counter 纪录使用容量和空闲容量</li>\n<li>状态追踪以及其他操作</li>\n<li>返回</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">V value = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">  // allocate the value outside the synchronized block, because it can be pretty expensive</div><div class=\"line\">  // we could have done the allocation inside the synchronized block,</div><div class=\"line\">  // but that would have blocked out other operations on the pool</div><div class=\"line\">  value = alloc(bucketedSize);</div><div class=\"line\">&#125; catch (Throwable e) &#123;</div><div class=\"line\">  // Assumption we made previously is not valid - allocation failed. We need to fix internal</div><div class=\"line\">  // counters.</div><div class=\"line\">  synchronized (this) &#123;</div><div class=\"line\">    mUsed.decrement(sizeInBytes);</div><div class=\"line\">    Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\">    if (bucket != null) &#123;</div><div class=\"line\">      bucket.decrementInUseCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Throwables.propagateIfPossible(e);</div><div class=\"line\">&#125;</div><div class=\"line\">    synchronized(this) &#123;</div><div class=\"line\">  Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\">  // If we&apos;re over the pool&apos;s max size, try to trim the pool appropriately</div><div class=\"line\">  trimToSoftCap();</div><div class=\"line\">  mPoolStatsTracker.onAlloc(sizeInBytes);</div><div class=\"line\">  logStats();</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;get (alloc) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">        System.identityHashCode(value),</div><div class=\"line\">        bucketedSize);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return value;</div></pre></td></tr></table></figure>\n<ul>\n<li>没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有</li>\n<li>如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。</li>\n</ul>\n<h4 id=\"5-2-BasePool-release\"><a href=\"#5-2-BasePool-release\" class=\"headerlink\" title=\"5.2 BasePool#release\"></a>5.2 BasePool#release</h4><p>这个方法是我们主动释放一个对象所占用的内存。</p>\n<p>实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco加载数据","date":"2016-12-12T15:51:23.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n![](/images/fresco/fresco_1.png)\n\n\n### 2.SimpleDraweeView#setImageURI\n\n在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\n* 根据attrs更新GenericDraweeHierarchyBuilder\n* 更新图像的宽高比\n* 设置Hierarchy\n\n在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。\n\n继续看DraweeView#setImageURI\n\n```\n  public void setImageURI(Uri uri, @Nullable Object callerContext) {\n    DraweeController controller = mSimpleDraweeControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\n    setController(controller);\n  }er.setImageURI(uri);\n  }\n```\n\n先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：\n\n```\n  public void setController(@Nullable DraweeController draweeController) {\n    boolean wasAttached = mIsControllerAttached;\n    if (wasAttached) {\n      detachController();\n    }\n\n    // Clear the old controller\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);\n      mController.setHierarchy(null);\n    }\n    mController = draweeController;\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);\n      mController.setHierarchy(mHierarchy);\n    } else {\n      mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);\n    }\n\n    if (wasAttached) {\n      attachController();\n    }\n  }\n\n```\n\n* 如果已经关联过controller，则取消与拿来的关联\n* 如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，\n* 如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件\n* 关联controller\n\n在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。\n\n### 3.AbstractDraweeController#onAttach\n\n```\n  public void onAttach() {\n    if (FLog.isLoggable(FLog.VERBOSE)) {\n      FLog.v(\n          TAG,\n          \"controller %x %s: onAttach: %s\",\n          System.identityHashCode(this),\n          mId,\n          mIsRequestSubmitted ? \"request already submitted\" : \"request needs submit\");\n    }\n    mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);\n    Preconditions.checkNotNull(mSettableDraweeHierarchy);\n    mDeferredReleaser.cancelDeferredRelease(this);\n    mIsAttached = true;\n    if (!mIsRequestSubmitted) {\n      submitRequest();\n    }\n  }\n```\n\n\n* 打印日志\n* 纪录事件\n* 发送请求\n\n### 4. submitRequest\n\n这个方法分为俩个部分。\n\n* 读取memory cache 同步\n* 读取除了memorycache 的其他部分\n\n\n#### 4.1 读取缓存部分\n\n```\n    final T closeableImage = getCachedImage();\n    if (closeableImage != null) {\n      mDataSource = null;\n      mIsRequestSubmitted = true;\n      mHasFetchFailed = false;\n      mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);\n      getControllerListener().onSubmit(mId, mCallerContext);\n      onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);\n      return;\n    }\n```\n\n* 通过getCachedImage 获取缓存数据\n* 纪录缓存命中事件\n* 回调，后面再将\n\n我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中\n\n```\n  @Override\n  protected CloseableReference<CloseableImage> getCachedImage() {\n    if (mMemoryCache == null || mCacheKey == null) {\n      return null;\n    }\n    // We get the CacheKey\n    CloseableReference<CloseableImage> closeableImage = mMemoryCache.get(mCacheKey);\n    if (closeableImage != null && !closeableImage.get().getQualityInfo().isOfFullQuality()) {\n      closeableImage.close();\n      return null;\n    }\n    return closeableImage;\n  }\n```\n\n可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。\n\n现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。\n\n从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。\n\n\n到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方\n\n* ImagePipelineFactory#getBitmapMemoryCache\n* BitmapMemoryCacheFactory\n* InstrumentedMemoryCache\n\n```\n  @Override\n  public CloseableReference<V> get(K key) {\n    CloseableReference<V> result = mDelegate.get(key);\n    if (result == null) {\n      mTracker.onCacheMiss();\n    } else {\n      mTracker.onCacheHit(key);\n    }\n    return result;\n  }\n```\n\n我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。\n\n#### 4.2 其他部分\n\n首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。\n\n而从其他部分获取的关键就在于fetchDecodedImage中的如下代码\n\n```\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext);\n```\n我们看看getDecodedImageProducerSequence的具体实现。\n\n```\n  public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(\n      ImageRequest imageRequest) {\n    Producer<CloseableReference<CloseableImage>> pipelineSequence =\n        getBasicDecodedImageSequence(imageRequest);\n    if (imageRequest.getPostprocessor() != null) {\n      return getPostprocessorSequence(pipelineSequence);\n    } else {\n      return pipelineSequence;\n    }\n  }\n```\n\n我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。\n\n> swallow result if prefetch -> bitmap cache get ->\n  background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->\n  encoded cache -> disk cache -> (webp transcode) -> network fetch.\n\n\n这里的具体细节我们不管，继续看submitFetchRequest，\n在submitFetchRequest函数中做了三件事：\n\n* 取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；\n* 将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。\n* 创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。\n\n至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。\n\n\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","source":"_posts/fresco加载数据.md","raw":"---\ntitle: fresco加载数据\ndate: 2016-12-12 23:51:23\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n![](/images/fresco/fresco_1.png)\n\n\n### 2.SimpleDraweeView#setImageURI\n\n在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\n* 根据attrs更新GenericDraweeHierarchyBuilder\n* 更新图像的宽高比\n* 设置Hierarchy\n\n在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。\n\n继续看DraweeView#setImageURI\n\n```\n  public void setImageURI(Uri uri, @Nullable Object callerContext) {\n    DraweeController controller = mSimpleDraweeControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\n    setController(controller);\n  }er.setImageURI(uri);\n  }\n```\n\n先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：\n\n```\n  public void setController(@Nullable DraweeController draweeController) {\n    boolean wasAttached = mIsControllerAttached;\n    if (wasAttached) {\n      detachController();\n    }\n\n    // Clear the old controller\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);\n      mController.setHierarchy(null);\n    }\n    mController = draweeController;\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);\n      mController.setHierarchy(mHierarchy);\n    } else {\n      mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);\n    }\n\n    if (wasAttached) {\n      attachController();\n    }\n  }\n\n```\n\n* 如果已经关联过controller，则取消与拿来的关联\n* 如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，\n* 如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件\n* 关联controller\n\n在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。\n\n### 3.AbstractDraweeController#onAttach\n\n```\n  public void onAttach() {\n    if (FLog.isLoggable(FLog.VERBOSE)) {\n      FLog.v(\n          TAG,\n          \"controller %x %s: onAttach: %s\",\n          System.identityHashCode(this),\n          mId,\n          mIsRequestSubmitted ? \"request already submitted\" : \"request needs submit\");\n    }\n    mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);\n    Preconditions.checkNotNull(mSettableDraweeHierarchy);\n    mDeferredReleaser.cancelDeferredRelease(this);\n    mIsAttached = true;\n    if (!mIsRequestSubmitted) {\n      submitRequest();\n    }\n  }\n```\n\n\n* 打印日志\n* 纪录事件\n* 发送请求\n\n### 4. submitRequest\n\n这个方法分为俩个部分。\n\n* 读取memory cache 同步\n* 读取除了memorycache 的其他部分\n\n\n#### 4.1 读取缓存部分\n\n```\n    final T closeableImage = getCachedImage();\n    if (closeableImage != null) {\n      mDataSource = null;\n      mIsRequestSubmitted = true;\n      mHasFetchFailed = false;\n      mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);\n      getControllerListener().onSubmit(mId, mCallerContext);\n      onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);\n      return;\n    }\n```\n\n* 通过getCachedImage 获取缓存数据\n* 纪录缓存命中事件\n* 回调，后面再将\n\n我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中\n\n```\n  @Override\n  protected CloseableReference<CloseableImage> getCachedImage() {\n    if (mMemoryCache == null || mCacheKey == null) {\n      return null;\n    }\n    // We get the CacheKey\n    CloseableReference<CloseableImage> closeableImage = mMemoryCache.get(mCacheKey);\n    if (closeableImage != null && !closeableImage.get().getQualityInfo().isOfFullQuality()) {\n      closeableImage.close();\n      return null;\n    }\n    return closeableImage;\n  }\n```\n\n可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。\n\n现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。\n\n从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。\n\n\n到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方\n\n* ImagePipelineFactory#getBitmapMemoryCache\n* BitmapMemoryCacheFactory\n* InstrumentedMemoryCache\n\n```\n  @Override\n  public CloseableReference<V> get(K key) {\n    CloseableReference<V> result = mDelegate.get(key);\n    if (result == null) {\n      mTracker.onCacheMiss();\n    } else {\n      mTracker.onCacheHit(key);\n    }\n    return result;\n  }\n```\n\n我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。\n\n#### 4.2 其他部分\n\n首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。\n\n而从其他部分获取的关键就在于fetchDecodedImage中的如下代码\n\n```\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext);\n```\n我们看看getDecodedImageProducerSequence的具体实现。\n\n```\n  public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(\n      ImageRequest imageRequest) {\n    Producer<CloseableReference<CloseableImage>> pipelineSequence =\n        getBasicDecodedImageSequence(imageRequest);\n    if (imageRequest.getPostprocessor() != null) {\n      return getPostprocessorSequence(pipelineSequence);\n    } else {\n      return pipelineSequence;\n    }\n  }\n```\n\n我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。\n\n> swallow result if prefetch -> bitmap cache get ->\n  background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->\n  encoded cache -> disk cache -> (webp transcode) -> network fetch.\n\n\n这里的具体细节我们不管，继续看submitFetchRequest，\n在submitFetchRequest函数中做了三件事：\n\n* 取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；\n* 将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。\n* 创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。\n\n至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。\n\n\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","slug":"fresco加载数据","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslyy003g19fyg8e3c313","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<p><img src=\"/images/fresco/fresco_1.png\" alt=\"\"></p>\n<h3 id=\"2-SimpleDraweeView-setImageURI\"><a href=\"#2-SimpleDraweeView-setImageURI\" class=\"headerlink\" title=\"2.SimpleDraweeView#setImageURI\"></a>2.SimpleDraweeView#setImageURI</h3><p>在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据attrs更新GenericDraweeHierarchyBuilder</li>\n<li>更新图像的宽高比</li>\n<li>设置Hierarchy</li>\n</ul>\n<p>在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。</p>\n<p>继续看DraweeView#setImageURI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setImageURI(Uri uri, @Nullable Object callerContext) &#123;</div><div class=\"line\">  DraweeController controller = mSimpleDraweeControllerBuilder</div><div class=\"line\">      .setCallerContext(callerContext)</div><div class=\"line\">      .setUri(uri)</div><div class=\"line\">      .setOldController(getController())</div><div class=\"line\">      .build();</div><div class=\"line\">  setController(controller);</div><div class=\"line\">&#125;er.setImageURI(uri);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setController(@Nullable DraweeController draweeController) &#123;</div><div class=\"line\">  boolean wasAttached = mIsControllerAttached;</div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    detachController();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Clear the old controller</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(null);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mController = draweeController;</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(mHierarchy);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    attachController();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果已经关联过controller，则取消与拿来的关联</li>\n<li>如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，</li>\n<li>如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件</li>\n<li>关联controller</li>\n</ul>\n<p>在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。</p>\n<h3 id=\"3-AbstractDraweeController-onAttach\"><a href=\"#3-AbstractDraweeController-onAttach\" class=\"headerlink\" title=\"3.AbstractDraweeController#onAttach\"></a>3.AbstractDraweeController#onAttach</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void onAttach() &#123;</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;controller %x %s: onAttach: %s&quot;,</div><div class=\"line\">        System.identityHashCode(this),</div><div class=\"line\">        mId,</div><div class=\"line\">        mIsRequestSubmitted ? &quot;request already submitted&quot; : &quot;request needs submit&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</div><div class=\"line\">  Preconditions.checkNotNull(mSettableDraweeHierarchy);</div><div class=\"line\">  mDeferredReleaser.cancelDeferredRelease(this);</div><div class=\"line\">  mIsAttached = true;</div><div class=\"line\">  if (!mIsRequestSubmitted) &#123;</div><div class=\"line\">    submitRequest();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>打印日志</li>\n<li>纪录事件</li>\n<li>发送请求</li>\n</ul>\n<h3 id=\"4-submitRequest\"><a href=\"#4-submitRequest\" class=\"headerlink\" title=\"4. submitRequest\"></a>4. submitRequest</h3><p>这个方法分为俩个部分。</p>\n<ul>\n<li>读取memory cache 同步</li>\n<li>读取除了memorycache 的其他部分</li>\n</ul>\n<h4 id=\"4-1-读取缓存部分\"><a href=\"#4-1-读取缓存部分\" class=\"headerlink\" title=\"4.1 读取缓存部分\"></a>4.1 读取缓存部分</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">final T closeableImage = getCachedImage();</div><div class=\"line\">if (closeableImage != null) &#123;</div><div class=\"line\">  mDataSource = null;</div><div class=\"line\">  mIsRequestSubmitted = true;</div><div class=\"line\">  mHasFetchFailed = false;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);</div><div class=\"line\">  getControllerListener().onSubmit(mId, mCallerContext);</div><div class=\"line\">  onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);</div><div class=\"line\">  return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过getCachedImage 获取缓存数据</li>\n<li>纪录缓存命中事件</li>\n<li>回调，后面再将</li>\n</ul>\n<p>我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected CloseableReference&lt;CloseableImage&gt; getCachedImage() &#123;</div><div class=\"line\">  if (mMemoryCache == null || mCacheKey == null) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  // We get the CacheKey</div><div class=\"line\">  CloseableReference&lt;CloseableImage&gt; closeableImage = mMemoryCache.get(mCacheKey);</div><div class=\"line\">  if (closeableImage != null &amp;&amp; !closeableImage.get().getQualityInfo().isOfFullQuality()) &#123;</div><div class=\"line\">    closeableImage.close();</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return closeableImage;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。</p>\n<p>现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。</p>\n<p>从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。</p>\n<p>到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方</p>\n<ul>\n<li>ImagePipelineFactory#getBitmapMemoryCache</li>\n<li>BitmapMemoryCacheFactory</li>\n<li>InstrumentedMemoryCache</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;V&gt; get(K key) &#123;</div><div class=\"line\">  CloseableReference&lt;V&gt; result = mDelegate.get(key);</div><div class=\"line\">  if (result == null) &#123;</div><div class=\"line\">    mTracker.onCacheMiss();</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mTracker.onCacheHit(key);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。</p>\n<h4 id=\"4-2-其他部分\"><a href=\"#4-2-其他部分\" class=\"headerlink\" title=\"4.2 其他部分\"></a>4.2 其他部分</h4><p>首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。</p>\n<p>而从其他部分获取的关键就在于fetchDecodedImage中的如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</div><div class=\"line\">    mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</div><div class=\"line\">return submitFetchRequest(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    imageRequest,</div><div class=\"line\">    lowestPermittedRequestLevelOnSubmit,</div><div class=\"line\">    callerContext);</div></pre></td></tr></table></figure>\n<p>我们看看getDecodedImageProducerSequence的具体实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDecodedImageProducerSequence(</div><div class=\"line\">    ImageRequest imageRequest) &#123;</div><div class=\"line\">  Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; pipelineSequence =</div><div class=\"line\">      getBasicDecodedImageSequence(imageRequest);</div><div class=\"line\">  if (imageRequest.getPostprocessor() != null) &#123;</div><div class=\"line\">    return getPostprocessorSequence(pipelineSequence);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    return pipelineSequence;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。</p>\n<blockquote>\n<p>swallow result if prefetch -&gt; bitmap cache get -&gt;<br>  background thread hand-off -&gt; multiplex -&gt; bitmap cache -&gt; decode -&gt; multiplex -&gt;<br>  encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.</p>\n</blockquote>\n<p>这里的具体细节我们不管，继续看submitFetchRequest，<br>在submitFetchRequest函数中做了三件事：</p>\n<ul>\n<li>取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；</li>\n<li>将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。</li>\n<li>创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。</li>\n</ul>\n<p>至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<p><img src=\"/images/fresco/fresco_1.png\" alt=\"\"></p>\n<h3 id=\"2-SimpleDraweeView-setImageURI\"><a href=\"#2-SimpleDraweeView-setImageURI\" class=\"headerlink\" title=\"2.SimpleDraweeView#setImageURI\"></a>2.SimpleDraweeView#setImageURI</h3><p>在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据attrs更新GenericDraweeHierarchyBuilder</li>\n<li>更新图像的宽高比</li>\n<li>设置Hierarchy</li>\n</ul>\n<p>在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。</p>\n<p>继续看DraweeView#setImageURI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setImageURI(Uri uri, @Nullable Object callerContext) &#123;</div><div class=\"line\">  DraweeController controller = mSimpleDraweeControllerBuilder</div><div class=\"line\">      .setCallerContext(callerContext)</div><div class=\"line\">      .setUri(uri)</div><div class=\"line\">      .setOldController(getController())</div><div class=\"line\">      .build();</div><div class=\"line\">  setController(controller);</div><div class=\"line\">&#125;er.setImageURI(uri);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setController(@Nullable DraweeController draweeController) &#123;</div><div class=\"line\">  boolean wasAttached = mIsControllerAttached;</div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    detachController();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Clear the old controller</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(null);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mController = draweeController;</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(mHierarchy);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    attachController();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果已经关联过controller，则取消与拿来的关联</li>\n<li>如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，</li>\n<li>如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件</li>\n<li>关联controller</li>\n</ul>\n<p>在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。</p>\n<h3 id=\"3-AbstractDraweeController-onAttach\"><a href=\"#3-AbstractDraweeController-onAttach\" class=\"headerlink\" title=\"3.AbstractDraweeController#onAttach\"></a>3.AbstractDraweeController#onAttach</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void onAttach() &#123;</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;controller %x %s: onAttach: %s&quot;,</div><div class=\"line\">        System.identityHashCode(this),</div><div class=\"line\">        mId,</div><div class=\"line\">        mIsRequestSubmitted ? &quot;request already submitted&quot; : &quot;request needs submit&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</div><div class=\"line\">  Preconditions.checkNotNull(mSettableDraweeHierarchy);</div><div class=\"line\">  mDeferredReleaser.cancelDeferredRelease(this);</div><div class=\"line\">  mIsAttached = true;</div><div class=\"line\">  if (!mIsRequestSubmitted) &#123;</div><div class=\"line\">    submitRequest();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>打印日志</li>\n<li>纪录事件</li>\n<li>发送请求</li>\n</ul>\n<h3 id=\"4-submitRequest\"><a href=\"#4-submitRequest\" class=\"headerlink\" title=\"4. submitRequest\"></a>4. submitRequest</h3><p>这个方法分为俩个部分。</p>\n<ul>\n<li>读取memory cache 同步</li>\n<li>读取除了memorycache 的其他部分</li>\n</ul>\n<h4 id=\"4-1-读取缓存部分\"><a href=\"#4-1-读取缓存部分\" class=\"headerlink\" title=\"4.1 读取缓存部分\"></a>4.1 读取缓存部分</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">final T closeableImage = getCachedImage();</div><div class=\"line\">if (closeableImage != null) &#123;</div><div class=\"line\">  mDataSource = null;</div><div class=\"line\">  mIsRequestSubmitted = true;</div><div class=\"line\">  mHasFetchFailed = false;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);</div><div class=\"line\">  getControllerListener().onSubmit(mId, mCallerContext);</div><div class=\"line\">  onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);</div><div class=\"line\">  return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过getCachedImage 获取缓存数据</li>\n<li>纪录缓存命中事件</li>\n<li>回调，后面再将</li>\n</ul>\n<p>我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected CloseableReference&lt;CloseableImage&gt; getCachedImage() &#123;</div><div class=\"line\">  if (mMemoryCache == null || mCacheKey == null) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  // We get the CacheKey</div><div class=\"line\">  CloseableReference&lt;CloseableImage&gt; closeableImage = mMemoryCache.get(mCacheKey);</div><div class=\"line\">  if (closeableImage != null &amp;&amp; !closeableImage.get().getQualityInfo().isOfFullQuality()) &#123;</div><div class=\"line\">    closeableImage.close();</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return closeableImage;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。</p>\n<p>现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。</p>\n<p>从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。</p>\n<p>到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方</p>\n<ul>\n<li>ImagePipelineFactory#getBitmapMemoryCache</li>\n<li>BitmapMemoryCacheFactory</li>\n<li>InstrumentedMemoryCache</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;V&gt; get(K key) &#123;</div><div class=\"line\">  CloseableReference&lt;V&gt; result = mDelegate.get(key);</div><div class=\"line\">  if (result == null) &#123;</div><div class=\"line\">    mTracker.onCacheMiss();</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mTracker.onCacheHit(key);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。</p>\n<h4 id=\"4-2-其他部分\"><a href=\"#4-2-其他部分\" class=\"headerlink\" title=\"4.2 其他部分\"></a>4.2 其他部分</h4><p>首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。</p>\n<p>而从其他部分获取的关键就在于fetchDecodedImage中的如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</div><div class=\"line\">    mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</div><div class=\"line\">return submitFetchRequest(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    imageRequest,</div><div class=\"line\">    lowestPermittedRequestLevelOnSubmit,</div><div class=\"line\">    callerContext);</div></pre></td></tr></table></figure>\n<p>我们看看getDecodedImageProducerSequence的具体实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDecodedImageProducerSequence(</div><div class=\"line\">    ImageRequest imageRequest) &#123;</div><div class=\"line\">  Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; pipelineSequence =</div><div class=\"line\">      getBasicDecodedImageSequence(imageRequest);</div><div class=\"line\">  if (imageRequest.getPostprocessor() != null) &#123;</div><div class=\"line\">    return getPostprocessorSequence(pipelineSequence);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    return pipelineSequence;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。</p>\n<blockquote>\n<p>swallow result if prefetch -&gt; bitmap cache get -&gt;<br>  background thread hand-off -&gt; multiplex -&gt; bitmap cache -&gt; decode -&gt; multiplex -&gt;<br>  encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.</p>\n</blockquote>\n<p>这里的具体细节我们不管，继续看submitFetchRequest，<br>在submitFetchRequest函数中做了三件事：</p>\n<ul>\n<li>取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；</li>\n<li>将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。</li>\n<li>创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。</li>\n</ul>\n<p>至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco用法","date":"2016-12-12T06:27:12.000Z","_content":"<Excerpt in index | 首页摘要>\n### 0.前言\n\n在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 1.fresco中的关键概念\n\n* Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式\n\t* DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可\n\t* DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。\n\t* DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。\n如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。\n\t* DraweeControllerBuilder \nDraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改\n\t* Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。\n* The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。\n在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。\nSimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 \n\n### 3.支持的URI类型\n\n* http|https\n* file://\n* content://\n* asset://\n* res://\n* data:mime/type;base64 uri中指定图片数据\n\n### 4.支持的xml属性\n\n[支持的xml属性](https://www.fresco-cn.org/docs/using-drawees-xml.html)\n\n### 5.在java中使用Drawees\n\n#### 5.1 自定义DraweeHierarchy\n\n```\n        GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());\n        GenericDraweeHierarchy hierarchy = builder\n                .setFadeDuration(300)\n                //and so on\n                .build();\n        image.setHierarchy(hierarchy);\n```\n\n从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\nxml中对应的属性，由hierarchy控制。\n\n#### 5.2 运行时修改 DraweeHierarchy\n\n要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。\n\n```\n        GenericDraweeHierarchy hierarchy = image.getHierarchy();\n        hierarchy.setFadeDuration(400);\n```\n\n其他属性同理。\n\n#### 5.3 配置效果\n\n我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。\n\n在ControllerBuilder 中如下设置:\n\n```\n.setTapToRetryEnabled(true)\n```\n\n* XML 中属性值: retryImage\n* Hierarchy builder中的方法: setRetryImage\n\n#### 5.4 进度条\n\n构建GenericDraweeHierarchy的时候\n\n\n```\n.setProgressBarImage(new ProgressBarDrawable())\n```\n，我们也可以自定义，实现Drawable.onLevelChange。\n\n\n### 6 DraweeController增加对图片的控制\n\n```\nControllerListener listener = new BaseControllerListener() {...}\n\nDraweeController controller = Fresco.newDraweeControllerBuilder()\n    .setUri(uri)\n    .setTapToRetryEnabled(true)\n    .setOldController(mSimpleDraweeView.getController())\n    .setControllerListener(listener)\n    .build();\n\nmSimpleDraweeView.setController(controller);\n```\n\n* 使用渐进式jpeg图。\n\n    ```\n    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(\"xxx\"))\n                //打开渐进 渲染\n                .setProgressiveRenderingEnabled(true)\n                .build();\n\t```\n\t\n* 动画自动播放\n\t\n\t```\n\tdraweeController.setAutoPlayAnimations(true)\n\t```\n* 动画手动播放，\n\n\t```\n\t        ControllerListener listener = new BaseControllerListener<ImageInfo>(){\n            @Override\n            public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) {\n                super.onFinalImageSet(id, imageInfo, animatable);\n                if (animatable != null){\n                    animatable.start();\n                }\n            }\n        };\n        \n        draweeController.setControllerListener(listener)\n\t```\n* 后处理器Postprocessor 对图片进行后期处理\n\n```\nPostprocessor redMeshPostprocessor = new BasePostprocessor() {\n  @Override\n  public String getName() {\n    return \"redMeshPostprocessor\";\n  }\n\n  @Override\n  public void process(Bitmap bitmap) {\n    for (int x = 0; x < bitmap.getWidth(); x+=2) {\n      for (int y = 0; y < bitmap.getHeight(); y+=2) {\n        bitmap.setPixel(x, y, Color.RED);\n      }\n    }\n  }\n}\n\nImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)\n    .setPostprocessor(redMeshPostprocessor)\n    .build();\n```\n\n### 7.Image Requests\n\n使用ImageRequestBuilder来做更多的事情。\n\n```\nUri uri;\n\nImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()\n    .setBackgroundColor(Color.GREEN)\n    .build();\n\nImageRequest request = ImageRequestBuilder\n    .newBuilderWithSource(uri)\n    .setImageDecodeOptions(decodeOptions)\n    .setAutoRotateEnabled(true)\n    .setLocalThumbnailPreviewsEnabled(true)\n    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    \n    .setProgressiveRenderingEnabled(false)\n    .setResizeOptions(new ResizeOptions(width, height))\n    .build();\n```\n\n### 8.Image Pipeline\nImage pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。\n\n```\nImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)\n    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)\n    .setCacheKeyFactory(cacheKeyFactory)\n    .setDownsampleEnabled(true)\n    .setWebpSupportEnabled(true)\n    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)\n    .setExecutorSupplier(executorSupplier)\n    .setImageCacheStatsTracker(imageCacheStatsTracker)\n    .setMainDiskCacheConfig(mainDiskCacheConfig)\n    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)\n    .setNetworkFetchProducer(networkFetchProducer)\n    .setPoolFactory(poolFactory)\n    .setProgressiveJpegConfig(progressiveJpegConfig)\n    .setRequestListeners(requestListeners)\n    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)\n    .build();\nFresco.initialize(context, config);\n```\n\n上面的可配置项会因为版本的不同有稍微的区别。\n\n#### 8.1 缓存\n\n在fresco里面，\n\n* bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上\n* 未解码图片的内存缓存\n* 磁盘缓存\n\n我们可以通过imagepipeline判断bitmap是否被缓存，\n\n```\n        ImagePipeline imagePipeline = Fresco.getImagePipeline();\n        imagePipeline.isInBitmapMemoryCache(Uri.parse(\"\"));\n        imagePipeline.isInDiskCache(Uri.parse(\"xxx\"));\n```\n\n删除指定缓存\n\n```\n        Uri uri = Uri.parse(\"xxx\");\n        imagePipeline.evictFromCache(uri);\n        imagePipeline.evictFromDiskCache(uri);\n```\n\n\n使用imagepipeline可以对整个工程加入一些控制。更多用法[文档](https://www.fresco-cn.org/docs/using-image-pipeline.html)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/fresco用法.md","raw":"---\ntitle: fresco用法\ndate: 2016-12-12 14:27:12\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 0.前言\n\n在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 1.fresco中的关键概念\n\n* Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式\n\t* DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可\n\t* DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。\n\t* DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。\n如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。\n\t* DraweeControllerBuilder \nDraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改\n\t* Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。\n* The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。\n在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。\nSimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 \n\n### 3.支持的URI类型\n\n* http|https\n* file://\n* content://\n* asset://\n* res://\n* data:mime/type;base64 uri中指定图片数据\n\n### 4.支持的xml属性\n\n[支持的xml属性](https://www.fresco-cn.org/docs/using-drawees-xml.html)\n\n### 5.在java中使用Drawees\n\n#### 5.1 自定义DraweeHierarchy\n\n```\n        GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());\n        GenericDraweeHierarchy hierarchy = builder\n                .setFadeDuration(300)\n                //and so on\n                .build();\n        image.setHierarchy(hierarchy);\n```\n\n从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\nxml中对应的属性，由hierarchy控制。\n\n#### 5.2 运行时修改 DraweeHierarchy\n\n要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。\n\n```\n        GenericDraweeHierarchy hierarchy = image.getHierarchy();\n        hierarchy.setFadeDuration(400);\n```\n\n其他属性同理。\n\n#### 5.3 配置效果\n\n我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。\n\n在ControllerBuilder 中如下设置:\n\n```\n.setTapToRetryEnabled(true)\n```\n\n* XML 中属性值: retryImage\n* Hierarchy builder中的方法: setRetryImage\n\n#### 5.4 进度条\n\n构建GenericDraweeHierarchy的时候\n\n\n```\n.setProgressBarImage(new ProgressBarDrawable())\n```\n，我们也可以自定义，实现Drawable.onLevelChange。\n\n\n### 6 DraweeController增加对图片的控制\n\n```\nControllerListener listener = new BaseControllerListener() {...}\n\nDraweeController controller = Fresco.newDraweeControllerBuilder()\n    .setUri(uri)\n    .setTapToRetryEnabled(true)\n    .setOldController(mSimpleDraweeView.getController())\n    .setControllerListener(listener)\n    .build();\n\nmSimpleDraweeView.setController(controller);\n```\n\n* 使用渐进式jpeg图。\n\n    ```\n    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(\"xxx\"))\n                //打开渐进 渲染\n                .setProgressiveRenderingEnabled(true)\n                .build();\n\t```\n\t\n* 动画自动播放\n\t\n\t```\n\tdraweeController.setAutoPlayAnimations(true)\n\t```\n* 动画手动播放，\n\n\t```\n\t        ControllerListener listener = new BaseControllerListener<ImageInfo>(){\n            @Override\n            public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) {\n                super.onFinalImageSet(id, imageInfo, animatable);\n                if (animatable != null){\n                    animatable.start();\n                }\n            }\n        };\n        \n        draweeController.setControllerListener(listener)\n\t```\n* 后处理器Postprocessor 对图片进行后期处理\n\n```\nPostprocessor redMeshPostprocessor = new BasePostprocessor() {\n  @Override\n  public String getName() {\n    return \"redMeshPostprocessor\";\n  }\n\n  @Override\n  public void process(Bitmap bitmap) {\n    for (int x = 0; x < bitmap.getWidth(); x+=2) {\n      for (int y = 0; y < bitmap.getHeight(); y+=2) {\n        bitmap.setPixel(x, y, Color.RED);\n      }\n    }\n  }\n}\n\nImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)\n    .setPostprocessor(redMeshPostprocessor)\n    .build();\n```\n\n### 7.Image Requests\n\n使用ImageRequestBuilder来做更多的事情。\n\n```\nUri uri;\n\nImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()\n    .setBackgroundColor(Color.GREEN)\n    .build();\n\nImageRequest request = ImageRequestBuilder\n    .newBuilderWithSource(uri)\n    .setImageDecodeOptions(decodeOptions)\n    .setAutoRotateEnabled(true)\n    .setLocalThumbnailPreviewsEnabled(true)\n    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    \n    .setProgressiveRenderingEnabled(false)\n    .setResizeOptions(new ResizeOptions(width, height))\n    .build();\n```\n\n### 8.Image Pipeline\nImage pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。\n\n```\nImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)\n    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)\n    .setCacheKeyFactory(cacheKeyFactory)\n    .setDownsampleEnabled(true)\n    .setWebpSupportEnabled(true)\n    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)\n    .setExecutorSupplier(executorSupplier)\n    .setImageCacheStatsTracker(imageCacheStatsTracker)\n    .setMainDiskCacheConfig(mainDiskCacheConfig)\n    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)\n    .setNetworkFetchProducer(networkFetchProducer)\n    .setPoolFactory(poolFactory)\n    .setProgressiveJpegConfig(progressiveJpegConfig)\n    .setRequestListeners(requestListeners)\n    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)\n    .build();\nFresco.initialize(context, config);\n```\n\n上面的可配置项会因为版本的不同有稍微的区别。\n\n#### 8.1 缓存\n\n在fresco里面，\n\n* bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上\n* 未解码图片的内存缓存\n* 磁盘缓存\n\n我们可以通过imagepipeline判断bitmap是否被缓存，\n\n```\n        ImagePipeline imagePipeline = Fresco.getImagePipeline();\n        imagePipeline.isInBitmapMemoryCache(Uri.parse(\"\"));\n        imagePipeline.isInDiskCache(Uri.parse(\"xxx\"));\n```\n\n删除指定缓存\n\n```\n        Uri uri = Uri.parse(\"xxx\");\n        imagePipeline.evictFromCache(uri);\n        imagePipeline.evictFromDiskCache(uri);\n```\n\n\n使用imagepipeline可以对整个工程加入一些控制。更多用法[文档](https://www.fresco-cn.org/docs/using-image-pipeline.html)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"fresco用法","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslz0003k19fyis7gjzz6","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0.前言\"></a>0.前言</h3><p>在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"1-fresco中的关键概念\"><a href=\"#1-fresco中的关键概念\" class=\"headerlink\" title=\"1.fresco中的关键概念\"></a>1.fresco中的关键概念</h3><ul>\n<li>Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式<ul>\n<li>DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可</li>\n<li>DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。</li>\n<li>DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。<br>如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。</li>\n<li>DraweeControllerBuilder<br>DraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改</li>\n<li>Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。</li>\n</ul>\n</li>\n<li>The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。<br>在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。<br>SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 </li>\n</ul>\n<h3 id=\"3-支持的URI类型\"><a href=\"#3-支持的URI类型\" class=\"headerlink\" title=\"3.支持的URI类型\"></a>3.支持的URI类型</h3><ul>\n<li>http|https</li>\n<li>file://</li>\n<li>content://</li>\n<li>asset://</li>\n<li>res://</li>\n<li>data:mime/type;base64 uri中指定图片数据</li>\n</ul>\n<h3 id=\"4-支持的xml属性\"><a href=\"#4-支持的xml属性\" class=\"headerlink\" title=\"4.支持的xml属性\"></a>4.支持的xml属性</h3><p><a href=\"https://www.fresco-cn.org/docs/using-drawees-xml.html\" target=\"_blank\" rel=\"external\">支持的xml属性</a></p>\n<h3 id=\"5-在java中使用Drawees\"><a href=\"#5-在java中使用Drawees\" class=\"headerlink\" title=\"5.在java中使用Drawees\"></a>5.在java中使用Drawees</h3><h4 id=\"5-1-自定义DraweeHierarchy\"><a href=\"#5-1-自定义DraweeHierarchy\" class=\"headerlink\" title=\"5.1 自定义DraweeHierarchy\"></a>5.1 自定义DraweeHierarchy</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());</div><div class=\"line\">GenericDraweeHierarchy hierarchy = builder</div><div class=\"line\">        .setFadeDuration(300)</div><div class=\"line\">        //and so on</div><div class=\"line\">        .build();</div><div class=\"line\">image.setHierarchy(hierarchy);</div></pre></td></tr></table></figure>\n<p>从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>xml中对应的属性，由hierarchy控制。</p>\n<h4 id=\"5-2-运行时修改-DraweeHierarchy\"><a href=\"#5-2-运行时修改-DraweeHierarchy\" class=\"headerlink\" title=\"5.2 运行时修改 DraweeHierarchy\"></a>5.2 运行时修改 DraweeHierarchy</h4><p>要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchy hierarchy = image.getHierarchy();</div><div class=\"line\">hierarchy.setFadeDuration(400);</div></pre></td></tr></table></figure>\n<p>其他属性同理。</p>\n<h4 id=\"5-3-配置效果\"><a href=\"#5-3-配置效果\" class=\"headerlink\" title=\"5.3 配置效果\"></a>5.3 配置效果</h4><p>我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。</p>\n<p>在ControllerBuilder 中如下设置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setTapToRetryEnabled(true)</div></pre></td></tr></table></figure>\n<ul>\n<li>XML 中属性值: retryImage</li>\n<li>Hierarchy builder中的方法: setRetryImage</li>\n</ul>\n<h4 id=\"5-4-进度条\"><a href=\"#5-4-进度条\" class=\"headerlink\" title=\"5.4 进度条\"></a>5.4 进度条</h4><p>构建GenericDraweeHierarchy的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setProgressBarImage(new ProgressBarDrawable())</div></pre></td></tr></table></figure>\n<p>，我们也可以自定义，实现Drawable.onLevelChange。</p>\n<h3 id=\"6-DraweeController增加对图片的控制\"><a href=\"#6-DraweeController增加对图片的控制\" class=\"headerlink\" title=\"6 DraweeController增加对图片的控制\"></a>6 DraweeController增加对图片的控制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ControllerListener listener = new BaseControllerListener() &#123;...&#125;</div><div class=\"line\"></div><div class=\"line\">DraweeController controller = Fresco.newDraweeControllerBuilder()</div><div class=\"line\">    .setUri(uri)</div><div class=\"line\">    .setTapToRetryEnabled(true)</div><div class=\"line\">    .setOldController(mSimpleDraweeView.getController())</div><div class=\"line\">    .setControllerListener(listener)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">mSimpleDraweeView.setController(controller);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>使用渐进式jpeg图。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(&quot;xxx&quot;))</div><div class=\"line\">            //打开渐进 渲染</div><div class=\"line\">            .setProgressiveRenderingEnabled(true)</div><div class=\"line\">            .build();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>动画自动播放</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">draweeController.setAutoPlayAnimations(true)</div></pre></td></tr></table></figure>\n</li>\n<li><p>动画手动播放，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ControllerListener listener = new BaseControllerListener&lt;ImageInfo&gt;()&#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) &#123;</div><div class=\"line\">        super.onFinalImageSet(id, imageInfo, animatable);</div><div class=\"line\">        if (animatable != null)&#123;</div><div class=\"line\">            animatable.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">draweeController.setControllerListener(listener)</div></pre></td></tr></table></figure>\n</li>\n<li><p>后处理器Postprocessor 对图片进行后期处理</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Postprocessor redMeshPostprocessor = new BasePostprocessor() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public String getName() &#123;</div><div class=\"line\">    return &quot;redMeshPostprocessor&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void process(Bitmap bitmap) &#123;</div><div class=\"line\">    for (int x = 0; x &lt; bitmap.getWidth(); x+=2) &#123;</div><div class=\"line\">      for (int y = 0; y &lt; bitmap.getHeight(); y+=2) &#123;</div><div class=\"line\">        bitmap.setPixel(x, y, Color.RED);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)</div><div class=\"line\">    .setPostprocessor(redMeshPostprocessor)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"7-Image-Requests\"><a href=\"#7-Image-Requests\" class=\"headerlink\" title=\"7.Image Requests\"></a>7.Image Requests</h3><p>使用ImageRequestBuilder来做更多的事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri;</div><div class=\"line\"></div><div class=\"line\">ImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()</div><div class=\"line\">    .setBackgroundColor(Color.GREEN)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder</div><div class=\"line\">    .newBuilderWithSource(uri)</div><div class=\"line\">    .setImageDecodeOptions(decodeOptions)</div><div class=\"line\">    .setAutoRotateEnabled(true)</div><div class=\"line\">    .setLocalThumbnailPreviewsEnabled(true)</div><div class=\"line\">    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    </div><div class=\"line\">    .setProgressiveRenderingEnabled(false)</div><div class=\"line\">    .setResizeOptions(new ResizeOptions(width, height))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"8-Image-Pipeline\"><a href=\"#8-Image-Pipeline\" class=\"headerlink\" title=\"8.Image Pipeline\"></a>8.Image Pipeline</h3><p>Image pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)</div><div class=\"line\">    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)</div><div class=\"line\">    .setCacheKeyFactory(cacheKeyFactory)</div><div class=\"line\">    .setDownsampleEnabled(true)</div><div class=\"line\">    .setWebpSupportEnabled(true)</div><div class=\"line\">    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)</div><div class=\"line\">    .setExecutorSupplier(executorSupplier)</div><div class=\"line\">    .setImageCacheStatsTracker(imageCacheStatsTracker)</div><div class=\"line\">    .setMainDiskCacheConfig(mainDiskCacheConfig)</div><div class=\"line\">    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)</div><div class=\"line\">    .setNetworkFetchProducer(networkFetchProducer)</div><div class=\"line\">    .setPoolFactory(poolFactory)</div><div class=\"line\">    .setProgressiveJpegConfig(progressiveJpegConfig)</div><div class=\"line\">    .setRequestListeners(requestListeners)</div><div class=\"line\">    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)</div><div class=\"line\">    .build();</div><div class=\"line\">Fresco.initialize(context, config);</div></pre></td></tr></table></figure>\n<p>上面的可配置项会因为版本的不同有稍微的区别。</p>\n<h4 id=\"8-1-缓存\"><a href=\"#8-1-缓存\" class=\"headerlink\" title=\"8.1 缓存\"></a>8.1 缓存</h4><p>在fresco里面，</p>\n<ul>\n<li>bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上</li>\n<li>未解码图片的内存缓存</li>\n<li>磁盘缓存</li>\n</ul>\n<p>我们可以通过imagepipeline判断bitmap是否被缓存，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipeline imagePipeline = Fresco.getImagePipeline();</div><div class=\"line\">imagePipeline.isInBitmapMemoryCache(Uri.parse(&quot;&quot;));</div><div class=\"line\">imagePipeline.isInDiskCache(Uri.parse(&quot;xxx&quot;));</div></pre></td></tr></table></figure>\n<p>删除指定缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(&quot;xxx&quot;);</div><div class=\"line\">imagePipeline.evictFromCache(uri);</div><div class=\"line\">imagePipeline.evictFromDiskCache(uri);</div></pre></td></tr></table></figure>\n<p>使用imagepipeline可以对整个工程加入一些控制。更多用法<a href=\"https://www.fresco-cn.org/docs/using-image-pipeline.html\" target=\"_blank\" rel=\"external\">文档</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0.前言\"></a>0.前言</h3><p>在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"1-fresco中的关键概念\"><a href=\"#1-fresco中的关键概念\" class=\"headerlink\" title=\"1.fresco中的关键概念\"></a>1.fresco中的关键概念</h3><ul>\n<li>Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式<ul>\n<li>DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可</li>\n<li>DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。</li>\n<li>DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。<br>如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。</li>\n<li>DraweeControllerBuilder<br>DraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改</li>\n<li>Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。</li>\n</ul>\n</li>\n<li>The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。<br>在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。<br>SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 </li>\n</ul>\n<h3 id=\"3-支持的URI类型\"><a href=\"#3-支持的URI类型\" class=\"headerlink\" title=\"3.支持的URI类型\"></a>3.支持的URI类型</h3><ul>\n<li>http|https</li>\n<li>file://</li>\n<li>content://</li>\n<li>asset://</li>\n<li>res://</li>\n<li>data:mime/type;base64 uri中指定图片数据</li>\n</ul>\n<h3 id=\"4-支持的xml属性\"><a href=\"#4-支持的xml属性\" class=\"headerlink\" title=\"4.支持的xml属性\"></a>4.支持的xml属性</h3><p><a href=\"https://www.fresco-cn.org/docs/using-drawees-xml.html\">支持的xml属性</a></p>\n<h3 id=\"5-在java中使用Drawees\"><a href=\"#5-在java中使用Drawees\" class=\"headerlink\" title=\"5.在java中使用Drawees\"></a>5.在java中使用Drawees</h3><h4 id=\"5-1-自定义DraweeHierarchy\"><a href=\"#5-1-自定义DraweeHierarchy\" class=\"headerlink\" title=\"5.1 自定义DraweeHierarchy\"></a>5.1 自定义DraweeHierarchy</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());</div><div class=\"line\">GenericDraweeHierarchy hierarchy = builder</div><div class=\"line\">        .setFadeDuration(300)</div><div class=\"line\">        //and so on</div><div class=\"line\">        .build();</div><div class=\"line\">image.setHierarchy(hierarchy);</div></pre></td></tr></table></figure>\n<p>从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>xml中对应的属性，由hierarchy控制。</p>\n<h4 id=\"5-2-运行时修改-DraweeHierarchy\"><a href=\"#5-2-运行时修改-DraweeHierarchy\" class=\"headerlink\" title=\"5.2 运行时修改 DraweeHierarchy\"></a>5.2 运行时修改 DraweeHierarchy</h4><p>要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchy hierarchy = image.getHierarchy();</div><div class=\"line\">hierarchy.setFadeDuration(400);</div></pre></td></tr></table></figure>\n<p>其他属性同理。</p>\n<h4 id=\"5-3-配置效果\"><a href=\"#5-3-配置效果\" class=\"headerlink\" title=\"5.3 配置效果\"></a>5.3 配置效果</h4><p>我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。</p>\n<p>在ControllerBuilder 中如下设置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setTapToRetryEnabled(true)</div></pre></td></tr></table></figure>\n<ul>\n<li>XML 中属性值: retryImage</li>\n<li>Hierarchy builder中的方法: setRetryImage</li>\n</ul>\n<h4 id=\"5-4-进度条\"><a href=\"#5-4-进度条\" class=\"headerlink\" title=\"5.4 进度条\"></a>5.4 进度条</h4><p>构建GenericDraweeHierarchy的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setProgressBarImage(new ProgressBarDrawable())</div></pre></td></tr></table></figure>\n<p>，我们也可以自定义，实现Drawable.onLevelChange。</p>\n<h3 id=\"6-DraweeController增加对图片的控制\"><a href=\"#6-DraweeController增加对图片的控制\" class=\"headerlink\" title=\"6 DraweeController增加对图片的控制\"></a>6 DraweeController增加对图片的控制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ControllerListener listener = new BaseControllerListener() &#123;...&#125;</div><div class=\"line\"></div><div class=\"line\">DraweeController controller = Fresco.newDraweeControllerBuilder()</div><div class=\"line\">    .setUri(uri)</div><div class=\"line\">    .setTapToRetryEnabled(true)</div><div class=\"line\">    .setOldController(mSimpleDraweeView.getController())</div><div class=\"line\">    .setControllerListener(listener)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">mSimpleDraweeView.setController(controller);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>使用渐进式jpeg图。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(&quot;xxx&quot;))</div><div class=\"line\">            //打开渐进 渲染</div><div class=\"line\">            .setProgressiveRenderingEnabled(true)</div><div class=\"line\">            .build();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>动画自动播放</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">draweeController.setAutoPlayAnimations(true)</div></pre></td></tr></table></figure>\n</li>\n<li><p>动画手动播放，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ControllerListener listener = new BaseControllerListener&lt;ImageInfo&gt;()&#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) &#123;</div><div class=\"line\">        super.onFinalImageSet(id, imageInfo, animatable);</div><div class=\"line\">        if (animatable != null)&#123;</div><div class=\"line\">            animatable.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">draweeController.setControllerListener(listener)</div></pre></td></tr></table></figure>\n</li>\n<li><p>后处理器Postprocessor 对图片进行后期处理</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Postprocessor redMeshPostprocessor = new BasePostprocessor() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public String getName() &#123;</div><div class=\"line\">    return &quot;redMeshPostprocessor&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void process(Bitmap bitmap) &#123;</div><div class=\"line\">    for (int x = 0; x &lt; bitmap.getWidth(); x+=2) &#123;</div><div class=\"line\">      for (int y = 0; y &lt; bitmap.getHeight(); y+=2) &#123;</div><div class=\"line\">        bitmap.setPixel(x, y, Color.RED);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)</div><div class=\"line\">    .setPostprocessor(redMeshPostprocessor)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"7-Image-Requests\"><a href=\"#7-Image-Requests\" class=\"headerlink\" title=\"7.Image Requests\"></a>7.Image Requests</h3><p>使用ImageRequestBuilder来做更多的事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri;</div><div class=\"line\"></div><div class=\"line\">ImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()</div><div class=\"line\">    .setBackgroundColor(Color.GREEN)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder</div><div class=\"line\">    .newBuilderWithSource(uri)</div><div class=\"line\">    .setImageDecodeOptions(decodeOptions)</div><div class=\"line\">    .setAutoRotateEnabled(true)</div><div class=\"line\">    .setLocalThumbnailPreviewsEnabled(true)</div><div class=\"line\">    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    </div><div class=\"line\">    .setProgressiveRenderingEnabled(false)</div><div class=\"line\">    .setResizeOptions(new ResizeOptions(width, height))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"8-Image-Pipeline\"><a href=\"#8-Image-Pipeline\" class=\"headerlink\" title=\"8.Image Pipeline\"></a>8.Image Pipeline</h3><p>Image pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)</div><div class=\"line\">    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)</div><div class=\"line\">    .setCacheKeyFactory(cacheKeyFactory)</div><div class=\"line\">    .setDownsampleEnabled(true)</div><div class=\"line\">    .setWebpSupportEnabled(true)</div><div class=\"line\">    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)</div><div class=\"line\">    .setExecutorSupplier(executorSupplier)</div><div class=\"line\">    .setImageCacheStatsTracker(imageCacheStatsTracker)</div><div class=\"line\">    .setMainDiskCacheConfig(mainDiskCacheConfig)</div><div class=\"line\">    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)</div><div class=\"line\">    .setNetworkFetchProducer(networkFetchProducer)</div><div class=\"line\">    .setPoolFactory(poolFactory)</div><div class=\"line\">    .setProgressiveJpegConfig(progressiveJpegConfig)</div><div class=\"line\">    .setRequestListeners(requestListeners)</div><div class=\"line\">    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)</div><div class=\"line\">    .build();</div><div class=\"line\">Fresco.initialize(context, config);</div></pre></td></tr></table></figure>\n<p>上面的可配置项会因为版本的不同有稍微的区别。</p>\n<h4 id=\"8-1-缓存\"><a href=\"#8-1-缓存\" class=\"headerlink\" title=\"8.1 缓存\"></a>8.1 缓存</h4><p>在fresco里面，</p>\n<ul>\n<li>bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上</li>\n<li>未解码图片的内存缓存</li>\n<li>磁盘缓存</li>\n</ul>\n<p>我们可以通过imagepipeline判断bitmap是否被缓存，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipeline imagePipeline = Fresco.getImagePipeline();</div><div class=\"line\">imagePipeline.isInBitmapMemoryCache(Uri.parse(&quot;&quot;));</div><div class=\"line\">imagePipeline.isInDiskCache(Uri.parse(&quot;xxx&quot;));</div></pre></td></tr></table></figure>\n<p>删除指定缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(&quot;xxx&quot;);</div><div class=\"line\">imagePipeline.evictFromCache(uri);</div><div class=\"line\">imagePipeline.evictFromDiskCache(uri);</div></pre></td></tr></table></figure>\n<p>使用imagepipeline可以对整个工程加入一些控制。更多用法<a href=\"https://www.fresco-cn.org/docs/using-image-pipeline.html\">文档</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"gradle的几点小技巧","date":"2017-03-14T14:15:12.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n最近入职新公司，也开发出来一些比较不错的小技巧，来分享给大家。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 如何在release包中去除一些debug包中的东西\n\n我们平常肯定有遇到过这种情况，就是我们一些帮助调试的三方框架，我们并不想打包到release包中，而一次次的删出代码、删依赖总是很麻烦，有没有简单点的办法呢。必须有。思路是这样的，创建一个debughelper，我们在打包的时候，分别针对release和debug包，做依赖以及文件排除、等工作。\n\n```\n--debug\n\t--DebugHelper.java\n--main\n--release\n\t--DebugHelper.java\n\n```\n\n\n其中，我们在debug目录下，放debug的一些代码，如\n\n```\n    public static void initLeakCanary(Application application){\n        if (LeakCanary.isInAnalyzerProcess(application)){\n            return;\n        }\n        LeakCanary.install(application);\n    }\n\n    public static OkHttpClient.Builder createOkHttpBuilder(){\n        return new OkHttpClient().newBuilder()\n                .addNetworkInterceptor(new HttpLoggingInterceptor()\n                        .setLevel(HttpLoggingInterceptor.Level.BODY))\n                .addNetworkInterceptor(new StethoInterceptor());\n    }\n```\n\nrelease目录下，放release的，当然，这下面是空的。\n\n```\n    public static void initStethoInterceptor(Application application){\n    }\n\n    public static void initLeakCanary(Application application){\n\n    }\n    public static OkHttpClient.Builder createOkHttpBuilder(){\n        return new OkHttpClient().newBuilder();\n    }\n```\n\n需要注意的是，debug目录、release目录都，文件的包名都要一样。\n最后，在gradle文件中配置。\n\n```\n            dependencies {\n                debugCompile \"com.facebook.stetho:stetho:${libraryVersion.stetho}\"\n                debugCompile \"com.facebook.stetho:stetho-okhttp3:${libraryVersion.stetho}\"\n                debugCompile \"com.facebook.stetho:stetho-js-rhino:${libraryVersion.stetho}\"\n            }\n            sourceSets{\n                sourceSets{\n                    main{\n                        java {\n                            srcDir 'src/main/java'\n                            exclude '**/DebugHelper.java'\n                            srcDir 'src/debug/java'\n                        }\n                    }\n                }\n            }\n            \n            sourceSets{\n                main{\n                    java.srcDirs = ['src/main/java','src/release/java']\n                }\n            }\n```\n\n这样就可以了。\n\n\n### 三方包的统一管理\n\n这里要说的不是在根gradle文件中，写ext的方法，而是另外一种。\n\n我们将这些写在一个properties文件中，然后在一个gradle脚本中读取。脚本内容如下:\n\n```\ndef libraryVersion = new Properties()\nlibraryVersion.load(new FileInputStream(rootProject.file(\"libversion.properties\")))\nproject.ext.set(\"libraryVersion\", libraryVersion)\n```\n然后在需要的地方。\n\n```\napply from:'../libmanager.gradle'\n\ncompile \"com.squareup.okhttp3:logging-interceptor:${libraryVersion.loggingInterceptor}\"\n```\n\n### 如何在debug版本，依赖一个debug的model\n\n首先，我们需要在module的gradle文件中，添加如下配置\n\n```\noid {\n    publishNonDefault true\n```\n\n在主App中的gradel中做如下配置：\n\n```\n    buildTypes {\n\n        debug {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            buildConfigField \"boolean\", \"IS_DEBUG\", \"true\"\n            dependencies {\n                debugCompile project(path:':base', configuration:'debug')\n            }\n        }\n\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            buildConfigField \"boolean\", \"IS_DEBUG\", \"false\"\n            dependencies {\n                releaseCompile project(path:':base', configuration:'release')\n            }\n        }\n    }\n```\n\n如上配置之后，我们就能在debug版本中依赖debug的module，而在release版本中依赖release的module了。\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/gradle的几点小技巧.md","raw":"---\ntitle: gradle的几点小技巧\ndate: 2017-03-14 22:15:12\ntags: gradle\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n最近入职新公司，也开发出来一些比较不错的小技巧，来分享给大家。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 如何在release包中去除一些debug包中的东西\n\n我们平常肯定有遇到过这种情况，就是我们一些帮助调试的三方框架，我们并不想打包到release包中，而一次次的删出代码、删依赖总是很麻烦，有没有简单点的办法呢。必须有。思路是这样的，创建一个debughelper，我们在打包的时候，分别针对release和debug包，做依赖以及文件排除、等工作。\n\n```\n--debug\n\t--DebugHelper.java\n--main\n--release\n\t--DebugHelper.java\n\n```\n\n\n其中，我们在debug目录下，放debug的一些代码，如\n\n```\n    public static void initLeakCanary(Application application){\n        if (LeakCanary.isInAnalyzerProcess(application)){\n            return;\n        }\n        LeakCanary.install(application);\n    }\n\n    public static OkHttpClient.Builder createOkHttpBuilder(){\n        return new OkHttpClient().newBuilder()\n                .addNetworkInterceptor(new HttpLoggingInterceptor()\n                        .setLevel(HttpLoggingInterceptor.Level.BODY))\n                .addNetworkInterceptor(new StethoInterceptor());\n    }\n```\n\nrelease目录下，放release的，当然，这下面是空的。\n\n```\n    public static void initStethoInterceptor(Application application){\n    }\n\n    public static void initLeakCanary(Application application){\n\n    }\n    public static OkHttpClient.Builder createOkHttpBuilder(){\n        return new OkHttpClient().newBuilder();\n    }\n```\n\n需要注意的是，debug目录、release目录都，文件的包名都要一样。\n最后，在gradle文件中配置。\n\n```\n            dependencies {\n                debugCompile \"com.facebook.stetho:stetho:${libraryVersion.stetho}\"\n                debugCompile \"com.facebook.stetho:stetho-okhttp3:${libraryVersion.stetho}\"\n                debugCompile \"com.facebook.stetho:stetho-js-rhino:${libraryVersion.stetho}\"\n            }\n            sourceSets{\n                sourceSets{\n                    main{\n                        java {\n                            srcDir 'src/main/java'\n                            exclude '**/DebugHelper.java'\n                            srcDir 'src/debug/java'\n                        }\n                    }\n                }\n            }\n            \n            sourceSets{\n                main{\n                    java.srcDirs = ['src/main/java','src/release/java']\n                }\n            }\n```\n\n这样就可以了。\n\n\n### 三方包的统一管理\n\n这里要说的不是在根gradle文件中，写ext的方法，而是另外一种。\n\n我们将这些写在一个properties文件中，然后在一个gradle脚本中读取。脚本内容如下:\n\n```\ndef libraryVersion = new Properties()\nlibraryVersion.load(new FileInputStream(rootProject.file(\"libversion.properties\")))\nproject.ext.set(\"libraryVersion\", libraryVersion)\n```\n然后在需要的地方。\n\n```\napply from:'../libmanager.gradle'\n\ncompile \"com.squareup.okhttp3:logging-interceptor:${libraryVersion.loggingInterceptor}\"\n```\n\n### 如何在debug版本，依赖一个debug的model\n\n首先，我们需要在module的gradle文件中，添加如下配置\n\n```\noid {\n    publishNonDefault true\n```\n\n在主App中的gradel中做如下配置：\n\n```\n    buildTypes {\n\n        debug {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            buildConfigField \"boolean\", \"IS_DEBUG\", \"true\"\n            dependencies {\n                debugCompile project(path:':base', configuration:'debug')\n            }\n        }\n\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            buildConfigField \"boolean\", \"IS_DEBUG\", \"false\"\n            dependencies {\n                releaseCompile project(path:':base', configuration:'release')\n            }\n        }\n    }\n```\n\n如上配置之后，我们就能在debug版本中依赖debug的module，而在release版本中依赖release的module了。\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"gradle的几点小技巧","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslz2003n19fy77l1v9j6","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近入职新公司，也开发出来一些比较不错的小技巧，来分享给大家。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"如何在release包中去除一些debug包中的东西\"><a href=\"#如何在release包中去除一些debug包中的东西\" class=\"headerlink\" title=\"如何在release包中去除一些debug包中的东西\"></a>如何在release包中去除一些debug包中的东西</h3><p>我们平常肯定有遇到过这种情况，就是我们一些帮助调试的三方框架，我们并不想打包到release包中，而一次次的删出代码、删依赖总是很麻烦，有没有简单点的办法呢。必须有。思路是这样的，创建一个debughelper，我们在打包的时候，分别针对release和debug包，做依赖以及文件排除、等工作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">--debug</div><div class=\"line\">\t--DebugHelper.java</div><div class=\"line\">--main</div><div class=\"line\">--release</div><div class=\"line\">\t--DebugHelper.java</div></pre></td></tr></table></figure>\n<p>其中，我们在debug目录下，放debug的一些代码，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void initLeakCanary(Application application)&#123;</div><div class=\"line\">    if (LeakCanary.isInAnalyzerProcess(application))&#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    LeakCanary.install(application);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public static OkHttpClient.Builder createOkHttpBuilder()&#123;</div><div class=\"line\">    return new OkHttpClient().newBuilder()</div><div class=\"line\">            .addNetworkInterceptor(new HttpLoggingInterceptor()</div><div class=\"line\">                    .setLevel(HttpLoggingInterceptor.Level.BODY))</div><div class=\"line\">            .addNetworkInterceptor(new StethoInterceptor());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>release目录下，放release的，当然，这下面是空的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void initStethoInterceptor(Application application)&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public static void initLeakCanary(Application application)&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">public static OkHttpClient.Builder createOkHttpBuilder()&#123;</div><div class=\"line\">    return new OkHttpClient().newBuilder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是，debug目录、release目录都，文件的包名都要一样。<br>最后，在gradle文件中配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    debugCompile &quot;com.facebook.stetho:stetho:$&#123;libraryVersion.stetho&#125;&quot;</div><div class=\"line\">    debugCompile &quot;com.facebook.stetho:stetho-okhttp3:$&#123;libraryVersion.stetho&#125;&quot;</div><div class=\"line\">    debugCompile &quot;com.facebook.stetho:stetho-js-rhino:$&#123;libraryVersion.stetho&#125;&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">sourceSets&#123;</div><div class=\"line\">    sourceSets&#123;</div><div class=\"line\">        main&#123;</div><div class=\"line\">            java &#123;</div><div class=\"line\">                srcDir &apos;src/main/java&apos;</div><div class=\"line\">                exclude &apos;**/DebugHelper.java&apos;</div><div class=\"line\">                srcDir &apos;src/debug/java&apos;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">sourceSets&#123;</div><div class=\"line\">    main&#123;</div><div class=\"line\">        java.srcDirs = [&apos;src/main/java&apos;,&apos;src/release/java&apos;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就可以了。</p>\n<h3 id=\"三方包的统一管理\"><a href=\"#三方包的统一管理\" class=\"headerlink\" title=\"三方包的统一管理\"></a>三方包的统一管理</h3><p>这里要说的不是在根gradle文件中，写ext的方法，而是另外一种。</p>\n<p>我们将这些写在一个properties文件中，然后在一个gradle脚本中读取。脚本内容如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">def libraryVersion = new Properties()</div><div class=\"line\">libraryVersion.load(new FileInputStream(rootProject.file(&quot;libversion.properties&quot;)))</div><div class=\"line\">project.ext.set(&quot;libraryVersion&quot;, libraryVersion)</div></pre></td></tr></table></figure>\n<p>然后在需要的地方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply from:&apos;../libmanager.gradle&apos;</div><div class=\"line\"></div><div class=\"line\">compile &quot;com.squareup.okhttp3:logging-interceptor:$&#123;libraryVersion.loggingInterceptor&#125;&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"如何在debug版本，依赖一个debug的model\"><a href=\"#如何在debug版本，依赖一个debug的model\" class=\"headerlink\" title=\"如何在debug版本，依赖一个debug的model\"></a>如何在debug版本，依赖一个debug的model</h3><p>首先，我们需要在module的gradle文件中，添加如下配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">oid &#123;</div><div class=\"line\">    publishNonDefault true</div></pre></td></tr></table></figure>\n<p>在主App中的gradel中做如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">buildTypes &#123;</div><div class=\"line\"></div><div class=\"line\">    debug &#123;</div><div class=\"line\">        minifyEnabled false</div><div class=\"line\">        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class=\"line\">        buildConfigField &quot;boolean&quot;, &quot;IS_DEBUG&quot;, &quot;true&quot;</div><div class=\"line\">        dependencies &#123;</div><div class=\"line\">            debugCompile project(path:&apos;:base&apos;, configuration:&apos;debug&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    release &#123;</div><div class=\"line\">        minifyEnabled false</div><div class=\"line\">        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class=\"line\">        buildConfigField &quot;boolean&quot;, &quot;IS_DEBUG&quot;, &quot;false&quot;</div><div class=\"line\">        dependencies &#123;</div><div class=\"line\">            releaseCompile project(path:&apos;:base&apos;, configuration:&apos;release&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上配置之后，我们就能在debug版本中依赖debug的module，而在release版本中依赖release的module了。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近入职新公司，也开发出来一些比较不错的小技巧，来分享给大家。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"如何在release包中去除一些debug包中的东西\"><a href=\"#如何在release包中去除一些debug包中的东西\" class=\"headerlink\" title=\"如何在release包中去除一些debug包中的东西\"></a>如何在release包中去除一些debug包中的东西</h3><p>我们平常肯定有遇到过这种情况，就是我们一些帮助调试的三方框架，我们并不想打包到release包中，而一次次的删出代码、删依赖总是很麻烦，有没有简单点的办法呢。必须有。思路是这样的，创建一个debughelper，我们在打包的时候，分别针对release和debug包，做依赖以及文件排除、等工作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">--debug</div><div class=\"line\">\t--DebugHelper.java</div><div class=\"line\">--main</div><div class=\"line\">--release</div><div class=\"line\">\t--DebugHelper.java</div></pre></td></tr></table></figure>\n<p>其中，我们在debug目录下，放debug的一些代码，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void initLeakCanary(Application application)&#123;</div><div class=\"line\">    if (LeakCanary.isInAnalyzerProcess(application))&#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    LeakCanary.install(application);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public static OkHttpClient.Builder createOkHttpBuilder()&#123;</div><div class=\"line\">    return new OkHttpClient().newBuilder()</div><div class=\"line\">            .addNetworkInterceptor(new HttpLoggingInterceptor()</div><div class=\"line\">                    .setLevel(HttpLoggingInterceptor.Level.BODY))</div><div class=\"line\">            .addNetworkInterceptor(new StethoInterceptor());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>release目录下，放release的，当然，这下面是空的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void initStethoInterceptor(Application application)&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public static void initLeakCanary(Application application)&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">public static OkHttpClient.Builder createOkHttpBuilder()&#123;</div><div class=\"line\">    return new OkHttpClient().newBuilder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是，debug目录、release目录都，文件的包名都要一样。<br>最后，在gradle文件中配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    debugCompile &quot;com.facebook.stetho:stetho:$&#123;libraryVersion.stetho&#125;&quot;</div><div class=\"line\">    debugCompile &quot;com.facebook.stetho:stetho-okhttp3:$&#123;libraryVersion.stetho&#125;&quot;</div><div class=\"line\">    debugCompile &quot;com.facebook.stetho:stetho-js-rhino:$&#123;libraryVersion.stetho&#125;&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">sourceSets&#123;</div><div class=\"line\">    sourceSets&#123;</div><div class=\"line\">        main&#123;</div><div class=\"line\">            java &#123;</div><div class=\"line\">                srcDir &apos;src/main/java&apos;</div><div class=\"line\">                exclude &apos;**/DebugHelper.java&apos;</div><div class=\"line\">                srcDir &apos;src/debug/java&apos;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">sourceSets&#123;</div><div class=\"line\">    main&#123;</div><div class=\"line\">        java.srcDirs = [&apos;src/main/java&apos;,&apos;src/release/java&apos;]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就可以了。</p>\n<h3 id=\"三方包的统一管理\"><a href=\"#三方包的统一管理\" class=\"headerlink\" title=\"三方包的统一管理\"></a>三方包的统一管理</h3><p>这里要说的不是在根gradle文件中，写ext的方法，而是另外一种。</p>\n<p>我们将这些写在一个properties文件中，然后在一个gradle脚本中读取。脚本内容如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">def libraryVersion = new Properties()</div><div class=\"line\">libraryVersion.load(new FileInputStream(rootProject.file(&quot;libversion.properties&quot;)))</div><div class=\"line\">project.ext.set(&quot;libraryVersion&quot;, libraryVersion)</div></pre></td></tr></table></figure>\n<p>然后在需要的地方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply from:&apos;../libmanager.gradle&apos;</div><div class=\"line\"></div><div class=\"line\">compile &quot;com.squareup.okhttp3:logging-interceptor:$&#123;libraryVersion.loggingInterceptor&#125;&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"如何在debug版本，依赖一个debug的model\"><a href=\"#如何在debug版本，依赖一个debug的model\" class=\"headerlink\" title=\"如何在debug版本，依赖一个debug的model\"></a>如何在debug版本，依赖一个debug的model</h3><p>首先，我们需要在module的gradle文件中，添加如下配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">oid &#123;</div><div class=\"line\">    publishNonDefault true</div></pre></td></tr></table></figure>\n<p>在主App中的gradel中做如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">buildTypes &#123;</div><div class=\"line\"></div><div class=\"line\">    debug &#123;</div><div class=\"line\">        minifyEnabled false</div><div class=\"line\">        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class=\"line\">        buildConfigField &quot;boolean&quot;, &quot;IS_DEBUG&quot;, &quot;true&quot;</div><div class=\"line\">        dependencies &#123;</div><div class=\"line\">            debugCompile project(path:&apos;:base&apos;, configuration:&apos;debug&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    release &#123;</div><div class=\"line\">        minifyEnabled false</div><div class=\"line\">        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class=\"line\">        buildConfigField &quot;boolean&quot;, &quot;IS_DEBUG&quot;, &quot;false&quot;</div><div class=\"line\">        dependencies &#123;</div><div class=\"line\">            releaseCompile project(path:&apos;:base&apos;, configuration:&apos;release&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上配置之后，我们就能在debug版本中依赖debug的module，而在release版本中依赖release的module了。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"layout":"使用hexo+githb","title":"pages搭建个人博客","date":"2016-11-29T03:49:42.000Z","_content":"<Excerpt in index | 首页摘要> \n### 搭建步骤\n\n1. 下载nodejs并安装\n2. 安装hexo npm install -g hexo-cli\n<!-- more -->\n<The rest of contents | 余下全文>\n3. 初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx\n4. 进入本地仓库，初始化hexo站点，hexo init\n5. 修改配置_config.yml，public_dir 为 ./\n6. 修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下\n7. 修改root目录下的_congig.yml文件，修改```theme: spfk``` 并且修改deploy 为 \n\t\n\t```\ndeploy:\n  type: git\n  repo: https://github.com/Guolei1130/Guolei1130.github.io.git\n  branch: master \n\t``` \n根据需求或者主题需要，修改其他相应的配置\n\n8. hexo generate 重新生成静态网页\n9. hexo new blogname，生成你的blog\n10. push到github,进行测试\n\n\n\n### 一些基本操作\n\n* hexo new blogname 生成blog\n* hexo generate(g)  重新生成静态页面\n* hexo server(s)  启动本地服务器\n\n### 关于博客中的图片\n\n个人建议放在_posts同级目录，规则按image/年/月/文章/来放\n\n### 关于删除文章\n\n直接删除_post下的即可\n\n\n\n### 多说\n\n大部分主题支持pv统计和多说，pv统计，大多数我们不需要改\n去http://duoshuo.com/create-site/注册，并修改theme中的配置\n\n```\nduoshuo: \n  on: true\n  domain: guolei1130\n  # 是否开启多说评论，http://duoshuo.com/create-site/\n  # 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\n  # http://<要填的部分>.duoshuo.com (domain只填上<>里的内容，不要填整个网址)\n```\n\n配置完push到github，就可在多说管理后台进行管理\n\n### 关于全文模式\n先在主题的配置文件中，添加\n```\nauto_excerpt:\nenable: false\nlength: 150\n```\n\n然后在文章的最前面加\n\n```\n<Excerpt in index | 首页摘要> \n```\n\n在文章最后增加 \n\n```\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n```\n\n### 关于图片资源问题\n\n有两种办法\n\n* 将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法\n* 找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/hexo+github pages搭建个人博客.md","raw":"layout: 使用hexo+githb\ntitle: pages搭建个人博客\ncategories: hexo\ndate: 2016-11-29 11:49:42\ntags: hexo\n\n---\n<Excerpt in index | 首页摘要> \n### 搭建步骤\n\n1. 下载nodejs并安装\n2. 安装hexo npm install -g hexo-cli\n<!-- more -->\n<The rest of contents | 余下全文>\n3. 初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx\n4. 进入本地仓库，初始化hexo站点，hexo init\n5. 修改配置_config.yml，public_dir 为 ./\n6. 修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下\n7. 修改root目录下的_congig.yml文件，修改```theme: spfk``` 并且修改deploy 为 \n\t\n\t```\ndeploy:\n  type: git\n  repo: https://github.com/Guolei1130/Guolei1130.github.io.git\n  branch: master \n\t``` \n根据需求或者主题需要，修改其他相应的配置\n\n8. hexo generate 重新生成静态网页\n9. hexo new blogname，生成你的blog\n10. push到github,进行测试\n\n\n\n### 一些基本操作\n\n* hexo new blogname 生成blog\n* hexo generate(g)  重新生成静态页面\n* hexo server(s)  启动本地服务器\n\n### 关于博客中的图片\n\n个人建议放在_posts同级目录，规则按image/年/月/文章/来放\n\n### 关于删除文章\n\n直接删除_post下的即可\n\n\n\n### 多说\n\n大部分主题支持pv统计和多说，pv统计，大多数我们不需要改\n去http://duoshuo.com/create-site/注册，并修改theme中的配置\n\n```\nduoshuo: \n  on: true\n  domain: guolei1130\n  # 是否开启多说评论，http://duoshuo.com/create-site/\n  # 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\n  # http://<要填的部分>.duoshuo.com (domain只填上<>里的内容，不要填整个网址)\n```\n\n配置完push到github，就可在多说管理后台进行管理\n\n### 关于全文模式\n先在主题的配置文件中，添加\n```\nauto_excerpt:\nenable: false\nlength: 150\n```\n\n然后在文章的最前面加\n\n```\n<Excerpt in index | 首页摘要> \n```\n\n在文章最后增加 \n\n```\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n```\n\n### 关于图片资源问题\n\n有两种办法\n\n* 将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法\n* 找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"hexo+github pages搭建个人博客","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"photos":[],"link":"","_id":"cjfrzslz4003r19fyu1ppvr1s","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"> </excerpt></p>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3><ol>\n<li>下载nodejs并安装</li>\n<li>安装hexo npm install -g hexo-cli<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\"></the></li>\n<li>初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx</li>\n<li>进入本地仓库，初始化hexo站点，hexo init</li>\n<li>修改配置_config.yml，public_dir 为 ./</li>\n<li>修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下</li>\n<li>修改root目录下的_congig.yml文件，修改<figure class=\"highlight plain\"><figcaption><span>spfk``` 并且修改deploy 为 </span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t</div></pre></td></tr></table></figure></li>\n</ol>\n<p>deploy:<br>  type: git<br>  repo: <a href=\"https://github.com/Guolei1130/Guolei1130.github.io.git\" target=\"_blank\" rel=\"external\">https://github.com/Guolei1130/Guolei1130.github.io.git</a><br>  branch: master<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据需求或者主题需要，修改其他相应的配置</div><div class=\"line\"></div><div class=\"line\">8. hexo generate 重新生成静态网页</div><div class=\"line\">9. hexo new blogname，生成你的blog</div><div class=\"line\">10. push到github,进行测试</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 一些基本操作</div><div class=\"line\"></div><div class=\"line\">* hexo new blogname 生成blog</div><div class=\"line\">* hexo generate(g)  重新生成静态页面</div><div class=\"line\">* hexo server(s)  启动本地服务器</div><div class=\"line\"></div><div class=\"line\">### 关于博客中的图片</div><div class=\"line\"></div><div class=\"line\">个人建议放在_posts同级目录，规则按image/年/月/文章/来放</div><div class=\"line\"></div><div class=\"line\">### 关于删除文章</div><div class=\"line\"></div><div class=\"line\">直接删除_post下的即可</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 多说</div><div class=\"line\"></div><div class=\"line\">大部分主题支持pv统计和多说，pv统计，大多数我们不需要改</div><div class=\"line\">去http://duoshuo.com/create-site/注册，并修改theme中的配置</div></pre></td></tr></table></figure></p>\n<p>duoshuo:<br>  on: true<br>  domain: guolei1130</p>\n<h1 id=\"是否开启多说评论，http-duoshuo-com-create-site\"><a href=\"#是否开启多说评论，http-duoshuo-com-create-site\" class=\"headerlink\" title=\"是否开启多说评论，http://duoshuo.com/create-site/\"></a>是否开启多说评论，<a href=\"http://duoshuo.com/create-site/\" target=\"_blank\" rel=\"external\">http://duoshuo.com/create-site/</a></h1><h1 id=\"使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\"><a href=\"#使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\" class=\"headerlink\" title=\"使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\"></a>使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分</h1><h1 id=\"http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\"><a href=\"#http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\" class=\"headerlink\" title=\"http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)\"></a>http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">配置完push到github，就可在多说管理后台进行管理</div><div class=\"line\"></div><div class=\"line\">### 关于全文模式</div><div class=\"line\">先在主题的配置文件中，添加</div></pre></td></tr></table></figure>\n<p>auto_excerpt:<br>enable: false<br>length: 150<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后在文章的最前面加</div></pre></td></tr></table></figure></p>\n<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在文章最后增加</div></pre></td></tr></table></figure></excerpt></p>\n<ul>\n<li><!-- more -->\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n</the></li>\n</ul>\n<p>```</p>\n<h3 id=\"关于图片资源问题\"><a href=\"#关于图片资源问题\" class=\"headerlink\" title=\"关于图片资源问题\"></a>关于图片资源问题</h3><p>有两种办法</p>\n<ul>\n<li>将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法</li>\n<li>找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","excerpt":"<p><Excerpt in index | 首页摘要> </p>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3><ol>\n<li>下载nodejs并安装</li>\n<li>安装hexo npm install -g hexo-cli","more":"<The rest of contents | 余下全文></li>\n<li>初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx</li>\n<li>进入本地仓库，初始化hexo站点，hexo init</li>\n<li>修改配置_config.yml，public_dir 为 ./</li>\n<li>修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下</li>\n<li>修改root目录下的_congig.yml文件，修改<figure class=\"highlight plain\"><figcaption><span>spfk``` 并且修改deploy 为 </span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t</div></pre></td></tr></table></figure></li>\n</ol>\n<p>deploy:<br>  type: git<br>  repo: <a href=\"https://github.com/Guolei1130/Guolei1130.github.io.git\">https://github.com/Guolei1130/Guolei1130.github.io.git</a><br>  branch: master<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据需求或者主题需要，修改其他相应的配置</div><div class=\"line\"></div><div class=\"line\">8. hexo generate 重新生成静态网页</div><div class=\"line\">9. hexo new blogname，生成你的blog</div><div class=\"line\">10. push到github,进行测试</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 一些基本操作</div><div class=\"line\"></div><div class=\"line\">* hexo new blogname 生成blog</div><div class=\"line\">* hexo generate(g)  重新生成静态页面</div><div class=\"line\">* hexo server(s)  启动本地服务器</div><div class=\"line\"></div><div class=\"line\">### 关于博客中的图片</div><div class=\"line\"></div><div class=\"line\">个人建议放在_posts同级目录，规则按image/年/月/文章/来放</div><div class=\"line\"></div><div class=\"line\">### 关于删除文章</div><div class=\"line\"></div><div class=\"line\">直接删除_post下的即可</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 多说</div><div class=\"line\"></div><div class=\"line\">大部分主题支持pv统计和多说，pv统计，大多数我们不需要改</div><div class=\"line\">去http://duoshuo.com/create-site/注册，并修改theme中的配置</div></pre></td></tr></table></figure></p>\n<p>duoshuo:<br>  on: true<br>  domain: guolei1130</p>\n<h1 id=\"是否开启多说评论，http-duoshuo-com-create-site\"><a href=\"#是否开启多说评论，http-duoshuo-com-create-site\" class=\"headerlink\" title=\"是否开启多说评论，http://duoshuo.com/create-site/\"></a>是否开启多说评论，<a href=\"http://duoshuo.com/create-site/\">http://duoshuo.com/create-site/</a></h1><h1 id=\"使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\"><a href=\"#使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\" class=\"headerlink\" title=\"使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\"></a>使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分</h1><h1 id=\"http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\"><a href=\"#http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\" class=\"headerlink\" title=\"http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)\"></a>http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">配置完push到github，就可在多说管理后台进行管理</div><div class=\"line\"></div><div class=\"line\">### 关于全文模式</div><div class=\"line\">先在主题的配置文件中，添加</div></pre></td></tr></table></figure>\n<p>auto_excerpt:<br>enable: false<br>length: 150<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后在文章的最前面加</div></pre></td></tr></table></figure></p>\n<p><Excerpt in index | 首页摘要><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在文章最后增加</div></pre></td></tr></table></figure></p>\n<ul>\n<li><!-- more -->\n<The rest of contents | 余下全文>\n\n</li>\n</ul>\n<p>```</p>\n<h3 id=\"关于图片资源问题\"><a href=\"#关于图片资源问题\" class=\"headerlink\" title=\"关于图片资源问题\"></a>关于图片资源问题</h3><p>有两种办法</p>\n<ul>\n<li>将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法</li>\n<li>找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"java内存区域","date":"2017-01-12T13:31:56.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n我决定停一段时间的framework，插播一些jvm的学习内容。首先，就是内存区域。学无止境，加油。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 运行时的数据区域\n\n根据jvm规范，java虚拟机所管理的内存区域包括图中的几个运行时数据区域，下面，来进行学习。\n\n![](/images/jvm/内存区域.png)\n\n#### 程序计数器\n\n* 线程私有\n\n>程序计数器(Program Counter Register)是一块较小的内存空间，可以看成是线程执行的字节码的行号指示器(执行到多少行字节码指令),在概念模型中，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来实现。\n\n>如果虚拟机执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native方法，这为空。\n\n#### Java虚拟机栈\n\n* 线程私有\n* 生命周期和线程相同\n* StackOverflowError\n* OutOfMemoryError\n\n>每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，就对应一个栈帧在虚拟机栈的入栈和出栈。\n\n局部变量表存放了编译时期的一些数据：\n\n* 8种基本数据类型，\n* 引用类型\n\t* 指向对象起点的引用指针\n\t* 代表对象的句柄或其他与此对象相关的地址\n\t* returnAddress类型(指向一条字节码指令的地址)\n\n>局部变量表所需要的空间在编译时完成分配，当进入一个方法时，这个方法说需要在帧中分配的空间时完全确定的，在方法运行时间不会修改局部变量表的大小。\n\n#### 本地方法栈\n\n>与虚拟机栈类似，只不过本地方法栈为虚拟机使用到的Native方法服务。\n\n#### Java堆\n\n* 大\n* 线程共享\n* OutOfMemoryError\n\n几乎所有的对象实例都在这里分配内存(包括数组)\n\n\n#### 方法区\n\n* 线程共享\n* OutOfMemoryError\n\n用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。\n\n##### 运行时常量池\n\n* OutOfMemoryError\n\n这是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n\n\n### 直接存储\n\n并不是运行时数据区的一部分，如使用nio。\n\n### hotspot虚拟机对象\n\n#### 对象的创建\n\n虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查是否经过了类加载，如果没有，则执行类加载过程。对象的大小在类加载完之后就确定了。\n\n解析来虚拟机为对象分配内存，(从java堆中划分),有两种分配方式:\n\n* 指针碰撞方式 内存是规整的，中间放着一个指示器，一边是分配了的，一边是空闲的，给对象分配内存的时候，只需要将指示器往空闲的一边移动对象大小的位置就好\n* 空闲列表方式 虚拟机维护着一个列表，列表纪录着哪块内存可用，分配内存时，在列表中找一个足够大的划分给对象，更新列表。\n\n\n这些分配方式，在并发的情况下并不是线程安全的。解决办法：\n\n* cas配合失败重试的方式保持原子性\n* 按线程分配在不同的空间中，每个线程在java堆预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)\n\n分配完毕之后，将分配到的内存空间初始化为0值(不包括对象头),如果使用了tlab，初始化过程将会提前到tlab分配时，\n\n接下来对对象进行必要的设置，如是哪个对象的实例、对象的hash值、对象的gc年龄代、这些存在对象头中。\n\n最后，进行对象的初始化。\n\n总结下，对象的创建过程如下：\n\n1. 碰到new指令\n2. 执行类加载过程(如果没加载过)\n3. 在java堆上分配内存\n4. 内存初始化为0值\n5. 设置对象头\n6. 进行对象初始化\n\n#### 对象的内存布局\n\n分为三块区域:\n\n* 对象头 Header\n\t* 对象自身的运行时数据 Mark World\n\t* 类型指针\n* 实例数据 Instance Data\n* 对齐填充 Padding\n\n![](http://img.blog.csdn.net/20160808174044369)\n\n##### Mark World\n \n存储了如hashcode、gc年龄代、锁状态标志、线程持有的锁，偏向线程id，偏向时间挫等\n\n##### 类型指针\n\n对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。但是，并不是所有的都有，如数组。\n\n##### 实例数据 \n\n对象正在存储的有效信息\n\n##### 对其填充\n\n起占位符的作用，保证对象的大小是8字节的整数倍。\n\n#### 对象的访问定位\n\n目前访问对象有两种方式：\n\n* 使用句柄\n* 直接指针\n\n##### 使用句柄\n\njava堆分配出一块区域当作句柄池，句柄中包含了对象实例数据与类型数据各自具体的地址信息。\n\n* 稳定，不需要根据对象移动而修改\n* 访问速度慢\n\n##### 直接地址\n\n存储的直接是对象地址。\n\n* 访问速度快\n\n\n### 参考资料\n\n* 深入理解java虚拟机\n\n \n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/java内存区域.md","raw":"---\ntitle: java内存区域\ndate: 2017-01-12 21:31:56\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n我决定停一段时间的framework，插播一些jvm的学习内容。首先，就是内存区域。学无止境，加油。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 运行时的数据区域\n\n根据jvm规范，java虚拟机所管理的内存区域包括图中的几个运行时数据区域，下面，来进行学习。\n\n![](/images/jvm/内存区域.png)\n\n#### 程序计数器\n\n* 线程私有\n\n>程序计数器(Program Counter Register)是一块较小的内存空间，可以看成是线程执行的字节码的行号指示器(执行到多少行字节码指令),在概念模型中，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来实现。\n\n>如果虚拟机执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native方法，这为空。\n\n#### Java虚拟机栈\n\n* 线程私有\n* 生命周期和线程相同\n* StackOverflowError\n* OutOfMemoryError\n\n>每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，就对应一个栈帧在虚拟机栈的入栈和出栈。\n\n局部变量表存放了编译时期的一些数据：\n\n* 8种基本数据类型，\n* 引用类型\n\t* 指向对象起点的引用指针\n\t* 代表对象的句柄或其他与此对象相关的地址\n\t* returnAddress类型(指向一条字节码指令的地址)\n\n>局部变量表所需要的空间在编译时完成分配，当进入一个方法时，这个方法说需要在帧中分配的空间时完全确定的，在方法运行时间不会修改局部变量表的大小。\n\n#### 本地方法栈\n\n>与虚拟机栈类似，只不过本地方法栈为虚拟机使用到的Native方法服务。\n\n#### Java堆\n\n* 大\n* 线程共享\n* OutOfMemoryError\n\n几乎所有的对象实例都在这里分配内存(包括数组)\n\n\n#### 方法区\n\n* 线程共享\n* OutOfMemoryError\n\n用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。\n\n##### 运行时常量池\n\n* OutOfMemoryError\n\n这是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n\n\n### 直接存储\n\n并不是运行时数据区的一部分，如使用nio。\n\n### hotspot虚拟机对象\n\n#### 对象的创建\n\n虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查是否经过了类加载，如果没有，则执行类加载过程。对象的大小在类加载完之后就确定了。\n\n解析来虚拟机为对象分配内存，(从java堆中划分),有两种分配方式:\n\n* 指针碰撞方式 内存是规整的，中间放着一个指示器，一边是分配了的，一边是空闲的，给对象分配内存的时候，只需要将指示器往空闲的一边移动对象大小的位置就好\n* 空闲列表方式 虚拟机维护着一个列表，列表纪录着哪块内存可用，分配内存时，在列表中找一个足够大的划分给对象，更新列表。\n\n\n这些分配方式，在并发的情况下并不是线程安全的。解决办法：\n\n* cas配合失败重试的方式保持原子性\n* 按线程分配在不同的空间中，每个线程在java堆预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)\n\n分配完毕之后，将分配到的内存空间初始化为0值(不包括对象头),如果使用了tlab，初始化过程将会提前到tlab分配时，\n\n接下来对对象进行必要的设置，如是哪个对象的实例、对象的hash值、对象的gc年龄代、这些存在对象头中。\n\n最后，进行对象的初始化。\n\n总结下，对象的创建过程如下：\n\n1. 碰到new指令\n2. 执行类加载过程(如果没加载过)\n3. 在java堆上分配内存\n4. 内存初始化为0值\n5. 设置对象头\n6. 进行对象初始化\n\n#### 对象的内存布局\n\n分为三块区域:\n\n* 对象头 Header\n\t* 对象自身的运行时数据 Mark World\n\t* 类型指针\n* 实例数据 Instance Data\n* 对齐填充 Padding\n\n![](http://img.blog.csdn.net/20160808174044369)\n\n##### Mark World\n \n存储了如hashcode、gc年龄代、锁状态标志、线程持有的锁，偏向线程id，偏向时间挫等\n\n##### 类型指针\n\n对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。但是，并不是所有的都有，如数组。\n\n##### 实例数据 \n\n对象正在存储的有效信息\n\n##### 对其填充\n\n起占位符的作用，保证对象的大小是8字节的整数倍。\n\n#### 对象的访问定位\n\n目前访问对象有两种方式：\n\n* 使用句柄\n* 直接指针\n\n##### 使用句柄\n\njava堆分配出一块区域当作句柄池，句柄中包含了对象实例数据与类型数据各自具体的地址信息。\n\n* 稳定，不需要根据对象移动而修改\n* 访问速度慢\n\n##### 直接地址\n\n存储的直接是对象地址。\n\n* 访问速度快\n\n\n### 参考资料\n\n* 深入理解java虚拟机\n\n \n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"java内存区域","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslz5003u19fypit0nxtj","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>我决定停一段时间的framework，插播一些jvm的学习内容。首先，就是内存区域。学无止境，加油。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"运行时的数据区域\"><a href=\"#运行时的数据区域\" class=\"headerlink\" title=\"运行时的数据区域\"></a>运行时的数据区域</h3><p>根据jvm规范，java虚拟机所管理的内存区域包括图中的几个运行时数据区域，下面，来进行学习。</p>\n<p><img src=\"/images/jvm/内存区域.png\" alt=\"\"></p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><ul>\n<li>线程私有</li>\n</ul>\n<blockquote>\n<p>程序计数器(Program Counter Register)是一块较小的内存空间，可以看成是线程执行的字节码的行号指示器(执行到多少行字节码指令),在概念模型中，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来实现。</p>\n<p>如果虚拟机执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native方法，这为空。</p>\n</blockquote>\n<h4 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h4><ul>\n<li>线程私有</li>\n<li>生命周期和线程相同</li>\n<li>StackOverflowError</li>\n<li>OutOfMemoryError</li>\n</ul>\n<blockquote>\n<p>每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，就对应一个栈帧在虚拟机栈的入栈和出栈。</p>\n</blockquote>\n<p>局部变量表存放了编译时期的一些数据：</p>\n<ul>\n<li>8种基本数据类型，</li>\n<li>引用类型<ul>\n<li>指向对象起点的引用指针</li>\n<li>代表对象的句柄或其他与此对象相关的地址</li>\n<li>returnAddress类型(指向一条字节码指令的地址)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>局部变量表所需要的空间在编译时完成分配，当进入一个方法时，这个方法说需要在帧中分配的空间时完全确定的，在方法运行时间不会修改局部变量表的大小。</p>\n</blockquote>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><blockquote>\n<p>与虚拟机栈类似，只不过本地方法栈为虚拟机使用到的Native方法服务。</p>\n</blockquote>\n<h4 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h4><ul>\n<li>大</li>\n<li>线程共享</li>\n<li>OutOfMemoryError</li>\n</ul>\n<p>几乎所有的对象实例都在这里分配内存(包括数组)</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><ul>\n<li>线程共享</li>\n<li>OutOfMemoryError</li>\n</ul>\n<p>用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。</p>\n<h5 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h5><ul>\n<li>OutOfMemoryError</li>\n</ul>\n<p>这是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>\n<h3 id=\"直接存储\"><a href=\"#直接存储\" class=\"headerlink\" title=\"直接存储\"></a>直接存储</h3><p>并不是运行时数据区的一部分，如使用nio。</p>\n<h3 id=\"hotspot虚拟机对象\"><a href=\"#hotspot虚拟机对象\" class=\"headerlink\" title=\"hotspot虚拟机对象\"></a>hotspot虚拟机对象</h3><h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查是否经过了类加载，如果没有，则执行类加载过程。对象的大小在类加载完之后就确定了。</p>\n<p>解析来虚拟机为对象分配内存，(从java堆中划分),有两种分配方式:</p>\n<ul>\n<li>指针碰撞方式 内存是规整的，中间放着一个指示器，一边是分配了的，一边是空闲的，给对象分配内存的时候，只需要将指示器往空闲的一边移动对象大小的位置就好</li>\n<li>空闲列表方式 虚拟机维护着一个列表，列表纪录着哪块内存可用，分配内存时，在列表中找一个足够大的划分给对象，更新列表。</li>\n</ul>\n<p>这些分配方式，在并发的情况下并不是线程安全的。解决办法：</p>\n<ul>\n<li>cas配合失败重试的方式保持原子性</li>\n<li>按线程分配在不同的空间中，每个线程在java堆预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</li>\n</ul>\n<p>分配完毕之后，将分配到的内存空间初始化为0值(不包括对象头),如果使用了tlab，初始化过程将会提前到tlab分配时，</p>\n<p>接下来对对象进行必要的设置，如是哪个对象的实例、对象的hash值、对象的gc年龄代、这些存在对象头中。</p>\n<p>最后，进行对象的初始化。</p>\n<p>总结下，对象的创建过程如下：</p>\n<ol>\n<li>碰到new指令</li>\n<li>执行类加载过程(如果没加载过)</li>\n<li>在java堆上分配内存</li>\n<li>内存初始化为0值</li>\n<li>设置对象头</li>\n<li>进行对象初始化</li>\n</ol>\n<h4 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h4><p>分为三块区域:</p>\n<ul>\n<li>对象头 Header<ul>\n<li>对象自身的运行时数据 Mark World</li>\n<li>类型指针</li>\n</ul>\n</li>\n<li>实例数据 Instance Data</li>\n<li>对齐填充 Padding</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20160808174044369\" alt=\"\"></p>\n<h5 id=\"Mark-World\"><a href=\"#Mark-World\" class=\"headerlink\" title=\"Mark World\"></a>Mark World</h5><p>存储了如hashcode、gc年龄代、锁状态标志、线程持有的锁，偏向线程id，偏向时间挫等</p>\n<h5 id=\"类型指针\"><a href=\"#类型指针\" class=\"headerlink\" title=\"类型指针\"></a>类型指针</h5><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。但是，并不是所有的都有，如数组。</p>\n<h5 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h5><p>对象正在存储的有效信息</p>\n<h5 id=\"对其填充\"><a href=\"#对其填充\" class=\"headerlink\" title=\"对其填充\"></a>对其填充</h5><p>起占位符的作用，保证对象的大小是8字节的整数倍。</p>\n<h4 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h4><p>目前访问对象有两种方式：</p>\n<ul>\n<li>使用句柄</li>\n<li>直接指针</li>\n</ul>\n<h5 id=\"使用句柄\"><a href=\"#使用句柄\" class=\"headerlink\" title=\"使用句柄\"></a>使用句柄</h5><p>java堆分配出一块区域当作句柄池，句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p>\n<ul>\n<li>稳定，不需要根据对象移动而修改</li>\n<li>访问速度慢</li>\n</ul>\n<h5 id=\"直接地址\"><a href=\"#直接地址\" class=\"headerlink\" title=\"直接地址\"></a>直接地址</h5><p>存储的直接是对象地址。</p>\n<ul>\n<li>访问速度快</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>深入理解java虚拟机</li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>我决定停一段时间的framework，插播一些jvm的学习内容。首先，就是内存区域。学无止境，加油。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"运行时的数据区域\"><a href=\"#运行时的数据区域\" class=\"headerlink\" title=\"运行时的数据区域\"></a>运行时的数据区域</h3><p>根据jvm规范，java虚拟机所管理的内存区域包括图中的几个运行时数据区域，下面，来进行学习。</p>\n<p><img src=\"/images/jvm/内存区域.png\" alt=\"\"></p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><ul>\n<li>线程私有</li>\n</ul>\n<blockquote>\n<p>程序计数器(Program Counter Register)是一块较小的内存空间，可以看成是线程执行的字节码的行号指示器(执行到多少行字节码指令),在概念模型中，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来实现。</p>\n<p>如果虚拟机执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native方法，这为空。</p>\n</blockquote>\n<h4 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h4><ul>\n<li>线程私有</li>\n<li>生命周期和线程相同</li>\n<li>StackOverflowError</li>\n<li>OutOfMemoryError</li>\n</ul>\n<blockquote>\n<p>每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，就对应一个栈帧在虚拟机栈的入栈和出栈。</p>\n</blockquote>\n<p>局部变量表存放了编译时期的一些数据：</p>\n<ul>\n<li>8种基本数据类型，</li>\n<li>引用类型<ul>\n<li>指向对象起点的引用指针</li>\n<li>代表对象的句柄或其他与此对象相关的地址</li>\n<li>returnAddress类型(指向一条字节码指令的地址)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>局部变量表所需要的空间在编译时完成分配，当进入一个方法时，这个方法说需要在帧中分配的空间时完全确定的，在方法运行时间不会修改局部变量表的大小。</p>\n</blockquote>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><blockquote>\n<p>与虚拟机栈类似，只不过本地方法栈为虚拟机使用到的Native方法服务。</p>\n</blockquote>\n<h4 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h4><ul>\n<li>大</li>\n<li>线程共享</li>\n<li>OutOfMemoryError</li>\n</ul>\n<p>几乎所有的对象实例都在这里分配内存(包括数组)</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><ul>\n<li>线程共享</li>\n<li>OutOfMemoryError</li>\n</ul>\n<p>用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。</p>\n<h5 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h5><ul>\n<li>OutOfMemoryError</li>\n</ul>\n<p>这是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>\n<h3 id=\"直接存储\"><a href=\"#直接存储\" class=\"headerlink\" title=\"直接存储\"></a>直接存储</h3><p>并不是运行时数据区的一部分，如使用nio。</p>\n<h3 id=\"hotspot虚拟机对象\"><a href=\"#hotspot虚拟机对象\" class=\"headerlink\" title=\"hotspot虚拟机对象\"></a>hotspot虚拟机对象</h3><h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查是否经过了类加载，如果没有，则执行类加载过程。对象的大小在类加载完之后就确定了。</p>\n<p>解析来虚拟机为对象分配内存，(从java堆中划分),有两种分配方式:</p>\n<ul>\n<li>指针碰撞方式 内存是规整的，中间放着一个指示器，一边是分配了的，一边是空闲的，给对象分配内存的时候，只需要将指示器往空闲的一边移动对象大小的位置就好</li>\n<li>空闲列表方式 虚拟机维护着一个列表，列表纪录着哪块内存可用，分配内存时，在列表中找一个足够大的划分给对象，更新列表。</li>\n</ul>\n<p>这些分配方式，在并发的情况下并不是线程安全的。解决办法：</p>\n<ul>\n<li>cas配合失败重试的方式保持原子性</li>\n<li>按线程分配在不同的空间中，每个线程在java堆预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</li>\n</ul>\n<p>分配完毕之后，将分配到的内存空间初始化为0值(不包括对象头),如果使用了tlab，初始化过程将会提前到tlab分配时，</p>\n<p>接下来对对象进行必要的设置，如是哪个对象的实例、对象的hash值、对象的gc年龄代、这些存在对象头中。</p>\n<p>最后，进行对象的初始化。</p>\n<p>总结下，对象的创建过程如下：</p>\n<ol>\n<li>碰到new指令</li>\n<li>执行类加载过程(如果没加载过)</li>\n<li>在java堆上分配内存</li>\n<li>内存初始化为0值</li>\n<li>设置对象头</li>\n<li>进行对象初始化</li>\n</ol>\n<h4 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h4><p>分为三块区域:</p>\n<ul>\n<li>对象头 Header<ul>\n<li>对象自身的运行时数据 Mark World</li>\n<li>类型指针</li>\n</ul>\n</li>\n<li>实例数据 Instance Data</li>\n<li>对齐填充 Padding</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20160808174044369\" alt=\"\"></p>\n<h5 id=\"Mark-World\"><a href=\"#Mark-World\" class=\"headerlink\" title=\"Mark World\"></a>Mark World</h5><p>存储了如hashcode、gc年龄代、锁状态标志、线程持有的锁，偏向线程id，偏向时间挫等</p>\n<h5 id=\"类型指针\"><a href=\"#类型指针\" class=\"headerlink\" title=\"类型指针\"></a>类型指针</h5><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。但是，并不是所有的都有，如数组。</p>\n<h5 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h5><p>对象正在存储的有效信息</p>\n<h5 id=\"对其填充\"><a href=\"#对其填充\" class=\"headerlink\" title=\"对其填充\"></a>对其填充</h5><p>起占位符的作用，保证对象的大小是8字节的整数倍。</p>\n<h4 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h4><p>目前访问对象有两种方式：</p>\n<ul>\n<li>使用句柄</li>\n<li>直接指针</li>\n</ul>\n<h5 id=\"使用句柄\"><a href=\"#使用句柄\" class=\"headerlink\" title=\"使用句柄\"></a>使用句柄</h5><p>java堆分配出一块区域当作句柄池，句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p>\n<ul>\n<li>稳定，不需要根据对象移动而修改</li>\n<li>访问速度慢</li>\n</ul>\n<h5 id=\"直接地址\"><a href=\"#直接地址\" class=\"headerlink\" title=\"直接地址\"></a>直接地址</h5><p>存储的直接是对象地址。</p>\n<ul>\n<li>访问速度快</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>深入理解java虚拟机</li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"jvm垃圾回收","date":"2017-01-14T12:00:28.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\njava与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。\n\n### 如何判断对象已死\n\n#### 引用计数\n\n首先说明，jvm中并没有选择引用计数。\n\n给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。\n\n#### 可达性分析算法\n\n通过一系列\"GC Roots\"的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。\n\n![](http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n在java中，GC Roots对象包括以下几种:\n\n* 虚拟机栈(帧栈中的本地变量表)中的应用对象\n* 方法区中类静态属性引用的对象(static)\n* 方法区中常量引用的对象\n* 本地方法栈中(一般说的native方法)引用的对象\n\n#### 自我救赎\n\n在可达性分析中被标记不可达的对象，也不是非死不可。\n\n要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。\n\n#### 回收方法区\n\n方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。\n\n废弃常量-没有对象引用的话，就会被移除常量池，进行回收\n无用的类，类加载容易，卸载难，满足卸载的条件如下：\n\n* 该类的所有实例都被回收\n* 加载该类的ClassLoader被回收\n* 对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法\n\n### 垃圾回收算法\n\n#### 标记－清理算法\n\n![](http://images.cnitblog.com/i/288799/201406/181024382398115.jpg)\n\n首先标记出需要回收的对象，然后清理掉需要回收的对象。\n\n缺点：\n\n* 标记和回收的过程效率都不高\n* 会产生内存碎片\n\n#### 复制算法\n\n![](http://images.cnitblog.com/i/288799/201406/181041528488728.jpg)\n\n将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。\n\nhotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。\n\n但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)\n\n在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。\n\n#### 标记－整体算法\n\n![](http://images.cnitblog.com/i/288799/201406/181100129575916.jpg)\n\n先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。\n\n#### 分代算法\n\n将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。\n\n#### 总结\n\n新生代适合复制算法。老生代适合标记－清理、标记－整体之类。\n\n\n### HotSpot的算法实现\n\n* 枚举根节点,这个时候需要停止所有的执行线程(Stop The World)\n* 安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停\n* 安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc\n\n### 垃圾收集器\n\n![](http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg)\n\n####  Serial(old)收集器\n\n串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。\n\n![](http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg)\n\n图为Serial和Serial Old结合使用的图。\n\n#### ParNew收集器\n\n是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：\n\n![](http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg)\n\n\nParNew收集器在cpu核数多的情况下才有优势。\n\n#### Parallel Scavenge收集器\n\n目标：吞吐量\n\n参数：\n\n* -XX:MaxGCPauseMillis 控制最大停顿时间\n* -XX:GCTimeRatio 直接设置吞吐量大小\n\n#### Parallel Old\n\nParallel的老生代版本，使用多线程和标记－整理算法。\n\n#### CMS收集器\n\nCMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。\n\n过程：\n\n* 初始标记 cms initial mark\n* 并发标记 cms concurrent mark\n* 重新标记 cms remark\n* 并发清除 cms concurrent sweep\n\n![](http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg)\n\n缺点：\n\n* 对cpu资源敏感\n* 无法处理浮动垃圾\n* 大量碎片\n\n#### G1收集器\n\nG1(garbage first)，面向服务端的垃圾收集器。具备以下特点：\n\n* 并行与并发\n* 分代收集\n* 空间整合\n* 可预测停顿\n\ng1收集器的运作大致可划分为以下几个步骤:\n\n* 初始标记 initial marking\n* 并发标记 concurrent marking\n* 最终标记 final marking\n* 筛选会后 live data counting and evacuation\n\n\n\n\n\n### 内存分配策略\n\n* 对象优先在Eden分配(新生代)\n* 大对象直接进入老年代\n* 长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代\n* 动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代\n* 空间分配担保,在这里需要先介绍两个名词\n\t* Minor GC 新生代gc\n\t* Major GC 老生代gc\n\t* 在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。\n\t\n### 总结\n\n许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/jvm垃圾回收.md","raw":"---\ntitle: jvm垃圾回收\ndate: 2017-01-14 20:00:28\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\njava与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。\n\n### 如何判断对象已死\n\n#### 引用计数\n\n首先说明，jvm中并没有选择引用计数。\n\n给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。\n\n#### 可达性分析算法\n\n通过一系列\"GC Roots\"的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。\n\n![](http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n在java中，GC Roots对象包括以下几种:\n\n* 虚拟机栈(帧栈中的本地变量表)中的应用对象\n* 方法区中类静态属性引用的对象(static)\n* 方法区中常量引用的对象\n* 本地方法栈中(一般说的native方法)引用的对象\n\n#### 自我救赎\n\n在可达性分析中被标记不可达的对象，也不是非死不可。\n\n要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。\n\n#### 回收方法区\n\n方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。\n\n废弃常量-没有对象引用的话，就会被移除常量池，进行回收\n无用的类，类加载容易，卸载难，满足卸载的条件如下：\n\n* 该类的所有实例都被回收\n* 加载该类的ClassLoader被回收\n* 对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法\n\n### 垃圾回收算法\n\n#### 标记－清理算法\n\n![](http://images.cnitblog.com/i/288799/201406/181024382398115.jpg)\n\n首先标记出需要回收的对象，然后清理掉需要回收的对象。\n\n缺点：\n\n* 标记和回收的过程效率都不高\n* 会产生内存碎片\n\n#### 复制算法\n\n![](http://images.cnitblog.com/i/288799/201406/181041528488728.jpg)\n\n将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。\n\nhotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。\n\n但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)\n\n在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。\n\n#### 标记－整体算法\n\n![](http://images.cnitblog.com/i/288799/201406/181100129575916.jpg)\n\n先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。\n\n#### 分代算法\n\n将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。\n\n#### 总结\n\n新生代适合复制算法。老生代适合标记－清理、标记－整体之类。\n\n\n### HotSpot的算法实现\n\n* 枚举根节点,这个时候需要停止所有的执行线程(Stop The World)\n* 安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停\n* 安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc\n\n### 垃圾收集器\n\n![](http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg)\n\n####  Serial(old)收集器\n\n串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。\n\n![](http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg)\n\n图为Serial和Serial Old结合使用的图。\n\n#### ParNew收集器\n\n是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：\n\n![](http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg)\n\n\nParNew收集器在cpu核数多的情况下才有优势。\n\n#### Parallel Scavenge收集器\n\n目标：吞吐量\n\n参数：\n\n* -XX:MaxGCPauseMillis 控制最大停顿时间\n* -XX:GCTimeRatio 直接设置吞吐量大小\n\n#### Parallel Old\n\nParallel的老生代版本，使用多线程和标记－整理算法。\n\n#### CMS收集器\n\nCMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。\n\n过程：\n\n* 初始标记 cms initial mark\n* 并发标记 cms concurrent mark\n* 重新标记 cms remark\n* 并发清除 cms concurrent sweep\n\n![](http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg)\n\n缺点：\n\n* 对cpu资源敏感\n* 无法处理浮动垃圾\n* 大量碎片\n\n#### G1收集器\n\nG1(garbage first)，面向服务端的垃圾收集器。具备以下特点：\n\n* 并行与并发\n* 分代收集\n* 空间整合\n* 可预测停顿\n\ng1收集器的运作大致可划分为以下几个步骤:\n\n* 初始标记 initial marking\n* 并发标记 concurrent marking\n* 最终标记 final marking\n* 筛选会后 live data counting and evacuation\n\n\n\n\n\n### 内存分配策略\n\n* 对象优先在Eden分配(新生代)\n* 大对象直接进入老年代\n* 长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代\n* 动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代\n* 空间分配担保,在这里需要先介绍两个名词\n\t* Minor GC 新生代gc\n\t* Major GC 老生代gc\n\t* 在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。\n\t\n### 总结\n\n许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"jvm垃圾回收","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslz6003w19fylpbrj8zp","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p>java与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。</p>\n<h3 id=\"如何判断对象已死\"><a href=\"#如何判断对象已死\" class=\"headerlink\" title=\"如何判断对象已死\"></a>如何判断对象已死</h3><h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>首先说明，jvm中并没有选择引用计数。</p>\n<p>给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。</p>\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>通过一系列”GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。</p>\n<p><img src=\"http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>在java中，GC Roots对象包括以下几种:</p>\n<ul>\n<li>虚拟机栈(帧栈中的本地变量表)中的应用对象</li>\n<li>方法区中类静态属性引用的对象(static)</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中(一般说的native方法)引用的对象</li>\n</ul>\n<h4 id=\"自我救赎\"><a href=\"#自我救赎\" class=\"headerlink\" title=\"自我救赎\"></a>自我救赎</h4><p>在可达性分析中被标记不可达的对象，也不是非死不可。</p>\n<p>要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。</p>\n<h4 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h4><p>方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。</p>\n<p>废弃常量-没有对象引用的话，就会被移除常量池，进行回收<br>无用的类，类加载容易，卸载难，满足卸载的条件如下：</p>\n<ul>\n<li>该类的所有实例都被回收</li>\n<li>加载该类的ClassLoader被回收</li>\n<li>对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><h4 id=\"标记－清理算法\"><a href=\"#标记－清理算法\" class=\"headerlink\" title=\"标记－清理算法\"></a>标记－清理算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181024382398115.jpg\" alt=\"\"></p>\n<p>首先标记出需要回收的对象，然后清理掉需要回收的对象。</p>\n<p>缺点：</p>\n<ul>\n<li>标记和回收的过程效率都不高</li>\n<li>会产生内存碎片</li>\n</ul>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181041528488728.jpg\" alt=\"\"></p>\n<p>将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。</p>\n<p>hotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。</p>\n<p>但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)</p>\n<p>在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。</p>\n<h4 id=\"标记－整体算法\"><a href=\"#标记－整体算法\" class=\"headerlink\" title=\"标记－整体算法\"></a>标记－整体算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181100129575916.jpg\" alt=\"\"></p>\n<p>先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。</p>\n<h4 id=\"分代算法\"><a href=\"#分代算法\" class=\"headerlink\" title=\"分代算法\"></a>分代算法</h4><p>将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>新生代适合复制算法。老生代适合标记－清理、标记－整体之类。</p>\n<h3 id=\"HotSpot的算法实现\"><a href=\"#HotSpot的算法实现\" class=\"headerlink\" title=\"HotSpot的算法实现\"></a>HotSpot的算法实现</h3><ul>\n<li>枚举根节点,这个时候需要停止所有的执行线程(Stop The World)</li>\n<li>安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停</li>\n<li>安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src=\"http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg\" alt=\"\"></p>\n<h4 id=\"Serial-old-收集器\"><a href=\"#Serial-old-收集器\" class=\"headerlink\" title=\"Serial(old)收集器\"></a>Serial(old)收集器</h4><p>串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。</p>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg\" alt=\"\"></p>\n<p>图为Serial和Serial Old结合使用的图。</p>\n<h4 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h4><p>是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：</p>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg\" alt=\"\"></p>\n<p>ParNew收集器在cpu核数多的情况下才有优势。</p>\n<h4 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h4><p>目标：吞吐量</p>\n<p>参数：</p>\n<ul>\n<li>-XX:MaxGCPauseMillis 控制最大停顿时间</li>\n<li>-XX:GCTimeRatio 直接设置吞吐量大小</li>\n</ul>\n<h4 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h4><p>Parallel的老生代版本，使用多线程和标记－整理算法。</p>\n<h4 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h4><p>CMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。</p>\n<p>过程：</p>\n<ul>\n<li>初始标记 cms initial mark</li>\n<li>并发标记 cms concurrent mark</li>\n<li>重新标记 cms remark</li>\n<li>并发清除 cms concurrent sweep</li>\n</ul>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg\" alt=\"\"></p>\n<p>缺点：</p>\n<ul>\n<li>对cpu资源敏感</li>\n<li>无法处理浮动垃圾</li>\n<li>大量碎片</li>\n</ul>\n<h4 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h4><p>G1(garbage first)，面向服务端的垃圾收集器。具备以下特点：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测停顿</li>\n</ul>\n<p>g1收集器的运作大致可划分为以下几个步骤:</p>\n<ul>\n<li>初始标记 initial marking</li>\n<li>并发标记 concurrent marking</li>\n<li>最终标记 final marking</li>\n<li>筛选会后 live data counting and evacuation</li>\n</ul>\n<h3 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h3><ul>\n<li>对象优先在Eden分配(新生代)</li>\n<li>大对象直接进入老年代</li>\n<li>长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代</li>\n<li>动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代</li>\n<li>空间分配担保,在这里需要先介绍两个名词<ul>\n<li>Minor GC 新生代gc</li>\n<li>Major GC 老生代gc</li>\n<li>在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。</p>","more":"<The rest of contents | 余下全文>\n\n\n<p>java与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。</p>\n<h3 id=\"如何判断对象已死\"><a href=\"#如何判断对象已死\" class=\"headerlink\" title=\"如何判断对象已死\"></a>如何判断对象已死</h3><h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>首先说明，jvm中并没有选择引用计数。</p>\n<p>给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。</p>\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>通过一系列”GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。</p>\n<p><img src=\"http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>在java中，GC Roots对象包括以下几种:</p>\n<ul>\n<li>虚拟机栈(帧栈中的本地变量表)中的应用对象</li>\n<li>方法区中类静态属性引用的对象(static)</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中(一般说的native方法)引用的对象</li>\n</ul>\n<h4 id=\"自我救赎\"><a href=\"#自我救赎\" class=\"headerlink\" title=\"自我救赎\"></a>自我救赎</h4><p>在可达性分析中被标记不可达的对象，也不是非死不可。</p>\n<p>要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。</p>\n<h4 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h4><p>方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。</p>\n<p>废弃常量-没有对象引用的话，就会被移除常量池，进行回收<br>无用的类，类加载容易，卸载难，满足卸载的条件如下：</p>\n<ul>\n<li>该类的所有实例都被回收</li>\n<li>加载该类的ClassLoader被回收</li>\n<li>对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><h4 id=\"标记－清理算法\"><a href=\"#标记－清理算法\" class=\"headerlink\" title=\"标记－清理算法\"></a>标记－清理算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181024382398115.jpg\" alt=\"\"></p>\n<p>首先标记出需要回收的对象，然后清理掉需要回收的对象。</p>\n<p>缺点：</p>\n<ul>\n<li>标记和回收的过程效率都不高</li>\n<li>会产生内存碎片</li>\n</ul>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181041528488728.jpg\" alt=\"\"></p>\n<p>将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。</p>\n<p>hotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。</p>\n<p>但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)</p>\n<p>在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。</p>\n<h4 id=\"标记－整体算法\"><a href=\"#标记－整体算法\" class=\"headerlink\" title=\"标记－整体算法\"></a>标记－整体算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181100129575916.jpg\" alt=\"\"></p>\n<p>先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。</p>\n<h4 id=\"分代算法\"><a href=\"#分代算法\" class=\"headerlink\" title=\"分代算法\"></a>分代算法</h4><p>将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>新生代适合复制算法。老生代适合标记－清理、标记－整体之类。</p>\n<h3 id=\"HotSpot的算法实现\"><a href=\"#HotSpot的算法实现\" class=\"headerlink\" title=\"HotSpot的算法实现\"></a>HotSpot的算法实现</h3><ul>\n<li>枚举根节点,这个时候需要停止所有的执行线程(Stop The World)</li>\n<li>安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停</li>\n<li>安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src=\"http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg\" alt=\"\"></p>\n<h4 id=\"Serial-old-收集器\"><a href=\"#Serial-old-收集器\" class=\"headerlink\" title=\"Serial(old)收集器\"></a>Serial(old)收集器</h4><p>串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。</p>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg\" alt=\"\"></p>\n<p>图为Serial和Serial Old结合使用的图。</p>\n<h4 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h4><p>是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：</p>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg\" alt=\"\"></p>\n<p>ParNew收集器在cpu核数多的情况下才有优势。</p>\n<h4 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h4><p>目标：吞吐量</p>\n<p>参数：</p>\n<ul>\n<li>-XX:MaxGCPauseMillis 控制最大停顿时间</li>\n<li>-XX:GCTimeRatio 直接设置吞吐量大小</li>\n</ul>\n<h4 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h4><p>Parallel的老生代版本，使用多线程和标记－整理算法。</p>\n<h4 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h4><p>CMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。</p>\n<p>过程：</p>\n<ul>\n<li>初始标记 cms initial mark</li>\n<li>并发标记 cms concurrent mark</li>\n<li>重新标记 cms remark</li>\n<li>并发清除 cms concurrent sweep</li>\n</ul>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg\" alt=\"\"></p>\n<p>缺点：</p>\n<ul>\n<li>对cpu资源敏感</li>\n<li>无法处理浮动垃圾</li>\n<li>大量碎片</li>\n</ul>\n<h4 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h4><p>G1(garbage first)，面向服务端的垃圾收集器。具备以下特点：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测停顿</li>\n</ul>\n<p>g1收集器的运作大致可划分为以下几个步骤:</p>\n<ul>\n<li>初始标记 initial marking</li>\n<li>并发标记 concurrent marking</li>\n<li>最终标记 final marking</li>\n<li>筛选会后 live data counting and evacuation</li>\n</ul>\n<h3 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h3><ul>\n<li>对象优先在Eden分配(新生代)</li>\n<li>大对象直接进入老年代</li>\n<li>长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代</li>\n<li>动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代</li>\n<li>空间分配担保,在这里需要先介绍两个名词<ul>\n<li>Minor GC 新生代gc</li>\n<li>Major GC 老生代gc</li>\n<li>在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"jvm字节码执行引擎","date":"2017-01-18T14:53:00.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\n\n从概念模型的角度来说，虚拟机的的方法调用和字节码执行。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 运行时帧栈结构\n\n帧栈是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息，每一个方法从调用到返回，都是入栈和出栈的过程。\n\n在编译程序代码的时候，帧栈中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并写入到方法表的Code属性之中，因此，一个帧栈需要的内存不会受运行期变量数据的影响。\n\n![](http://img2.tuicool.com/z2EFBnN.png!web)\n\n\n#### 局部变量表\n\n用于存放方法参数和方法内部定义的局部变量。在编译为Class文件时，经在方法的Code属性的max_locals数据项中确定了该方法需要分配的局部变量表的最大容量。\n\n基本单位:槽 Slot\n存放数据:boolean、byte、char、short、int、float、reference、returnAddress\n\nSlot可以存放32位，如果需要64位，则由两个Slot存放。\n\n虚拟机通过索引定位的方式访问局部变量表，索引从0开始，\n\n在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。\n\nSlot会影响GC，例子就不举了，直接说结果。局部变量表还有对象的引用的话，就会影响.\n\n#### 操作数栈\n\n操作数栈的最大深度在编译时写入Code属性的max_stacks中。\n\n![](http://img1.tuicool.com/VZj2ue.png!web)\n\n\n#### 动态链接\n\n每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。\n\n#### 方法的返回地址\n\n有两种情况会退出:\n\n* 执行引擎遇到返回的字节码指令\n* 遇到异常\n\n在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。方法退出的过程实际上等同于把当前栈帧出栈。\n\n### 方法调用\n\n方法调用阶段就是确定应该调用哪一个方法。\n\n#### 解析\n\n调用目标在程序代码写好、编译器进行编译时就必须确定下来，称为解析。主要包括静态方法和私有方法两大类，对应的字节码指令如下:\n\n* invokestatic 调用静态方法\n* invokespecial 调用实例构造器<init>方法、私有方法和父类方法\n* invokevirtual 调用所有虚方法\n* invokeinterface 调用接口方法\n\n#### 分派\n\n确定调用方法是哪一个的过程。\n\n* 静态分配 调用静态方法，编译期无法知道是何种类型，这时会调用他父类的这个方法。\n* 动态分配 和重写有关(@override)，会根据实际类型来选择方法。\n\n### 总结\n\n这一章难度比较大，还有一些地方没理解到，未完，待续。\n\n\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/jvm字节码执行引擎.md","raw":"---\ntitle: jvm字节码执行引擎\ndate: 2017-01-18 22:53:00\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\n\n从概念模型的角度来说，虚拟机的的方法调用和字节码执行。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 运行时帧栈结构\n\n帧栈是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息，每一个方法从调用到返回，都是入栈和出栈的过程。\n\n在编译程序代码的时候，帧栈中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并写入到方法表的Code属性之中，因此，一个帧栈需要的内存不会受运行期变量数据的影响。\n\n![](http://img2.tuicool.com/z2EFBnN.png!web)\n\n\n#### 局部变量表\n\n用于存放方法参数和方法内部定义的局部变量。在编译为Class文件时，经在方法的Code属性的max_locals数据项中确定了该方法需要分配的局部变量表的最大容量。\n\n基本单位:槽 Slot\n存放数据:boolean、byte、char、short、int、float、reference、returnAddress\n\nSlot可以存放32位，如果需要64位，则由两个Slot存放。\n\n虚拟机通过索引定位的方式访问局部变量表，索引从0开始，\n\n在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。\n\nSlot会影响GC，例子就不举了，直接说结果。局部变量表还有对象的引用的话，就会影响.\n\n#### 操作数栈\n\n操作数栈的最大深度在编译时写入Code属性的max_stacks中。\n\n![](http://img1.tuicool.com/VZj2ue.png!web)\n\n\n#### 动态链接\n\n每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。\n\n#### 方法的返回地址\n\n有两种情况会退出:\n\n* 执行引擎遇到返回的字节码指令\n* 遇到异常\n\n在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。方法退出的过程实际上等同于把当前栈帧出栈。\n\n### 方法调用\n\n方法调用阶段就是确定应该调用哪一个方法。\n\n#### 解析\n\n调用目标在程序代码写好、编译器进行编译时就必须确定下来，称为解析。主要包括静态方法和私有方法两大类，对应的字节码指令如下:\n\n* invokestatic 调用静态方法\n* invokespecial 调用实例构造器<init>方法、私有方法和父类方法\n* invokevirtual 调用所有虚方法\n* invokeinterface 调用接口方法\n\n#### 分派\n\n确定调用方法是哪一个的过程。\n\n* 静态分配 调用静态方法，编译期无法知道是何种类型，这时会调用他父类的这个方法。\n* 动态分配 和重写有关(@override)，会根据实际类型来选择方法。\n\n### 总结\n\n这一章难度比较大，还有一些地方没理解到，未完，待续。\n\n\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"jvm字节码执行引擎","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslz8003z19fy9ec656gv","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>从概念模型的角度来说，虚拟机的的方法调用和字节码执行。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"运行时帧栈结构\"><a href=\"#运行时帧栈结构\" class=\"headerlink\" title=\"运行时帧栈结构\"></a>运行时帧栈结构</h3><p>帧栈是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息，每一个方法从调用到返回，都是入栈和出栈的过程。</p>\n<p>在编译程序代码的时候，帧栈中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并写入到方法表的Code属性之中，因此，一个帧栈需要的内存不会受运行期变量数据的影响。</p>\n<p><img src=\"http://img2.tuicool.com/z2EFBnN.png!web\" alt=\"\"></p>\n<h4 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h4><p>用于存放方法参数和方法内部定义的局部变量。在编译为Class文件时，经在方法的Code属性的max_locals数据项中确定了该方法需要分配的局部变量表的最大容量。</p>\n<p>基本单位:槽 Slot<br>存放数据:boolean、byte、char、short、int、float、reference、returnAddress</p>\n<p>Slot可以存放32位，如果需要64位，则由两个Slot存放。</p>\n<p>虚拟机通过索引定位的方式访问局部变量表，索引从0开始，</p>\n<p>在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。</p>\n<p>Slot会影响GC，例子就不举了，直接说结果。局部变量表还有对象的引用的话，就会影响.</p>\n<h4 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h4><p>操作数栈的最大深度在编译时写入Code属性的max_stacks中。</p>\n<p><img src=\"http://img1.tuicool.com/VZj2ue.png!web\" alt=\"\"></p>\n<h4 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。</p>\n<h4 id=\"方法的返回地址\"><a href=\"#方法的返回地址\" class=\"headerlink\" title=\"方法的返回地址\"></a>方法的返回地址</h4><p>有两种情况会退出:</p>\n<ul>\n<li>执行引擎遇到返回的字节码指令</li>\n<li>遇到异常</li>\n</ul>\n<p>在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。方法退出的过程实际上等同于把当前栈帧出栈。</p>\n<h3 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h3><p>方法调用阶段就是确定应该调用哪一个方法。</p>\n<h4 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h4><p>调用目标在程序代码写好、编译器进行编译时就必须确定下来，称为解析。主要包括静态方法和私有方法两大类，对应的字节码指令如下:</p>\n<ul>\n<li>invokestatic 调用静态方法</li>\n<li>invokespecial 调用实例构造器<init>方法、私有方法和父类方法</init></li>\n<li>invokevirtual 调用所有虚方法</li>\n<li>invokeinterface 调用接口方法</li>\n</ul>\n<h4 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h4><p>确定调用方法是哪一个的过程。</p>\n<ul>\n<li>静态分配 调用静态方法，编译期无法知道是何种类型，这时会调用他父类的这个方法。</li>\n<li>动态分配 和重写有关(@override)，会根据实际类型来选择方法。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这一章难度比较大，还有一些地方没理解到，未完，待续。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>从概念模型的角度来说，虚拟机的的方法调用和字节码执行。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"运行时帧栈结构\"><a href=\"#运行时帧栈结构\" class=\"headerlink\" title=\"运行时帧栈结构\"></a>运行时帧栈结构</h3><p>帧栈是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息，每一个方法从调用到返回，都是入栈和出栈的过程。</p>\n<p>在编译程序代码的时候，帧栈中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并写入到方法表的Code属性之中，因此，一个帧栈需要的内存不会受运行期变量数据的影响。</p>\n<p><img src=\"http://img2.tuicool.com/z2EFBnN.png!web\" alt=\"\"></p>\n<h4 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h4><p>用于存放方法参数和方法内部定义的局部变量。在编译为Class文件时，经在方法的Code属性的max_locals数据项中确定了该方法需要分配的局部变量表的最大容量。</p>\n<p>基本单位:槽 Slot<br>存放数据:boolean、byte、char、short、int、float、reference、returnAddress</p>\n<p>Slot可以存放32位，如果需要64位，则由两个Slot存放。</p>\n<p>虚拟机通过索引定位的方式访问局部变量表，索引从0开始，</p>\n<p>在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。</p>\n<p>Slot会影响GC，例子就不举了，直接说结果。局部变量表还有对象的引用的话，就会影响.</p>\n<h4 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h4><p>操作数栈的最大深度在编译时写入Code属性的max_stacks中。</p>\n<p><img src=\"http://img1.tuicool.com/VZj2ue.png!web\" alt=\"\"></p>\n<h4 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。</p>\n<h4 id=\"方法的返回地址\"><a href=\"#方法的返回地址\" class=\"headerlink\" title=\"方法的返回地址\"></a>方法的返回地址</h4><p>有两种情况会退出:</p>\n<ul>\n<li>执行引擎遇到返回的字节码指令</li>\n<li>遇到异常</li>\n</ul>\n<p>在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。方法退出的过程实际上等同于把当前栈帧出栈。</p>\n<h3 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h3><p>方法调用阶段就是确定应该调用哪一个方法。</p>\n<h4 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h4><p>调用目标在程序代码写好、编译器进行编译时就必须确定下来，称为解析。主要包括静态方法和私有方法两大类，对应的字节码指令如下:</p>\n<ul>\n<li>invokestatic 调用静态方法</li>\n<li>invokespecial 调用实例构造器<init>方法、私有方法和父类方法</li>\n<li>invokevirtual 调用所有虚方法</li>\n<li>invokeinterface 调用接口方法</li>\n</ul>\n<h4 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h4><p>确定调用方法是哪一个的过程。</p>\n<ul>\n<li>静态分配 调用静态方法，编译期无法知道是何种类型，这时会调用他父类的这个方法。</li>\n<li>动态分配 和重写有关(@override)，会根据实际类型来选择方法。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这一章难度比较大，还有一些地方没理解到，未完，待续。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"jvm编译器优化","date":"2017-01-19T13:33:35.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\njava是编译运行的，因此，在运行之前，会进行编译操作。在java中，有三种类型，如下：\n\n* 前期编译器:将.java编译成.class，常见的如javac\n* JIT编译器(just in time compiler)：将.class字节码转化为机器码，如hotspot的C1,C2\n* AOT编译器(Ahead Of Time Compiler)：将.java文件直接转化为机器码的过程\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### javac的编译过程\n\njavac的编译过程分为下面三个步骤：\n\n* 解析与填充符号表的过程\n* 插入式注解处理器的注解处理过程\n* 分析与字节码生成过程\n\n#### 解析与填充符号表的过程\n\n解析过程包括词法分析与语法分析两个过程。\n\n* 词法分析 词法分析是将源代码的字符流转化为标记(Token)集合，标记是编译过程中的最小元素、关键字、变量名、字面量、运算符等都可以成为标记\n* 语法分析 是根据token生成抽象语法树的过程\n\n#### 注解处理器\n\n这个过程就是处理我们编译时注解的过程。\n\n\n#### 语义分析与字节码生成\n\n* 语义分析\n \t1. 标注检查，检查的内容包括变量使用前是否已被申明、变量与赋值过程的类型是否匹配等，在这个过程中，会进行一个重要的操作，叫做常量折叠，如 int A = 1 + 2,编译成 int A = 3\n \t2. 数据及控制流分析，对程序上下文逻辑更进一步的验证，检查程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值等等问题。\n\t3. 解语法糖，包括自动拆箱、装箱等\n* 字节码生成 将前面各个步骤生成的信息，写入到磁盘中。\n\n### Java中语法糖\n\n* 泛型与类型擦除，讲ArrayList<int>,ArrayList<String>擦除程同一种类型\n* 自动装箱、拆箱与遍历循环\n* 条件编译 如果发现只会为true，或者false，只会编译对应分支。\n\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/jvm编译器优化.md","raw":"---\ntitle: jvm编译器优化\ndate: 2017-01-19 21:33:35\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\njava是编译运行的，因此，在运行之前，会进行编译操作。在java中，有三种类型，如下：\n\n* 前期编译器:将.java编译成.class，常见的如javac\n* JIT编译器(just in time compiler)：将.class字节码转化为机器码，如hotspot的C1,C2\n* AOT编译器(Ahead Of Time Compiler)：将.java文件直接转化为机器码的过程\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### javac的编译过程\n\njavac的编译过程分为下面三个步骤：\n\n* 解析与填充符号表的过程\n* 插入式注解处理器的注解处理过程\n* 分析与字节码生成过程\n\n#### 解析与填充符号表的过程\n\n解析过程包括词法分析与语法分析两个过程。\n\n* 词法分析 词法分析是将源代码的字符流转化为标记(Token)集合，标记是编译过程中的最小元素、关键字、变量名、字面量、运算符等都可以成为标记\n* 语法分析 是根据token生成抽象语法树的过程\n\n#### 注解处理器\n\n这个过程就是处理我们编译时注解的过程。\n\n\n#### 语义分析与字节码生成\n\n* 语义分析\n \t1. 标注检查，检查的内容包括变量使用前是否已被申明、变量与赋值过程的类型是否匹配等，在这个过程中，会进行一个重要的操作，叫做常量折叠，如 int A = 1 + 2,编译成 int A = 3\n \t2. 数据及控制流分析，对程序上下文逻辑更进一步的验证，检查程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值等等问题。\n\t3. 解语法糖，包括自动拆箱、装箱等\n* 字节码生成 将前面各个步骤生成的信息，写入到磁盘中。\n\n### Java中语法糖\n\n* 泛型与类型擦除，讲ArrayList<int>,ArrayList<String>擦除程同一种类型\n* 自动装箱、拆箱与遍历循环\n* 条件编译 如果发现只会为true，或者false，只会编译对应分支。\n\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"jvm编译器优化","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslza004019fybbzc3r8c","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>java是编译运行的，因此，在运行之前，会进行编译操作。在java中，有三种类型，如下：</p>\n<ul>\n<li>前期编译器:将.java编译成.class，常见的如javac</li>\n<li>JIT编译器(just in time compiler)：将.class字节码转化为机器码，如hotspot的C1,C2</li>\n<li>AOT编译器(Ahead Of Time Compiler)：将.java文件直接转化为机器码的过程</li>\n</ul>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"javac的编译过程\"><a href=\"#javac的编译过程\" class=\"headerlink\" title=\"javac的编译过程\"></a>javac的编译过程</h3><p>javac的编译过程分为下面三个步骤：</p>\n<ul>\n<li>解析与填充符号表的过程</li>\n<li>插入式注解处理器的注解处理过程</li>\n<li>分析与字节码生成过程</li>\n</ul>\n<h4 id=\"解析与填充符号表的过程\"><a href=\"#解析与填充符号表的过程\" class=\"headerlink\" title=\"解析与填充符号表的过程\"></a>解析与填充符号表的过程</h4><p>解析过程包括词法分析与语法分析两个过程。</p>\n<ul>\n<li>词法分析 词法分析是将源代码的字符流转化为标记(Token)集合，标记是编译过程中的最小元素、关键字、变量名、字面量、运算符等都可以成为标记</li>\n<li>语法分析 是根据token生成抽象语法树的过程</li>\n</ul>\n<h4 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h4><p>这个过程就是处理我们编译时注解的过程。</p>\n<h4 id=\"语义分析与字节码生成\"><a href=\"#语义分析与字节码生成\" class=\"headerlink\" title=\"语义分析与字节码生成\"></a>语义分析与字节码生成</h4><ul>\n<li>语义分析<ol>\n<li>标注检查，检查的内容包括变量使用前是否已被申明、变量与赋值过程的类型是否匹配等，在这个过程中，会进行一个重要的操作，叫做常量折叠，如 int A = 1 + 2,编译成 int A = 3</li>\n<li>数据及控制流分析，对程序上下文逻辑更进一步的验证，检查程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值等等问题。<ol>\n<li>解语法糖，包括自动拆箱、装箱等</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>字节码生成 将前面各个步骤生成的信息，写入到磁盘中。</li>\n</ul>\n<h3 id=\"Java中语法糖\"><a href=\"#Java中语法糖\" class=\"headerlink\" title=\"Java中语法糖\"></a>Java中语法糖</h3><ul>\n<li>泛型与类型擦除，讲ArrayList<int>,ArrayList<string>擦除程同一种类型</string></int></li>\n<li>自动装箱、拆箱与遍历循环</li>\n<li>条件编译 如果发现只会为true，或者false，只会编译对应分支。</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>java是编译运行的，因此，在运行之前，会进行编译操作。在java中，有三种类型，如下：</p>\n<ul>\n<li>前期编译器:将.java编译成.class，常见的如javac</li>\n<li>JIT编译器(just in time compiler)：将.class字节码转化为机器码，如hotspot的C1,C2</li>\n<li>AOT编译器(Ahead Of Time Compiler)：将.java文件直接转化为机器码的过程</li>\n</ul>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"javac的编译过程\"><a href=\"#javac的编译过程\" class=\"headerlink\" title=\"javac的编译过程\"></a>javac的编译过程</h3><p>javac的编译过程分为下面三个步骤：</p>\n<ul>\n<li>解析与填充符号表的过程</li>\n<li>插入式注解处理器的注解处理过程</li>\n<li>分析与字节码生成过程</li>\n</ul>\n<h4 id=\"解析与填充符号表的过程\"><a href=\"#解析与填充符号表的过程\" class=\"headerlink\" title=\"解析与填充符号表的过程\"></a>解析与填充符号表的过程</h4><p>解析过程包括词法分析与语法分析两个过程。</p>\n<ul>\n<li>词法分析 词法分析是将源代码的字符流转化为标记(Token)集合，标记是编译过程中的最小元素、关键字、变量名、字面量、运算符等都可以成为标记</li>\n<li>语法分析 是根据token生成抽象语法树的过程</li>\n</ul>\n<h4 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h4><p>这个过程就是处理我们编译时注解的过程。</p>\n<h4 id=\"语义分析与字节码生成\"><a href=\"#语义分析与字节码生成\" class=\"headerlink\" title=\"语义分析与字节码生成\"></a>语义分析与字节码生成</h4><ul>\n<li>语义分析<ol>\n<li>标注检查，检查的内容包括变量使用前是否已被申明、变量与赋值过程的类型是否匹配等，在这个过程中，会进行一个重要的操作，叫做常量折叠，如 int A = 1 + 2,编译成 int A = 3</li>\n<li>数据及控制流分析，对程序上下文逻辑更进一步的验证，检查程序局部变量在使用前是否有赋值、方法的每条路径是否有返回值等等问题。<ol>\n<li>解语法糖，包括自动拆箱、装箱等</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>字节码生成 将前面各个步骤生成的信息，写入到磁盘中。</li>\n</ul>\n<h3 id=\"Java中语法糖\"><a href=\"#Java中语法糖\" class=\"headerlink\" title=\"Java中语法糖\"></a>Java中语法糖</h3><ul>\n<li>泛型与类型擦除，讲ArrayList<int>,ArrayList<String>擦除程同一种类型</li>\n<li>自动装箱、拆箱与遍历循环</li>\n<li>条件编译 如果发现只会为true，或者false，只会编译对应分支。</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"jvm类加载机制","date":"2017-01-17T14:59:18.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\n类加载机制是jvm中，非常重要的一部分，也是后面可能说道的分包、插件化、热修复等技术的基础。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的加载机制。\n\n### 类加载机制的时机\n\n类加载机制的整个生命周期如下：\n\n* 加载\n* 验证\n* 准备\n* 解析\n* 初始化\n* 使用\n* 卸载\n\n其中，卸载的条件比较难达到，在方法区gc的时候提到过。\n\n虚拟机规范中，严格规定了有且只有5种情况必须对类进行\"初始化\"(而加载、验证、准备、初始化需要在此之前)\n\n1. 遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果没有进行过初始化，则要先出发初始化，对应的操作为new对象、读取或设置static字段(被final修饰或编译器把结果放入到常量池的静态字段)，以及屌用一个类的静态方法的时候，PS：因为被final修饰的字段，在编译期会被优化，放入到类的常量池中。\n2. 使用java.lang.reflect包的方法对类进行反射调用\n3. 当初始化一个类时，如果其父类没有进行过初始化，则先初始化父类\n4. 当虚拟机启动时，需要指定一个执行的主类(入口)，虚拟机会先初始化这个类\n5. 使用动态语言支持时，动态代理，遇到REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄\n\n上面的几种为主动引用，而被动引用就不会触发初始化，被动引用的例子如：\n\n* 子类引用父类的静态字段\n* 通过数组定义引用类\n* 常量在编译时会被放入常量池，本质上并没有引用到类\n\n### 加载阶段\n\n在加载阶段，虚拟机需要完成三件事情：\n\n1. 通过类的全限定名来获取定义此类的二进制流(全限定名,用/替换.)\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据\n3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口\n\n加载二进制流的手段如下：\n\n* 从zip包中获取，如jar\n* 从网络中获取，Applet\n* 运行时计算生成，动态代理\n* 由其他文件生成，jsp\n* 从数据库中读取，较少\n\n对我们Android程序员来说，最常见的就是zip包和动态代理这种。\n\n<p style=\"color:red\">对于数组类，不一样了，数组类由不通过类加载器创建，而由虚拟机直接创建，</p>数组类的加载过程遵循以下规则：\n\n1. 如果数组的组件类型(每一个值)是引用类型，则递归采用类的家在过程去加载\n2. 如果不是引用类型，而是int[]中，将数组标记为与引导类加载器关联\n3. 如果不是引用类型，则数组的可见类型默认为public\n\n### 验证阶段\n\n这一阶段是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致分为四个检验工作，如下：\n\n1. 文件格式验证，验证字节流是否符合Class文件格式的规范，并且是否能被虚拟机处理(版本号是否在处理范围)\n\t* 是否以魔数0xCAFEBABE开头\n\t* 主次版本号是否在虚拟机处理范围内\n\t* 常量池中的常量是否有不被支持的类型\n\t* 指向常量的各种引用值中是否有不存在的常量或者不支持的类型\n\t* 等等\n\t后面会说道class文件结构\n2. 元数据验证 进行语义分析\n\t* 是否有父类(Object类除外)\n\t* 是否继承了不允许被继承的类\n\t* 如果不是抽象类，要求实现父类或者接口中要求实现的类\n\t* 类中的字段、方法是否与父类产生矛盾\n\t* ...\n3. 字节码验证 确定程序语义是否合法、符合逻辑\n\t* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作\n\t* 保证跳转指令不会跳转到方法体以外的字节码指令上\n\t* 保证方法体中类型转换是有效的\n\t* ...\n4. 符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候\n\t* 符号引用中能否通过字符串描述的全限定名找到对应的类\n\t* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段\n\t* 符号引用中的类、字段、方法的访问性是否可被当前类引用\n\t\n\n### 准备阶段 \n\n准备阶段正式为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都在方法区进行分配。这里只包括类变量，不包括实例变量，\n<span style=\"color:red\">如果被final修饰，则进行赋值操作，就不是零值了，千万注意<span>\n\n### 解析阶段\n\n解析阶段是讲常量池内的符号引用解析成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行。\n\n\n### 初始化阶段\n\n初始化阶段，根据程序的主观计划去初始化一个类变量和其他资源，也就是执行类构造器<clinit>()方法的过程\n\n* <clinit>(),由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合而成。顺序，有语句在源文件出现的顺序决定\n* <clinit>() 和<init>()不同，不需要显示的调用父类的这个方法，会保证子类的<clinit>()执行之前，父类的<clinit>()已经执行完毕。\n* 父类的静态语句块优与子类\n* <clinit>() 对类和接口来说并不是必须的，如果没有静态语句块和赋值操作，就不生成\n* 执行接口的<clinit>()之前，不需要先执行父类的\n* 保证类的<clinit>()在多线程环境中正确使用\n\n\n### 类与类加载器\n\n比较两个类是否相等，只有这两个类是由同一个类加载器加载，并且来自同一个Class文件。\n\n\n\n### 双亲委派模型\n\n![](http://img.blog.csdn.net/20160102154038185)\n\n* BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。\n* Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n* Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。\n\n加载过程如下：\n\n1. 如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。\n2. 每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器\n3. 如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载\n\n双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。\n\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/jvm类加载机制.md","raw":"---\ntitle: jvm类加载机制\ndate: 2017-01-17 22:59:18\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\n类加载机制是jvm中，非常重要的一部分，也是后面可能说道的分包、插件化、热修复等技术的基础。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的加载机制。\n\n### 类加载机制的时机\n\n类加载机制的整个生命周期如下：\n\n* 加载\n* 验证\n* 准备\n* 解析\n* 初始化\n* 使用\n* 卸载\n\n其中，卸载的条件比较难达到，在方法区gc的时候提到过。\n\n虚拟机规范中，严格规定了有且只有5种情况必须对类进行\"初始化\"(而加载、验证、准备、初始化需要在此之前)\n\n1. 遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果没有进行过初始化，则要先出发初始化，对应的操作为new对象、读取或设置static字段(被final修饰或编译器把结果放入到常量池的静态字段)，以及屌用一个类的静态方法的时候，PS：因为被final修饰的字段，在编译期会被优化，放入到类的常量池中。\n2. 使用java.lang.reflect包的方法对类进行反射调用\n3. 当初始化一个类时，如果其父类没有进行过初始化，则先初始化父类\n4. 当虚拟机启动时，需要指定一个执行的主类(入口)，虚拟机会先初始化这个类\n5. 使用动态语言支持时，动态代理，遇到REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄\n\n上面的几种为主动引用，而被动引用就不会触发初始化，被动引用的例子如：\n\n* 子类引用父类的静态字段\n* 通过数组定义引用类\n* 常量在编译时会被放入常量池，本质上并没有引用到类\n\n### 加载阶段\n\n在加载阶段，虚拟机需要完成三件事情：\n\n1. 通过类的全限定名来获取定义此类的二进制流(全限定名,用/替换.)\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据\n3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口\n\n加载二进制流的手段如下：\n\n* 从zip包中获取，如jar\n* 从网络中获取，Applet\n* 运行时计算生成，动态代理\n* 由其他文件生成，jsp\n* 从数据库中读取，较少\n\n对我们Android程序员来说，最常见的就是zip包和动态代理这种。\n\n<p style=\"color:red\">对于数组类，不一样了，数组类由不通过类加载器创建，而由虚拟机直接创建，</p>数组类的加载过程遵循以下规则：\n\n1. 如果数组的组件类型(每一个值)是引用类型，则递归采用类的家在过程去加载\n2. 如果不是引用类型，而是int[]中，将数组标记为与引导类加载器关联\n3. 如果不是引用类型，则数组的可见类型默认为public\n\n### 验证阶段\n\n这一阶段是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致分为四个检验工作，如下：\n\n1. 文件格式验证，验证字节流是否符合Class文件格式的规范，并且是否能被虚拟机处理(版本号是否在处理范围)\n\t* 是否以魔数0xCAFEBABE开头\n\t* 主次版本号是否在虚拟机处理范围内\n\t* 常量池中的常量是否有不被支持的类型\n\t* 指向常量的各种引用值中是否有不存在的常量或者不支持的类型\n\t* 等等\n\t后面会说道class文件结构\n2. 元数据验证 进行语义分析\n\t* 是否有父类(Object类除外)\n\t* 是否继承了不允许被继承的类\n\t* 如果不是抽象类，要求实现父类或者接口中要求实现的类\n\t* 类中的字段、方法是否与父类产生矛盾\n\t* ...\n3. 字节码验证 确定程序语义是否合法、符合逻辑\n\t* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作\n\t* 保证跳转指令不会跳转到方法体以外的字节码指令上\n\t* 保证方法体中类型转换是有效的\n\t* ...\n4. 符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候\n\t* 符号引用中能否通过字符串描述的全限定名找到对应的类\n\t* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段\n\t* 符号引用中的类、字段、方法的访问性是否可被当前类引用\n\t\n\n### 准备阶段 \n\n准备阶段正式为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都在方法区进行分配。这里只包括类变量，不包括实例变量，\n<span style=\"color:red\">如果被final修饰，则进行赋值操作，就不是零值了，千万注意<span>\n\n### 解析阶段\n\n解析阶段是讲常量池内的符号引用解析成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行。\n\n\n### 初始化阶段\n\n初始化阶段，根据程序的主观计划去初始化一个类变量和其他资源，也就是执行类构造器<clinit>()方法的过程\n\n* <clinit>(),由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合而成。顺序，有语句在源文件出现的顺序决定\n* <clinit>() 和<init>()不同，不需要显示的调用父类的这个方法，会保证子类的<clinit>()执行之前，父类的<clinit>()已经执行完毕。\n* 父类的静态语句块优与子类\n* <clinit>() 对类和接口来说并不是必须的，如果没有静态语句块和赋值操作，就不生成\n* 执行接口的<clinit>()之前，不需要先执行父类的\n* 保证类的<clinit>()在多线程环境中正确使用\n\n\n### 类与类加载器\n\n比较两个类是否相等，只有这两个类是由同一个类加载器加载，并且来自同一个Class文件。\n\n\n\n### 双亲委派模型\n\n![](http://img.blog.csdn.net/20160102154038185)\n\n* BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。\n* Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n* Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。\n\n加载过程如下：\n\n1. 如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。\n2. 每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器\n3. 如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载\n\n双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。\n\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"jvm类加载机制","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzc004419fysyg8ry1o","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>类加载机制是jvm中，非常重要的一部分，也是后面可能说道的分包、插件化、热修复等技术的基础。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的加载机制。</p>\n<h3 id=\"类加载机制的时机\"><a href=\"#类加载机制的时机\" class=\"headerlink\" title=\"类加载机制的时机\"></a>类加载机制的时机</h3><p>类加载机制的整个生命周期如下：</p>\n<ul>\n<li>加载</li>\n<li>验证</li>\n<li>准备</li>\n<li>解析</li>\n<li>初始化</li>\n<li>使用</li>\n<li>卸载</li>\n</ul>\n<p>其中，卸载的条件比较难达到，在方法区gc的时候提到过。</p>\n<p>虚拟机规范中，严格规定了有且只有5种情况必须对类进行”初始化”(而加载、验证、准备、初始化需要在此之前)</p>\n<ol>\n<li>遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果没有进行过初始化，则要先出发初始化，对应的操作为new对象、读取或设置static字段(被final修饰或编译器把结果放入到常量池的静态字段)，以及屌用一个类的静态方法的时候，PS：因为被final修饰的字段，在编译期会被优化，放入到类的常量池中。</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用</li>\n<li>当初始化一个类时，如果其父类没有进行过初始化，则先初始化父类</li>\n<li>当虚拟机启动时，需要指定一个执行的主类(入口)，虚拟机会先初始化这个类</li>\n<li>使用动态语言支持时，动态代理，遇到REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄</li>\n</ol>\n<p>上面的几种为主动引用，而被动引用就不会触发初始化，被动引用的例子如：</p>\n<ul>\n<li>子类引用父类的静态字段</li>\n<li>通过数组定义引用类</li>\n<li>常量在编译时会被放入常量池，本质上并没有引用到类</li>\n</ul>\n<h3 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h3><p>在加载阶段，虚拟机需要完成三件事情：</p>\n<ol>\n<li>通过类的全限定名来获取定义此类的二进制流(全限定名,用/替换.)</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据</li>\n<li>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>加载二进制流的手段如下：</p>\n<ul>\n<li>从zip包中获取，如jar</li>\n<li>从网络中获取，Applet</li>\n<li>运行时计算生成，动态代理</li>\n<li>由其他文件生成，jsp</li>\n<li>从数据库中读取，较少</li>\n</ul>\n<p>对我们Android程序员来说，最常见的就是zip包和动态代理这种。</p>\n<p></p><p style=\"color:red\">对于数组类，不一样了，数组类由不通过类加载器创建，而由虚拟机直接创建，</p>数组类的加载过程遵循以下规则：<p></p>\n<ol>\n<li>如果数组的组件类型(每一个值)是引用类型，则递归采用类的家在过程去加载</li>\n<li>如果不是引用类型，而是int[]中，将数组标记为与引导类加载器关联</li>\n<li>如果不是引用类型，则数组的可见类型默认为public</li>\n</ol>\n<h3 id=\"验证阶段\"><a href=\"#验证阶段\" class=\"headerlink\" title=\"验证阶段\"></a>验证阶段</h3><p>这一阶段是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致分为四个检验工作，如下：</p>\n<ol>\n<li>文件格式验证，验证字节流是否符合Class文件格式的规范，并且是否能被虚拟机处理(版本号是否在处理范围)<ul>\n<li>是否以魔数0xCAFEBABE开头</li>\n<li>主次版本号是否在虚拟机处理范围内</li>\n<li>常量池中的常量是否有不被支持的类型</li>\n<li>指向常量的各种引用值中是否有不存在的常量或者不支持的类型</li>\n<li>等等<br>后面会说道class文件结构</li>\n</ul>\n</li>\n<li>元数据验证 进行语义分析<ul>\n<li>是否有父类(Object类除外)</li>\n<li>是否继承了不允许被继承的类</li>\n<li>如果不是抽象类，要求实现父类或者接口中要求实现的类</li>\n<li>类中的字段、方法是否与父类产生矛盾</li>\n<li>…</li>\n</ul>\n</li>\n<li>字节码验证 确定程序语义是否合法、符合逻辑<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>\n<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>\n<li>保证方法体中类型转换是有效的</li>\n<li>…</li>\n</ul>\n</li>\n<li>符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候<ul>\n<li>符号引用中能否通过字符串描述的全限定名找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>\n<li>符号引用中的类、字段、方法的访问性是否可被当前类引用</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h3><p>准备阶段正式为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都在方法区进行分配。这里只包括类变量，不包括实例变量，<br><span style=\"color:red\">如果被final修饰，则进行赋值操作，就不是零值了，千万注意<span></span></span></p>\n<h3 id=\"解析阶段\"><a href=\"#解析阶段\" class=\"headerlink\" title=\"解析阶段\"></a>解析阶段</h3><p>解析阶段是讲常量池内的符号引用解析成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行。</p>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>初始化阶段，根据程序的主观计划去初始化一个类变量和其他资源，也就是执行类构造器<clinit>()方法的过程</clinit></p>\n<ul>\n<li><clinit>(),由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合而成。顺序，有语句在源文件出现的顺序决定</clinit></li>\n<li><clinit>() 和<init>()不同，不需要显示的调用父类的这个方法，会保证子类的<clinit>()执行之前，父类的<clinit>()已经执行完毕。</clinit></clinit></init></clinit></li>\n<li>父类的静态语句块优与子类</li>\n<li><clinit>() 对类和接口来说并不是必须的，如果没有静态语句块和赋值操作，就不生成</clinit></li>\n<li>执行接口的<clinit>()之前，不需要先执行父类的</clinit></li>\n<li>保证类的<clinit>()在多线程环境中正确使用</clinit></li>\n</ul>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><p>比较两个类是否相等，只有这两个类是由同一个类加载器加载，并且来自同一个Class文件。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p><img src=\"http://img.blog.csdn.net/20160102154038185\" alt=\"\"></p>\n<ul>\n<li>BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。</li>\n<li>Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>\n<li>Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。</li>\n</ul>\n<p>加载过程如下：</p>\n<ol>\n<li>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。</li>\n<li>每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器</li>\n<li>如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载</li>\n</ol>\n<p>双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>类加载机制是jvm中，非常重要的一部分，也是后面可能说道的分包、插件化、热修复等技术的基础。</p>","more":"<The rest of contents | 余下全文>\n\n\n<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的加载机制。</p>\n<h3 id=\"类加载机制的时机\"><a href=\"#类加载机制的时机\" class=\"headerlink\" title=\"类加载机制的时机\"></a>类加载机制的时机</h3><p>类加载机制的整个生命周期如下：</p>\n<ul>\n<li>加载</li>\n<li>验证</li>\n<li>准备</li>\n<li>解析</li>\n<li>初始化</li>\n<li>使用</li>\n<li>卸载</li>\n</ul>\n<p>其中，卸载的条件比较难达到，在方法区gc的时候提到过。</p>\n<p>虚拟机规范中，严格规定了有且只有5种情况必须对类进行”初始化”(而加载、验证、准备、初始化需要在此之前)</p>\n<ol>\n<li>遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果没有进行过初始化，则要先出发初始化，对应的操作为new对象、读取或设置static字段(被final修饰或编译器把结果放入到常量池的静态字段)，以及屌用一个类的静态方法的时候，PS：因为被final修饰的字段，在编译期会被优化，放入到类的常量池中。</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用</li>\n<li>当初始化一个类时，如果其父类没有进行过初始化，则先初始化父类</li>\n<li>当虚拟机启动时，需要指定一个执行的主类(入口)，虚拟机会先初始化这个类</li>\n<li>使用动态语言支持时，动态代理，遇到REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄</li>\n</ol>\n<p>上面的几种为主动引用，而被动引用就不会触发初始化，被动引用的例子如：</p>\n<ul>\n<li>子类引用父类的静态字段</li>\n<li>通过数组定义引用类</li>\n<li>常量在编译时会被放入常量池，本质上并没有引用到类</li>\n</ul>\n<h3 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h3><p>在加载阶段，虚拟机需要完成三件事情：</p>\n<ol>\n<li>通过类的全限定名来获取定义此类的二进制流(全限定名,用/替换.)</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据</li>\n<li>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>加载二进制流的手段如下：</p>\n<ul>\n<li>从zip包中获取，如jar</li>\n<li>从网络中获取，Applet</li>\n<li>运行时计算生成，动态代理</li>\n<li>由其他文件生成，jsp</li>\n<li>从数据库中读取，较少</li>\n</ul>\n<p>对我们Android程序员来说，最常见的就是zip包和动态代理这种。</p>\n<p><p style=\"color:red\">对于数组类，不一样了，数组类由不通过类加载器创建，而由虚拟机直接创建，</p>数组类的加载过程遵循以下规则：</p>\n<ol>\n<li>如果数组的组件类型(每一个值)是引用类型，则递归采用类的家在过程去加载</li>\n<li>如果不是引用类型，而是int[]中，将数组标记为与引导类加载器关联</li>\n<li>如果不是引用类型，则数组的可见类型默认为public</li>\n</ol>\n<h3 id=\"验证阶段\"><a href=\"#验证阶段\" class=\"headerlink\" title=\"验证阶段\"></a>验证阶段</h3><p>这一阶段是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致分为四个检验工作，如下：</p>\n<ol>\n<li>文件格式验证，验证字节流是否符合Class文件格式的规范，并且是否能被虚拟机处理(版本号是否在处理范围)<ul>\n<li>是否以魔数0xCAFEBABE开头</li>\n<li>主次版本号是否在虚拟机处理范围内</li>\n<li>常量池中的常量是否有不被支持的类型</li>\n<li>指向常量的各种引用值中是否有不存在的常量或者不支持的类型</li>\n<li>等等<br>后面会说道class文件结构</li>\n</ul>\n</li>\n<li>元数据验证 进行语义分析<ul>\n<li>是否有父类(Object类除外)</li>\n<li>是否继承了不允许被继承的类</li>\n<li>如果不是抽象类，要求实现父类或者接口中要求实现的类</li>\n<li>类中的字段、方法是否与父类产生矛盾</li>\n<li>…</li>\n</ul>\n</li>\n<li>字节码验证 确定程序语义是否合法、符合逻辑<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>\n<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>\n<li>保证方法体中类型转换是有效的</li>\n<li>…</li>\n</ul>\n</li>\n<li>符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候<ul>\n<li>符号引用中能否通过字符串描述的全限定名找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>\n<li>符号引用中的类、字段、方法的访问性是否可被当前类引用</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h3><p>准备阶段正式为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都在方法区进行分配。这里只包括类变量，不包括实例变量，<br><span style=\"color:red\">如果被final修饰，则进行赋值操作，就不是零值了，千万注意<span></p>\n<h3 id=\"解析阶段\"><a href=\"#解析阶段\" class=\"headerlink\" title=\"解析阶段\"></a>解析阶段</h3><p>解析阶段是讲常量池内的符号引用解析成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行。</p>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>初始化阶段，根据程序的主观计划去初始化一个类变量和其他资源，也就是执行类构造器<clinit>()方法的过程</p>\n<ul>\n<li><clinit>(),由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合而成。顺序，有语句在源文件出现的顺序决定</li>\n<li><clinit>() 和<init>()不同，不需要显示的调用父类的这个方法，会保证子类的<clinit>()执行之前，父类的<clinit>()已经执行完毕。</li>\n<li>父类的静态语句块优与子类</li>\n<li><clinit>() 对类和接口来说并不是必须的，如果没有静态语句块和赋值操作，就不生成</li>\n<li>执行接口的<clinit>()之前，不需要先执行父类的</li>\n<li>保证类的<clinit>()在多线程环境中正确使用</li>\n</ul>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><p>比较两个类是否相等，只有这两个类是由同一个类加载器加载，并且来自同一个Class文件。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p><img src=\"http://img.blog.csdn.net/20160102154038185\" alt=\"\"></p>\n<ul>\n<li>BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。</li>\n<li>Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>\n<li>Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。</li>\n</ul>\n<p>加载过程如下：</p>\n<ol>\n<li>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。</li>\n<li>每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器</li>\n<li>如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载</li>\n</ol>\n<p>双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"jvm运行时优化","date":"2017-01-20T13:48:56.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\njava虚拟机最开始是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为\"热点代码\"，为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(JIT)\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n![](http://s15.sinaimg.cn/mw690/0019kvgRgy6XClCB6OOfe)\n\n* Clinet Compiler C1编译器\n* Server Compiler C2编译器\n\n为了在程序启动和运行效率之间达到平衡，hotspot虚拟机会逐渐启动分层编译:\n\n* 第一层 程序解释执行\n* 第二层 C1编译，将字节码编译成本地代码，进行简单、可靠的优化\n* 第二层 C2编译，将字节码编译成本地代码，会进行深层次的优化\n\n### 编译对象与触发条件\n\n热点代码有两种:\n\n* 被多次调用的方法体，编译器会以整个方法作为编译对象，标准的JIT编译\n* 被多次执行的循环体，编译器依然会编译整个方法，发生在方法的执行过程中，被称为栈上替换。\n\n判断热点代码的方式有两种：\n\n* 基于采样的热点探测\n* 基于计数器的热点探测\n\nhotspot虚拟机中采用的是第二种。为每个方法提供两种计数器:方法计数器(计数方法被调用次数)和回边计数器(循环体代码执行次数)，当两个计数器的和达到阀值，就会触发JIT编译。在一定的时间内，如果没有代码执行，就会衰减。\n\n### 编译优化技术\n\n编译优化的技术特别多，这里记录下书中的几个。\n\n* 方法内联，去除方法调用成本，\n* 冗余访问消除\n* 复写传播\n* 无用代码消除\n* 公共子表达式消除，没必要重复计算公共子表达式的值\n* 数组边界检查消除\n* 逃逸分析，分析对象的动态作用域，一个对象定以后，被外部方法调用，称为方法逃逸，被其他线程访问到，称为线程逃逸\n\t* 栈上分配\n\t* 同步消除\n\t* 标量替换\n\t\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/jvm运行时优化.md","raw":"---\ntitle: jvm运行时优化\ndate: 2017-01-20 21:48:56\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\njava虚拟机最开始是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为\"热点代码\"，为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(JIT)\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n![](http://s15.sinaimg.cn/mw690/0019kvgRgy6XClCB6OOfe)\n\n* Clinet Compiler C1编译器\n* Server Compiler C2编译器\n\n为了在程序启动和运行效率之间达到平衡，hotspot虚拟机会逐渐启动分层编译:\n\n* 第一层 程序解释执行\n* 第二层 C1编译，将字节码编译成本地代码，进行简单、可靠的优化\n* 第二层 C2编译，将字节码编译成本地代码，会进行深层次的优化\n\n### 编译对象与触发条件\n\n热点代码有两种:\n\n* 被多次调用的方法体，编译器会以整个方法作为编译对象，标准的JIT编译\n* 被多次执行的循环体，编译器依然会编译整个方法，发生在方法的执行过程中，被称为栈上替换。\n\n判断热点代码的方式有两种：\n\n* 基于采样的热点探测\n* 基于计数器的热点探测\n\nhotspot虚拟机中采用的是第二种。为每个方法提供两种计数器:方法计数器(计数方法被调用次数)和回边计数器(循环体代码执行次数)，当两个计数器的和达到阀值，就会触发JIT编译。在一定的时间内，如果没有代码执行，就会衰减。\n\n### 编译优化技术\n\n编译优化的技术特别多，这里记录下书中的几个。\n\n* 方法内联，去除方法调用成本，\n* 冗余访问消除\n* 复写传播\n* 无用代码消除\n* 公共子表达式消除，没必要重复计算公共子表达式的值\n* 数组边界检查消除\n* 逃逸分析，分析对象的动态作用域，一个对象定以后，被外部方法调用，称为方法逃逸，被其他线程访问到，称为线程逃逸\n\t* 栈上分配\n\t* 同步消除\n\t* 标量替换\n\t\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"jvm运行时优化","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzd004619fy74dp4448","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>java虚拟机最开始是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为”热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(JIT)</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p><img src=\"http://s15.sinaimg.cn/mw690/0019kvgRgy6XClCB6OOfe\" alt=\"\"></p>\n<ul>\n<li>Clinet Compiler C1编译器</li>\n<li>Server Compiler C2编译器</li>\n</ul>\n<p>为了在程序启动和运行效率之间达到平衡，hotspot虚拟机会逐渐启动分层编译:</p>\n<ul>\n<li>第一层 程序解释执行</li>\n<li>第二层 C1编译，将字节码编译成本地代码，进行简单、可靠的优化</li>\n<li>第二层 C2编译，将字节码编译成本地代码，会进行深层次的优化</li>\n</ul>\n<h3 id=\"编译对象与触发条件\"><a href=\"#编译对象与触发条件\" class=\"headerlink\" title=\"编译对象与触发条件\"></a>编译对象与触发条件</h3><p>热点代码有两种:</p>\n<ul>\n<li>被多次调用的方法体，编译器会以整个方法作为编译对象，标准的JIT编译</li>\n<li>被多次执行的循环体，编译器依然会编译整个方法，发生在方法的执行过程中，被称为栈上替换。</li>\n</ul>\n<p>判断热点代码的方式有两种：</p>\n<ul>\n<li>基于采样的热点探测</li>\n<li>基于计数器的热点探测</li>\n</ul>\n<p>hotspot虚拟机中采用的是第二种。为每个方法提供两种计数器:方法计数器(计数方法被调用次数)和回边计数器(循环体代码执行次数)，当两个计数器的和达到阀值，就会触发JIT编译。在一定的时间内，如果没有代码执行，就会衰减。</p>\n<h3 id=\"编译优化技术\"><a href=\"#编译优化技术\" class=\"headerlink\" title=\"编译优化技术\"></a>编译优化技术</h3><p>编译优化的技术特别多，这里记录下书中的几个。</p>\n<ul>\n<li>方法内联，去除方法调用成本，</li>\n<li>冗余访问消除</li>\n<li>复写传播</li>\n<li>无用代码消除</li>\n<li>公共子表达式消除，没必要重复计算公共子表达式的值</li>\n<li>数组边界检查消除</li>\n<li>逃逸分析，分析对象的动态作用域，一个对象定以后，被外部方法调用，称为方法逃逸，被其他线程访问到，称为线程逃逸<ul>\n<li>栈上分配</li>\n<li>同步消除</li>\n<li>标量替换</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>java虚拟机最开始是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为”热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(JIT)</p>","more":"<The rest of contents | 余下全文>\n\n\n<p><img src=\"http://s15.sinaimg.cn/mw690/0019kvgRgy6XClCB6OOfe\" alt=\"\"></p>\n<ul>\n<li>Clinet Compiler C1编译器</li>\n<li>Server Compiler C2编译器</li>\n</ul>\n<p>为了在程序启动和运行效率之间达到平衡，hotspot虚拟机会逐渐启动分层编译:</p>\n<ul>\n<li>第一层 程序解释执行</li>\n<li>第二层 C1编译，将字节码编译成本地代码，进行简单、可靠的优化</li>\n<li>第二层 C2编译，将字节码编译成本地代码，会进行深层次的优化</li>\n</ul>\n<h3 id=\"编译对象与触发条件\"><a href=\"#编译对象与触发条件\" class=\"headerlink\" title=\"编译对象与触发条件\"></a>编译对象与触发条件</h3><p>热点代码有两种:</p>\n<ul>\n<li>被多次调用的方法体，编译器会以整个方法作为编译对象，标准的JIT编译</li>\n<li>被多次执行的循环体，编译器依然会编译整个方法，发生在方法的执行过程中，被称为栈上替换。</li>\n</ul>\n<p>判断热点代码的方式有两种：</p>\n<ul>\n<li>基于采样的热点探测</li>\n<li>基于计数器的热点探测</li>\n</ul>\n<p>hotspot虚拟机中采用的是第二种。为每个方法提供两种计数器:方法计数器(计数方法被调用次数)和回边计数器(循环体代码执行次数)，当两个计数器的和达到阀值，就会触发JIT编译。在一定的时间内，如果没有代码执行，就会衰减。</p>\n<h3 id=\"编译优化技术\"><a href=\"#编译优化技术\" class=\"headerlink\" title=\"编译优化技术\"></a>编译优化技术</h3><p>编译优化的技术特别多，这里记录下书中的几个。</p>\n<ul>\n<li>方法内联，去除方法调用成本，</li>\n<li>冗余访问消除</li>\n<li>复写传播</li>\n<li>无用代码消除</li>\n<li>公共子表达式消除，没必要重复计算公共子表达式的值</li>\n<li>数组边界检查消除</li>\n<li>逃逸分析，分析对象的动态作用域，一个对象定以后，被外部方法调用，称为方法逃逸，被其他线程访问到，称为线程逃逸<ul>\n<li>栈上分配</li>\n<li>同步消除</li>\n<li>标量替换</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"monkey和monkeyRunner","date":"2017-09-02T11:55:55.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\nMonkey测试还是挺好玩的。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### Monkey\n\n```\nadb shell monkey \n\n```\n\n便可查询一些monkey测试可使用的参数，链接手机或者模拟器\n\n```\nadb shell monkry -p 你的包名 -v 模拟点击次数\n```\n\n就可以执行一些非常简单的monkey测试。\n\n关于更多参数，自行查看提示或者查看文档。\n\n### MonkeyRunner\n\nmonkeyrunner提供了更多可控的操作，一般来说monkey测试太随机了。monkeyrunner可以执行一段我们预先可好的脚本，按照我们的要求去执行。\n\n[monkeyrunner基础文档](https://developer.android.com/studio/test/monkeyrunner/index.html)\n\n\n而我们只要在终端执行monkeyrunner，就能进入交互式环境。像写python一些编写，不过这里是jython。不多bb\n\n### 从源码中找寻可用api\n\n实话说，这里才是我想说的重点，monkery和monkeyrunner的用法，网上随处可见，但都千篇一律。似乎官方也没给出太多的文档。不过我们可以从源码中找到用法，但是是哪jython写的，不影响我们看。怎么滴一点简单的python总会吧。\n以monkeydrvice为例。他的源码在这里。[点我看代码，翻墙必须的](https://android.googlesource.com/platform/tools/swt/+/d9880c7c4d4c12d94d2059453361f1c3691a901d/monkeyrunner/src/main/java/com/android/monkeyrunner/MonkeyDevice.java?autodive=0%2F%2F%2F)\n\n找一个文档中没有给的例子\n\n```\n    @MonkeyRunnerExported(doc = \"Get the HierarchyViewer object for the device.\",\n            returns = \"A HierarchyViewer object\")\n    public HierarchyViewer getHierarchyViewer(PyObject[] args, String[] kws) {\n        return impl.getHierarchyViewer();\n    }\n```\n\n这个方法在文档中是没有给的，不过我们可以用这个，但是这个又涉及到HierarchyViewer的一些操作。没关系，我们知道如从源码中找寻可用api就行了。\n\n在举个带参数的例子。\n\n```\n    @MonkeyRunnerExported(doc = \"Given the name of a variable on the device, \" +\n            \"returns the variable's value\",\n            args = {\"key\"},\n            argDocs = {\"The name of the variable. The available names are listed in \" +\n            \"http://developer.android.com/guide/topics/testing/monkeyrunner.html.\"},\n            returns = \"The variable's value\")\n    public String getProperty(PyObject[] args, String[] kws) {\n        ArgParser ap = JythonUtils.createArgParser(args, kws);\n        Preconditions.checkNotNull(ap);\n        return impl.getProperty(ap.getString(0));\n    }\n```\n\n不想多说什么，清晰的不能再清晰了，虽然我们看不懂源码，但是我们却能冲MonkeyRunnerExported中找到用法。包裹参数，返回值等等信息。\n\n并且，源码中有很多文档被没有给出但是却额能十分有用的东西，比如easy、recorder等等。\n\n而HierarchyViewer，我们可以从[HierarchyViewer源码](https://android.googlesource.com/platform/tools/swt/+/d9880c7c4d4c12d94d2059453361f1c3691a901d/chimpchat/src/main/java/com/android/chimpchat/hierarchyviewer/HierarchyViewer.java?autodive=0%2F%2F%2F%2F%2F%2F%2F%2F)  获取到他的用法。\n\nandroid/platform/tools/下面，有非常多的工具，作为Android开发者，我觉得是有必要了解的。\n\n[地址，记得翻墙](https://android.googlesource.com/platform/tools/) \n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/monkey和monkeyRunner.md","raw":"---\ntitle: monkey和monkeyRunner\ndate: 2017-09-02 19:55:55\ntags: Android\ncategories: 自动化测试\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\nMonkey测试还是挺好玩的。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### Monkey\n\n```\nadb shell monkey \n\n```\n\n便可查询一些monkey测试可使用的参数，链接手机或者模拟器\n\n```\nadb shell monkry -p 你的包名 -v 模拟点击次数\n```\n\n就可以执行一些非常简单的monkey测试。\n\n关于更多参数，自行查看提示或者查看文档。\n\n### MonkeyRunner\n\nmonkeyrunner提供了更多可控的操作，一般来说monkey测试太随机了。monkeyrunner可以执行一段我们预先可好的脚本，按照我们的要求去执行。\n\n[monkeyrunner基础文档](https://developer.android.com/studio/test/monkeyrunner/index.html)\n\n\n而我们只要在终端执行monkeyrunner，就能进入交互式环境。像写python一些编写，不过这里是jython。不多bb\n\n### 从源码中找寻可用api\n\n实话说，这里才是我想说的重点，monkery和monkeyrunner的用法，网上随处可见，但都千篇一律。似乎官方也没给出太多的文档。不过我们可以从源码中找到用法，但是是哪jython写的，不影响我们看。怎么滴一点简单的python总会吧。\n以monkeydrvice为例。他的源码在这里。[点我看代码，翻墙必须的](https://android.googlesource.com/platform/tools/swt/+/d9880c7c4d4c12d94d2059453361f1c3691a901d/monkeyrunner/src/main/java/com/android/monkeyrunner/MonkeyDevice.java?autodive=0%2F%2F%2F)\n\n找一个文档中没有给的例子\n\n```\n    @MonkeyRunnerExported(doc = \"Get the HierarchyViewer object for the device.\",\n            returns = \"A HierarchyViewer object\")\n    public HierarchyViewer getHierarchyViewer(PyObject[] args, String[] kws) {\n        return impl.getHierarchyViewer();\n    }\n```\n\n这个方法在文档中是没有给的，不过我们可以用这个，但是这个又涉及到HierarchyViewer的一些操作。没关系，我们知道如从源码中找寻可用api就行了。\n\n在举个带参数的例子。\n\n```\n    @MonkeyRunnerExported(doc = \"Given the name of a variable on the device, \" +\n            \"returns the variable's value\",\n            args = {\"key\"},\n            argDocs = {\"The name of the variable. The available names are listed in \" +\n            \"http://developer.android.com/guide/topics/testing/monkeyrunner.html.\"},\n            returns = \"The variable's value\")\n    public String getProperty(PyObject[] args, String[] kws) {\n        ArgParser ap = JythonUtils.createArgParser(args, kws);\n        Preconditions.checkNotNull(ap);\n        return impl.getProperty(ap.getString(0));\n    }\n```\n\n不想多说什么，清晰的不能再清晰了，虽然我们看不懂源码，但是我们却能冲MonkeyRunnerExported中找到用法。包裹参数，返回值等等信息。\n\n并且，源码中有很多文档被没有给出但是却额能十分有用的东西，比如easy、recorder等等。\n\n而HierarchyViewer，我们可以从[HierarchyViewer源码](https://android.googlesource.com/platform/tools/swt/+/d9880c7c4d4c12d94d2059453361f1c3691a901d/chimpchat/src/main/java/com/android/chimpchat/hierarchyviewer/HierarchyViewer.java?autodive=0%2F%2F%2F%2F%2F%2F%2F%2F)  获取到他的用法。\n\nandroid/platform/tools/下面，有非常多的工具，作为Android开发者，我觉得是有必要了解的。\n\n[地址，记得翻墙](https://android.googlesource.com/platform/tools/) \n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"monkey和monkeyRunner","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslze004a19fyz9yun3yz","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Monkey测试还是挺好玩的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"Monkey\"><a href=\"#Monkey\" class=\"headerlink\" title=\"Monkey\"></a>Monkey</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell monkey</div></pre></td></tr></table></figure>\n<p>便可查询一些monkey测试可使用的参数，链接手机或者模拟器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell monkry -p 你的包名 -v 模拟点击次数</div></pre></td></tr></table></figure>\n<p>就可以执行一些非常简单的monkey测试。</p>\n<p>关于更多参数，自行查看提示或者查看文档。</p>\n<h3 id=\"MonkeyRunner\"><a href=\"#MonkeyRunner\" class=\"headerlink\" title=\"MonkeyRunner\"></a>MonkeyRunner</h3><p>monkeyrunner提供了更多可控的操作，一般来说monkey测试太随机了。monkeyrunner可以执行一段我们预先可好的脚本，按照我们的要求去执行。</p>\n<p><a href=\"https://developer.android.com/studio/test/monkeyrunner/index.html\" target=\"_blank\" rel=\"external\">monkeyrunner基础文档</a></p>\n<p>而我们只要在终端执行monkeyrunner，就能进入交互式环境。像写python一些编写，不过这里是jython。不多bb</p>\n<h3 id=\"从源码中找寻可用api\"><a href=\"#从源码中找寻可用api\" class=\"headerlink\" title=\"从源码中找寻可用api\"></a>从源码中找寻可用api</h3><p>实话说，这里才是我想说的重点，monkery和monkeyrunner的用法，网上随处可见，但都千篇一律。似乎官方也没给出太多的文档。不过我们可以从源码中找到用法，但是是哪jython写的，不影响我们看。怎么滴一点简单的python总会吧。<br>以monkeydrvice为例。他的源码在这里。<a href=\"https://android.googlesource.com/platform/tools/swt/+/d9880c7c4d4c12d94d2059453361f1c3691a901d/monkeyrunner/src/main/java/com/android/monkeyrunner/MonkeyDevice.java?autodive=0%2F%2F%2F\" target=\"_blank\" rel=\"external\">点我看代码，翻墙必须的</a></p>\n<p>找一个文档中没有给的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@MonkeyRunnerExported(doc = &quot;Get the HierarchyViewer object for the device.&quot;,</div><div class=\"line\">        returns = &quot;A HierarchyViewer object&quot;)</div><div class=\"line\">public HierarchyViewer getHierarchyViewer(PyObject[] args, String[] kws) &#123;</div><div class=\"line\">    return impl.getHierarchyViewer();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法在文档中是没有给的，不过我们可以用这个，但是这个又涉及到HierarchyViewer的一些操作。没关系，我们知道如从源码中找寻可用api就行了。</p>\n<p>在举个带参数的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@MonkeyRunnerExported(doc = &quot;Given the name of a variable on the device, &quot; +</div><div class=\"line\">        &quot;returns the variable&apos;s value&quot;,</div><div class=\"line\">        args = &#123;&quot;key&quot;&#125;,</div><div class=\"line\">        argDocs = &#123;&quot;The name of the variable. The available names are listed in &quot; +</div><div class=\"line\">        &quot;http://developer.android.com/guide/topics/testing/monkeyrunner.html.&quot;&#125;,</div><div class=\"line\">        returns = &quot;The variable&apos;s value&quot;)</div><div class=\"line\">public String getProperty(PyObject[] args, String[] kws) &#123;</div><div class=\"line\">    ArgParser ap = JythonUtils.createArgParser(args, kws);</div><div class=\"line\">    Preconditions.checkNotNull(ap);</div><div class=\"line\">    return impl.getProperty(ap.getString(0));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不想多说什么，清晰的不能再清晰了，虽然我们看不懂源码，但是我们却能冲MonkeyRunnerExported中找到用法。包裹参数，返回值等等信息。</p>\n<p>并且，源码中有很多文档被没有给出但是却额能十分有用的东西，比如easy、recorder等等。</p>\n<p>而HierarchyViewer，我们可以从<a href=\"https://android.googlesource.com/platform/tools/swt/+/d9880c7c4d4c12d94d2059453361f1c3691a901d/chimpchat/src/main/java/com/android/chimpchat/hierarchyviewer/HierarchyViewer.java?autodive=0%2F%2F%2F%2F%2F%2F%2F%2F\" target=\"_blank\" rel=\"external\">HierarchyViewer源码</a>  获取到他的用法。</p>\n<p>android/platform/tools/下面，有非常多的工具，作为Android开发者，我觉得是有必要了解的。</p>\n<p><a href=\"https://android.googlesource.com/platform/tools/\" target=\"_blank\" rel=\"external\">地址，记得翻墙</a> </p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Monkey测试还是挺好玩的。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"Monkey\"><a href=\"#Monkey\" class=\"headerlink\" title=\"Monkey\"></a>Monkey</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell monkey</div></pre></td></tr></table></figure>\n<p>便可查询一些monkey测试可使用的参数，链接手机或者模拟器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell monkry -p 你的包名 -v 模拟点击次数</div></pre></td></tr></table></figure>\n<p>就可以执行一些非常简单的monkey测试。</p>\n<p>关于更多参数，自行查看提示或者查看文档。</p>\n<h3 id=\"MonkeyRunner\"><a href=\"#MonkeyRunner\" class=\"headerlink\" title=\"MonkeyRunner\"></a>MonkeyRunner</h3><p>monkeyrunner提供了更多可控的操作，一般来说monkey测试太随机了。monkeyrunner可以执行一段我们预先可好的脚本，按照我们的要求去执行。</p>\n<p><a href=\"https://developer.android.com/studio/test/monkeyrunner/index.html\">monkeyrunner基础文档</a></p>\n<p>而我们只要在终端执行monkeyrunner，就能进入交互式环境。像写python一些编写，不过这里是jython。不多bb</p>\n<h3 id=\"从源码中找寻可用api\"><a href=\"#从源码中找寻可用api\" class=\"headerlink\" title=\"从源码中找寻可用api\"></a>从源码中找寻可用api</h3><p>实话说，这里才是我想说的重点，monkery和monkeyrunner的用法，网上随处可见，但都千篇一律。似乎官方也没给出太多的文档。不过我们可以从源码中找到用法，但是是哪jython写的，不影响我们看。怎么滴一点简单的python总会吧。<br>以monkeydrvice为例。他的源码在这里。<a href=\"https://android.googlesource.com/platform/tools/swt/+/d9880c7c4d4c12d94d2059453361f1c3691a901d/monkeyrunner/src/main/java/com/android/monkeyrunner/MonkeyDevice.java?autodive=0%2F%2F%2F\">点我看代码，翻墙必须的</a></p>\n<p>找一个文档中没有给的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@MonkeyRunnerExported(doc = &quot;Get the HierarchyViewer object for the device.&quot;,</div><div class=\"line\">        returns = &quot;A HierarchyViewer object&quot;)</div><div class=\"line\">public HierarchyViewer getHierarchyViewer(PyObject[] args, String[] kws) &#123;</div><div class=\"line\">    return impl.getHierarchyViewer();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法在文档中是没有给的，不过我们可以用这个，但是这个又涉及到HierarchyViewer的一些操作。没关系，我们知道如从源码中找寻可用api就行了。</p>\n<p>在举个带参数的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@MonkeyRunnerExported(doc = &quot;Given the name of a variable on the device, &quot; +</div><div class=\"line\">        &quot;returns the variable&apos;s value&quot;,</div><div class=\"line\">        args = &#123;&quot;key&quot;&#125;,</div><div class=\"line\">        argDocs = &#123;&quot;The name of the variable. The available names are listed in &quot; +</div><div class=\"line\">        &quot;http://developer.android.com/guide/topics/testing/monkeyrunner.html.&quot;&#125;,</div><div class=\"line\">        returns = &quot;The variable&apos;s value&quot;)</div><div class=\"line\">public String getProperty(PyObject[] args, String[] kws) &#123;</div><div class=\"line\">    ArgParser ap = JythonUtils.createArgParser(args, kws);</div><div class=\"line\">    Preconditions.checkNotNull(ap);</div><div class=\"line\">    return impl.getProperty(ap.getString(0));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不想多说什么，清晰的不能再清晰了，虽然我们看不懂源码，但是我们却能冲MonkeyRunnerExported中找到用法。包裹参数，返回值等等信息。</p>\n<p>并且，源码中有很多文档被没有给出但是却额能十分有用的东西，比如easy、recorder等等。</p>\n<p>而HierarchyViewer，我们可以从<a href=\"https://android.googlesource.com/platform/tools/swt/+/d9880c7c4d4c12d94d2059453361f1c3691a901d/chimpchat/src/main/java/com/android/chimpchat/hierarchyviewer/HierarchyViewer.java?autodive=0%2F%2F%2F%2F%2F%2F%2F%2F\">HierarchyViewer源码</a>  获取到他的用法。</p>\n<p>android/platform/tools/下面，有非常多的工具，作为Android开发者，我觉得是有必要了解的。</p>\n<p><a href=\"https://android.googlesource.com/platform/tools/\">地址，记得翻墙</a> </p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"tinker-diff和patch","date":"2017-04-14T07:37:27.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n本篇轮到说客户端进行patch操作已经patch包生成的过程了。由于这里面涉及到的东西太复杂，就不讲原理了.\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### TinkerPatchService\n\n这个service就是用来进行patch的，因为patch合成的过程是一个耗时操作。默认的进行合成的类\n\n```\n        try {\n            if (upgradePatchProcessor == null) {\n                throw new TinkerRuntimeException(\"upgradePatchProcessor is null.\");\n            }\n            result = upgradePatchProcessor.tryPatch(context, path, patchResult);\n        } catch (Throwable throwable) {\n            e = throwable;\n            result = false;\n            tinker.getPatchReporter().onPatchException(patchFile, e);\n        }\n```\n\n在这里，利用upgradePatchProcessor.tryPatch去进行patch操作，默认的实现为UpgradePatch这个类。在这个类中，有如下代码。\n\n```\n        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {\n            TinkerLog.e(TAG, \"UpgradePatch tryPatch:new patch recover, try patch dex failed\");\n            return false;\n        }\n\n        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {\n            TinkerLog.e(TAG, \"UpgradePatch tryPatch:new patch recover, try patch library failed\");\n            return false;\n        }\n\n        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {\n            TinkerLog.e(TAG, \"UpgradePatch tryPatch:new patch recover, try patch resource failed\");\n            return false;\n        }\n```\n\n上面的代码，分别针对dex，so，resource。\n\n### bsdiff和bspatch\n\n这个是针对二进制文件进行差分和合成的，我昨天试了下，发现即使修改一点点内容，生成的差分文件还是比较大。\n\n[Binary diff/patch utility](http://www.daemonology.net/bsdiff/)\n\n大家可以去上面的链接中，下载到对应的源代码，自行编译，尝试。tinker中使用的对应的java版本，代码几乎完全一致。\n\n如果想了解原理的话，可以参考[ [差量更新系列1]BSDiff算法学习笔记](http://blog.csdn.net/add_ada/article/details/51232889),这篇文章。\n\n不过编译之前，我们需要修改点东西，首先，将Makefile文件的倒数第一行和倒数第三行增加缩进。然后在bspatch.c文件中，添加\n\n```\ntypedef unsigned char u_char;\n```\n\n从新编译，即可生成bsdiff和bspatch的可执行文件。./bsdiff ./bspatch会有提示。如何使用\n\n### dexdiff和dexpatch\n\n这个算法就高大上了，大家可以看这篇文章进行学习。[Tinker Dexdiff算法解析](https://www.zybuluo.com/dodola/note/554061)。\n\n\n### 总结\n\n这一部分是tinker的核心内容之一，虽然比较难懂，但是资料还是不少的。\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/tinker-diff和patch.md","raw":"---\ntitle: tinker-diff和patch\ndate: 2017-04-14 15:37:27\ntags: tinker\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n本篇轮到说客户端进行patch操作已经patch包生成的过程了。由于这里面涉及到的东西太复杂，就不讲原理了.\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### TinkerPatchService\n\n这个service就是用来进行patch的，因为patch合成的过程是一个耗时操作。默认的进行合成的类\n\n```\n        try {\n            if (upgradePatchProcessor == null) {\n                throw new TinkerRuntimeException(\"upgradePatchProcessor is null.\");\n            }\n            result = upgradePatchProcessor.tryPatch(context, path, patchResult);\n        } catch (Throwable throwable) {\n            e = throwable;\n            result = false;\n            tinker.getPatchReporter().onPatchException(patchFile, e);\n        }\n```\n\n在这里，利用upgradePatchProcessor.tryPatch去进行patch操作，默认的实现为UpgradePatch这个类。在这个类中，有如下代码。\n\n```\n        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {\n            TinkerLog.e(TAG, \"UpgradePatch tryPatch:new patch recover, try patch dex failed\");\n            return false;\n        }\n\n        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {\n            TinkerLog.e(TAG, \"UpgradePatch tryPatch:new patch recover, try patch library failed\");\n            return false;\n        }\n\n        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) {\n            TinkerLog.e(TAG, \"UpgradePatch tryPatch:new patch recover, try patch resource failed\");\n            return false;\n        }\n```\n\n上面的代码，分别针对dex，so，resource。\n\n### bsdiff和bspatch\n\n这个是针对二进制文件进行差分和合成的，我昨天试了下，发现即使修改一点点内容，生成的差分文件还是比较大。\n\n[Binary diff/patch utility](http://www.daemonology.net/bsdiff/)\n\n大家可以去上面的链接中，下载到对应的源代码，自行编译，尝试。tinker中使用的对应的java版本，代码几乎完全一致。\n\n如果想了解原理的话，可以参考[ [差量更新系列1]BSDiff算法学习笔记](http://blog.csdn.net/add_ada/article/details/51232889),这篇文章。\n\n不过编译之前，我们需要修改点东西，首先，将Makefile文件的倒数第一行和倒数第三行增加缩进。然后在bspatch.c文件中，添加\n\n```\ntypedef unsigned char u_char;\n```\n\n从新编译，即可生成bsdiff和bspatch的可执行文件。./bsdiff ./bspatch会有提示。如何使用\n\n### dexdiff和dexpatch\n\n这个算法就高大上了，大家可以看这篇文章进行学习。[Tinker Dexdiff算法解析](https://www.zybuluo.com/dodola/note/554061)。\n\n\n### 总结\n\n这一部分是tinker的核心内容之一，虽然比较难懂，但是资料还是不少的。\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"tinker-diff和patch","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzg004c19fyzqef31au","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本篇轮到说客户端进行patch操作已经patch包生成的过程了。由于这里面涉及到的东西太复杂，就不讲原理了.</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"TinkerPatchService\"><a href=\"#TinkerPatchService\" class=\"headerlink\" title=\"TinkerPatchService\"></a>TinkerPatchService</h3><p>这个service就是用来进行patch的，因为patch合成的过程是一个耗时操作。默认的进行合成的类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    if (upgradePatchProcessor == null) &#123;</div><div class=\"line\">        throw new TinkerRuntimeException(&quot;upgradePatchProcessor is null.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    result = upgradePatchProcessor.tryPatch(context, path, patchResult);</div><div class=\"line\">&#125; catch (Throwable throwable) &#123;</div><div class=\"line\">    e = throwable;</div><div class=\"line\">    result = false;</div><div class=\"line\">    tinker.getPatchReporter().onPatchException(patchFile, e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，利用upgradePatchProcessor.tryPatch去进行patch操作，默认的实现为UpgradePatch这个类。在这个类中，有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class=\"line\">    TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch dex failed&quot;);</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class=\"line\">    TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch library failed&quot;);</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class=\"line\">    TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch resource failed&quot;);</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码，分别针对dex，so，resource。</p>\n<h3 id=\"bsdiff和bspatch\"><a href=\"#bsdiff和bspatch\" class=\"headerlink\" title=\"bsdiff和bspatch\"></a>bsdiff和bspatch</h3><p>这个是针对二进制文件进行差分和合成的，我昨天试了下，发现即使修改一点点内容，生成的差分文件还是比较大。</p>\n<p><a href=\"http://www.daemonology.net/bsdiff/\" target=\"_blank\" rel=\"external\">Binary diff/patch utility</a></p>\n<p>大家可以去上面的链接中，下载到对应的源代码，自行编译，尝试。tinker中使用的对应的java版本，代码几乎完全一致。</p>\n<p>如果想了解原理的话，可以参考<a href=\"http://blog.csdn.net/add_ada/article/details/51232889\" target=\"_blank\" rel=\"external\"> [差量更新系列1]BSDiff算法学习笔记</a>,这篇文章。</p>\n<p>不过编译之前，我们需要修改点东西，首先，将Makefile文件的倒数第一行和倒数第三行增加缩进。然后在bspatch.c文件中，添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char u_char;</div></pre></td></tr></table></figure>\n<p>从新编译，即可生成bsdiff和bspatch的可执行文件。./bsdiff ./bspatch会有提示。如何使用</p>\n<h3 id=\"dexdiff和dexpatch\"><a href=\"#dexdiff和dexpatch\" class=\"headerlink\" title=\"dexdiff和dexpatch\"></a>dexdiff和dexpatch</h3><p>这个算法就高大上了，大家可以看这篇文章进行学习。<a href=\"https://www.zybuluo.com/dodola/note/554061\" target=\"_blank\" rel=\"external\">Tinker Dexdiff算法解析</a>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这一部分是tinker的核心内容之一，虽然比较难懂，但是资料还是不少的。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本篇轮到说客户端进行patch操作已经patch包生成的过程了。由于这里面涉及到的东西太复杂，就不讲原理了.</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"TinkerPatchService\"><a href=\"#TinkerPatchService\" class=\"headerlink\" title=\"TinkerPatchService\"></a>TinkerPatchService</h3><p>这个service就是用来进行patch的，因为patch合成的过程是一个耗时操作。默认的进行合成的类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    if (upgradePatchProcessor == null) &#123;</div><div class=\"line\">        throw new TinkerRuntimeException(&quot;upgradePatchProcessor is null.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    result = upgradePatchProcessor.tryPatch(context, path, patchResult);</div><div class=\"line\">&#125; catch (Throwable throwable) &#123;</div><div class=\"line\">    e = throwable;</div><div class=\"line\">    result = false;</div><div class=\"line\">    tinker.getPatchReporter().onPatchException(patchFile, e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，利用upgradePatchProcessor.tryPatch去进行patch操作，默认的实现为UpgradePatch这个类。在这个类中，有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class=\"line\">    TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch dex failed&quot;);</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class=\"line\">    TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch library failed&quot;);</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class=\"line\">    TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch resource failed&quot;);</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码，分别针对dex，so，resource。</p>\n<h3 id=\"bsdiff和bspatch\"><a href=\"#bsdiff和bspatch\" class=\"headerlink\" title=\"bsdiff和bspatch\"></a>bsdiff和bspatch</h3><p>这个是针对二进制文件进行差分和合成的，我昨天试了下，发现即使修改一点点内容，生成的差分文件还是比较大。</p>\n<p><a href=\"http://www.daemonology.net/bsdiff/\">Binary diff/patch utility</a></p>\n<p>大家可以去上面的链接中，下载到对应的源代码，自行编译，尝试。tinker中使用的对应的java版本，代码几乎完全一致。</p>\n<p>如果想了解原理的话，可以参考<a href=\"http://blog.csdn.net/add_ada/article/details/51232889\"> [差量更新系列1]BSDiff算法学习笔记</a>,这篇文章。</p>\n<p>不过编译之前，我们需要修改点东西，首先，将Makefile文件的倒数第一行和倒数第三行增加缩进。然后在bspatch.c文件中，添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char u_char;</div></pre></td></tr></table></figure>\n<p>从新编译，即可生成bsdiff和bspatch的可执行文件。./bsdiff ./bspatch会有提示。如何使用</p>\n<h3 id=\"dexdiff和dexpatch\"><a href=\"#dexdiff和dexpatch\" class=\"headerlink\" title=\"dexdiff和dexpatch\"></a>dexdiff和dexpatch</h3><p>这个算法就高大上了，大家可以看这篇文章进行学习。<a href=\"https://www.zybuluo.com/dodola/note/554061\">Tinker Dexdiff算法解析</a>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这一部分是tinker的核心内容之一，虽然比较难懂，但是资料还是不少的。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"tinker-application","date":"2017-04-09T14:54:53.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n从上文的一些知识中，知道，真正的Application是注解生成的，并且继承与TinkerApplication。那么我们就来分析下。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### attachBaseContext\n\n首先看attachBaseContext这个方法。\n\n```\n    @Override\n    protected void attachBaseContext(Context base) {\n        super.attachBaseContext(base);\n        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));\n        onBaseContextAttached(base);\n    }\n```\n\n* 设置UncaughtExceptionHandler\n* 调用onBaseContextAttached方法。\n\nonBaseContextAttached方法代码如下：\n\n```\n    private void onBaseContextAttached(Context base) {\n        applicationStartElapsedTime = SystemClock.elapsedRealtime();\n        applicationStartMillisTime = System.currentTimeMillis();\n        loadTinker();\n        ensureDelegate();\n        applicationLike.onBaseContextAttached(base);\n        //reset save mode\n        if (useSafeMode) {\n            String processName = ShareTinkerInternals.getProcessName(this);\n            String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;\n            SharedPreferences sp = getSharedPreferences(preferName, Context.MODE_PRIVATE);\n            sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();\n        }\n    }\n```\n\n* 获取系统已运行时间，作为applicationStartElapsedTime\n* 获取系统当前时间，作为applicationStartMillisTime\n* loadTinker() load tinker\n* ensureDelegate 确认下delegate是否没有初始化\n* 调用applicationLike的onBaseContextAttached方法，对应demo中的SampleApplicationLike的onBaseContextAttached方法。\n* 如果是安全模式，就获取当前进程名，preferName，并将安全模式count置为0。\n\n\n#### loadTinker\n\n代码如下：\n\n```\n    private void loadTinker() {\n        //disable tinker, not need to install\n        if (tinkerFlags == TINKER_DISABLE) {\n            return;\n        }\n        tinkerResultIntent = new Intent();\n        try {\n            //reflect tinker loader, because loaderClass may be define by user!\n            Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());\n\n            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);\n            Constructor<?> constructor = tinkerLoadClass.getConstructor();\n            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);\n        } catch (Throwable e) {\n            //has exception, put exception error code\n            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);\n            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);\n        }\n    }\n```\n\n* 首先判断flag，如果为TINKER_DISABLE，直接return\n* 生成tinkerLoadClass的Class\n* 获得tryLoad方法的Method\n* 获取tinkerLoadClass的构造方法\n* 调用tryLoad方法返回Intent对象\n\n#### ensureDelegate\n\n```\n   private synchronized void ensureDelegate() {\n        if (applicationLike == null) {\n            applicationLike = createDelegate();\n        }\n    }\n```\n\n在这个方法中，会判断applicationLike是不是null，如果是的话，就调用createDelegate去创建一个代理对象。\n\n```\n    private ApplicationLike createDelegate() {\n        try {\n            // Use reflection to create the delegate so it doesn't need to go into the primary dex.\n            // And we can also patch it\n            Class<?> delegateClass = Class.forName(delegateClassName, false, getClassLoader());\n            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,\n                long.class, long.class, Intent.class);\n            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,\n                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);\n        } catch (Throwable e) {\n            throw new TinkerRuntimeException(\"createDelegate failed\", e);\n        }\n    }\n```\n\n在这个方法中，通过反射构造出一个代理对象，根据demo传入的参数，这里构造出来的对象，是SampleApplicationLike。\n\n在看下SampleApplicationLike的构造方法吧。\n\n```\n    public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,\n                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {\n        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);\n    }\n```\n\n参数很明显，我们还需要看下继承关系。SampleApplicationLike->DefaultApplicationLike->ApplicationLike,ApplicationLike实现了ApplicationLifeCycle的一系列接口。这个接口完全按照Application的一些方法，比如onCreate,onLowMemory等等。\n\nSampleApplicationLike的构造方法会调用父类的构造方法，最后调用到ApplicationLike的。\n\n```\n    public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,\n                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {\n        this.application = application;\n        this.tinkerFlags = tinkerFlags;\n        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;\n        this.applicationStartElapsedTime = applicationStartElapsedTime;\n        this.applicationStartMillisTime = applicationStartMillisTime;\n        this.tinkerResultIntent = tinkerResultIntent;\n    }\n```\n\n这里就是把参数进行初始化。\n\n#### SampleApplicationLike#onBaseContextAttached\n\n```\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    @Override\n    public void onBaseContextAttached(Context base) {\n        super.onBaseContextAttached(base);\n        //you must install multiDex whatever tinker is installed!\n        MultiDex.install(base);\n\n        SampleApplicationContext.application = getApplication();\n        SampleApplicationContext.context = getApplication();\n        TinkerManager.setTinkerApplicationLike(this);\n\n        TinkerManager.initFastCrashProtect();\n        //should set before tinker is installed\n        TinkerManager.setUpgradeRetryEnable(true);\n\n        //optional set logIml, or you can use default debug log\n        TinkerInstaller.setLogIml(new MyLogImp());\n\n        //installTinker after load multiDex\n        //or you can put com.tencent.tinker.** to main dex\n        TinkerManager.installTinker(this);\n        Tinker tinker = Tinker.with(getApplication());\n    }\n```\n\n* 首先调用MultiDex.install方法\n* 然后初始化一些个参数\n* 调用TinkerManager的一些方法来初始化或者设置一些值\n* 然后installTinker\n* 生成一个Tinker对象\n\n### \n\n#### 小结\n\n从逻辑流程来看，核心部分在于TinkerLoadeClass的tryLoad，以及TinkerManager的一些方法。其他的方法就是做一些初始化之类的工作，当然，这些也很重要。\n\n### TinkerLoader#tryLoad方法\n\n```\n    @Override\n    public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag) {\n        Intent resultIntent = new Intent();\n\n        long begin = SystemClock.elapsedRealtime();\n        tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);\n        long cost = SystemClock.elapsedRealtime() - begin;\n        ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);\n        return resultIntent;\n    }\n```\n\n这个方法内部主要是调用tryLoadPatchFilesInternal方法，\n\n```\nprivate void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag, Intent resultIntent) {\n        if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);\n            return;\n        }\n        //tinker\n        File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);\n        if (patchDirectoryFile == null) {\n            Log.w(TAG, \"tryLoadPatchFiles:getPatchDirectory == null\");\n            //treat as not exist\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n            return;\n        }\n        String patchDirectoryPath = patchDirectoryFile.getAbsolutePath();\n\n        //check patch directory whether exist\n        if (!patchDirectoryFile.exists()) {\n            Log.w(TAG, \"tryLoadPatchFiles:patch dir not exist:\" + patchDirectoryPath);\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n            return;\n        }\n\n        //tinker/patch.info\n        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);\n\n        //check patch info file whether exist\n        if (!patchInfoFile.exists()) {\n            Log.w(TAG, \"tryLoadPatchFiles:patch info not exist:\" + patchInfoFile.getAbsolutePath());\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);\n            return;\n        }\n        //old = 641e634c5b8f1649c75caf73794acbdf\n        //new = 2c150d8560334966952678930ba67fa8\n        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);\n\n        patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);\n        if (patchInfo == null) {\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n            return;\n        }\n\n        String oldVersion = patchInfo.oldVersion;\n        String newVersion = patchInfo.newVersion;\n\n        if (oldVersion == null || newVersion == null) {\n            //it is nice to clean patch\n            Log.w(TAG, \"tryLoadPatchFiles:onPatchInfoCorrupted\");\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n            return;\n        }\n\n        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);\n        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);\n\n        boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);\n        boolean versionChanged = !(oldVersion.equals(newVersion));\n\n        String version = oldVersion;\n        if (versionChanged && mainProcess) {\n            version = newVersion;\n        }\n        if (ShareTinkerInternals.isNullOrNil(version)) {\n            Log.w(TAG, \"tryLoadPatchFiles:version is blank, wait main process to restart\");\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);\n            return;\n        }\n\n        //patch-641e634c\n        String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);\n        if (patchName == null) {\n            Log.w(TAG, \"tryLoadPatchFiles:patchName is null\");\n            //we may delete patch info file\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n            return;\n        }\n        //tinker/patch.info/patch-641e634c\n        String patchVersionDirectory = patchDirectoryPath + \"/\" + patchName;\n        File patchVersionDirectoryFile = new File(patchVersionDirectory);\n\n        if (!patchVersionDirectoryFile.exists()) {\n            Log.w(TAG, \"tryLoadPatchFiles:onPatchVersionDirectoryNotFound\");\n            //we may delete patch info file\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n            return;\n        }\n\n        //tinker/patch.info/patch-641e634c/patch-641e634c.apk\n        File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));\n\n        if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {\n            Log.w(TAG, \"tryLoadPatchFiles:onPatchVersionFileNotFound\");\n            //we may delete patch info file\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);\n            return;\n        }\n\n        ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);\n\n        int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);\n        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {\n            Log.w(TAG, \"tryLoadPatchFiles:checkTinkerPackage\");\n            resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);\n            return;\n        }\n\n        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());\n\n        final boolean isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);\n\n        if (isEnabledForDex) {\n            //tinker/patch.info/patch-641e634c/dex\n            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);\n            if (!dexCheck) {\n                //file not found, do not load patch\n                Log.w(TAG, \"tryLoadPatchFiles:dex check fail\");\n                return;\n            }\n        }\n\n        final boolean isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);\n\n        if (isEnabledForNativeLib) {\n            //tinker/patch.info/patch-641e634c/lib\n            boolean libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);\n            if (!libCheck) {\n                //file not found, do not load patch\n                Log.w(TAG, \"tryLoadPatchFiles:native lib check fail\");\n                return;\n            }\n        }\n\n        //check resource\n        final boolean isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);\n        Log.w(TAG, \"tryLoadPatchFiles:isEnabledForResource:\" + isEnabledForResource);\n        if (isEnabledForResource) {\n            boolean resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);\n            if (!resourceCheck) {\n                //file not found, do not load patch\n                Log.w(TAG, \"tryLoadPatchFiles:resource check fail\");\n                return;\n            }\n        }\n        //only work for art platform oat\n        boolean isSystemOTA = ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);\n        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);\n\n        //we should first try rewrite patch info file, if there is a error, we can't load jar\n        if (isSystemOTA\n            || (mainProcess && versionChanged)) {\n            patchInfo.oldVersion = version;\n            //update old version to new\n            if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {\n                ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n                Log.w(TAG, \"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n                return;\n            }\n        }\n        if (!checkSafeModeCount(app)) {\n            resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, new TinkerRuntimeException(\"checkSafeModeCount fail\"));\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);\n            Log.w(TAG, \"tryLoadPatchFiles:checkSafeModeCount fail\");\n            return;\n        }\n        //now we can load patch jar\n        if (isEnabledForDex) {\n            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);\n            if (!loadTinkerJars) {\n                Log.w(TAG, \"tryLoadPatchFiles:onPatchLoadDexesFail\");\n                return;\n            }\n        }\n\n        //now we can load patch resource\n        if (isEnabledForResource) {\n            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);\n            if (!loadTinkerResources) {\n                Log.w(TAG, \"tryLoadPatchFiles:onPatchLoadResourcesFail\");\n                return;\n            }\n        }\n        //all is ok!\n        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);\n        Log.i(TAG, \"tryLoadPatchFiles: load end, ok!\");\n        return;\n    }\n```\n\n这个方法的代码特别长，但是逻辑并不是特别复杂：\n\n* 首先获取patchDirectoryFile，为/data/user/0/packageName/tinker\n* 获取patchInfoFile、patchInfoLockFile等等\n* 获取旧版本号、新版本号等信息\n* 获取其他的一些信息\n* 进行一些so、dex、resource的check\n* 然后进行load操作\n* 将结果写入intent返回\n\n#### TinkerManager的一些方法\n\n主要是进行参数设置以及Tinker的install操作，Tinker的install操作，由TinkerInstaller的install方法完成。\n\n### TinkerApplication的其他方法\n\n在这里的其他方法中，我们看到的代码几乎都是将这些操作，委托(代理)SampleApplicationLike中对应的方法来完成。\n\n\n### 总结\n\n过程如下，先loadTinker，在这里面会进行tryLoad操作，然后在创建代理对象，最后调用applicationLike的#onBaseContextAttached方法来初始化TinkerManager以及Tinker的安装。\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/tinker-application.md","raw":"---\ntitle: tinker-application\ndate: 2017-04-09 22:54:53\ntags: tinker\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n从上文的一些知识中，知道，真正的Application是注解生成的，并且继承与TinkerApplication。那么我们就来分析下。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### attachBaseContext\n\n首先看attachBaseContext这个方法。\n\n```\n    @Override\n    protected void attachBaseContext(Context base) {\n        super.attachBaseContext(base);\n        Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));\n        onBaseContextAttached(base);\n    }\n```\n\n* 设置UncaughtExceptionHandler\n* 调用onBaseContextAttached方法。\n\nonBaseContextAttached方法代码如下：\n\n```\n    private void onBaseContextAttached(Context base) {\n        applicationStartElapsedTime = SystemClock.elapsedRealtime();\n        applicationStartMillisTime = System.currentTimeMillis();\n        loadTinker();\n        ensureDelegate();\n        applicationLike.onBaseContextAttached(base);\n        //reset save mode\n        if (useSafeMode) {\n            String processName = ShareTinkerInternals.getProcessName(this);\n            String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;\n            SharedPreferences sp = getSharedPreferences(preferName, Context.MODE_PRIVATE);\n            sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();\n        }\n    }\n```\n\n* 获取系统已运行时间，作为applicationStartElapsedTime\n* 获取系统当前时间，作为applicationStartMillisTime\n* loadTinker() load tinker\n* ensureDelegate 确认下delegate是否没有初始化\n* 调用applicationLike的onBaseContextAttached方法，对应demo中的SampleApplicationLike的onBaseContextAttached方法。\n* 如果是安全模式，就获取当前进程名，preferName，并将安全模式count置为0。\n\n\n#### loadTinker\n\n代码如下：\n\n```\n    private void loadTinker() {\n        //disable tinker, not need to install\n        if (tinkerFlags == TINKER_DISABLE) {\n            return;\n        }\n        tinkerResultIntent = new Intent();\n        try {\n            //reflect tinker loader, because loaderClass may be define by user!\n            Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());\n\n            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);\n            Constructor<?> constructor = tinkerLoadClass.getConstructor();\n            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);\n        } catch (Throwable e) {\n            //has exception, put exception error code\n            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);\n            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);\n        }\n    }\n```\n\n* 首先判断flag，如果为TINKER_DISABLE，直接return\n* 生成tinkerLoadClass的Class\n* 获得tryLoad方法的Method\n* 获取tinkerLoadClass的构造方法\n* 调用tryLoad方法返回Intent对象\n\n#### ensureDelegate\n\n```\n   private synchronized void ensureDelegate() {\n        if (applicationLike == null) {\n            applicationLike = createDelegate();\n        }\n    }\n```\n\n在这个方法中，会判断applicationLike是不是null，如果是的话，就调用createDelegate去创建一个代理对象。\n\n```\n    private ApplicationLike createDelegate() {\n        try {\n            // Use reflection to create the delegate so it doesn't need to go into the primary dex.\n            // And we can also patch it\n            Class<?> delegateClass = Class.forName(delegateClassName, false, getClassLoader());\n            Constructor<?> constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,\n                long.class, long.class, Intent.class);\n            return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,\n                applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);\n        } catch (Throwable e) {\n            throw new TinkerRuntimeException(\"createDelegate failed\", e);\n        }\n    }\n```\n\n在这个方法中，通过反射构造出一个代理对象，根据demo传入的参数，这里构造出来的对象，是SampleApplicationLike。\n\n在看下SampleApplicationLike的构造方法吧。\n\n```\n    public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,\n                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {\n        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);\n    }\n```\n\n参数很明显，我们还需要看下继承关系。SampleApplicationLike->DefaultApplicationLike->ApplicationLike,ApplicationLike实现了ApplicationLifeCycle的一系列接口。这个接口完全按照Application的一些方法，比如onCreate,onLowMemory等等。\n\nSampleApplicationLike的构造方法会调用父类的构造方法，最后调用到ApplicationLike的。\n\n```\n    public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,\n                           long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) {\n        this.application = application;\n        this.tinkerFlags = tinkerFlags;\n        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;\n        this.applicationStartElapsedTime = applicationStartElapsedTime;\n        this.applicationStartMillisTime = applicationStartMillisTime;\n        this.tinkerResultIntent = tinkerResultIntent;\n    }\n```\n\n这里就是把参数进行初始化。\n\n#### SampleApplicationLike#onBaseContextAttached\n\n```\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    @Override\n    public void onBaseContextAttached(Context base) {\n        super.onBaseContextAttached(base);\n        //you must install multiDex whatever tinker is installed!\n        MultiDex.install(base);\n\n        SampleApplicationContext.application = getApplication();\n        SampleApplicationContext.context = getApplication();\n        TinkerManager.setTinkerApplicationLike(this);\n\n        TinkerManager.initFastCrashProtect();\n        //should set before tinker is installed\n        TinkerManager.setUpgradeRetryEnable(true);\n\n        //optional set logIml, or you can use default debug log\n        TinkerInstaller.setLogIml(new MyLogImp());\n\n        //installTinker after load multiDex\n        //or you can put com.tencent.tinker.** to main dex\n        TinkerManager.installTinker(this);\n        Tinker tinker = Tinker.with(getApplication());\n    }\n```\n\n* 首先调用MultiDex.install方法\n* 然后初始化一些个参数\n* 调用TinkerManager的一些方法来初始化或者设置一些值\n* 然后installTinker\n* 生成一个Tinker对象\n\n### \n\n#### 小结\n\n从逻辑流程来看，核心部分在于TinkerLoadeClass的tryLoad，以及TinkerManager的一些方法。其他的方法就是做一些初始化之类的工作，当然，这些也很重要。\n\n### TinkerLoader#tryLoad方法\n\n```\n    @Override\n    public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag) {\n        Intent resultIntent = new Intent();\n\n        long begin = SystemClock.elapsedRealtime();\n        tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);\n        long cost = SystemClock.elapsedRealtime() - begin;\n        ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);\n        return resultIntent;\n    }\n```\n\n这个方法内部主要是调用tryLoadPatchFilesInternal方法，\n\n```\nprivate void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag, Intent resultIntent) {\n        if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);\n            return;\n        }\n        //tinker\n        File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);\n        if (patchDirectoryFile == null) {\n            Log.w(TAG, \"tryLoadPatchFiles:getPatchDirectory == null\");\n            //treat as not exist\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n            return;\n        }\n        String patchDirectoryPath = patchDirectoryFile.getAbsolutePath();\n\n        //check patch directory whether exist\n        if (!patchDirectoryFile.exists()) {\n            Log.w(TAG, \"tryLoadPatchFiles:patch dir not exist:\" + patchDirectoryPath);\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n            return;\n        }\n\n        //tinker/patch.info\n        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);\n\n        //check patch info file whether exist\n        if (!patchInfoFile.exists()) {\n            Log.w(TAG, \"tryLoadPatchFiles:patch info not exist:\" + patchInfoFile.getAbsolutePath());\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);\n            return;\n        }\n        //old = 641e634c5b8f1649c75caf73794acbdf\n        //new = 2c150d8560334966952678930ba67fa8\n        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);\n\n        patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);\n        if (patchInfo == null) {\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n            return;\n        }\n\n        String oldVersion = patchInfo.oldVersion;\n        String newVersion = patchInfo.newVersion;\n\n        if (oldVersion == null || newVersion == null) {\n            //it is nice to clean patch\n            Log.w(TAG, \"tryLoadPatchFiles:onPatchInfoCorrupted\");\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n            return;\n        }\n\n        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);\n        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);\n\n        boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);\n        boolean versionChanged = !(oldVersion.equals(newVersion));\n\n        String version = oldVersion;\n        if (versionChanged && mainProcess) {\n            version = newVersion;\n        }\n        if (ShareTinkerInternals.isNullOrNil(version)) {\n            Log.w(TAG, \"tryLoadPatchFiles:version is blank, wait main process to restart\");\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);\n            return;\n        }\n\n        //patch-641e634c\n        String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);\n        if (patchName == null) {\n            Log.w(TAG, \"tryLoadPatchFiles:patchName is null\");\n            //we may delete patch info file\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n            return;\n        }\n        //tinker/patch.info/patch-641e634c\n        String patchVersionDirectory = patchDirectoryPath + \"/\" + patchName;\n        File patchVersionDirectoryFile = new File(patchVersionDirectory);\n\n        if (!patchVersionDirectoryFile.exists()) {\n            Log.w(TAG, \"tryLoadPatchFiles:onPatchVersionDirectoryNotFound\");\n            //we may delete patch info file\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n            return;\n        }\n\n        //tinker/patch.info/patch-641e634c/patch-641e634c.apk\n        File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));\n\n        if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {\n            Log.w(TAG, \"tryLoadPatchFiles:onPatchVersionFileNotFound\");\n            //we may delete patch info file\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);\n            return;\n        }\n\n        ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);\n\n        int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);\n        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {\n            Log.w(TAG, \"tryLoadPatchFiles:checkTinkerPackage\");\n            resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);\n            return;\n        }\n\n        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());\n\n        final boolean isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);\n\n        if (isEnabledForDex) {\n            //tinker/patch.info/patch-641e634c/dex\n            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);\n            if (!dexCheck) {\n                //file not found, do not load patch\n                Log.w(TAG, \"tryLoadPatchFiles:dex check fail\");\n                return;\n            }\n        }\n\n        final boolean isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);\n\n        if (isEnabledForNativeLib) {\n            //tinker/patch.info/patch-641e634c/lib\n            boolean libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);\n            if (!libCheck) {\n                //file not found, do not load patch\n                Log.w(TAG, \"tryLoadPatchFiles:native lib check fail\");\n                return;\n            }\n        }\n\n        //check resource\n        final boolean isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);\n        Log.w(TAG, \"tryLoadPatchFiles:isEnabledForResource:\" + isEnabledForResource);\n        if (isEnabledForResource) {\n            boolean resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);\n            if (!resourceCheck) {\n                //file not found, do not load patch\n                Log.w(TAG, \"tryLoadPatchFiles:resource check fail\");\n                return;\n            }\n        }\n        //only work for art platform oat\n        boolean isSystemOTA = ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);\n        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);\n\n        //we should first try rewrite patch info file, if there is a error, we can't load jar\n        if (isSystemOTA\n            || (mainProcess && versionChanged)) {\n            patchInfo.oldVersion = version;\n            //update old version to new\n            if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {\n                ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n                Log.w(TAG, \"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n                return;\n            }\n        }\n        if (!checkSafeModeCount(app)) {\n            resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, new TinkerRuntimeException(\"checkSafeModeCount fail\"));\n            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);\n            Log.w(TAG, \"tryLoadPatchFiles:checkSafeModeCount fail\");\n            return;\n        }\n        //now we can load patch jar\n        if (isEnabledForDex) {\n            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);\n            if (!loadTinkerJars) {\n                Log.w(TAG, \"tryLoadPatchFiles:onPatchLoadDexesFail\");\n                return;\n            }\n        }\n\n        //now we can load patch resource\n        if (isEnabledForResource) {\n            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);\n            if (!loadTinkerResources) {\n                Log.w(TAG, \"tryLoadPatchFiles:onPatchLoadResourcesFail\");\n                return;\n            }\n        }\n        //all is ok!\n        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);\n        Log.i(TAG, \"tryLoadPatchFiles: load end, ok!\");\n        return;\n    }\n```\n\n这个方法的代码特别长，但是逻辑并不是特别复杂：\n\n* 首先获取patchDirectoryFile，为/data/user/0/packageName/tinker\n* 获取patchInfoFile、patchInfoLockFile等等\n* 获取旧版本号、新版本号等信息\n* 获取其他的一些信息\n* 进行一些so、dex、resource的check\n* 然后进行load操作\n* 将结果写入intent返回\n\n#### TinkerManager的一些方法\n\n主要是进行参数设置以及Tinker的install操作，Tinker的install操作，由TinkerInstaller的install方法完成。\n\n### TinkerApplication的其他方法\n\n在这里的其他方法中，我们看到的代码几乎都是将这些操作，委托(代理)SampleApplicationLike中对应的方法来完成。\n\n\n### 总结\n\n过程如下，先loadTinker，在这里面会进行tryLoad操作，然后在创建代理对象，最后调用applicationLike的#onBaseContextAttached方法来初始化TinkerManager以及Tinker的安装。\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"tinker-application","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzi004h19fy13jyc4v2","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从上文的一些知识中，知道，真正的Application是注解生成的，并且继承与TinkerApplication。那么我们就来分析下。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"attachBaseContext\"><a href=\"#attachBaseContext\" class=\"headerlink\" title=\"attachBaseContext\"></a>attachBaseContext</h3><p>首先看attachBaseContext这个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void attachBaseContext(Context base) &#123;</div><div class=\"line\">    super.attachBaseContext(base);</div><div class=\"line\">    Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));</div><div class=\"line\">    onBaseContextAttached(base);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>设置UncaughtExceptionHandler</li>\n<li>调用onBaseContextAttached方法。</li>\n</ul>\n<p>onBaseContextAttached方法代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onBaseContextAttached(Context base) &#123;</div><div class=\"line\">    applicationStartElapsedTime = SystemClock.elapsedRealtime();</div><div class=\"line\">    applicationStartMillisTime = System.currentTimeMillis();</div><div class=\"line\">    loadTinker();</div><div class=\"line\">    ensureDelegate();</div><div class=\"line\">    applicationLike.onBaseContextAttached(base);</div><div class=\"line\">    //reset save mode</div><div class=\"line\">    if (useSafeMode) &#123;</div><div class=\"line\">        String processName = ShareTinkerInternals.getProcessName(this);</div><div class=\"line\">        String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;</div><div class=\"line\">        SharedPreferences sp = getSharedPreferences(preferName, Context.MODE_PRIVATE);</div><div class=\"line\">        sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>获取系统已运行时间，作为applicationStartElapsedTime</li>\n<li>获取系统当前时间，作为applicationStartMillisTime</li>\n<li>loadTinker() load tinker</li>\n<li>ensureDelegate 确认下delegate是否没有初始化</li>\n<li>调用applicationLike的onBaseContextAttached方法，对应demo中的SampleApplicationLike的onBaseContextAttached方法。</li>\n<li>如果是安全模式，就获取当前进程名，preferName，并将安全模式count置为0。</li>\n</ul>\n<h4 id=\"loadTinker\"><a href=\"#loadTinker\" class=\"headerlink\" title=\"loadTinker\"></a>loadTinker</h4><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void loadTinker() &#123;</div><div class=\"line\">    //disable tinker, not need to install</div><div class=\"line\">    if (tinkerFlags == TINKER_DISABLE) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    tinkerResultIntent = new Intent();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        //reflect tinker loader, because loaderClass may be define by user!</div><div class=\"line\">        Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());</div><div class=\"line\"></div><div class=\"line\">        Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);</div><div class=\"line\">        Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</div><div class=\"line\">        tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);</div><div class=\"line\">    &#125; catch (Throwable e) &#123;</div><div class=\"line\">        //has exception, put exception error code</div><div class=\"line\">        ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</div><div class=\"line\">        tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先判断flag，如果为TINKER_DISABLE，直接return</li>\n<li>生成tinkerLoadClass的Class</li>\n<li>获得tryLoad方法的Method</li>\n<li>获取tinkerLoadClass的构造方法</li>\n<li>调用tryLoad方法返回Intent对象</li>\n</ul>\n<h4 id=\"ensureDelegate\"><a href=\"#ensureDelegate\" class=\"headerlink\" title=\"ensureDelegate\"></a>ensureDelegate</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">private synchronized void ensureDelegate() &#123;</div><div class=\"line\">     if (applicationLike == null) &#123;</div><div class=\"line\">         applicationLike = createDelegate();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，会判断applicationLike是不是null，如果是的话，就调用createDelegate去创建一个代理对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private ApplicationLike createDelegate() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        // Use reflection to create the delegate so it doesn&apos;t need to go into the primary dex.</div><div class=\"line\">        // And we can also patch it</div><div class=\"line\">        Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, false, getClassLoader());</div><div class=\"line\">        Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,</div><div class=\"line\">            long.class, long.class, Intent.class);</div><div class=\"line\">        return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,</div><div class=\"line\">            applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</div><div class=\"line\">    &#125; catch (Throwable e) &#123;</div><div class=\"line\">        throw new TinkerRuntimeException(&quot;createDelegate failed&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，通过反射构造出一个代理对象，根据demo传入的参数，这里构造出来的对象，是SampleApplicationLike。</p>\n<p>在看下SampleApplicationLike的构造方法吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</div><div class=\"line\">                             long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</div><div class=\"line\">    super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>参数很明显，我们还需要看下继承关系。SampleApplicationLike-&gt;DefaultApplicationLike-&gt;ApplicationLike,ApplicationLike实现了ApplicationLifeCycle的一系列接口。这个接口完全按照Application的一些方法，比如onCreate,onLowMemory等等。</p>\n<p>SampleApplicationLike的构造方法会调用父类的构造方法，最后调用到ApplicationLike的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</div><div class=\"line\">                       long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</div><div class=\"line\">    this.application = application;</div><div class=\"line\">    this.tinkerFlags = tinkerFlags;</div><div class=\"line\">    this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</div><div class=\"line\">    this.applicationStartElapsedTime = applicationStartElapsedTime;</div><div class=\"line\">    this.applicationStartMillisTime = applicationStartMillisTime;</div><div class=\"line\">    this.tinkerResultIntent = tinkerResultIntent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里就是把参数进行初始化。</p>\n<h4 id=\"SampleApplicationLike-onBaseContextAttached\"><a href=\"#SampleApplicationLike-onBaseContextAttached\" class=\"headerlink\" title=\"SampleApplicationLike#onBaseContextAttached\"></a>SampleApplicationLike#onBaseContextAttached</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class=\"line\">@Override</div><div class=\"line\">public void onBaseContextAttached(Context base) &#123;</div><div class=\"line\">    super.onBaseContextAttached(base);</div><div class=\"line\">    //you must install multiDex whatever tinker is installed!</div><div class=\"line\">    MultiDex.install(base);</div><div class=\"line\"></div><div class=\"line\">    SampleApplicationContext.application = getApplication();</div><div class=\"line\">    SampleApplicationContext.context = getApplication();</div><div class=\"line\">    TinkerManager.setTinkerApplicationLike(this);</div><div class=\"line\"></div><div class=\"line\">    TinkerManager.initFastCrashProtect();</div><div class=\"line\">    //should set before tinker is installed</div><div class=\"line\">    TinkerManager.setUpgradeRetryEnable(true);</div><div class=\"line\"></div><div class=\"line\">    //optional set logIml, or you can use default debug log</div><div class=\"line\">    TinkerInstaller.setLogIml(new MyLogImp());</div><div class=\"line\"></div><div class=\"line\">    //installTinker after load multiDex</div><div class=\"line\">    //or you can put com.tencent.tinker.** to main dex</div><div class=\"line\">    TinkerManager.installTinker(this);</div><div class=\"line\">    Tinker tinker = Tinker.with(getApplication());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先调用MultiDex.install方法</li>\n<li>然后初始化一些个参数</li>\n<li>调用TinkerManager的一些方法来初始化或者设置一些值</li>\n<li>然后installTinker</li>\n<li>生成一个Tinker对象</li>\n</ul>\n<p>### </p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>从逻辑流程来看，核心部分在于TinkerLoadeClass的tryLoad，以及TinkerManager的一些方法。其他的方法就是做一些初始化之类的工作，当然，这些也很重要。</p>\n<h3 id=\"TinkerLoader-tryLoad方法\"><a href=\"#TinkerLoader-tryLoad方法\" class=\"headerlink\" title=\"TinkerLoader#tryLoad方法\"></a>TinkerLoader#tryLoad方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag) &#123;</div><div class=\"line\">    Intent resultIntent = new Intent();</div><div class=\"line\"></div><div class=\"line\">    long begin = SystemClock.elapsedRealtime();</div><div class=\"line\">    tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);</div><div class=\"line\">    long cost = SystemClock.elapsedRealtime() - begin;</div><div class=\"line\">    ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);</div><div class=\"line\">    return resultIntent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法内部主要是调用tryLoadPatchFilesInternal方法，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag, Intent resultIntent) &#123;</div><div class=\"line\">        if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) &#123;</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //tinker</div><div class=\"line\">        File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);</div><div class=\"line\">        if (patchDirectoryFile == null) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:getPatchDirectory == null&quot;);</div><div class=\"line\">            //treat as not exist</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        String patchDirectoryPath = patchDirectoryFile.getAbsolutePath();</div><div class=\"line\"></div><div class=\"line\">        //check patch directory whether exist</div><div class=\"line\">        if (!patchDirectoryFile.exists()) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:patch dir not exist:&quot; + patchDirectoryPath);</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //tinker/patch.info</div><div class=\"line\">        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);</div><div class=\"line\"></div><div class=\"line\">        //check patch info file whether exist</div><div class=\"line\">        if (!patchInfoFile.exists()) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:patch info not exist:&quot; + patchInfoFile.getAbsolutePath());</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //old = 641e634c5b8f1649c75caf73794acbdf</div><div class=\"line\">        //new = 2c150d8560334966952678930ba67fa8</div><div class=\"line\">        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);</div><div class=\"line\"></div><div class=\"line\">        patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</div><div class=\"line\">        if (patchInfo == null) &#123;</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        String oldVersion = patchInfo.oldVersion;</div><div class=\"line\">        String newVersion = patchInfo.newVersion;</div><div class=\"line\"></div><div class=\"line\">        if (oldVersion == null || newVersion == null) &#123;</div><div class=\"line\">            //it is nice to clean patch</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:onPatchInfoCorrupted&quot;);</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);</div><div class=\"line\">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);</div><div class=\"line\"></div><div class=\"line\">        boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);</div><div class=\"line\">        boolean versionChanged = !(oldVersion.equals(newVersion));</div><div class=\"line\"></div><div class=\"line\">        String version = oldVersion;</div><div class=\"line\">        if (versionChanged &amp;&amp; mainProcess) &#123;</div><div class=\"line\">            version = newVersion;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (ShareTinkerInternals.isNullOrNil(version)) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:version is blank, wait main process to restart&quot;);</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //patch-641e634c</div><div class=\"line\">        String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);</div><div class=\"line\">        if (patchName == null) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:patchName is null&quot;);</div><div class=\"line\">            //we may delete patch info file</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //tinker/patch.info/patch-641e634c</div><div class=\"line\">        String patchVersionDirectory = patchDirectoryPath + &quot;/&quot; + patchName;</div><div class=\"line\">        File patchVersionDirectoryFile = new File(patchVersionDirectory);</div><div class=\"line\"></div><div class=\"line\">        if (!patchVersionDirectoryFile.exists()) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:onPatchVersionDirectoryNotFound&quot;);</div><div class=\"line\">            //we may delete patch info file</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //tinker/patch.info/patch-641e634c/patch-641e634c.apk</div><div class=\"line\">        File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));</div><div class=\"line\"></div><div class=\"line\">        if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:onPatchVersionFileNotFound&quot;);</div><div class=\"line\">            //we may delete patch info file</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);</div><div class=\"line\"></div><div class=\"line\">        int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);</div><div class=\"line\">        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:checkTinkerPackage&quot;);</div><div class=\"line\">            resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());</div><div class=\"line\"></div><div class=\"line\">        final boolean isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);</div><div class=\"line\"></div><div class=\"line\">        if (isEnabledForDex) &#123;</div><div class=\"line\">            //tinker/patch.info/patch-641e634c/dex</div><div class=\"line\">            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class=\"line\">            if (!dexCheck) &#123;</div><div class=\"line\">                //file not found, do not load patch</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:dex check fail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        final boolean isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</div><div class=\"line\"></div><div class=\"line\">        if (isEnabledForNativeLib) &#123;</div><div class=\"line\">            //tinker/patch.info/patch-641e634c/lib</div><div class=\"line\">            boolean libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class=\"line\">            if (!libCheck) &#123;</div><div class=\"line\">                //file not found, do not load patch</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:native lib check fail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //check resource</div><div class=\"line\">        final boolean isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</div><div class=\"line\">        Log.w(TAG, &quot;tryLoadPatchFiles:isEnabledForResource:&quot; + isEnabledForResource);</div><div class=\"line\">        if (isEnabledForResource) &#123;</div><div class=\"line\">            boolean resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</div><div class=\"line\">            if (!resourceCheck) &#123;</div><div class=\"line\">                //file not found, do not load patch</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:resource check fail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //only work for art platform oat</div><div class=\"line\">        boolean isSystemOTA = ShareTinkerInternals.isVmArt() &amp;&amp; ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);</div><div class=\"line\">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);</div><div class=\"line\"></div><div class=\"line\">        //we should first try rewrite patch info file, if there is a error, we can&apos;t load jar</div><div class=\"line\">        if (isSystemOTA</div><div class=\"line\">            || (mainProcess &amp;&amp; versionChanged)) &#123;</div><div class=\"line\">            patchInfo.oldVersion = version;</div><div class=\"line\">            //update old version to new</div><div class=\"line\">            if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123;</div><div class=\"line\">                ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:onReWritePatchInfoCorrupted&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (!checkSafeModeCount(app)) &#123;</div><div class=\"line\">            resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, new TinkerRuntimeException(&quot;checkSafeModeCount fail&quot;));</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:checkSafeModeCount fail&quot;);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //now we can load patch jar</div><div class=\"line\">        if (isEnabledForDex) &#123;</div><div class=\"line\">            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);</div><div class=\"line\">            if (!loadTinkerJars) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:onPatchLoadDexesFail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //now we can load patch resource</div><div class=\"line\">        if (isEnabledForResource) &#123;</div><div class=\"line\">            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);</div><div class=\"line\">            if (!loadTinkerResources) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:onPatchLoadResourcesFail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //all is ok!</div><div class=\"line\">        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);</div><div class=\"line\">        Log.i(TAG, &quot;tryLoadPatchFiles: load end, ok!&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个方法的代码特别长，但是逻辑并不是特别复杂：</p>\n<ul>\n<li>首先获取patchDirectoryFile，为/data/user/0/packageName/tinker</li>\n<li>获取patchInfoFile、patchInfoLockFile等等</li>\n<li>获取旧版本号、新版本号等信息</li>\n<li>获取其他的一些信息</li>\n<li>进行一些so、dex、resource的check</li>\n<li>然后进行load操作</li>\n<li>将结果写入intent返回</li>\n</ul>\n<h4 id=\"TinkerManager的一些方法\"><a href=\"#TinkerManager的一些方法\" class=\"headerlink\" title=\"TinkerManager的一些方法\"></a>TinkerManager的一些方法</h4><p>主要是进行参数设置以及Tinker的install操作，Tinker的install操作，由TinkerInstaller的install方法完成。</p>\n<h3 id=\"TinkerApplication的其他方法\"><a href=\"#TinkerApplication的其他方法\" class=\"headerlink\" title=\"TinkerApplication的其他方法\"></a>TinkerApplication的其他方法</h3><p>在这里的其他方法中，我们看到的代码几乎都是将这些操作，委托(代理)SampleApplicationLike中对应的方法来完成。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>过程如下，先loadTinker，在这里面会进行tryLoad操作，然后在创建代理对象，最后调用applicationLike的#onBaseContextAttached方法来初始化TinkerManager以及Tinker的安装。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从上文的一些知识中，知道，真正的Application是注解生成的，并且继承与TinkerApplication。那么我们就来分析下。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"attachBaseContext\"><a href=\"#attachBaseContext\" class=\"headerlink\" title=\"attachBaseContext\"></a>attachBaseContext</h3><p>首先看attachBaseContext这个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void attachBaseContext(Context base) &#123;</div><div class=\"line\">    super.attachBaseContext(base);</div><div class=\"line\">    Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this));</div><div class=\"line\">    onBaseContextAttached(base);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>设置UncaughtExceptionHandler</li>\n<li>调用onBaseContextAttached方法。</li>\n</ul>\n<p>onBaseContextAttached方法代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onBaseContextAttached(Context base) &#123;</div><div class=\"line\">    applicationStartElapsedTime = SystemClock.elapsedRealtime();</div><div class=\"line\">    applicationStartMillisTime = System.currentTimeMillis();</div><div class=\"line\">    loadTinker();</div><div class=\"line\">    ensureDelegate();</div><div class=\"line\">    applicationLike.onBaseContextAttached(base);</div><div class=\"line\">    //reset save mode</div><div class=\"line\">    if (useSafeMode) &#123;</div><div class=\"line\">        String processName = ShareTinkerInternals.getProcessName(this);</div><div class=\"line\">        String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;</div><div class=\"line\">        SharedPreferences sp = getSharedPreferences(preferName, Context.MODE_PRIVATE);</div><div class=\"line\">        sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, 0).commit();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>获取系统已运行时间，作为applicationStartElapsedTime</li>\n<li>获取系统当前时间，作为applicationStartMillisTime</li>\n<li>loadTinker() load tinker</li>\n<li>ensureDelegate 确认下delegate是否没有初始化</li>\n<li>调用applicationLike的onBaseContextAttached方法，对应demo中的SampleApplicationLike的onBaseContextAttached方法。</li>\n<li>如果是安全模式，就获取当前进程名，preferName，并将安全模式count置为0。</li>\n</ul>\n<h4 id=\"loadTinker\"><a href=\"#loadTinker\" class=\"headerlink\" title=\"loadTinker\"></a>loadTinker</h4><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void loadTinker() &#123;</div><div class=\"line\">    //disable tinker, not need to install</div><div class=\"line\">    if (tinkerFlags == TINKER_DISABLE) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    tinkerResultIntent = new Intent();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        //reflect tinker loader, because loaderClass may be define by user!</div><div class=\"line\">        Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());</div><div class=\"line\"></div><div class=\"line\">        Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);</div><div class=\"line\">        Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</div><div class=\"line\">        tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);</div><div class=\"line\">    &#125; catch (Throwable e) &#123;</div><div class=\"line\">        //has exception, put exception error code</div><div class=\"line\">        ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</div><div class=\"line\">        tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先判断flag，如果为TINKER_DISABLE，直接return</li>\n<li>生成tinkerLoadClass的Class</li>\n<li>获得tryLoad方法的Method</li>\n<li>获取tinkerLoadClass的构造方法</li>\n<li>调用tryLoad方法返回Intent对象</li>\n</ul>\n<h4 id=\"ensureDelegate\"><a href=\"#ensureDelegate\" class=\"headerlink\" title=\"ensureDelegate\"></a>ensureDelegate</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">private synchronized void ensureDelegate() &#123;</div><div class=\"line\">     if (applicationLike == null) &#123;</div><div class=\"line\">         applicationLike = createDelegate();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，会判断applicationLike是不是null，如果是的话，就调用createDelegate去创建一个代理对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private ApplicationLike createDelegate() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        // Use reflection to create the delegate so it doesn&apos;t need to go into the primary dex.</div><div class=\"line\">        // And we can also patch it</div><div class=\"line\">        Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, false, getClassLoader());</div><div class=\"line\">        Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, int.class, boolean.class,</div><div class=\"line\">            long.class, long.class, Intent.class);</div><div class=\"line\">        return (ApplicationLike) constructor.newInstance(this, tinkerFlags, tinkerLoadVerifyFlag,</div><div class=\"line\">            applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</div><div class=\"line\">    &#125; catch (Throwable e) &#123;</div><div class=\"line\">        throw new TinkerRuntimeException(&quot;createDelegate failed&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个方法中，通过反射构造出一个代理对象，根据demo传入的参数，这里构造出来的对象，是SampleApplicationLike。</p>\n<p>在看下SampleApplicationLike的构造方法吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</div><div class=\"line\">                             long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</div><div class=\"line\">    super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>参数很明显，我们还需要看下继承关系。SampleApplicationLike-&gt;DefaultApplicationLike-&gt;ApplicationLike,ApplicationLike实现了ApplicationLifeCycle的一系列接口。这个接口完全按照Application的一些方法，比如onCreate,onLowMemory等等。</p>\n<p>SampleApplicationLike的构造方法会调用父类的构造方法，最后调用到ApplicationLike的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</div><div class=\"line\">                       long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</div><div class=\"line\">    this.application = application;</div><div class=\"line\">    this.tinkerFlags = tinkerFlags;</div><div class=\"line\">    this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</div><div class=\"line\">    this.applicationStartElapsedTime = applicationStartElapsedTime;</div><div class=\"line\">    this.applicationStartMillisTime = applicationStartMillisTime;</div><div class=\"line\">    this.tinkerResultIntent = tinkerResultIntent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里就是把参数进行初始化。</p>\n<h4 id=\"SampleApplicationLike-onBaseContextAttached\"><a href=\"#SampleApplicationLike-onBaseContextAttached\" class=\"headerlink\" title=\"SampleApplicationLike#onBaseContextAttached\"></a>SampleApplicationLike#onBaseContextAttached</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class=\"line\">@Override</div><div class=\"line\">public void onBaseContextAttached(Context base) &#123;</div><div class=\"line\">    super.onBaseContextAttached(base);</div><div class=\"line\">    //you must install multiDex whatever tinker is installed!</div><div class=\"line\">    MultiDex.install(base);</div><div class=\"line\"></div><div class=\"line\">    SampleApplicationContext.application = getApplication();</div><div class=\"line\">    SampleApplicationContext.context = getApplication();</div><div class=\"line\">    TinkerManager.setTinkerApplicationLike(this);</div><div class=\"line\"></div><div class=\"line\">    TinkerManager.initFastCrashProtect();</div><div class=\"line\">    //should set before tinker is installed</div><div class=\"line\">    TinkerManager.setUpgradeRetryEnable(true);</div><div class=\"line\"></div><div class=\"line\">    //optional set logIml, or you can use default debug log</div><div class=\"line\">    TinkerInstaller.setLogIml(new MyLogImp());</div><div class=\"line\"></div><div class=\"line\">    //installTinker after load multiDex</div><div class=\"line\">    //or you can put com.tencent.tinker.** to main dex</div><div class=\"line\">    TinkerManager.installTinker(this);</div><div class=\"line\">    Tinker tinker = Tinker.with(getApplication());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先调用MultiDex.install方法</li>\n<li>然后初始化一些个参数</li>\n<li>调用TinkerManager的一些方法来初始化或者设置一些值</li>\n<li>然后installTinker</li>\n<li>生成一个Tinker对象</li>\n</ul>\n<p>### </p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>从逻辑流程来看，核心部分在于TinkerLoadeClass的tryLoad，以及TinkerManager的一些方法。其他的方法就是做一些初始化之类的工作，当然，这些也很重要。</p>\n<h3 id=\"TinkerLoader-tryLoad方法\"><a href=\"#TinkerLoader-tryLoad方法\" class=\"headerlink\" title=\"TinkerLoader#tryLoad方法\"></a>TinkerLoader#tryLoad方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag) &#123;</div><div class=\"line\">    Intent resultIntent = new Intent();</div><div class=\"line\"></div><div class=\"line\">    long begin = SystemClock.elapsedRealtime();</div><div class=\"line\">    tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);</div><div class=\"line\">    long cost = SystemClock.elapsedRealtime() - begin;</div><div class=\"line\">    ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);</div><div class=\"line\">    return resultIntent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法内部主要是调用tryLoadPatchFilesInternal方法，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag, Intent resultIntent) &#123;</div><div class=\"line\">        if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) &#123;</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //tinker</div><div class=\"line\">        File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);</div><div class=\"line\">        if (patchDirectoryFile == null) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:getPatchDirectory == null&quot;);</div><div class=\"line\">            //treat as not exist</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        String patchDirectoryPath = patchDirectoryFile.getAbsolutePath();</div><div class=\"line\"></div><div class=\"line\">        //check patch directory whether exist</div><div class=\"line\">        if (!patchDirectoryFile.exists()) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:patch dir not exist:&quot; + patchDirectoryPath);</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //tinker/patch.info</div><div class=\"line\">        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);</div><div class=\"line\"></div><div class=\"line\">        //check patch info file whether exist</div><div class=\"line\">        if (!patchInfoFile.exists()) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:patch info not exist:&quot; + patchInfoFile.getAbsolutePath());</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //old = 641e634c5b8f1649c75caf73794acbdf</div><div class=\"line\">        //new = 2c150d8560334966952678930ba67fa8</div><div class=\"line\">        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);</div><div class=\"line\"></div><div class=\"line\">        patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</div><div class=\"line\">        if (patchInfo == null) &#123;</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        String oldVersion = patchInfo.oldVersion;</div><div class=\"line\">        String newVersion = patchInfo.newVersion;</div><div class=\"line\"></div><div class=\"line\">        if (oldVersion == null || newVersion == null) &#123;</div><div class=\"line\">            //it is nice to clean patch</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:onPatchInfoCorrupted&quot;);</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);</div><div class=\"line\">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);</div><div class=\"line\"></div><div class=\"line\">        boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);</div><div class=\"line\">        boolean versionChanged = !(oldVersion.equals(newVersion));</div><div class=\"line\"></div><div class=\"line\">        String version = oldVersion;</div><div class=\"line\">        if (versionChanged &amp;&amp; mainProcess) &#123;</div><div class=\"line\">            version = newVersion;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (ShareTinkerInternals.isNullOrNil(version)) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:version is blank, wait main process to restart&quot;);</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //patch-641e634c</div><div class=\"line\">        String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);</div><div class=\"line\">        if (patchName == null) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:patchName is null&quot;);</div><div class=\"line\">            //we may delete patch info file</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //tinker/patch.info/patch-641e634c</div><div class=\"line\">        String patchVersionDirectory = patchDirectoryPath + &quot;/&quot; + patchName;</div><div class=\"line\">        File patchVersionDirectoryFile = new File(patchVersionDirectory);</div><div class=\"line\"></div><div class=\"line\">        if (!patchVersionDirectoryFile.exists()) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:onPatchVersionDirectoryNotFound&quot;);</div><div class=\"line\">            //we may delete patch info file</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //tinker/patch.info/patch-641e634c/patch-641e634c.apk</div><div class=\"line\">        File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));</div><div class=\"line\"></div><div class=\"line\">        if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:onPatchVersionFileNotFound&quot;);</div><div class=\"line\">            //we may delete patch info file</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);</div><div class=\"line\"></div><div class=\"line\">        int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);</div><div class=\"line\">        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:checkTinkerPackage&quot;);</div><div class=\"line\">            resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());</div><div class=\"line\"></div><div class=\"line\">        final boolean isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);</div><div class=\"line\"></div><div class=\"line\">        if (isEnabledForDex) &#123;</div><div class=\"line\">            //tinker/patch.info/patch-641e634c/dex</div><div class=\"line\">            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class=\"line\">            if (!dexCheck) &#123;</div><div class=\"line\">                //file not found, do not load patch</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:dex check fail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        final boolean isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</div><div class=\"line\"></div><div class=\"line\">        if (isEnabledForNativeLib) &#123;</div><div class=\"line\">            //tinker/patch.info/patch-641e634c/lib</div><div class=\"line\">            boolean libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class=\"line\">            if (!libCheck) &#123;</div><div class=\"line\">                //file not found, do not load patch</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:native lib check fail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //check resource</div><div class=\"line\">        final boolean isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</div><div class=\"line\">        Log.w(TAG, &quot;tryLoadPatchFiles:isEnabledForResource:&quot; + isEnabledForResource);</div><div class=\"line\">        if (isEnabledForResource) &#123;</div><div class=\"line\">            boolean resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</div><div class=\"line\">            if (!resourceCheck) &#123;</div><div class=\"line\">                //file not found, do not load patch</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:resource check fail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //only work for art platform oat</div><div class=\"line\">        boolean isSystemOTA = ShareTinkerInternals.isVmArt() &amp;&amp; ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);</div><div class=\"line\">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);</div><div class=\"line\"></div><div class=\"line\">        //we should first try rewrite patch info file, if there is a error, we can&apos;t load jar</div><div class=\"line\">        if (isSystemOTA</div><div class=\"line\">            || (mainProcess &amp;&amp; versionChanged)) &#123;</div><div class=\"line\">            patchInfo.oldVersion = version;</div><div class=\"line\">            //update old version to new</div><div class=\"line\">            if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123;</div><div class=\"line\">                ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:onReWritePatchInfoCorrupted&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (!checkSafeModeCount(app)) &#123;</div><div class=\"line\">            resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, new TinkerRuntimeException(&quot;checkSafeModeCount fail&quot;));</div><div class=\"line\">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);</div><div class=\"line\">            Log.w(TAG, &quot;tryLoadPatchFiles:checkSafeModeCount fail&quot;);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //now we can load patch jar</div><div class=\"line\">        if (isEnabledForDex) &#123;</div><div class=\"line\">            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);</div><div class=\"line\">            if (!loadTinkerJars) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:onPatchLoadDexesFail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //now we can load patch resource</div><div class=\"line\">        if (isEnabledForResource) &#123;</div><div class=\"line\">            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);</div><div class=\"line\">            if (!loadTinkerResources) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;tryLoadPatchFiles:onPatchLoadResourcesFail&quot;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //all is ok!</div><div class=\"line\">        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);</div><div class=\"line\">        Log.i(TAG, &quot;tryLoadPatchFiles: load end, ok!&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个方法的代码特别长，但是逻辑并不是特别复杂：</p>\n<ul>\n<li>首先获取patchDirectoryFile，为/data/user/0/packageName/tinker</li>\n<li>获取patchInfoFile、patchInfoLockFile等等</li>\n<li>获取旧版本号、新版本号等信息</li>\n<li>获取其他的一些信息</li>\n<li>进行一些so、dex、resource的check</li>\n<li>然后进行load操作</li>\n<li>将结果写入intent返回</li>\n</ul>\n<h4 id=\"TinkerManager的一些方法\"><a href=\"#TinkerManager的一些方法\" class=\"headerlink\" title=\"TinkerManager的一些方法\"></a>TinkerManager的一些方法</h4><p>主要是进行参数设置以及Tinker的install操作，Tinker的install操作，由TinkerInstaller的install方法完成。</p>\n<h3 id=\"TinkerApplication的其他方法\"><a href=\"#TinkerApplication的其他方法\" class=\"headerlink\" title=\"TinkerApplication的其他方法\"></a>TinkerApplication的其他方法</h3><p>在这里的其他方法中，我们看到的代码几乎都是将这些操作，委托(代理)SampleApplicationLike中对应的方法来完成。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>过程如下，先loadTinker，在这里面会进行tryLoad操作，然后在创建代理对象，最后调用applicationLike的#onBaseContextAttached方法来初始化TinkerManager以及Tinker的安装。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"tinker-loader部分","date":"2017-04-12T13:00:20.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\ntinker-loader部分负责对补丁包进行检测和加载，分为三部分\n\n* dex\n* so\n* resource\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### TinkerLoader\n\n这是loader的大管家，在他的tryLoad方法中，调用内部的tryLoadPatchFilesInternal方法，在这个方法中，进行各种验证。然后调用TinkerDexLoader#loadTinkerJars 加载dex，利用TinkerResourceLoader的loadTinkerResources来加载补丁resource。并将结果什么的写入到Intent中\n\n### TinkerDexLoader\n\n这个类负责检查dex的合法性已经加载dex。加载过程的主要代码如下\n\n```\nSystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);\n\n```\n\n在SystemClassLoaderAdder.installDexes中，根绝不同的版本，选择不同的方式去hook。\n\n```\n\n        if (!files.isEmpty()) {\n            ClassLoader classLoader = loader;\n            if (Build.VERSION.SDK_INT >= 24) {\n                classLoader = AndroidNClassLoader.inject(loader, application);\n            }\n            //because in dalvik, if inner class is not the same classloader with it wrapper class.\n            //it won't fail at dex2opt\n            if (Build.VERSION.SDK_INT >= 23) {\n                V23.install(classLoader, files, dexOptDir);\n            } else if (Build.VERSION.SDK_INT >= 19) {\n                V19.install(classLoader, files, dexOptDir);\n            } else if (Build.VERSION.SDK_INT >= 14) {\n                V14.install(classLoader, files, dexOptDir);\n            } else {\n                V4.install(classLoader, files, dexOptDir);\n            }\n            //install done\n            sPatchDexCount = files.size();\n            Log.i(TAG, \"after loaded classloader: \" + classLoader + \", dex size:\" + sPatchDexCount);\n\n            if (!checkDexInstall(classLoader)) {\n                //reset patch dex\n                SystemClassLoaderAdder.uninstallPatchDex(classLoader);\n                throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);\n            }\n        }\n```\n\n其中各个版本都是hook classLoader进行插桩处理，具体的代码，我们就不看了。\n\n### TinkerResourceLoader\n\n在这个类的loadTinkerResources方法中，有加载补丁资源包的代码。\n\n```\nTinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);\n```\n\n加载的代码和dex的类似，都是hook一些东西，关于hook那些东西，由于需要对AssetManager比较熟悉，我这里不熟悉，就不记录了，可以去网上找点资料。\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/tinker-loader部分.md","raw":"---\ntitle: tinker-loader部分\ndate: 2017-04-12 21:00:20\ntags: tinker\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\ntinker-loader部分负责对补丁包进行检测和加载，分为三部分\n\n* dex\n* so\n* resource\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### TinkerLoader\n\n这是loader的大管家，在他的tryLoad方法中，调用内部的tryLoadPatchFilesInternal方法，在这个方法中，进行各种验证。然后调用TinkerDexLoader#loadTinkerJars 加载dex，利用TinkerResourceLoader的loadTinkerResources来加载补丁resource。并将结果什么的写入到Intent中\n\n### TinkerDexLoader\n\n这个类负责检查dex的合法性已经加载dex。加载过程的主要代码如下\n\n```\nSystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);\n\n```\n\n在SystemClassLoaderAdder.installDexes中，根绝不同的版本，选择不同的方式去hook。\n\n```\n\n        if (!files.isEmpty()) {\n            ClassLoader classLoader = loader;\n            if (Build.VERSION.SDK_INT >= 24) {\n                classLoader = AndroidNClassLoader.inject(loader, application);\n            }\n            //because in dalvik, if inner class is not the same classloader with it wrapper class.\n            //it won't fail at dex2opt\n            if (Build.VERSION.SDK_INT >= 23) {\n                V23.install(classLoader, files, dexOptDir);\n            } else if (Build.VERSION.SDK_INT >= 19) {\n                V19.install(classLoader, files, dexOptDir);\n            } else if (Build.VERSION.SDK_INT >= 14) {\n                V14.install(classLoader, files, dexOptDir);\n            } else {\n                V4.install(classLoader, files, dexOptDir);\n            }\n            //install done\n            sPatchDexCount = files.size();\n            Log.i(TAG, \"after loaded classloader: \" + classLoader + \", dex size:\" + sPatchDexCount);\n\n            if (!checkDexInstall(classLoader)) {\n                //reset patch dex\n                SystemClassLoaderAdder.uninstallPatchDex(classLoader);\n                throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);\n            }\n        }\n```\n\n其中各个版本都是hook classLoader进行插桩处理，具体的代码，我们就不看了。\n\n### TinkerResourceLoader\n\n在这个类的loadTinkerResources方法中，有加载补丁资源包的代码。\n\n```\nTinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);\n```\n\n加载的代码和dex的类似，都是hook一些东西，关于hook那些东西，由于需要对AssetManager比较熟悉，我这里不熟悉，就不记录了，可以去网上找点资料。\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"tinker-loader部分","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzi004k19fybzadc66n","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>tinker-loader部分负责对补丁包进行检测和加载，分为三部分</p>\n<ul>\n<li>dex</li>\n<li>so</li>\n<li>resource</li>\n</ul>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"TinkerLoader\"><a href=\"#TinkerLoader\" class=\"headerlink\" title=\"TinkerLoader\"></a>TinkerLoader</h3><p>这是loader的大管家，在他的tryLoad方法中，调用内部的tryLoadPatchFilesInternal方法，在这个方法中，进行各种验证。然后调用TinkerDexLoader#loadTinkerJars 加载dex，利用TinkerResourceLoader的loadTinkerResources来加载补丁resource。并将结果什么的写入到Intent中</p>\n<h3 id=\"TinkerDexLoader\"><a href=\"#TinkerDexLoader\" class=\"headerlink\" title=\"TinkerDexLoader\"></a>TinkerDexLoader</h3><p>这个类负责检查dex的合法性已经加载dex。加载过程的主要代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);</div></pre></td></tr></table></figure>\n<p>在SystemClassLoaderAdder.installDexes中，根绝不同的版本，选择不同的方式去hook。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">if (!files.isEmpty()) &#123;</div><div class=\"line\">    ClassLoader classLoader = loader;</div><div class=\"line\">    if (Build.VERSION.SDK_INT &gt;= 24) &#123;</div><div class=\"line\">        classLoader = AndroidNClassLoader.inject(loader, application);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //because in dalvik, if inner class is not the same classloader with it wrapper class.</div><div class=\"line\">    //it won&apos;t fail at dex2opt</div><div class=\"line\">    if (Build.VERSION.SDK_INT &gt;= 23) &#123;</div><div class=\"line\">        V23.install(classLoader, files, dexOptDir);</div><div class=\"line\">    &#125; else if (Build.VERSION.SDK_INT &gt;= 19) &#123;</div><div class=\"line\">        V19.install(classLoader, files, dexOptDir);</div><div class=\"line\">    &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</div><div class=\"line\">        V14.install(classLoader, files, dexOptDir);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        V4.install(classLoader, files, dexOptDir);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //install done</div><div class=\"line\">    sPatchDexCount = files.size();</div><div class=\"line\">    Log.i(TAG, &quot;after loaded classloader: &quot; + classLoader + &quot;, dex size:&quot; + sPatchDexCount);</div><div class=\"line\"></div><div class=\"line\">    if (!checkDexInstall(classLoader)) &#123;</div><div class=\"line\">        //reset patch dex</div><div class=\"line\">        SystemClassLoaderAdder.uninstallPatchDex(classLoader);</div><div class=\"line\">        throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中各个版本都是hook classLoader进行插桩处理，具体的代码，我们就不看了。</p>\n<h3 id=\"TinkerResourceLoader\"><a href=\"#TinkerResourceLoader\" class=\"headerlink\" title=\"TinkerResourceLoader\"></a>TinkerResourceLoader</h3><p>在这个类的loadTinkerResources方法中，有加载补丁资源包的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);</div></pre></td></tr></table></figure>\n<p>加载的代码和dex的类似，都是hook一些东西，关于hook那些东西，由于需要对AssetManager比较熟悉，我这里不熟悉，就不记录了，可以去网上找点资料。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>tinker-loader部分负责对补丁包进行检测和加载，分为三部分</p>\n<ul>\n<li>dex</li>\n<li>so</li>\n<li>resource</li>\n</ul>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"TinkerLoader\"><a href=\"#TinkerLoader\" class=\"headerlink\" title=\"TinkerLoader\"></a>TinkerLoader</h3><p>这是loader的大管家，在他的tryLoad方法中，调用内部的tryLoadPatchFilesInternal方法，在这个方法中，进行各种验证。然后调用TinkerDexLoader#loadTinkerJars 加载dex，利用TinkerResourceLoader的loadTinkerResources来加载补丁resource。并将结果什么的写入到Intent中</p>\n<h3 id=\"TinkerDexLoader\"><a href=\"#TinkerDexLoader\" class=\"headerlink\" title=\"TinkerDexLoader\"></a>TinkerDexLoader</h3><p>这个类负责检查dex的合法性已经加载dex。加载过程的主要代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);</div></pre></td></tr></table></figure>\n<p>在SystemClassLoaderAdder.installDexes中，根绝不同的版本，选择不同的方式去hook。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">if (!files.isEmpty()) &#123;</div><div class=\"line\">    ClassLoader classLoader = loader;</div><div class=\"line\">    if (Build.VERSION.SDK_INT &gt;= 24) &#123;</div><div class=\"line\">        classLoader = AndroidNClassLoader.inject(loader, application);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //because in dalvik, if inner class is not the same classloader with it wrapper class.</div><div class=\"line\">    //it won&apos;t fail at dex2opt</div><div class=\"line\">    if (Build.VERSION.SDK_INT &gt;= 23) &#123;</div><div class=\"line\">        V23.install(classLoader, files, dexOptDir);</div><div class=\"line\">    &#125; else if (Build.VERSION.SDK_INT &gt;= 19) &#123;</div><div class=\"line\">        V19.install(classLoader, files, dexOptDir);</div><div class=\"line\">    &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</div><div class=\"line\">        V14.install(classLoader, files, dexOptDir);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        V4.install(classLoader, files, dexOptDir);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //install done</div><div class=\"line\">    sPatchDexCount = files.size();</div><div class=\"line\">    Log.i(TAG, &quot;after loaded classloader: &quot; + classLoader + &quot;, dex size:&quot; + sPatchDexCount);</div><div class=\"line\"></div><div class=\"line\">    if (!checkDexInstall(classLoader)) &#123;</div><div class=\"line\">        //reset patch dex</div><div class=\"line\">        SystemClassLoaderAdder.uninstallPatchDex(classLoader);</div><div class=\"line\">        throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中各个版本都是hook classLoader进行插桩处理，具体的代码，我们就不看了。</p>\n<h3 id=\"TinkerResourceLoader\"><a href=\"#TinkerResourceLoader\" class=\"headerlink\" title=\"TinkerResourceLoader\"></a>TinkerResourceLoader</h3><p>在这个类的loadTinkerResources方法中，有加载补丁资源包的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);</div></pre></td></tr></table></figure>\n<p>加载的代码和dex的类似，都是hook一些东西，关于hook那些东西，由于需要对AssetManager比较熟悉，我这里不熟悉，就不记录了，可以去网上找点资料。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"tinker-注解部分","date":"2017-04-08T11:39:13.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\ntinker-android-anno是用来生成application类的，我们就来看下是如何生成的\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### DefaultLifeCycle\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.SOURCE)\n@Inherited\npublic @interface DefaultLifeCycle {\n\n    String application();\n\n    String loaderClass() default \"com.tencent.tinker.loader.TinkerLoader\";\n\n    int flags();\n\n    boolean loadVerifyFlag() default false;\n\n\n}\n```\n\n### Processor\n\n```\n private void processDefaultLifeCycle(Set<? extends Element> elements) {\n        // DefaultLifeCycle\n        for (Element e : elements) {\n            DefaultLifeCycle ca = e.getAnnotation(DefaultLifeCycle.class);\n\n            String lifeCycleClassName = ((TypeElement) e).getQualifiedName().toString();\n            String lifeCyclePackageName = lifeCycleClassName.substring(0, lifeCycleClassName.lastIndexOf('.'));\n            lifeCycleClassName = lifeCycleClassName.substring(lifeCycleClassName.lastIndexOf('.') + 1);\n\n            String applicationClassName = ca.application();\n            if (applicationClassName.startsWith(\".\")) {\n                applicationClassName = lifeCyclePackageName + applicationClassName;\n            }\n            String applicationPackageName = applicationClassName.substring(0, applicationClassName.lastIndexOf('.'));\n            applicationClassName = applicationClassName.substring(applicationClassName.lastIndexOf('.') + 1);\n\n            String loaderClassName = ca.loaderClass();\n            if (loaderClassName.startsWith(\".\")) {\n                loaderClassName = lifeCyclePackageName + loaderClassName;\n            }\n\n            System.out.println(\"*\");\n\n            final InputStream is = AnnotationProcessor.class.getResourceAsStream(APPLICATION_TEMPLATE_PATH);\n            final Scanner scanner = new Scanner(is);\n            final String template = scanner.useDelimiter(\"\\\\A\").next();\n            final String fileContent = template\n                .replaceAll(\"%PACKAGE%\", applicationPackageName)\n                .replaceAll(\"%APPLICATION%\", applicationClassName)\n                .replaceAll(\"%APPLICATION_LIFE_CYCLE%\", lifeCyclePackageName + \".\" + lifeCycleClassName)\n                .replaceAll(\"%TINKER_FLAGS%\", \"\" + ca.flags())\n                .replaceAll(\"%TINKER_LOADER_CLASS%\", \"\" + loaderClassName)\n                .replaceAll(\"%TINKER_LOAD_VERIFY_FLAG%\", \"\" + ca.loadVerifyFlag());\n\n            try {\n                JavaFileObject fileObject = processingEnv.getFiler().createSourceFile(applicationPackageName + \".\" + applicationClassName);\n                processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, \"Creating \" + fileObject.toUri());\n                Writer writer = fileObject.openWriter();\n                try {\n                    PrintWriter pw = new PrintWriter(writer);\n                    pw.print(fileContent);\n                    pw.flush();\n\n                } finally {\n                    writer.close();\n                }\n            } catch (IOException x) {\n                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());\n            }\n        }\n    }\n```\n\n* 首先获取包名，applicaitonClassName\n* 然后获取resource目录下的TinkerAnnoApplication.tmpl文件，根据注解的信息，替换其中的内容，生成一个新的Application类\n\n```\npublic class %APPLICATION% extends TinkerApplication {\n\n    public %APPLICATION%() {\n        super(%TINKER_FLAGS%, \"%APPLICATION_LIFE_CYCLE%\", \"%TINKER_LOADER_CLASS%\", %TINKER_LOAD_VERIFY_FLAG%);\n    }\n\n}\n```\n\n可以看到，注解生成的Application类继承自TinkerApplication，接下来，我们要看的就是这个啦。\n\n### 生成的Application以及传入的参数\n\n从模板文件中，我们看到继承自TinkerApplication。而从生成的过程来看，传入的参数如下：\n\n* applicationClassName，注解中application部分，在demo中就是tinker.sample.android.app.SampleApplication\n* lifeCyclePackageName，对应demo中的包名+SampleApplicationLike\n* falg 就是注解中的flag\n* loaderClass就是loaderClassName，对应demo中就是默认值，om.tencent.tinker.loader.TinkerLoader\n* verify_flag就是 flag\n\n生成的文件中，会调用父类的构造方法，对应为\n\n```\n   protected TinkerApplication(int tinkerFlags, String delegateClassName,\n                                String loaderClassName, boolean tinkerLoadVerifyFlag) {\n        this.tinkerFlags = tinkerFlags;\n        this.delegateClassName = delegateClassName;\n        this.loaderClassName = loaderClassName;\n        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;\n\n    }\n```\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/tinker-注解部分.md","raw":"---\ntitle: tinker-注解部分\ndate: 2017-04-08 19:39:13\ntags: tinker\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\ntinker-android-anno是用来生成application类的，我们就来看下是如何生成的\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### DefaultLifeCycle\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.SOURCE)\n@Inherited\npublic @interface DefaultLifeCycle {\n\n    String application();\n\n    String loaderClass() default \"com.tencent.tinker.loader.TinkerLoader\";\n\n    int flags();\n\n    boolean loadVerifyFlag() default false;\n\n\n}\n```\n\n### Processor\n\n```\n private void processDefaultLifeCycle(Set<? extends Element> elements) {\n        // DefaultLifeCycle\n        for (Element e : elements) {\n            DefaultLifeCycle ca = e.getAnnotation(DefaultLifeCycle.class);\n\n            String lifeCycleClassName = ((TypeElement) e).getQualifiedName().toString();\n            String lifeCyclePackageName = lifeCycleClassName.substring(0, lifeCycleClassName.lastIndexOf('.'));\n            lifeCycleClassName = lifeCycleClassName.substring(lifeCycleClassName.lastIndexOf('.') + 1);\n\n            String applicationClassName = ca.application();\n            if (applicationClassName.startsWith(\".\")) {\n                applicationClassName = lifeCyclePackageName + applicationClassName;\n            }\n            String applicationPackageName = applicationClassName.substring(0, applicationClassName.lastIndexOf('.'));\n            applicationClassName = applicationClassName.substring(applicationClassName.lastIndexOf('.') + 1);\n\n            String loaderClassName = ca.loaderClass();\n            if (loaderClassName.startsWith(\".\")) {\n                loaderClassName = lifeCyclePackageName + loaderClassName;\n            }\n\n            System.out.println(\"*\");\n\n            final InputStream is = AnnotationProcessor.class.getResourceAsStream(APPLICATION_TEMPLATE_PATH);\n            final Scanner scanner = new Scanner(is);\n            final String template = scanner.useDelimiter(\"\\\\A\").next();\n            final String fileContent = template\n                .replaceAll(\"%PACKAGE%\", applicationPackageName)\n                .replaceAll(\"%APPLICATION%\", applicationClassName)\n                .replaceAll(\"%APPLICATION_LIFE_CYCLE%\", lifeCyclePackageName + \".\" + lifeCycleClassName)\n                .replaceAll(\"%TINKER_FLAGS%\", \"\" + ca.flags())\n                .replaceAll(\"%TINKER_LOADER_CLASS%\", \"\" + loaderClassName)\n                .replaceAll(\"%TINKER_LOAD_VERIFY_FLAG%\", \"\" + ca.loadVerifyFlag());\n\n            try {\n                JavaFileObject fileObject = processingEnv.getFiler().createSourceFile(applicationPackageName + \".\" + applicationClassName);\n                processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, \"Creating \" + fileObject.toUri());\n                Writer writer = fileObject.openWriter();\n                try {\n                    PrintWriter pw = new PrintWriter(writer);\n                    pw.print(fileContent);\n                    pw.flush();\n\n                } finally {\n                    writer.close();\n                }\n            } catch (IOException x) {\n                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());\n            }\n        }\n    }\n```\n\n* 首先获取包名，applicaitonClassName\n* 然后获取resource目录下的TinkerAnnoApplication.tmpl文件，根据注解的信息，替换其中的内容，生成一个新的Application类\n\n```\npublic class %APPLICATION% extends TinkerApplication {\n\n    public %APPLICATION%() {\n        super(%TINKER_FLAGS%, \"%APPLICATION_LIFE_CYCLE%\", \"%TINKER_LOADER_CLASS%\", %TINKER_LOAD_VERIFY_FLAG%);\n    }\n\n}\n```\n\n可以看到，注解生成的Application类继承自TinkerApplication，接下来，我们要看的就是这个啦。\n\n### 生成的Application以及传入的参数\n\n从模板文件中，我们看到继承自TinkerApplication。而从生成的过程来看，传入的参数如下：\n\n* applicationClassName，注解中application部分，在demo中就是tinker.sample.android.app.SampleApplication\n* lifeCyclePackageName，对应demo中的包名+SampleApplicationLike\n* falg 就是注解中的flag\n* loaderClass就是loaderClassName，对应demo中就是默认值，om.tencent.tinker.loader.TinkerLoader\n* verify_flag就是 flag\n\n生成的文件中，会调用父类的构造方法，对应为\n\n```\n   protected TinkerApplication(int tinkerFlags, String delegateClassName,\n                                String loaderClassName, boolean tinkerLoadVerifyFlag) {\n        this.tinkerFlags = tinkerFlags;\n        this.delegateClassName = delegateClassName;\n        this.loaderClassName = loaderClassName;\n        this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;\n\n    }\n```\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"tinker-注解部分","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzk004p19fy9cpk4gfb","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>tinker-android-anno是用来生成application类的，我们就来看下是如何生成的</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"DefaultLifeCycle\"><a href=\"#DefaultLifeCycle\" class=\"headerlink\" title=\"DefaultLifeCycle\"></a>DefaultLifeCycle</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(ElementType.TYPE)</div><div class=\"line\">@Retention(RetentionPolicy.SOURCE)</div><div class=\"line\">@Inherited</div><div class=\"line\">public @interface DefaultLifeCycle &#123;</div><div class=\"line\"></div><div class=\"line\">    String application();</div><div class=\"line\"></div><div class=\"line\">    String loaderClass() default &quot;com.tencent.tinker.loader.TinkerLoader&quot;;</div><div class=\"line\"></div><div class=\"line\">    int flags();</div><div class=\"line\"></div><div class=\"line\">    boolean loadVerifyFlag() default false;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Processor\"><a href=\"#Processor\" class=\"headerlink\" title=\"Processor\"></a>Processor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void processDefaultLifeCycle(Set&lt;? extends Element&gt; elements) &#123;</div><div class=\"line\">       // DefaultLifeCycle</div><div class=\"line\">       for (Element e : elements) &#123;</div><div class=\"line\">           DefaultLifeCycle ca = e.getAnnotation(DefaultLifeCycle.class);</div><div class=\"line\"></div><div class=\"line\">           String lifeCycleClassName = ((TypeElement) e).getQualifiedName().toString();</div><div class=\"line\">           String lifeCyclePackageName = lifeCycleClassName.substring(0, lifeCycleClassName.lastIndexOf(&apos;.&apos;));</div><div class=\"line\">           lifeCycleClassName = lifeCycleClassName.substring(lifeCycleClassName.lastIndexOf(&apos;.&apos;) + 1);</div><div class=\"line\"></div><div class=\"line\">           String applicationClassName = ca.application();</div><div class=\"line\">           if (applicationClassName.startsWith(&quot;.&quot;)) &#123;</div><div class=\"line\">               applicationClassName = lifeCyclePackageName + applicationClassName;</div><div class=\"line\">           &#125;</div><div class=\"line\">           String applicationPackageName = applicationClassName.substring(0, applicationClassName.lastIndexOf(&apos;.&apos;));</div><div class=\"line\">           applicationClassName = applicationClassName.substring(applicationClassName.lastIndexOf(&apos;.&apos;) + 1);</div><div class=\"line\"></div><div class=\"line\">           String loaderClassName = ca.loaderClass();</div><div class=\"line\">           if (loaderClassName.startsWith(&quot;.&quot;)) &#123;</div><div class=\"line\">               loaderClassName = lifeCyclePackageName + loaderClassName;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           System.out.println(&quot;*&quot;);</div><div class=\"line\"></div><div class=\"line\">           final InputStream is = AnnotationProcessor.class.getResourceAsStream(APPLICATION_TEMPLATE_PATH);</div><div class=\"line\">           final Scanner scanner = new Scanner(is);</div><div class=\"line\">           final String template = scanner.useDelimiter(&quot;\\\\A&quot;).next();</div><div class=\"line\">           final String fileContent = template</div><div class=\"line\">               .replaceAll(&quot;%PACKAGE%&quot;, applicationPackageName)</div><div class=\"line\">               .replaceAll(&quot;%APPLICATION%&quot;, applicationClassName)</div><div class=\"line\">               .replaceAll(&quot;%APPLICATION_LIFE_CYCLE%&quot;, lifeCyclePackageName + &quot;.&quot; + lifeCycleClassName)</div><div class=\"line\">               .replaceAll(&quot;%TINKER_FLAGS%&quot;, &quot;&quot; + ca.flags())</div><div class=\"line\">               .replaceAll(&quot;%TINKER_LOADER_CLASS%&quot;, &quot;&quot; + loaderClassName)</div><div class=\"line\">               .replaceAll(&quot;%TINKER_LOAD_VERIFY_FLAG%&quot;, &quot;&quot; + ca.loadVerifyFlag());</div><div class=\"line\"></div><div class=\"line\">           try &#123;</div><div class=\"line\">               JavaFileObject fileObject = processingEnv.getFiler().createSourceFile(applicationPackageName + &quot;.&quot; + applicationClassName);</div><div class=\"line\">               processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, &quot;Creating &quot; + fileObject.toUri());</div><div class=\"line\">               Writer writer = fileObject.openWriter();</div><div class=\"line\">               try &#123;</div><div class=\"line\">                   PrintWriter pw = new PrintWriter(writer);</div><div class=\"line\">                   pw.print(fileContent);</div><div class=\"line\">                   pw.flush();</div><div class=\"line\"></div><div class=\"line\">               &#125; finally &#123;</div><div class=\"line\">                   writer.close();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125; catch (IOException x) &#123;</div><div class=\"line\">               processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先获取包名，applicaitonClassName</li>\n<li>然后获取resource目录下的TinkerAnnoApplication.tmpl文件，根据注解的信息，替换其中的内容，生成一个新的Application类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class %APPLICATION% extends TinkerApplication &#123;</div><div class=\"line\"></div><div class=\"line\">    public %APPLICATION%() &#123;</div><div class=\"line\">        super(%TINKER_FLAGS%, &quot;%APPLICATION_LIFE_CYCLE%&quot;, &quot;%TINKER_LOADER_CLASS%&quot;, %TINKER_LOAD_VERIFY_FLAG%);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，注解生成的Application类继承自TinkerApplication，接下来，我们要看的就是这个啦。</p>\n<h3 id=\"生成的Application以及传入的参数\"><a href=\"#生成的Application以及传入的参数\" class=\"headerlink\" title=\"生成的Application以及传入的参数\"></a>生成的Application以及传入的参数</h3><p>从模板文件中，我们看到继承自TinkerApplication。而从生成的过程来看，传入的参数如下：</p>\n<ul>\n<li>applicationClassName，注解中application部分，在demo中就是tinker.sample.android.app.SampleApplication</li>\n<li>lifeCyclePackageName，对应demo中的包名+SampleApplicationLike</li>\n<li>falg 就是注解中的flag</li>\n<li>loaderClass就是loaderClassName，对应demo中就是默认值，om.tencent.tinker.loader.TinkerLoader</li>\n<li>verify_flag就是 flag</li>\n</ul>\n<p>生成的文件中，会调用父类的构造方法，对应为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected TinkerApplication(int tinkerFlags, String delegateClassName,</div><div class=\"line\">                             String loaderClassName, boolean tinkerLoadVerifyFlag) &#123;</div><div class=\"line\">     this.tinkerFlags = tinkerFlags;</div><div class=\"line\">     this.delegateClassName = delegateClassName;</div><div class=\"line\">     this.loaderClassName = loaderClassName;</div><div class=\"line\">     this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</div><div class=\"line\"></div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>tinker-android-anno是用来生成application类的，我们就来看下是如何生成的</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"DefaultLifeCycle\"><a href=\"#DefaultLifeCycle\" class=\"headerlink\" title=\"DefaultLifeCycle\"></a>DefaultLifeCycle</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(ElementType.TYPE)</div><div class=\"line\">@Retention(RetentionPolicy.SOURCE)</div><div class=\"line\">@Inherited</div><div class=\"line\">public @interface DefaultLifeCycle &#123;</div><div class=\"line\"></div><div class=\"line\">    String application();</div><div class=\"line\"></div><div class=\"line\">    String loaderClass() default &quot;com.tencent.tinker.loader.TinkerLoader&quot;;</div><div class=\"line\"></div><div class=\"line\">    int flags();</div><div class=\"line\"></div><div class=\"line\">    boolean loadVerifyFlag() default false;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Processor\"><a href=\"#Processor\" class=\"headerlink\" title=\"Processor\"></a>Processor</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void processDefaultLifeCycle(Set&lt;? extends Element&gt; elements) &#123;</div><div class=\"line\">       // DefaultLifeCycle</div><div class=\"line\">       for (Element e : elements) &#123;</div><div class=\"line\">           DefaultLifeCycle ca = e.getAnnotation(DefaultLifeCycle.class);</div><div class=\"line\"></div><div class=\"line\">           String lifeCycleClassName = ((TypeElement) e).getQualifiedName().toString();</div><div class=\"line\">           String lifeCyclePackageName = lifeCycleClassName.substring(0, lifeCycleClassName.lastIndexOf(&apos;.&apos;));</div><div class=\"line\">           lifeCycleClassName = lifeCycleClassName.substring(lifeCycleClassName.lastIndexOf(&apos;.&apos;) + 1);</div><div class=\"line\"></div><div class=\"line\">           String applicationClassName = ca.application();</div><div class=\"line\">           if (applicationClassName.startsWith(&quot;.&quot;)) &#123;</div><div class=\"line\">               applicationClassName = lifeCyclePackageName + applicationClassName;</div><div class=\"line\">           &#125;</div><div class=\"line\">           String applicationPackageName = applicationClassName.substring(0, applicationClassName.lastIndexOf(&apos;.&apos;));</div><div class=\"line\">           applicationClassName = applicationClassName.substring(applicationClassName.lastIndexOf(&apos;.&apos;) + 1);</div><div class=\"line\"></div><div class=\"line\">           String loaderClassName = ca.loaderClass();</div><div class=\"line\">           if (loaderClassName.startsWith(&quot;.&quot;)) &#123;</div><div class=\"line\">               loaderClassName = lifeCyclePackageName + loaderClassName;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           System.out.println(&quot;*&quot;);</div><div class=\"line\"></div><div class=\"line\">           final InputStream is = AnnotationProcessor.class.getResourceAsStream(APPLICATION_TEMPLATE_PATH);</div><div class=\"line\">           final Scanner scanner = new Scanner(is);</div><div class=\"line\">           final String template = scanner.useDelimiter(&quot;\\\\A&quot;).next();</div><div class=\"line\">           final String fileContent = template</div><div class=\"line\">               .replaceAll(&quot;%PACKAGE%&quot;, applicationPackageName)</div><div class=\"line\">               .replaceAll(&quot;%APPLICATION%&quot;, applicationClassName)</div><div class=\"line\">               .replaceAll(&quot;%APPLICATION_LIFE_CYCLE%&quot;, lifeCyclePackageName + &quot;.&quot; + lifeCycleClassName)</div><div class=\"line\">               .replaceAll(&quot;%TINKER_FLAGS%&quot;, &quot;&quot; + ca.flags())</div><div class=\"line\">               .replaceAll(&quot;%TINKER_LOADER_CLASS%&quot;, &quot;&quot; + loaderClassName)</div><div class=\"line\">               .replaceAll(&quot;%TINKER_LOAD_VERIFY_FLAG%&quot;, &quot;&quot; + ca.loadVerifyFlag());</div><div class=\"line\"></div><div class=\"line\">           try &#123;</div><div class=\"line\">               JavaFileObject fileObject = processingEnv.getFiler().createSourceFile(applicationPackageName + &quot;.&quot; + applicationClassName);</div><div class=\"line\">               processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, &quot;Creating &quot; + fileObject.toUri());</div><div class=\"line\">               Writer writer = fileObject.openWriter();</div><div class=\"line\">               try &#123;</div><div class=\"line\">                   PrintWriter pw = new PrintWriter(writer);</div><div class=\"line\">                   pw.print(fileContent);</div><div class=\"line\">                   pw.flush();</div><div class=\"line\"></div><div class=\"line\">               &#125; finally &#123;</div><div class=\"line\">                   writer.close();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125; catch (IOException x) &#123;</div><div class=\"line\">               processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先获取包名，applicaitonClassName</li>\n<li>然后获取resource目录下的TinkerAnnoApplication.tmpl文件，根据注解的信息，替换其中的内容，生成一个新的Application类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class %APPLICATION% extends TinkerApplication &#123;</div><div class=\"line\"></div><div class=\"line\">    public %APPLICATION%() &#123;</div><div class=\"line\">        super(%TINKER_FLAGS%, &quot;%APPLICATION_LIFE_CYCLE%&quot;, &quot;%TINKER_LOADER_CLASS%&quot;, %TINKER_LOAD_VERIFY_FLAG%);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，注解生成的Application类继承自TinkerApplication，接下来，我们要看的就是这个啦。</p>\n<h3 id=\"生成的Application以及传入的参数\"><a href=\"#生成的Application以及传入的参数\" class=\"headerlink\" title=\"生成的Application以及传入的参数\"></a>生成的Application以及传入的参数</h3><p>从模板文件中，我们看到继承自TinkerApplication。而从生成的过程来看，传入的参数如下：</p>\n<ul>\n<li>applicationClassName，注解中application部分，在demo中就是tinker.sample.android.app.SampleApplication</li>\n<li>lifeCyclePackageName，对应demo中的包名+SampleApplicationLike</li>\n<li>falg 就是注解中的flag</li>\n<li>loaderClass就是loaderClassName，对应demo中就是默认值，om.tencent.tinker.loader.TinkerLoader</li>\n<li>verify_flag就是 flag</li>\n</ul>\n<p>生成的文件中，会调用父类的构造方法，对应为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected TinkerApplication(int tinkerFlags, String delegateClassName,</div><div class=\"line\">                             String loaderClassName, boolean tinkerLoadVerifyFlag) &#123;</div><div class=\"line\">     this.tinkerFlags = tinkerFlags;</div><div class=\"line\">     this.delegateClassName = delegateClassName;</div><div class=\"line\">     this.loaderClassName = loaderClassName;</div><div class=\"line\">     this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</div><div class=\"line\"></div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"ubuntu下搭建ATC弱网测试环境","date":"2017-04-27T06:09:35.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n看到了Fresco的弱网测试框架，尝试一下。[github地址](https://github.com/facebook/augmented-traffic-control)\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n1. 安装python virtualenv \n\n\t```\nsudo apt-get install python-virtualenv\n```\n\n2. 创建一个python 2.7的虚拟环境\n\n\n\t```\nvirtualenv python2.7 --python=python2.7\n\n\t```\n\n3. 切换到虚拟环境\n\n\t```\nsource python2.7/bin.activate\n\t```\n\n4. 安装django，版本必须1.10\n\n\t```\nsudo pip install django==1.10\n```\n\n5. 安装ATC相关东西\n\n\t```\nsudo pip install atc_thrift atcd django-atc-api django-atc-demo-ui django-atc-profile-storage\n```\n\n6. 初始化一个django项目\n\n\t```\ndjango-admin startproject atcui\ncd atcui\n\t```\n\n\t```\nINSTALLED_APPS = (\n    ...\n    # Django ATC API\n    'rest_framework',\n    'atc_api',\n    # Django ATC Demo UI\n    'bootstrap_themes',\n    'django_static_jquery',\n    'atc_demo_ui',\n    # Django ATC Profile Storage\n    'atc_profile_storage',\n)\n```\n\n\t```\t\n\t\n\tfrom django.views.generic.base import RedirectView\n\tfrom django.conf.urls import include,url\n\n\turlpatterns = [\n    \t...\n   \t # Django ATC API\n    \turl(r'^api/v1/', include('atc_api.urls')),\n    \t# Django ATC Demo UI\n    \turl(r'^atc_demo_ui/', include('atc_demo_ui.urls')),\n    \t# Django ATC profile storage\n    \turl(r'^api/v1/profiles/', include('atc_profile_storage.urls')),\n    \turl(r'^$', RedirectView.as_view(url='/atc_demo_ui/', permanent=False)),\n    \n\t]\n```\n\t\n\t```\t\n\tpython manage.py migrate\n\t\n\t```\n\n7. 启动atcd\n\n\t注意，启动的时候得指定wan和lan,通过ifconfig查看，第一个为wan，最后一个为lan\t\n\n\t```\n\n\tcd python2.7/bin/\n\n\tsudo ./atcd --atcd-wan wan名称 --atcd-lan lan名称\n\t\n\t``` \n\n8. 启动django\n\n\t```\t\npython manage.py runserver 0.0.0.0:8000\n```\n\n9. 测试\n\n\t本机链接localhost:8000\n\n\t手机链接IP \n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/ubuntu下搭建ATC弱网测试环境.md","raw":"---\ntitle: ubuntu下搭建ATC弱网测试环境\ndate: 2017-04-27 14:09:35\ntags: 测试\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n看到了Fresco的弱网测试框架，尝试一下。[github地址](https://github.com/facebook/augmented-traffic-control)\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n1. 安装python virtualenv \n\n\t```\nsudo apt-get install python-virtualenv\n```\n\n2. 创建一个python 2.7的虚拟环境\n\n\n\t```\nvirtualenv python2.7 --python=python2.7\n\n\t```\n\n3. 切换到虚拟环境\n\n\t```\nsource python2.7/bin.activate\n\t```\n\n4. 安装django，版本必须1.10\n\n\t```\nsudo pip install django==1.10\n```\n\n5. 安装ATC相关东西\n\n\t```\nsudo pip install atc_thrift atcd django-atc-api django-atc-demo-ui django-atc-profile-storage\n```\n\n6. 初始化一个django项目\n\n\t```\ndjango-admin startproject atcui\ncd atcui\n\t```\n\n\t```\nINSTALLED_APPS = (\n    ...\n    # Django ATC API\n    'rest_framework',\n    'atc_api',\n    # Django ATC Demo UI\n    'bootstrap_themes',\n    'django_static_jquery',\n    'atc_demo_ui',\n    # Django ATC Profile Storage\n    'atc_profile_storage',\n)\n```\n\n\t```\t\n\t\n\tfrom django.views.generic.base import RedirectView\n\tfrom django.conf.urls import include,url\n\n\turlpatterns = [\n    \t...\n   \t # Django ATC API\n    \turl(r'^api/v1/', include('atc_api.urls')),\n    \t# Django ATC Demo UI\n    \turl(r'^atc_demo_ui/', include('atc_demo_ui.urls')),\n    \t# Django ATC profile storage\n    \turl(r'^api/v1/profiles/', include('atc_profile_storage.urls')),\n    \turl(r'^$', RedirectView.as_view(url='/atc_demo_ui/', permanent=False)),\n    \n\t]\n```\n\t\n\t```\t\n\tpython manage.py migrate\n\t\n\t```\n\n7. 启动atcd\n\n\t注意，启动的时候得指定wan和lan,通过ifconfig查看，第一个为wan，最后一个为lan\t\n\n\t```\n\n\tcd python2.7/bin/\n\n\tsudo ./atcd --atcd-wan wan名称 --atcd-lan lan名称\n\t\n\t``` \n\n8. 启动django\n\n\t```\t\npython manage.py runserver 0.0.0.0:8000\n```\n\n9. 测试\n\n\t本机链接localhost:8000\n\n\t手机链接IP \n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"ubuntu下搭建ATC弱网测试环境","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzl004q19fyf4mgbhlc","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>看到了Fresco的弱网测试框架，尝试一下。<a href=\"https://github.com/facebook/augmented-traffic-control\" target=\"_blank\" rel=\"external\">github地址</a></p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<ol>\n<li><p>安装python virtualenv </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install python-virtualenv</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个python 2.7的虚拟环境</p>\n</li>\n</ol>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">virtualenv python2.7 --python=python2.7</div></pre></td></tr></table></figure>\n</code></pre><ol>\n<li><p>切换到虚拟环境</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">source python2.7/bin.activate</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装django，版本必须1.10</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install django==1.10</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装ATC相关东西</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install atc_thrift atcd django-atc-api django-atc-demo-ui django-atc-profile-storage</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化一个django项目</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">django-admin startproject atcui</div><div class=\"line\">cd atcui</div></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">INSTALLED_APPS = (</div><div class=\"line\">    ...</div><div class=\"line\">    # Django ATC API</div><div class=\"line\">    &apos;rest_framework&apos;,</div><div class=\"line\">    &apos;atc_api&apos;,</div><div class=\"line\">    # Django ATC Demo UI</div><div class=\"line\">    &apos;bootstrap_themes&apos;,</div><div class=\"line\">    &apos;django_static_jquery&apos;,</div><div class=\"line\">    &apos;atc_demo_ui&apos;,</div><div class=\"line\">    # Django ATC Profile Storage</div><div class=\"line\">    &apos;atc_profile_storage&apos;,</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">from django.views.generic.base import RedirectView</div><div class=\"line\">from django.conf.urls import include,url</div><div class=\"line\"></div><div class=\"line\">urlpatterns = [</div><div class=\"line\">   \t...</div><div class=\"line\">  \t # Django ATC API</div><div class=\"line\">   \turl(r&apos;^api/v1/&apos;, include(&apos;atc_api.urls&apos;)),</div><div class=\"line\">   \t# Django ATC Demo UI</div><div class=\"line\">   \turl(r&apos;^atc_demo_ui/&apos;, include(&apos;atc_demo_ui.urls&apos;)),</div><div class=\"line\">   \t# Django ATC profile storage</div><div class=\"line\">   \turl(r&apos;^api/v1/profiles/&apos;, include(&apos;atc_profile_storage.urls&apos;)),</div><div class=\"line\">   \turl(r&apos;^$&apos;, RedirectView.as_view(url=&apos;/atc_demo_ui/&apos;, permanent=False)),</div><div class=\"line\">   </div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python manage.py migrate</div></pre></td></tr></table></figure>\n</code></pre><ol>\n<li><p>启动atcd</p>\n<p> 注意，启动的时候得指定wan和lan,通过ifconfig查看，第一个为wan，最后一个为lan    </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">\tcd python2.7/bin/</div><div class=\"line\"></div><div class=\"line\">\tsudo ./atcd --atcd-wan wan名称 --atcd-lan lan名称</div><div class=\"line\">\t</div><div class=\"line\">\t``` </div><div class=\"line\"></div><div class=\"line\">8. 启动django</div><div class=\"line\"></div><div class=\"line\">\t```\t</div><div class=\"line\">python manage.py runserver 0.0.0.0:8000</div></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<p> 本机链接localhost:8000</p>\n<p> 手机链接IP </p>\n</li>\n</ol>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>看到了Fresco的弱网测试框架，尝试一下。<a href=\"https://github.com/facebook/augmented-traffic-control\">github地址</a></p>","more":"<The rest of contents | 余下全文>\n\n\n\n<ol>\n<li><p>安装python virtualenv </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install python-virtualenv</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个python 2.7的虚拟环境</p>\n</li>\n</ol>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">virtualenv python2.7 --python=python2.7</div></pre></td></tr></table></figure>\n</code></pre><ol>\n<li><p>切换到虚拟环境</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">source python2.7/bin.activate</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装django，版本必须1.10</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install django==1.10</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装ATC相关东西</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install atc_thrift atcd django-atc-api django-atc-demo-ui django-atc-profile-storage</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化一个django项目</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">django-admin startproject atcui</div><div class=\"line\">cd atcui</div></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">INSTALLED_APPS = (</div><div class=\"line\">    ...</div><div class=\"line\">    # Django ATC API</div><div class=\"line\">    &apos;rest_framework&apos;,</div><div class=\"line\">    &apos;atc_api&apos;,</div><div class=\"line\">    # Django ATC Demo UI</div><div class=\"line\">    &apos;bootstrap_themes&apos;,</div><div class=\"line\">    &apos;django_static_jquery&apos;,</div><div class=\"line\">    &apos;atc_demo_ui&apos;,</div><div class=\"line\">    # Django ATC Profile Storage</div><div class=\"line\">    &apos;atc_profile_storage&apos;,</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">from django.views.generic.base import RedirectView</div><div class=\"line\">from django.conf.urls import include,url</div><div class=\"line\"></div><div class=\"line\">urlpatterns = [</div><div class=\"line\">   \t...</div><div class=\"line\">  \t # Django ATC API</div><div class=\"line\">   \turl(r&apos;^api/v1/&apos;, include(&apos;atc_api.urls&apos;)),</div><div class=\"line\">   \t# Django ATC Demo UI</div><div class=\"line\">   \turl(r&apos;^atc_demo_ui/&apos;, include(&apos;atc_demo_ui.urls&apos;)),</div><div class=\"line\">   \t# Django ATC profile storage</div><div class=\"line\">   \turl(r&apos;^api/v1/profiles/&apos;, include(&apos;atc_profile_storage.urls&apos;)),</div><div class=\"line\">   \turl(r&apos;^$&apos;, RedirectView.as_view(url=&apos;/atc_demo_ui/&apos;, permanent=False)),</div><div class=\"line\">   </div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python manage.py migrate</div></pre></td></tr></table></figure>\n</code></pre><ol>\n<li><p>启动atcd</p>\n<p> 注意，启动的时候得指定wan和lan,通过ifconfig查看，第一个为wan，最后一个为lan    </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">\tcd python2.7/bin/</div><div class=\"line\"></div><div class=\"line\">\tsudo ./atcd --atcd-wan wan名称 --atcd-lan lan名称</div><div class=\"line\">\t</div><div class=\"line\">\t``` </div><div class=\"line\"></div><div class=\"line\">8. 启动django</div><div class=\"line\"></div><div class=\"line\">\t```\t</div><div class=\"line\">python manage.py runserver 0.0.0.0:8000</div></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<p> 本机链接localhost:8000</p>\n<p> 手机链接IP </p>\n</li>\n</ol>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"一个仿qq图片上传的Drawable","date":"2018-01-22T14:37:17.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n感觉qq聊天里面，传图片的效果很赞，感觉可以用到自己的项目里，因此，也写了一个这个效果，实现方式非常简单。就是一个Drawable。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### ProgressDrawable\n\n先看下效果\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/progressdrawable.gif?raw=true)\n\n\n```\npackage com.guolei.customviews;\n\n//                    _    _   _ _\n//__      _____  _ __| | _| |_(_) | ___\n//\\ \\ /\\ / / _ \\| '__| |/ / __| | |/ _ \\\n// \\ V  V / (_) | |  |   <| |_| | |  __/\n//  \\_/\\_/ \\___/|_|  |_|\\_\\\\__|_|_|\\___|\n\n\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.ColorFilter;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PixelFormat;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\nimport android.graphics.drawable.Drawable;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.util.Log;\n\n/**\n * Copyright © 2013-2017 Worktile. All Rights Reserved.\n * Author: guolei\n * Email: 1120832563@qq.com\n * Date: 18/1/17\n * Time: 下午2:17\n * Desc:\n */\npublic class ProgressDrawable extends Drawable {\n\n\n    private float progress;\n\n    private Paint mPaint;\n    private Paint mTextPaint;\n    private Path path = new Path();\n    private RectF rectF = new RectF(0, 0, 0, 0);\n\n    private int mBaseline = 0;\n\n    public ProgressDrawable() {\n        mPaint = new Paint();\n        mPaint.setAntiAlias(true);\n        mPaint.setDither(true);\n        mPaint.setColor(Color.parseColor(\"#99000000\"));\n\n        mTextPaint = new Paint(mPaint);\n        mTextPaint.setColor(Color.WHITE);\n        mTextPaint.setTextSize(40);\n    }\n\n    public float getProgress() {\n        return progress;\n    }\n\n    public void setProgress(float progress) {\n        this.progress = progress;\n        invalidateSelf();\n    }\n\n    @Override\n    public void draw(@NonNull Canvas canvas) {\n        path.reset();\n        path.addRect(rectF, Path.Direction.CCW);\n        int radius = (int) (progress * ((rectF.right) / 2 * 1.414 - 100)) + 100;\n        path.addCircle(rectF.right / 2, rectF.right / 2, radius > 100 ? radius : 100 , Path.Direction.CW);\n        canvas.drawPath(path, mPaint);\n        canvas.drawCircle(rectF.right / 2, rectF.right / 2, 80, mPaint);\n        String s = String.valueOf(progress * 100).substring(0,2) + \"%\";\n        s = s.replace(\".\",\"\");\n        int width = (int) mTextPaint.measureText(s);\n        canvas.drawText(s, rectF.right / 2 - (width / 2), mBaseline, mTextPaint);\n    }\n\n    @Override\n    public void setAlpha(int i) {\n\n    }\n\n    @Override\n    public void setColorFilter(@Nullable ColorFilter colorFilter) {\n\n    }\n\n    @Override\n    public int getOpacity() {\n        return PixelFormat.TRANSLUCENT;\n    }\n\n    @Override\n    protected void onBoundsChange(Rect bounds) {\n        rectF.set(0, 0, bounds.right, bounds.bottom);\n        computeBaseline();\n    }\n\n    private void computeBaseline() {\n        mBaseline = (int) (rectF.height() / 2 + (Math.abs(mTextPaint.ascent()) - mTextPaint.descent()) / 2);\n    }\n}\n\n```\n\n代码很简单，根据进度去绘制，分为3个部分。\n\n* 外圈 由path合成\n* 内圈 Circle\n* 字 \n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/一个仿qq图片上传的Drawable.md","raw":"---\ntitle: 一个仿qq图片上传的Drawable\ndate: 2018-01-22 22:37:17\ntags: Android\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n感觉qq聊天里面，传图片的效果很赞，感觉可以用到自己的项目里，因此，也写了一个这个效果，实现方式非常简单。就是一个Drawable。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### ProgressDrawable\n\n先看下效果\n\n![](https://github.com/Guolei1130/blog_resource/blob/master/art/progressdrawable.gif?raw=true)\n\n\n```\npackage com.guolei.customviews;\n\n//                    _    _   _ _\n//__      _____  _ __| | _| |_(_) | ___\n//\\ \\ /\\ / / _ \\| '__| |/ / __| | |/ _ \\\n// \\ V  V / (_) | |  |   <| |_| | |  __/\n//  \\_/\\_/ \\___/|_|  |_|\\_\\\\__|_|_|\\___|\n\n\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.ColorFilter;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PixelFormat;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\nimport android.graphics.drawable.Drawable;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.util.Log;\n\n/**\n * Copyright © 2013-2017 Worktile. All Rights Reserved.\n * Author: guolei\n * Email: 1120832563@qq.com\n * Date: 18/1/17\n * Time: 下午2:17\n * Desc:\n */\npublic class ProgressDrawable extends Drawable {\n\n\n    private float progress;\n\n    private Paint mPaint;\n    private Paint mTextPaint;\n    private Path path = new Path();\n    private RectF rectF = new RectF(0, 0, 0, 0);\n\n    private int mBaseline = 0;\n\n    public ProgressDrawable() {\n        mPaint = new Paint();\n        mPaint.setAntiAlias(true);\n        mPaint.setDither(true);\n        mPaint.setColor(Color.parseColor(\"#99000000\"));\n\n        mTextPaint = new Paint(mPaint);\n        mTextPaint.setColor(Color.WHITE);\n        mTextPaint.setTextSize(40);\n    }\n\n    public float getProgress() {\n        return progress;\n    }\n\n    public void setProgress(float progress) {\n        this.progress = progress;\n        invalidateSelf();\n    }\n\n    @Override\n    public void draw(@NonNull Canvas canvas) {\n        path.reset();\n        path.addRect(rectF, Path.Direction.CCW);\n        int radius = (int) (progress * ((rectF.right) / 2 * 1.414 - 100)) + 100;\n        path.addCircle(rectF.right / 2, rectF.right / 2, radius > 100 ? radius : 100 , Path.Direction.CW);\n        canvas.drawPath(path, mPaint);\n        canvas.drawCircle(rectF.right / 2, rectF.right / 2, 80, mPaint);\n        String s = String.valueOf(progress * 100).substring(0,2) + \"%\";\n        s = s.replace(\".\",\"\");\n        int width = (int) mTextPaint.measureText(s);\n        canvas.drawText(s, rectF.right / 2 - (width / 2), mBaseline, mTextPaint);\n    }\n\n    @Override\n    public void setAlpha(int i) {\n\n    }\n\n    @Override\n    public void setColorFilter(@Nullable ColorFilter colorFilter) {\n\n    }\n\n    @Override\n    public int getOpacity() {\n        return PixelFormat.TRANSLUCENT;\n    }\n\n    @Override\n    protected void onBoundsChange(Rect bounds) {\n        rectF.set(0, 0, bounds.right, bounds.bottom);\n        computeBaseline();\n    }\n\n    private void computeBaseline() {\n        mBaseline = (int) (rectF.height() / 2 + (Math.abs(mTextPaint.ascent()) - mTextPaint.descent()) / 2);\n    }\n}\n\n```\n\n代码很简单，根据进度去绘制，分为3个部分。\n\n* 外圈 由path合成\n* 内圈 Circle\n* 字 \n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"一个仿qq图片上传的Drawable","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzn004v19fylsdenjic","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>感觉qq聊天里面，传图片的效果很赞，感觉可以用到自己的项目里，因此，也写了一个这个效果，实现方式非常简单。就是一个Drawable。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"ProgressDrawable\"><a href=\"#ProgressDrawable\" class=\"headerlink\" title=\"ProgressDrawable\"></a>ProgressDrawable</h3><p>先看下效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/progressdrawable.gif?raw=true\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.guolei.customviews;</div><div class=\"line\"></div><div class=\"line\">//                    _    _   _ _</div><div class=\"line\">//__      _____  _ __| | _| |_(_) | ___</div><div class=\"line\">//\\ \\ /\\ / / _ \\| &apos;__| |/ / __| | |/ _ \\</div><div class=\"line\">// \\ V  V / (_) | |  |   &lt;| |_| | |  __/</div><div class=\"line\">//  \\_/\\_/ \\___/|_|  |_|\\_\\\\__|_|_|\\___|</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">import android.graphics.Canvas;</div><div class=\"line\">import android.graphics.Color;</div><div class=\"line\">import android.graphics.ColorFilter;</div><div class=\"line\">import android.graphics.Paint;</div><div class=\"line\">import android.graphics.Path;</div><div class=\"line\">import android.graphics.PixelFormat;</div><div class=\"line\">import android.graphics.PorterDuff;</div><div class=\"line\">import android.graphics.PorterDuffXfermode;</div><div class=\"line\">import android.graphics.Rect;</div><div class=\"line\">import android.graphics.RectF;</div><div class=\"line\">import android.graphics.drawable.Drawable;</div><div class=\"line\">import android.support.annotation.NonNull;</div><div class=\"line\">import android.support.annotation.Nullable;</div><div class=\"line\">import android.util.Log;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Copyright © 2013-2017 Worktile. All Rights Reserved.</div><div class=\"line\"> * Author: guolei</div><div class=\"line\"> * Email: 1120832563@qq.com</div><div class=\"line\"> * Date: 18/1/17</div><div class=\"line\"> * Time: 下午2:17</div><div class=\"line\"> * Desc:</div><div class=\"line\"> */</div><div class=\"line\">public class ProgressDrawable extends Drawable &#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    private float progress;</div><div class=\"line\"></div><div class=\"line\">    private Paint mPaint;</div><div class=\"line\">    private Paint mTextPaint;</div><div class=\"line\">    private Path path = new Path();</div><div class=\"line\">    private RectF rectF = new RectF(0, 0, 0, 0);</div><div class=\"line\"></div><div class=\"line\">    private int mBaseline = 0;</div><div class=\"line\"></div><div class=\"line\">    public ProgressDrawable() &#123;</div><div class=\"line\">        mPaint = new Paint();</div><div class=\"line\">        mPaint.setAntiAlias(true);</div><div class=\"line\">        mPaint.setDither(true);</div><div class=\"line\">        mPaint.setColor(Color.parseColor(&quot;#99000000&quot;));</div><div class=\"line\"></div><div class=\"line\">        mTextPaint = new Paint(mPaint);</div><div class=\"line\">        mTextPaint.setColor(Color.WHITE);</div><div class=\"line\">        mTextPaint.setTextSize(40);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public float getProgress() &#123;</div><div class=\"line\">        return progress;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void setProgress(float progress) &#123;</div><div class=\"line\">        this.progress = progress;</div><div class=\"line\">        invalidateSelf();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void draw(@NonNull Canvas canvas) &#123;</div><div class=\"line\">        path.reset();</div><div class=\"line\">        path.addRect(rectF, Path.Direction.CCW);</div><div class=\"line\">        int radius = (int) (progress * ((rectF.right) / 2 * 1.414 - 100)) + 100;</div><div class=\"line\">        path.addCircle(rectF.right / 2, rectF.right / 2, radius &gt; 100 ? radius : 100 , Path.Direction.CW);</div><div class=\"line\">        canvas.drawPath(path, mPaint);</div><div class=\"line\">        canvas.drawCircle(rectF.right / 2, rectF.right / 2, 80, mPaint);</div><div class=\"line\">        String s = String.valueOf(progress * 100).substring(0,2) + &quot;%&quot;;</div><div class=\"line\">        s = s.replace(&quot;.&quot;,&quot;&quot;);</div><div class=\"line\">        int width = (int) mTextPaint.measureText(s);</div><div class=\"line\">        canvas.drawText(s, rectF.right / 2 - (width / 2), mBaseline, mTextPaint);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void setAlpha(int i) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void setColorFilter(@Nullable ColorFilter colorFilter) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public int getOpacity() &#123;</div><div class=\"line\">        return PixelFormat.TRANSLUCENT;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onBoundsChange(Rect bounds) &#123;</div><div class=\"line\">        rectF.set(0, 0, bounds.right, bounds.bottom);</div><div class=\"line\">        computeBaseline();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void computeBaseline() &#123;</div><div class=\"line\">        mBaseline = (int) (rectF.height() / 2 + (Math.abs(mTextPaint.ascent()) - mTextPaint.descent()) / 2);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码很简单，根据进度去绘制，分为3个部分。</p>\n<ul>\n<li>外圈 由path合成</li>\n<li>内圈 Circle</li>\n<li>字 </li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>感觉qq聊天里面，传图片的效果很赞，感觉可以用到自己的项目里，因此，也写了一个这个效果，实现方式非常简单。就是一个Drawable。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"ProgressDrawable\"><a href=\"#ProgressDrawable\" class=\"headerlink\" title=\"ProgressDrawable\"></a>ProgressDrawable</h3><p>先看下效果</p>\n<p><img src=\"https://github.com/Guolei1130/blog_resource/blob/master/art/progressdrawable.gif?raw=true\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.guolei.customviews;</div><div class=\"line\"></div><div class=\"line\">//                    _    _   _ _</div><div class=\"line\">//__      _____  _ __| | _| |_(_) | ___</div><div class=\"line\">//\\ \\ /\\ / / _ \\| &apos;__| |/ / __| | |/ _ \\</div><div class=\"line\">// \\ V  V / (_) | |  |   &lt;| |_| | |  __/</div><div class=\"line\">//  \\_/\\_/ \\___/|_|  |_|\\_\\\\__|_|_|\\___|</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">import android.graphics.Canvas;</div><div class=\"line\">import android.graphics.Color;</div><div class=\"line\">import android.graphics.ColorFilter;</div><div class=\"line\">import android.graphics.Paint;</div><div class=\"line\">import android.graphics.Path;</div><div class=\"line\">import android.graphics.PixelFormat;</div><div class=\"line\">import android.graphics.PorterDuff;</div><div class=\"line\">import android.graphics.PorterDuffXfermode;</div><div class=\"line\">import android.graphics.Rect;</div><div class=\"line\">import android.graphics.RectF;</div><div class=\"line\">import android.graphics.drawable.Drawable;</div><div class=\"line\">import android.support.annotation.NonNull;</div><div class=\"line\">import android.support.annotation.Nullable;</div><div class=\"line\">import android.util.Log;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Copyright © 2013-2017 Worktile. All Rights Reserved.</div><div class=\"line\"> * Author: guolei</div><div class=\"line\"> * Email: 1120832563@qq.com</div><div class=\"line\"> * Date: 18/1/17</div><div class=\"line\"> * Time: 下午2:17</div><div class=\"line\"> * Desc:</div><div class=\"line\"> */</div><div class=\"line\">public class ProgressDrawable extends Drawable &#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    private float progress;</div><div class=\"line\"></div><div class=\"line\">    private Paint mPaint;</div><div class=\"line\">    private Paint mTextPaint;</div><div class=\"line\">    private Path path = new Path();</div><div class=\"line\">    private RectF rectF = new RectF(0, 0, 0, 0);</div><div class=\"line\"></div><div class=\"line\">    private int mBaseline = 0;</div><div class=\"line\"></div><div class=\"line\">    public ProgressDrawable() &#123;</div><div class=\"line\">        mPaint = new Paint();</div><div class=\"line\">        mPaint.setAntiAlias(true);</div><div class=\"line\">        mPaint.setDither(true);</div><div class=\"line\">        mPaint.setColor(Color.parseColor(&quot;#99000000&quot;));</div><div class=\"line\"></div><div class=\"line\">        mTextPaint = new Paint(mPaint);</div><div class=\"line\">        mTextPaint.setColor(Color.WHITE);</div><div class=\"line\">        mTextPaint.setTextSize(40);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public float getProgress() &#123;</div><div class=\"line\">        return progress;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void setProgress(float progress) &#123;</div><div class=\"line\">        this.progress = progress;</div><div class=\"line\">        invalidateSelf();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void draw(@NonNull Canvas canvas) &#123;</div><div class=\"line\">        path.reset();</div><div class=\"line\">        path.addRect(rectF, Path.Direction.CCW);</div><div class=\"line\">        int radius = (int) (progress * ((rectF.right) / 2 * 1.414 - 100)) + 100;</div><div class=\"line\">        path.addCircle(rectF.right / 2, rectF.right / 2, radius &gt; 100 ? radius : 100 , Path.Direction.CW);</div><div class=\"line\">        canvas.drawPath(path, mPaint);</div><div class=\"line\">        canvas.drawCircle(rectF.right / 2, rectF.right / 2, 80, mPaint);</div><div class=\"line\">        String s = String.valueOf(progress * 100).substring(0,2) + &quot;%&quot;;</div><div class=\"line\">        s = s.replace(&quot;.&quot;,&quot;&quot;);</div><div class=\"line\">        int width = (int) mTextPaint.measureText(s);</div><div class=\"line\">        canvas.drawText(s, rectF.right / 2 - (width / 2), mBaseline, mTextPaint);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void setAlpha(int i) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void setColorFilter(@Nullable ColorFilter colorFilter) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public int getOpacity() &#123;</div><div class=\"line\">        return PixelFormat.TRANSLUCENT;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onBoundsChange(Rect bounds) &#123;</div><div class=\"line\">        rectF.set(0, 0, bounds.right, bounds.bottom);</div><div class=\"line\">        computeBaseline();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void computeBaseline() &#123;</div><div class=\"line\">        mBaseline = (int) (rectF.height() / 2 + (Math.abs(mTextPaint.ascent()) - mTextPaint.descent()) / 2);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码很简单，根据进度去绘制，分为3个部分。</p>\n<ul>\n<li>外圈 由path合成</li>\n<li>内圈 Circle</li>\n<li>字 </li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解Drawable的ConstantState","date":"2017-08-22T14:18:25.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n在今天之前，我并不知道还有这么个机制。直到写的代码出了bug。在项目中使用了Tint对图片进行着色处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\nDrawable drawable = ResourcesCompat.getDrawable(getResources(), R.drawable.icon, getTheme());\ndrawable.setBounds(0, 0, 50, 50);\ndrawable = DrawableCompat.wrap(drawable);\nbinding.img.setCompoundDrawables(drawable, null, null, null);\n```\n\n但是，所有使用icon的地方，全部被着色了。一起来探讨下。\n\n### 从资源加载的角度入手\n\n废话不多说，直接看代码。\n\n```\n    public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme)\n            throws NotFoundException {\n        final TypedValue value = obtainTempTypedValue();\n        try {\n            final ResourcesImpl impl = mResourcesImpl;\n            impl.getValue(id, value, true);\n            return impl.loadDrawable(this, value, id, theme, true);\n        } finally {\n            releaseTempTypedValue(value);\n        }\n    }\n```\n\n资源的加载详细过程这里不做过多解释，在6.0的源码中 ，通过ResurcesImpl#loadDrawable来加载图片，当第一次加载我们apk中的drawable资源的时候，因为没有对应cache的关系，会从资源文件中，解析资源，并做相应的cache操作，对应代码如下：\n\n```\n            Drawable dr;\n            if (cs != null) {\n                dr = cs.newDrawable(wrapper);\n            } else if (isColorDrawable) {\n                dr = new ColorDrawable(value.data);\n            } else {\n                dr = loadDrawableForCookie(wrapper, value, id, null);\n            }\n\n            // Determine if the drawable has unresolved theme attributes. If it\n            // does, we'll need to apply a theme and store it in a theme-specific\n            // cache.\n            final boolean canApplyTheme = dr != null && dr.canApplyTheme();\n            if (canApplyTheme && theme != null) {\n                dr = dr.mutate();\n                dr.applyTheme(theme);\n                dr.clearMutated();\n            }\n\n            // If we were able to obtain a drawable, store it in the appropriate\n            // cache: preload, not themed, null theme, or theme-specific. Don't\n            // pollute the cache with drawables loaded from a foreign density.\n            if (dr != null && useCache) {\n                dr.setChangingConfigurations(value.changingConfigurations);\n                cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);\n            }\n```\n\n本文以BitmapDrawable为例，因此，加载全薪资源由loadDrawableForCookie完成，而cache操作由cacheDrawable来完成，那么，我们看下cache了哪些数据。\n\n```\n    private void cacheDrawable(TypedValue value, boolean isColorDrawable, DrawableCache caches,\n            Resources.Theme theme, boolean usesTheme, long key, Drawable dr) {\n        final Drawable.ConstantState cs = dr.getConstantState();\n        if (cs == null) {\n            return;\n        }\n\n        if (mPreloading) {\n            final int changingConfigs = cs.getChangingConfigurations();\n            if (isColorDrawable) {\n                if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, \"drawable\")) {\n                    sPreloadedColorDrawables.put(key, cs);\n                }\n            } else {\n                if (verifyPreloadConfig(\n                        changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, \"drawable\")) {\n                    if ((changingConfigs & LAYOUT_DIR_CONFIG) == 0) {\n                        // If this resource does not vary based on layout direction,\n                        // we can put it in all of the preload maps.\n                        sPreloadedDrawables[0].put(key, cs);\n                        sPreloadedDrawables[1].put(key, cs);\n                    } else {\n                        // Otherwise, only in the layout dir we loaded it for.\n                        sPreloadedDrawables[mConfiguration.getLayoutDirection()].put(key, cs);\n                    }\n                }\n            }\n        } else {\n            synchronized (mAccessLock) {\n                caches.put(key, theme, cs, usesTheme);\n            }\n        }\n    }\n```\n\n重点看头和尾，\n\n* dr.getConstantState\n* caches.put\n\n这里，我们不必要去关心cache的操作，我们关系的是getConstantState,以BitmapDrawable为例，他返回他的类型为BitmapState的成员。\n\n### 再看setTintList与getDrawable读取cache\n\n```\n    @Override\n    public void setTintList(ColorStateList tint) {\n        final BitmapState state = mBitmapState;\n        if (state.mTint != tint) {\n            state.mTint = tint;\n            mTintFilter = updateTintFilter(mTintFilter, tint, mBitmapState.mTintMode);\n            invalidateSelf();\n        }\n    }\n```\n\nBitmapDrawable的setTintList方法，将mBitmapState的mTint属性做了修改，而mBitmapState是被Resource缓存起来了的，因此，缓存中对应的部分也被修改了。\n\n在loadDrawable的方法中，有如下代码片段。\n\n```\nfinal Drawable cachedDrawable = caches.getInstance(key, wrapper, theme);\n```\n当从cache中，获取到之后，就会直接返回。再看下getInstance。\n\n```\n    public Drawable getInstance(long key, Resources resources, Resources.Theme theme) {\n        final Drawable.ConstantState entry = get(key, theme);\n        if (entry != null) {\n            return entry.newDrawable(resources, theme);\n        }\n\n        return null;\n    }\n```\n\n还是以BitmapDrawable为例，\n\n```\n        @Override\n        public Drawable newDrawable() {\n            return new BitmapDrawable(this, null);\n        }\n```\n\n因此，我们在先前修改了的mTint也被复制给了后续cache的Drawable，因此，他们也被着色了。\n\n### 如何避免\n\n想要避免这个问题，也很简单，调用Drawable#mutate方法，这个方法会返回一个新的State，我们对这个进行修改是不会作用到原先的State的.\n\n### 总结\n\n上述的Drawable.ConstantState，就是我们想说的ConstantState。这个的设计是为了节约内存。官方blog中也有对这个的介绍。详情见链接，需要翻墙。\n\n[Drawable mutations](https://android-developers.googleblog.com/2009/05/drawable-mutations.html)\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/了解Drawable的ConstantState.md","raw":"---\ntitle: 了解Drawable的ConstantState\ndate: 2017-08-22 22:18:25\ncategory: Android\ntags: Android\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n在今天之前，我并不知道还有这么个机制。直到写的代码出了bug。在项目中使用了Tint对图片进行着色处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\nDrawable drawable = ResourcesCompat.getDrawable(getResources(), R.drawable.icon, getTheme());\ndrawable.setBounds(0, 0, 50, 50);\ndrawable = DrawableCompat.wrap(drawable);\nbinding.img.setCompoundDrawables(drawable, null, null, null);\n```\n\n但是，所有使用icon的地方，全部被着色了。一起来探讨下。\n\n### 从资源加载的角度入手\n\n废话不多说，直接看代码。\n\n```\n    public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme)\n            throws NotFoundException {\n        final TypedValue value = obtainTempTypedValue();\n        try {\n            final ResourcesImpl impl = mResourcesImpl;\n            impl.getValue(id, value, true);\n            return impl.loadDrawable(this, value, id, theme, true);\n        } finally {\n            releaseTempTypedValue(value);\n        }\n    }\n```\n\n资源的加载详细过程这里不做过多解释，在6.0的源码中 ，通过ResurcesImpl#loadDrawable来加载图片，当第一次加载我们apk中的drawable资源的时候，因为没有对应cache的关系，会从资源文件中，解析资源，并做相应的cache操作，对应代码如下：\n\n```\n            Drawable dr;\n            if (cs != null) {\n                dr = cs.newDrawable(wrapper);\n            } else if (isColorDrawable) {\n                dr = new ColorDrawable(value.data);\n            } else {\n                dr = loadDrawableForCookie(wrapper, value, id, null);\n            }\n\n            // Determine if the drawable has unresolved theme attributes. If it\n            // does, we'll need to apply a theme and store it in a theme-specific\n            // cache.\n            final boolean canApplyTheme = dr != null && dr.canApplyTheme();\n            if (canApplyTheme && theme != null) {\n                dr = dr.mutate();\n                dr.applyTheme(theme);\n                dr.clearMutated();\n            }\n\n            // If we were able to obtain a drawable, store it in the appropriate\n            // cache: preload, not themed, null theme, or theme-specific. Don't\n            // pollute the cache with drawables loaded from a foreign density.\n            if (dr != null && useCache) {\n                dr.setChangingConfigurations(value.changingConfigurations);\n                cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);\n            }\n```\n\n本文以BitmapDrawable为例，因此，加载全薪资源由loadDrawableForCookie完成，而cache操作由cacheDrawable来完成，那么，我们看下cache了哪些数据。\n\n```\n    private void cacheDrawable(TypedValue value, boolean isColorDrawable, DrawableCache caches,\n            Resources.Theme theme, boolean usesTheme, long key, Drawable dr) {\n        final Drawable.ConstantState cs = dr.getConstantState();\n        if (cs == null) {\n            return;\n        }\n\n        if (mPreloading) {\n            final int changingConfigs = cs.getChangingConfigurations();\n            if (isColorDrawable) {\n                if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, \"drawable\")) {\n                    sPreloadedColorDrawables.put(key, cs);\n                }\n            } else {\n                if (verifyPreloadConfig(\n                        changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, \"drawable\")) {\n                    if ((changingConfigs & LAYOUT_DIR_CONFIG) == 0) {\n                        // If this resource does not vary based on layout direction,\n                        // we can put it in all of the preload maps.\n                        sPreloadedDrawables[0].put(key, cs);\n                        sPreloadedDrawables[1].put(key, cs);\n                    } else {\n                        // Otherwise, only in the layout dir we loaded it for.\n                        sPreloadedDrawables[mConfiguration.getLayoutDirection()].put(key, cs);\n                    }\n                }\n            }\n        } else {\n            synchronized (mAccessLock) {\n                caches.put(key, theme, cs, usesTheme);\n            }\n        }\n    }\n```\n\n重点看头和尾，\n\n* dr.getConstantState\n* caches.put\n\n这里，我们不必要去关心cache的操作，我们关系的是getConstantState,以BitmapDrawable为例，他返回他的类型为BitmapState的成员。\n\n### 再看setTintList与getDrawable读取cache\n\n```\n    @Override\n    public void setTintList(ColorStateList tint) {\n        final BitmapState state = mBitmapState;\n        if (state.mTint != tint) {\n            state.mTint = tint;\n            mTintFilter = updateTintFilter(mTintFilter, tint, mBitmapState.mTintMode);\n            invalidateSelf();\n        }\n    }\n```\n\nBitmapDrawable的setTintList方法，将mBitmapState的mTint属性做了修改，而mBitmapState是被Resource缓存起来了的，因此，缓存中对应的部分也被修改了。\n\n在loadDrawable的方法中，有如下代码片段。\n\n```\nfinal Drawable cachedDrawable = caches.getInstance(key, wrapper, theme);\n```\n当从cache中，获取到之后，就会直接返回。再看下getInstance。\n\n```\n    public Drawable getInstance(long key, Resources resources, Resources.Theme theme) {\n        final Drawable.ConstantState entry = get(key, theme);\n        if (entry != null) {\n            return entry.newDrawable(resources, theme);\n        }\n\n        return null;\n    }\n```\n\n还是以BitmapDrawable为例，\n\n```\n        @Override\n        public Drawable newDrawable() {\n            return new BitmapDrawable(this, null);\n        }\n```\n\n因此，我们在先前修改了的mTint也被复制给了后续cache的Drawable，因此，他们也被着色了。\n\n### 如何避免\n\n想要避免这个问题，也很简单，调用Drawable#mutate方法，这个方法会返回一个新的State，我们对这个进行修改是不会作用到原先的State的.\n\n### 总结\n\n上述的Drawable.ConstantState，就是我们想说的ConstantState。这个的设计是为了节约内存。官方blog中也有对这个的介绍。详情见链接，需要翻墙。\n\n[Drawable mutations](https://android-developers.googleblog.com/2009/05/drawable-mutations.html)\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"了解Drawable的ConstantState","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzo004w19fykfwhlq3a","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在今天之前，我并不知道还有这么个机制。直到写的代码出了bug。在项目中使用了Tint对图片进行着色处理。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Drawable drawable = ResourcesCompat.getDrawable(getResources(), R.drawable.icon, getTheme());</div><div class=\"line\">drawable.setBounds(0, 0, 50, 50);</div><div class=\"line\">drawable = DrawableCompat.wrap(drawable);</div><div class=\"line\">binding.img.setCompoundDrawables(drawable, null, null, null);</div></pre></td></tr></table></figure>\n<p>但是，所有使用icon的地方，全部被着色了。一起来探讨下。</p>\n<h3 id=\"从资源加载的角度入手\"><a href=\"#从资源加载的角度入手\" class=\"headerlink\" title=\"从资源加载的角度入手\"></a>从资源加载的角度入手</h3><p>废话不多说，直接看代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme)</div><div class=\"line\">        throws NotFoundException &#123;</div><div class=\"line\">    final TypedValue value = obtainTempTypedValue();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        final ResourcesImpl impl = mResourcesImpl;</div><div class=\"line\">        impl.getValue(id, value, true);</div><div class=\"line\">        return impl.loadDrawable(this, value, id, theme, true);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        releaseTempTypedValue(value);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>资源的加载详细过程这里不做过多解释，在6.0的源码中 ，通过ResurcesImpl#loadDrawable来加载图片，当第一次加载我们apk中的drawable资源的时候，因为没有对应cache的关系，会从资源文件中，解析资源，并做相应的cache操作，对应代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Drawable dr;</div><div class=\"line\">if (cs != null) &#123;</div><div class=\"line\">    dr = cs.newDrawable(wrapper);</div><div class=\"line\">&#125; else if (isColorDrawable) &#123;</div><div class=\"line\">    dr = new ColorDrawable(value.data);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    dr = loadDrawableForCookie(wrapper, value, id, null);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Determine if the drawable has unresolved theme attributes. If it</div><div class=\"line\">// does, we&apos;ll need to apply a theme and store it in a theme-specific</div><div class=\"line\">// cache.</div><div class=\"line\">final boolean canApplyTheme = dr != null &amp;&amp; dr.canApplyTheme();</div><div class=\"line\">if (canApplyTheme &amp;&amp; theme != null) &#123;</div><div class=\"line\">    dr = dr.mutate();</div><div class=\"line\">    dr.applyTheme(theme);</div><div class=\"line\">    dr.clearMutated();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// If we were able to obtain a drawable, store it in the appropriate</div><div class=\"line\">// cache: preload, not themed, null theme, or theme-specific. Don&apos;t</div><div class=\"line\">// pollute the cache with drawables loaded from a foreign density.</div><div class=\"line\">if (dr != null &amp;&amp; useCache) &#123;</div><div class=\"line\">    dr.setChangingConfigurations(value.changingConfigurations);</div><div class=\"line\">    cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本文以BitmapDrawable为例，因此，加载全薪资源由loadDrawableForCookie完成，而cache操作由cacheDrawable来完成，那么，我们看下cache了哪些数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void cacheDrawable(TypedValue value, boolean isColorDrawable, DrawableCache caches,</div><div class=\"line\">        Resources.Theme theme, boolean usesTheme, long key, Drawable dr) &#123;</div><div class=\"line\">    final Drawable.ConstantState cs = dr.getConstantState();</div><div class=\"line\">    if (cs == null) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mPreloading) &#123;</div><div class=\"line\">        final int changingConfigs = cs.getChangingConfigurations();</div><div class=\"line\">        if (isColorDrawable) &#123;</div><div class=\"line\">            if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, &quot;drawable&quot;)) &#123;</div><div class=\"line\">                sPreloadedColorDrawables.put(key, cs);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (verifyPreloadConfig(</div><div class=\"line\">                    changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, &quot;drawable&quot;)) &#123;</div><div class=\"line\">                if ((changingConfigs &amp; LAYOUT_DIR_CONFIG) == 0) &#123;</div><div class=\"line\">                    // If this resource does not vary based on layout direction,</div><div class=\"line\">                    // we can put it in all of the preload maps.</div><div class=\"line\">                    sPreloadedDrawables[0].put(key, cs);</div><div class=\"line\">                    sPreloadedDrawables[1].put(key, cs);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Otherwise, only in the layout dir we loaded it for.</div><div class=\"line\">                    sPreloadedDrawables[mConfiguration.getLayoutDirection()].put(key, cs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        synchronized (mAccessLock) &#123;</div><div class=\"line\">            caches.put(key, theme, cs, usesTheme);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重点看头和尾，</p>\n<ul>\n<li>dr.getConstantState</li>\n<li>caches.put</li>\n</ul>\n<p>这里，我们不必要去关心cache的操作，我们关系的是getConstantState,以BitmapDrawable为例，他返回他的类型为BitmapState的成员。</p>\n<h3 id=\"再看setTintList与getDrawable读取cache\"><a href=\"#再看setTintList与getDrawable读取cache\" class=\"headerlink\" title=\"再看setTintList与getDrawable读取cache\"></a>再看setTintList与getDrawable读取cache</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void setTintList(ColorStateList tint) &#123;</div><div class=\"line\">    final BitmapState state = mBitmapState;</div><div class=\"line\">    if (state.mTint != tint) &#123;</div><div class=\"line\">        state.mTint = tint;</div><div class=\"line\">        mTintFilter = updateTintFilter(mTintFilter, tint, mBitmapState.mTintMode);</div><div class=\"line\">        invalidateSelf();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>BitmapDrawable的setTintList方法，将mBitmapState的mTint属性做了修改，而mBitmapState是被Resource缓存起来了的，因此，缓存中对应的部分也被修改了。</p>\n<p>在loadDrawable的方法中，有如下代码片段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Drawable cachedDrawable = caches.getInstance(key, wrapper, theme);</div></pre></td></tr></table></figure>\n<p>当从cache中，获取到之后，就会直接返回。再看下getInstance。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Drawable getInstance(long key, Resources resources, Resources.Theme theme) &#123;</div><div class=\"line\">    final Drawable.ConstantState entry = get(key, theme);</div><div class=\"line\">    if (entry != null) &#123;</div><div class=\"line\">        return entry.newDrawable(resources, theme);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还是以BitmapDrawable为例，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Drawable newDrawable() &#123;</div><div class=\"line\">    return new BitmapDrawable(this, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因此，我们在先前修改了的mTint也被复制给了后续cache的Drawable，因此，他们也被着色了。</p>\n<h3 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h3><p>想要避免这个问题，也很简单，调用Drawable#mutate方法，这个方法会返回一个新的State，我们对这个进行修改是不会作用到原先的State的.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上述的Drawable.ConstantState，就是我们想说的ConstantState。这个的设计是为了节约内存。官方blog中也有对这个的介绍。详情见链接，需要翻墙。</p>\n<p><a href=\"https://android-developers.googleblog.com/2009/05/drawable-mutations.html\" target=\"_blank\" rel=\"external\">Drawable mutations</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在今天之前，我并不知道还有这么个机制。直到写的代码出了bug。在项目中使用了Tint对图片进行着色处理。</p>","more":"<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Drawable drawable = ResourcesCompat.getDrawable(getResources(), R.drawable.icon, getTheme());</div><div class=\"line\">drawable.setBounds(0, 0, 50, 50);</div><div class=\"line\">drawable = DrawableCompat.wrap(drawable);</div><div class=\"line\">binding.img.setCompoundDrawables(drawable, null, null, null);</div></pre></td></tr></table></figure>\n<p>但是，所有使用icon的地方，全部被着色了。一起来探讨下。</p>\n<h3 id=\"从资源加载的角度入手\"><a href=\"#从资源加载的角度入手\" class=\"headerlink\" title=\"从资源加载的角度入手\"></a>从资源加载的角度入手</h3><p>废话不多说，直接看代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme)</div><div class=\"line\">        throws NotFoundException &#123;</div><div class=\"line\">    final TypedValue value = obtainTempTypedValue();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        final ResourcesImpl impl = mResourcesImpl;</div><div class=\"line\">        impl.getValue(id, value, true);</div><div class=\"line\">        return impl.loadDrawable(this, value, id, theme, true);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        releaseTempTypedValue(value);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>资源的加载详细过程这里不做过多解释，在6.0的源码中 ，通过ResurcesImpl#loadDrawable来加载图片，当第一次加载我们apk中的drawable资源的时候，因为没有对应cache的关系，会从资源文件中，解析资源，并做相应的cache操作，对应代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Drawable dr;</div><div class=\"line\">if (cs != null) &#123;</div><div class=\"line\">    dr = cs.newDrawable(wrapper);</div><div class=\"line\">&#125; else if (isColorDrawable) &#123;</div><div class=\"line\">    dr = new ColorDrawable(value.data);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    dr = loadDrawableForCookie(wrapper, value, id, null);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Determine if the drawable has unresolved theme attributes. If it</div><div class=\"line\">// does, we&apos;ll need to apply a theme and store it in a theme-specific</div><div class=\"line\">// cache.</div><div class=\"line\">final boolean canApplyTheme = dr != null &amp;&amp; dr.canApplyTheme();</div><div class=\"line\">if (canApplyTheme &amp;&amp; theme != null) &#123;</div><div class=\"line\">    dr = dr.mutate();</div><div class=\"line\">    dr.applyTheme(theme);</div><div class=\"line\">    dr.clearMutated();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// If we were able to obtain a drawable, store it in the appropriate</div><div class=\"line\">// cache: preload, not themed, null theme, or theme-specific. Don&apos;t</div><div class=\"line\">// pollute the cache with drawables loaded from a foreign density.</div><div class=\"line\">if (dr != null &amp;&amp; useCache) &#123;</div><div class=\"line\">    dr.setChangingConfigurations(value.changingConfigurations);</div><div class=\"line\">    cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本文以BitmapDrawable为例，因此，加载全薪资源由loadDrawableForCookie完成，而cache操作由cacheDrawable来完成，那么，我们看下cache了哪些数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void cacheDrawable(TypedValue value, boolean isColorDrawable, DrawableCache caches,</div><div class=\"line\">        Resources.Theme theme, boolean usesTheme, long key, Drawable dr) &#123;</div><div class=\"line\">    final Drawable.ConstantState cs = dr.getConstantState();</div><div class=\"line\">    if (cs == null) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mPreloading) &#123;</div><div class=\"line\">        final int changingConfigs = cs.getChangingConfigurations();</div><div class=\"line\">        if (isColorDrawable) &#123;</div><div class=\"line\">            if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, &quot;drawable&quot;)) &#123;</div><div class=\"line\">                sPreloadedColorDrawables.put(key, cs);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (verifyPreloadConfig(</div><div class=\"line\">                    changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, &quot;drawable&quot;)) &#123;</div><div class=\"line\">                if ((changingConfigs &amp; LAYOUT_DIR_CONFIG) == 0) &#123;</div><div class=\"line\">                    // If this resource does not vary based on layout direction,</div><div class=\"line\">                    // we can put it in all of the preload maps.</div><div class=\"line\">                    sPreloadedDrawables[0].put(key, cs);</div><div class=\"line\">                    sPreloadedDrawables[1].put(key, cs);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Otherwise, only in the layout dir we loaded it for.</div><div class=\"line\">                    sPreloadedDrawables[mConfiguration.getLayoutDirection()].put(key, cs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        synchronized (mAccessLock) &#123;</div><div class=\"line\">            caches.put(key, theme, cs, usesTheme);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重点看头和尾，</p>\n<ul>\n<li>dr.getConstantState</li>\n<li>caches.put</li>\n</ul>\n<p>这里，我们不必要去关心cache的操作，我们关系的是getConstantState,以BitmapDrawable为例，他返回他的类型为BitmapState的成员。</p>\n<h3 id=\"再看setTintList与getDrawable读取cache\"><a href=\"#再看setTintList与getDrawable读取cache\" class=\"headerlink\" title=\"再看setTintList与getDrawable读取cache\"></a>再看setTintList与getDrawable读取cache</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void setTintList(ColorStateList tint) &#123;</div><div class=\"line\">    final BitmapState state = mBitmapState;</div><div class=\"line\">    if (state.mTint != tint) &#123;</div><div class=\"line\">        state.mTint = tint;</div><div class=\"line\">        mTintFilter = updateTintFilter(mTintFilter, tint, mBitmapState.mTintMode);</div><div class=\"line\">        invalidateSelf();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>BitmapDrawable的setTintList方法，将mBitmapState的mTint属性做了修改，而mBitmapState是被Resource缓存起来了的，因此，缓存中对应的部分也被修改了。</p>\n<p>在loadDrawable的方法中，有如下代码片段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Drawable cachedDrawable = caches.getInstance(key, wrapper, theme);</div></pre></td></tr></table></figure>\n<p>当从cache中，获取到之后，就会直接返回。再看下getInstance。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Drawable getInstance(long key, Resources resources, Resources.Theme theme) &#123;</div><div class=\"line\">    final Drawable.ConstantState entry = get(key, theme);</div><div class=\"line\">    if (entry != null) &#123;</div><div class=\"line\">        return entry.newDrawable(resources, theme);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还是以BitmapDrawable为例，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Drawable newDrawable() &#123;</div><div class=\"line\">    return new BitmapDrawable(this, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因此，我们在先前修改了的mTint也被复制给了后续cache的Drawable，因此，他们也被着色了。</p>\n<h3 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h3><p>想要避免这个问题，也很简单，调用Drawable#mutate方法，这个方法会返回一个新的State，我们对这个进行修改是不会作用到原先的State的.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上述的Drawable.ConstantState，就是我们想说的ConstantState。这个的设计是为了节约内存。官方blog中也有对这个的介绍。详情见链接，需要翻墙。</p>\n<p><a href=\"https://android-developers.googleblog.com/2009/05/drawable-mutations.html\">Drawable mutations</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解gradle（一）","date":"2016-12-05T13:27:31.000Z","_content":"<Excerpt in index | 首页摘要>\n想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。\n\n### 1.依赖管理\n\n```\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n    testCompile group: 'junit', name: 'junit', version: '4.+'\n}\n```\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n* respositories 声明我们要使用的仓库\n* dependencies 我们要依赖的一些东西\n\t* compile 依赖需要编译生产项目的来源\n\t* runtime 依赖运行时字节码\n\t* testCompile 依赖测试代码\n\t* testRuntime \n\t\n通常，我们声明仓库有两种方式\n\n* 使用中央仓库 mavenCentral()\n* 使用自己的仓库\n\t* 使用远程仓库\n\t\n\t\t```\n\trepositories {\n    maven {\n    \t// 自己远程仓库地址\n        url \"http://repo.mycompany.com/maven2\"\n    }\n}\n\t```\n\t* 使用本地仓库\t \n\t\n\t\t```\n\t\trepositories {\n    ivy {\n        // URL can refer to a local directory\n        url \"../local-repo\"\n    }\n}\n\t\t```\n\t\t\n\t\t\n\t\t\n再说我们的依赖包管理，同样有两种方式\n\n```\n// 1\ncompile 'org.hibernate:hibernate-core:3.6.7.Final'\n// 2\ncompile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n```\n\n我们最常用的是第一种方法。\n\n有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除\n\n```\n    compile(\"com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version\") {\n        exclude group: 'com.squareup.retrofit2'\n    }\n```\n\n关于如何上传仓库这里暂时不介绍,[可以看这里](https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle)\n\n### 2.编写gradle脚本\n\n#### 2.1 Project API\n\n```\nprintln project.buildDir\n```\n\n我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。\n\n#### 2.2 如何定义变量\n\n\n\n和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。\n\n```\ndef my_name = \"guolei\"\nprintln my_nme\n```\n\n#### 2.3 Extra 属性\n\n```\next {\n    my_name = \"guolei\"\n}\n\nprintln ext.my_name;\n```\n\n#### 2.4 TASK \n\ngradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。[gradle api文档地址](https://docs.gradle.org/current/javadoc/)，关于Api的使用，这里就不介绍了，文档上使用方法很全。\n\n#### 2.5 TASK之间的依赖关系\n\n我们可以使用dependsOn来指明task之间的关系。\n\n```\ntaskX.dependsOn taskY\n\n```\n\n如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。\n\n\n#### 2.6 有序的TASKS\n\n* shouldRunAfter\n* mustRunAfter\n\n\n#### 2.7 给task添加描述\n\n```\ntask a {\n\tdescription \"xxx\"\n\tprintln \"xx\"\n}\n\n```\n\n#### 2.8 跳过task不执行\n\n* onlyIf,满足条件的情况下才执行\n\n```\ntask hello {\n    doLast {\n        println 'hello world'\n    }\n}\n\nhello.onlyIf { !project.hasProperty('skipHello') }\n```\n\n* 用异常\n\n```\ncompile.doFirst {\n    // Here you would put arbitrary conditions in real life.\n    // But this is used in an integration test so we want defined behavior.\n    if (true) { throw new StopExecutionException() }\n}\n```\n\n* enabled属性\n\n```\ntask.enabled = false\n```\n\n### 3.如何操作文件\n\n\n我们可以利用Project.file 方法去获取文件\n\n```\n// Using a relative path\nFile configFile = file('src/config.xml')\n\n// Using an absolute path\nconfigFile = file(configFile.absolutePath)\n\n// Using a File object with a relative path\nconfigFile = file(new File('src/config.xml'))\n```\n\n\n然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）\n\n```\n\nFileCollection collection = files('src/file1.txt',new File('src/file2.txt'),['src/file3.txt', 'src/file4.txt'])\n```\n\n可以利用Project.fileTree获取文件树。\n\n```\n// Create a file tree with a base directory\nFileTree tree = fileTree(dir: 'src/main')\n\n// Add include and exclude patterns to the tree\ntree.include '**/*.java'\ntree.exclude '**/Abstract*'\n\n// Create a tree using path\ntree = fileTree('src').include('**/*.java')\n\n// Create a tree using closure\ntree = fileTree('src') {\n    include '**/*.java'\n}\n\n// Create a tree using a map\ntree = fileTree(dir: 'src', include: '**/*.java')\ntree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])\ntree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')\n\n```\n\n我们可以操作压缩文件。\n\n```\n\n// Create a ZIP file tree using path\nFileTree zip = zipTree('someFile.zip')\n\n// Create a TAR file tree using path\nFileTree tar = tarTree('someFile.tar')\n\n//tar tree attempts to guess the compression based on the file extension\n//however if you must specify the compression explicitly you can:\nFileTree someTar = tarTree(resources.gzip('someTar.ext'))\n```\n\n文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。\n\n关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。\n\n\n### 4. 如何打log\n\n我们可以通过logger的一些方法输出log日志\n\n```\nogger.quiet('An info log message which is always logged.')\nlogger.error('An error log message.')\nlogger.warn('A warning log message.')\nlogger.lifecycle('A lifecycle info log message.')\nlogger.info('An info log message.')\nlogger.debug('A debug log message.')\nlogger.trace('A trace log message.')\n```\n\n### 5. gradle plugins\n\n```\napply from: 'other.gradle'\n```\n\n```\nplugins {\n    id «plugin id» version «plugin version» [apply «false»]\n}\n```\n\n```\n apply plugin: 'org.gradle.sample.goodbye'\n```\n\n三种方式。\n\n### 6.总结 \n\n上面的一些用法，全部来自于文档.\n\n[gradle 文档地址](https://docs.gradle.org/current/userguide/)\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/了解gradle（一）.md","raw":"---\ntitle: 了解gradle（一）\ndate: 2016-12-05 21:27:31\ncategories: Gradle\ntags: gradle\n\n---\n<Excerpt in index | 首页摘要>\n想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。\n\n### 1.依赖管理\n\n```\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n    testCompile group: 'junit', name: 'junit', version: '4.+'\n}\n```\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n* respositories 声明我们要使用的仓库\n* dependencies 我们要依赖的一些东西\n\t* compile 依赖需要编译生产项目的来源\n\t* runtime 依赖运行时字节码\n\t* testCompile 依赖测试代码\n\t* testRuntime \n\t\n通常，我们声明仓库有两种方式\n\n* 使用中央仓库 mavenCentral()\n* 使用自己的仓库\n\t* 使用远程仓库\n\t\n\t\t```\n\trepositories {\n    maven {\n    \t// 自己远程仓库地址\n        url \"http://repo.mycompany.com/maven2\"\n    }\n}\n\t```\n\t* 使用本地仓库\t \n\t\n\t\t```\n\t\trepositories {\n    ivy {\n        // URL can refer to a local directory\n        url \"../local-repo\"\n    }\n}\n\t\t```\n\t\t\n\t\t\n\t\t\n再说我们的依赖包管理，同样有两种方式\n\n```\n// 1\ncompile 'org.hibernate:hibernate-core:3.6.7.Final'\n// 2\ncompile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n```\n\n我们最常用的是第一种方法。\n\n有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除\n\n```\n    compile(\"com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version\") {\n        exclude group: 'com.squareup.retrofit2'\n    }\n```\n\n关于如何上传仓库这里暂时不介绍,[可以看这里](https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle)\n\n### 2.编写gradle脚本\n\n#### 2.1 Project API\n\n```\nprintln project.buildDir\n```\n\n我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。\n\n#### 2.2 如何定义变量\n\n\n\n和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。\n\n```\ndef my_name = \"guolei\"\nprintln my_nme\n```\n\n#### 2.3 Extra 属性\n\n```\next {\n    my_name = \"guolei\"\n}\n\nprintln ext.my_name;\n```\n\n#### 2.4 TASK \n\ngradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。[gradle api文档地址](https://docs.gradle.org/current/javadoc/)，关于Api的使用，这里就不介绍了，文档上使用方法很全。\n\n#### 2.5 TASK之间的依赖关系\n\n我们可以使用dependsOn来指明task之间的关系。\n\n```\ntaskX.dependsOn taskY\n\n```\n\n如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。\n\n\n#### 2.6 有序的TASKS\n\n* shouldRunAfter\n* mustRunAfter\n\n\n#### 2.7 给task添加描述\n\n```\ntask a {\n\tdescription \"xxx\"\n\tprintln \"xx\"\n}\n\n```\n\n#### 2.8 跳过task不执行\n\n* onlyIf,满足条件的情况下才执行\n\n```\ntask hello {\n    doLast {\n        println 'hello world'\n    }\n}\n\nhello.onlyIf { !project.hasProperty('skipHello') }\n```\n\n* 用异常\n\n```\ncompile.doFirst {\n    // Here you would put arbitrary conditions in real life.\n    // But this is used in an integration test so we want defined behavior.\n    if (true) { throw new StopExecutionException() }\n}\n```\n\n* enabled属性\n\n```\ntask.enabled = false\n```\n\n### 3.如何操作文件\n\n\n我们可以利用Project.file 方法去获取文件\n\n```\n// Using a relative path\nFile configFile = file('src/config.xml')\n\n// Using an absolute path\nconfigFile = file(configFile.absolutePath)\n\n// Using a File object with a relative path\nconfigFile = file(new File('src/config.xml'))\n```\n\n\n然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）\n\n```\n\nFileCollection collection = files('src/file1.txt',new File('src/file2.txt'),['src/file3.txt', 'src/file4.txt'])\n```\n\n可以利用Project.fileTree获取文件树。\n\n```\n// Create a file tree with a base directory\nFileTree tree = fileTree(dir: 'src/main')\n\n// Add include and exclude patterns to the tree\ntree.include '**/*.java'\ntree.exclude '**/Abstract*'\n\n// Create a tree using path\ntree = fileTree('src').include('**/*.java')\n\n// Create a tree using closure\ntree = fileTree('src') {\n    include '**/*.java'\n}\n\n// Create a tree using a map\ntree = fileTree(dir: 'src', include: '**/*.java')\ntree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])\ntree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')\n\n```\n\n我们可以操作压缩文件。\n\n```\n\n// Create a ZIP file tree using path\nFileTree zip = zipTree('someFile.zip')\n\n// Create a TAR file tree using path\nFileTree tar = tarTree('someFile.tar')\n\n//tar tree attempts to guess the compression based on the file extension\n//however if you must specify the compression explicitly you can:\nFileTree someTar = tarTree(resources.gzip('someTar.ext'))\n```\n\n文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。\n\n关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。\n\n\n### 4. 如何打log\n\n我们可以通过logger的一些方法输出log日志\n\n```\nogger.quiet('An info log message which is always logged.')\nlogger.error('An error log message.')\nlogger.warn('A warning log message.')\nlogger.lifecycle('A lifecycle info log message.')\nlogger.info('An info log message.')\nlogger.debug('A debug log message.')\nlogger.trace('A trace log message.')\n```\n\n### 5. gradle plugins\n\n```\napply from: 'other.gradle'\n```\n\n```\nplugins {\n    id «plugin id» version «plugin version» [apply «false»]\n}\n```\n\n```\n apply plugin: 'org.gradle.sample.goodbye'\n```\n\n三种方式。\n\n### 6.总结 \n\n上面的一些用法，全部来自于文档.\n\n[gradle 文档地址](https://docs.gradle.org/current/userguide/)\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"了解gradle（一）","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzq005019fyg95jvfps","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br>想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。</excerpt></p>\n<h3 id=\"1-依赖管理\"><a href=\"#1-依赖管理\" class=\"headerlink\" title=\"1.依赖管理\"></a>1.依赖管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div><div class=\"line\">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.+&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<ul>\n<li>respositories 声明我们要使用的仓库</li>\n<li>dependencies 我们要依赖的一些东西<ul>\n<li>compile 依赖需要编译生产项目的来源</li>\n<li>runtime 依赖运行时字节码</li>\n<li>testCompile 依赖测试代码</li>\n<li>testRuntime </li>\n</ul>\n</li>\n</ul>\n<p>通常，我们声明仓库有两种方式</p>\n<ul>\n<li>使用中央仓库 mavenCentral()</li>\n<li><p>使用自己的仓库</p>\n<ul>\n<li><p>使用远程仓库</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\trepositories &#123;</div><div class=\"line\">    maven &#123;</div><div class=\"line\">    \t// 自己远程仓库地址</div><div class=\"line\">        url &quot;http://repo.mycompany.com/maven2&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用本地仓库     </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\trepositories &#123;</div><div class=\"line\">    ivy &#123;</div><div class=\"line\">        // URL can refer to a local directory</div><div class=\"line\">        url &quot;../local-repo&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>再说我们的依赖包管理，同样有两种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos;</div><div class=\"line\">// 2</div><div class=\"line\">compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div></pre></td></tr></table></figure>\n<p>我们最常用的是第一种方法。</p>\n<p>有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile(&quot;com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version&quot;) &#123;</div><div class=\"line\">    exclude group: &apos;com.squareup.retrofit2&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于如何上传仓库这里暂时不介绍,<a href=\"https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle\" target=\"_blank\" rel=\"external\">可以看这里</a></p>\n<h3 id=\"2-编写gradle脚本\"><a href=\"#2-编写gradle脚本\" class=\"headerlink\" title=\"2.编写gradle脚本\"></a>2.编写gradle脚本</h3><h4 id=\"2-1-Project-API\"><a href=\"#2-1-Project-API\" class=\"headerlink\" title=\"2.1 Project API\"></a>2.1 Project API</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">println project.buildDir</div></pre></td></tr></table></figure>\n<p>我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。</p>\n<h4 id=\"2-2-如何定义变量\"><a href=\"#2-2-如何定义变量\" class=\"headerlink\" title=\"2.2 如何定义变量\"></a>2.2 如何定义变量</h4><p>和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def my_name = &quot;guolei&quot;</div><div class=\"line\">println my_nme</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-Extra-属性\"><a href=\"#2-3-Extra-属性\" class=\"headerlink\" title=\"2.3 Extra 属性\"></a>2.3 Extra 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ext &#123;</div><div class=\"line\">    my_name = &quot;guolei&quot;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">println ext.my_name;</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-TASK\"><a href=\"#2-4-TASK\" class=\"headerlink\" title=\"2.4 TASK\"></a>2.4 TASK</h4><p>gradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。<a href=\"https://docs.gradle.org/current/javadoc/\" target=\"_blank\" rel=\"external\">gradle api文档地址</a>，关于Api的使用，这里就不介绍了，文档上使用方法很全。</p>\n<h4 id=\"2-5-TASK之间的依赖关系\"><a href=\"#2-5-TASK之间的依赖关系\" class=\"headerlink\" title=\"2.5 TASK之间的依赖关系\"></a>2.5 TASK之间的依赖关系</h4><p>我们可以使用dependsOn来指明task之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">taskX.dependsOn taskY</div></pre></td></tr></table></figure>\n<p>如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。</p>\n<h4 id=\"2-6-有序的TASKS\"><a href=\"#2-6-有序的TASKS\" class=\"headerlink\" title=\"2.6 有序的TASKS\"></a>2.6 有序的TASKS</h4><ul>\n<li>shouldRunAfter</li>\n<li>mustRunAfter</li>\n</ul>\n<h4 id=\"2-7-给task添加描述\"><a href=\"#2-7-给task添加描述\" class=\"headerlink\" title=\"2.7 给task添加描述\"></a>2.7 给task添加描述</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">task a &#123;</div><div class=\"line\">\tdescription &quot;xxx&quot;</div><div class=\"line\">\tprintln &quot;xx&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-8-跳过task不执行\"><a href=\"#2-8-跳过task不执行\" class=\"headerlink\" title=\"2.8 跳过task不执行\"></a>2.8 跳过task不执行</h4><ul>\n<li>onlyIf,满足条件的情况下才执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">task hello &#123;</div><div class=\"line\">    doLast &#123;</div><div class=\"line\">        println &apos;hello world&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">hello.onlyIf &#123; !project.hasProperty(&apos;skipHello&apos;) &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>用异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile.doFirst &#123;</div><div class=\"line\">    // Here you would put arbitrary conditions in real life.</div><div class=\"line\">    // But this is used in an integration test so we want defined behavior.</div><div class=\"line\">    if (true) &#123; throw new StopExecutionException() &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>enabled属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task.enabled = false</div></pre></td></tr></table></figure>\n<h3 id=\"3-如何操作文件\"><a href=\"#3-如何操作文件\" class=\"headerlink\" title=\"3.如何操作文件\"></a>3.如何操作文件</h3><p>我们可以利用Project.file 方法去获取文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Using a relative path</div><div class=\"line\">File configFile = file(&apos;src/config.xml&apos;)</div><div class=\"line\"></div><div class=\"line\">// Using an absolute path</div><div class=\"line\">configFile = file(configFile.absolutePath)</div><div class=\"line\"></div><div class=\"line\">// Using a File object with a relative path</div><div class=\"line\">configFile = file(new File(&apos;src/config.xml&apos;))</div></pre></td></tr></table></figure>\n<p>然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">FileCollection collection = files(&apos;src/file1.txt&apos;,new File(&apos;src/file2.txt&apos;),[&apos;src/file3.txt&apos;, &apos;src/file4.txt&apos;])</div></pre></td></tr></table></figure>\n<p>可以利用Project.fileTree获取文件树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Create a file tree with a base directory</div><div class=\"line\">FileTree tree = fileTree(dir: &apos;src/main&apos;)</div><div class=\"line\"></div><div class=\"line\">// Add include and exclude patterns to the tree</div><div class=\"line\">tree.include &apos;**/*.java&apos;</div><div class=\"line\">tree.exclude &apos;**/Abstract*&apos;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using path</div><div class=\"line\">tree = fileTree(&apos;src&apos;).include(&apos;**/*.java&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a tree using closure</div><div class=\"line\">tree = fileTree(&apos;src&apos;) &#123;</div><div class=\"line\">    include &apos;**/*.java&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using a map</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;)</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, includes: [&apos;**/*.java&apos;, &apos;**/*.xml&apos;])</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;, exclude: &apos;**/*test*/**&apos;)</div></pre></td></tr></table></figure>\n<p>我们可以操作压缩文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// Create a ZIP file tree using path</div><div class=\"line\">FileTree zip = zipTree(&apos;someFile.zip&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a TAR file tree using path</div><div class=\"line\">FileTree tar = tarTree(&apos;someFile.tar&apos;)</div><div class=\"line\"></div><div class=\"line\">//tar tree attempts to guess the compression based on the file extension</div><div class=\"line\">//however if you must specify the compression explicitly you can:</div><div class=\"line\">FileTree someTar = tarTree(resources.gzip(&apos;someTar.ext&apos;))</div></pre></td></tr></table></figure>\n<p>文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。</p>\n<p>关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。</p>\n<h3 id=\"4-如何打log\"><a href=\"#4-如何打log\" class=\"headerlink\" title=\"4. 如何打log\"></a>4. 如何打log</h3><p>我们可以通过logger的一些方法输出log日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ogger.quiet(&apos;An info log message which is always logged.&apos;)</div><div class=\"line\">logger.error(&apos;An error log message.&apos;)</div><div class=\"line\">logger.warn(&apos;A warning log message.&apos;)</div><div class=\"line\">logger.lifecycle(&apos;A lifecycle info log message.&apos;)</div><div class=\"line\">logger.info(&apos;An info log message.&apos;)</div><div class=\"line\">logger.debug(&apos;A debug log message.&apos;)</div><div class=\"line\">logger.trace(&apos;A trace log message.&apos;)</div></pre></td></tr></table></figure>\n<h3 id=\"5-gradle-plugins\"><a href=\"#5-gradle-plugins\" class=\"headerlink\" title=\"5. gradle plugins\"></a>5. gradle plugins</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply from: &apos;other.gradle&apos;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins &#123;</div><div class=\"line\">    id «plugin id» version «plugin version» [apply «false»]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;org.gradle.sample.goodbye&apos;</div></pre></td></tr></table></figure>\n<p>三种方式。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>上面的一些用法，全部来自于文档.</p>\n<p><a href=\"https://docs.gradle.org/current/userguide/\" target=\"_blank\" rel=\"external\">gradle 文档地址</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要><br>想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。</p>\n<h3 id=\"1-依赖管理\"><a href=\"#1-依赖管理\" class=\"headerlink\" title=\"1.依赖管理\"></a>1.依赖管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div><div class=\"line\">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.+&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<The rest of contents | 余下全文>\n\n\n\n<ul>\n<li>respositories 声明我们要使用的仓库</li>\n<li>dependencies 我们要依赖的一些东西<ul>\n<li>compile 依赖需要编译生产项目的来源</li>\n<li>runtime 依赖运行时字节码</li>\n<li>testCompile 依赖测试代码</li>\n<li>testRuntime </li>\n</ul>\n</li>\n</ul>\n<p>通常，我们声明仓库有两种方式</p>\n<ul>\n<li>使用中央仓库 mavenCentral()</li>\n<li><p>使用自己的仓库</p>\n<ul>\n<li><p>使用远程仓库</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\trepositories &#123;</div><div class=\"line\">    maven &#123;</div><div class=\"line\">    \t// 自己远程仓库地址</div><div class=\"line\">        url &quot;http://repo.mycompany.com/maven2&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用本地仓库     </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\trepositories &#123;</div><div class=\"line\">    ivy &#123;</div><div class=\"line\">        // URL can refer to a local directory</div><div class=\"line\">        url &quot;../local-repo&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>再说我们的依赖包管理，同样有两种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos;</div><div class=\"line\">// 2</div><div class=\"line\">compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div></pre></td></tr></table></figure>\n<p>我们最常用的是第一种方法。</p>\n<p>有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile(&quot;com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version&quot;) &#123;</div><div class=\"line\">    exclude group: &apos;com.squareup.retrofit2&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于如何上传仓库这里暂时不介绍,<a href=\"https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle\">可以看这里</a></p>\n<h3 id=\"2-编写gradle脚本\"><a href=\"#2-编写gradle脚本\" class=\"headerlink\" title=\"2.编写gradle脚本\"></a>2.编写gradle脚本</h3><h4 id=\"2-1-Project-API\"><a href=\"#2-1-Project-API\" class=\"headerlink\" title=\"2.1 Project API\"></a>2.1 Project API</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">println project.buildDir</div></pre></td></tr></table></figure>\n<p>我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。</p>\n<h4 id=\"2-2-如何定义变量\"><a href=\"#2-2-如何定义变量\" class=\"headerlink\" title=\"2.2 如何定义变量\"></a>2.2 如何定义变量</h4><p>和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def my_name = &quot;guolei&quot;</div><div class=\"line\">println my_nme</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-Extra-属性\"><a href=\"#2-3-Extra-属性\" class=\"headerlink\" title=\"2.3 Extra 属性\"></a>2.3 Extra 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ext &#123;</div><div class=\"line\">    my_name = &quot;guolei&quot;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">println ext.my_name;</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-TASK\"><a href=\"#2-4-TASK\" class=\"headerlink\" title=\"2.4 TASK\"></a>2.4 TASK</h4><p>gradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。<a href=\"https://docs.gradle.org/current/javadoc/\">gradle api文档地址</a>，关于Api的使用，这里就不介绍了，文档上使用方法很全。</p>\n<h4 id=\"2-5-TASK之间的依赖关系\"><a href=\"#2-5-TASK之间的依赖关系\" class=\"headerlink\" title=\"2.5 TASK之间的依赖关系\"></a>2.5 TASK之间的依赖关系</h4><p>我们可以使用dependsOn来指明task之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">taskX.dependsOn taskY</div></pre></td></tr></table></figure>\n<p>如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。</p>\n<h4 id=\"2-6-有序的TASKS\"><a href=\"#2-6-有序的TASKS\" class=\"headerlink\" title=\"2.6 有序的TASKS\"></a>2.6 有序的TASKS</h4><ul>\n<li>shouldRunAfter</li>\n<li>mustRunAfter</li>\n</ul>\n<h4 id=\"2-7-给task添加描述\"><a href=\"#2-7-给task添加描述\" class=\"headerlink\" title=\"2.7 给task添加描述\"></a>2.7 给task添加描述</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">task a &#123;</div><div class=\"line\">\tdescription &quot;xxx&quot;</div><div class=\"line\">\tprintln &quot;xx&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-8-跳过task不执行\"><a href=\"#2-8-跳过task不执行\" class=\"headerlink\" title=\"2.8 跳过task不执行\"></a>2.8 跳过task不执行</h4><ul>\n<li>onlyIf,满足条件的情况下才执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">task hello &#123;</div><div class=\"line\">    doLast &#123;</div><div class=\"line\">        println &apos;hello world&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">hello.onlyIf &#123; !project.hasProperty(&apos;skipHello&apos;) &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>用异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile.doFirst &#123;</div><div class=\"line\">    // Here you would put arbitrary conditions in real life.</div><div class=\"line\">    // But this is used in an integration test so we want defined behavior.</div><div class=\"line\">    if (true) &#123; throw new StopExecutionException() &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>enabled属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task.enabled = false</div></pre></td></tr></table></figure>\n<h3 id=\"3-如何操作文件\"><a href=\"#3-如何操作文件\" class=\"headerlink\" title=\"3.如何操作文件\"></a>3.如何操作文件</h3><p>我们可以利用Project.file 方法去获取文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Using a relative path</div><div class=\"line\">File configFile = file(&apos;src/config.xml&apos;)</div><div class=\"line\"></div><div class=\"line\">// Using an absolute path</div><div class=\"line\">configFile = file(configFile.absolutePath)</div><div class=\"line\"></div><div class=\"line\">// Using a File object with a relative path</div><div class=\"line\">configFile = file(new File(&apos;src/config.xml&apos;))</div></pre></td></tr></table></figure>\n<p>然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">FileCollection collection = files(&apos;src/file1.txt&apos;,new File(&apos;src/file2.txt&apos;),[&apos;src/file3.txt&apos;, &apos;src/file4.txt&apos;])</div></pre></td></tr></table></figure>\n<p>可以利用Project.fileTree获取文件树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Create a file tree with a base directory</div><div class=\"line\">FileTree tree = fileTree(dir: &apos;src/main&apos;)</div><div class=\"line\"></div><div class=\"line\">// Add include and exclude patterns to the tree</div><div class=\"line\">tree.include &apos;**/*.java&apos;</div><div class=\"line\">tree.exclude &apos;**/Abstract*&apos;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using path</div><div class=\"line\">tree = fileTree(&apos;src&apos;).include(&apos;**/*.java&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a tree using closure</div><div class=\"line\">tree = fileTree(&apos;src&apos;) &#123;</div><div class=\"line\">    include &apos;**/*.java&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using a map</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;)</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, includes: [&apos;**/*.java&apos;, &apos;**/*.xml&apos;])</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;, exclude: &apos;**/*test*/**&apos;)</div></pre></td></tr></table></figure>\n<p>我们可以操作压缩文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// Create a ZIP file tree using path</div><div class=\"line\">FileTree zip = zipTree(&apos;someFile.zip&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a TAR file tree using path</div><div class=\"line\">FileTree tar = tarTree(&apos;someFile.tar&apos;)</div><div class=\"line\"></div><div class=\"line\">//tar tree attempts to guess the compression based on the file extension</div><div class=\"line\">//however if you must specify the compression explicitly you can:</div><div class=\"line\">FileTree someTar = tarTree(resources.gzip(&apos;someTar.ext&apos;))</div></pre></td></tr></table></figure>\n<p>文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。</p>\n<p>关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。</p>\n<h3 id=\"4-如何打log\"><a href=\"#4-如何打log\" class=\"headerlink\" title=\"4. 如何打log\"></a>4. 如何打log</h3><p>我们可以通过logger的一些方法输出log日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ogger.quiet(&apos;An info log message which is always logged.&apos;)</div><div class=\"line\">logger.error(&apos;An error log message.&apos;)</div><div class=\"line\">logger.warn(&apos;A warning log message.&apos;)</div><div class=\"line\">logger.lifecycle(&apos;A lifecycle info log message.&apos;)</div><div class=\"line\">logger.info(&apos;An info log message.&apos;)</div><div class=\"line\">logger.debug(&apos;A debug log message.&apos;)</div><div class=\"line\">logger.trace(&apos;A trace log message.&apos;)</div></pre></td></tr></table></figure>\n<h3 id=\"5-gradle-plugins\"><a href=\"#5-gradle-plugins\" class=\"headerlink\" title=\"5. gradle plugins\"></a>5. gradle plugins</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply from: &apos;other.gradle&apos;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins &#123;</div><div class=\"line\">    id «plugin id» version «plugin version» [apply «false»]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;org.gradle.sample.goodbye&apos;</div></pre></td></tr></table></figure>\n<p>三种方式。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>上面的一些用法，全部来自于文档.</p>\n<p><a href=\"https://docs.gradle.org/current/userguide/\">gradle 文档地址</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解gradle（三）-编写简单的gradle插件，官方文档资料","date":"2017-03-21T15:35:44.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n前面也有介绍一些gradle的简单知识，但是这还不够，我们要想编写一些gradle插件，还是需要一些技巧，今天接着学习gradle。内容来自于官方文档。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 配置环境变量\n\n这里只介绍mac下的环境变量配置。首先进入到~目录\n\n```\ncd ~\n```\n\n然后用vim打开.bash_profile文件，如果没有，vim会为我们创建。\n\n```\nvim .bash_profile\n```\n\n在里面加入如下配置。\n\n```\n\nGRADLE_HOME=/Applications/Android\\ Studio.app/Contents/gradle/gradle-2.14.1\nexport GRADLE_HOME\nexport PATH=${PATH}:${GRADLE_HOME}/bin\n\n```\n\n* 注意将上面gradle的路径换成你自己的路径,保存退出\n\n最后\n\n```\nsource .bash_profile\n```\n\n同步配置,gradle -version测试一下。\n\n### 编写简单的plugin\n\n继承Plugin类，并实现apply方法。\n\n```\napply plugin: GreetingPlugin\n\nclass GreetingPlugin implements Plugin<Project> {\n    void apply(Project project) {\n        project.task('hello') {\n            doLast {\n                println \"Hello from the GreetingPlugin\"\n            }\n        }\n    }\n}\n```\n\n调用gradle -q hello 去运行这个task\n\n```\n> gradle -q hello\nHello from the GreetingPlugin\n```\n\n### 获取build中的输入\n\n代码如下：\n\n\n```\napply plugin: GreetingPlugin\n\ngreeting {\n    message = 'Hi'\n    greeter = 'Gradle'\n}\n\nclass GreetingPlugin implements Plugin<Project> {\n    void apply(Project project) {\n        project.extensions.create(\"greeting\", GreetingPluginExtension)\n        project.task('hello') {\n            doLast {\n                println \"${project.greeting.message} from ${project.greeting.greeter}\"\n            }\n        }\n    }\n}\n\nclass GreetingPluginExtension {\n    String message\n    String greeter\n}\n```\n\n不难理解，我们能从构建脚本中获取对应块中的内容，转化成我们插件中对象的类似java bean的东西。\n\n\n### 参考资料\n\n[Writing Custom Plugins](https://docs.gradle.org/current/userguide/custom_plugins.html)\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/了解gradle（三）-编写简单的gradle插件，官方文档资料.md","raw":"---\ntitle: 了解gradle（三）-编写简单的gradle插件，官方文档资料\ndate: 2017-03-21 23:35:44\ncategories: Gradle\ntags: gradle\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n前面也有介绍一些gradle的简单知识，但是这还不够，我们要想编写一些gradle插件，还是需要一些技巧，今天接着学习gradle。内容来自于官方文档。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 配置环境变量\n\n这里只介绍mac下的环境变量配置。首先进入到~目录\n\n```\ncd ~\n```\n\n然后用vim打开.bash_profile文件，如果没有，vim会为我们创建。\n\n```\nvim .bash_profile\n```\n\n在里面加入如下配置。\n\n```\n\nGRADLE_HOME=/Applications/Android\\ Studio.app/Contents/gradle/gradle-2.14.1\nexport GRADLE_HOME\nexport PATH=${PATH}:${GRADLE_HOME}/bin\n\n```\n\n* 注意将上面gradle的路径换成你自己的路径,保存退出\n\n最后\n\n```\nsource .bash_profile\n```\n\n同步配置,gradle -version测试一下。\n\n### 编写简单的plugin\n\n继承Plugin类，并实现apply方法。\n\n```\napply plugin: GreetingPlugin\n\nclass GreetingPlugin implements Plugin<Project> {\n    void apply(Project project) {\n        project.task('hello') {\n            doLast {\n                println \"Hello from the GreetingPlugin\"\n            }\n        }\n    }\n}\n```\n\n调用gradle -q hello 去运行这个task\n\n```\n> gradle -q hello\nHello from the GreetingPlugin\n```\n\n### 获取build中的输入\n\n代码如下：\n\n\n```\napply plugin: GreetingPlugin\n\ngreeting {\n    message = 'Hi'\n    greeter = 'Gradle'\n}\n\nclass GreetingPlugin implements Plugin<Project> {\n    void apply(Project project) {\n        project.extensions.create(\"greeting\", GreetingPluginExtension)\n        project.task('hello') {\n            doLast {\n                println \"${project.greeting.message} from ${project.greeting.greeter}\"\n            }\n        }\n    }\n}\n\nclass GreetingPluginExtension {\n    String message\n    String greeter\n}\n```\n\n不难理解，我们能从构建脚本中获取对应块中的内容，转化成我们插件中对象的类似java bean的东西。\n\n\n### 参考资料\n\n[Writing Custom Plugins](https://docs.gradle.org/current/userguide/custom_plugins.html)\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"了解gradle（三）-编写简单的gradle插件，官方文档资料","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzslzx005219fyhyajkpy1","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前面也有介绍一些gradle的简单知识，但是这还不够，我们要想编写一些gradle插件，还是需要一些技巧，今天接着学习gradle。内容来自于官方文档。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h3><p>这里只介绍mac下的环境变量配置。首先进入到~目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div></pre></td></tr></table></figure>\n<p>然后用vim打开.bash_profile文件，如果没有，vim会为我们创建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim .bash_profile</div></pre></td></tr></table></figure>\n<p>在里面加入如下配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">GRADLE_HOME=/Applications/Android\\ Studio.app/Contents/gradle/gradle-2.14.1</div><div class=\"line\">export GRADLE_HOME</div><div class=\"line\">export PATH=$&#123;PATH&#125;:$&#123;GRADLE_HOME&#125;/bin</div></pre></td></tr></table></figure>\n<ul>\n<li>注意将上面gradle的路径换成你自己的路径,保存退出</li>\n</ul>\n<p>最后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">source .bash_profile</div></pre></td></tr></table></figure>\n<p>同步配置,gradle -version测试一下。</p>\n<h3 id=\"编写简单的plugin\"><a href=\"#编写简单的plugin\" class=\"headerlink\" title=\"编写简单的plugin\"></a>编写简单的plugin</h3><p>继承Plugin类，并实现apply方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: GreetingPlugin</div><div class=\"line\"></div><div class=\"line\">class GreetingPlugin implements Plugin&lt;Project&gt; &#123;</div><div class=\"line\">    void apply(Project project) &#123;</div><div class=\"line\">        project.task(&apos;hello&apos;) &#123;</div><div class=\"line\">            doLast &#123;</div><div class=\"line\">                println &quot;Hello from the GreetingPlugin&quot;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用gradle -q hello 去运行这个task</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; gradle -q hello</div><div class=\"line\">Hello from the GreetingPlugin</div></pre></td></tr></table></figure>\n<h3 id=\"获取build中的输入\"><a href=\"#获取build中的输入\" class=\"headerlink\" title=\"获取build中的输入\"></a>获取build中的输入</h3><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: GreetingPlugin</div><div class=\"line\"></div><div class=\"line\">greeting &#123;</div><div class=\"line\">    message = &apos;Hi&apos;</div><div class=\"line\">    greeter = &apos;Gradle&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class GreetingPlugin implements Plugin&lt;Project&gt; &#123;</div><div class=\"line\">    void apply(Project project) &#123;</div><div class=\"line\">        project.extensions.create(&quot;greeting&quot;, GreetingPluginExtension)</div><div class=\"line\">        project.task(&apos;hello&apos;) &#123;</div><div class=\"line\">            doLast &#123;</div><div class=\"line\">                println &quot;$&#123;project.greeting.message&#125; from $&#123;project.greeting.greeter&#125;&quot;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class GreetingPluginExtension &#123;</div><div class=\"line\">    String message</div><div class=\"line\">    String greeter</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不难理解，我们能从构建脚本中获取对应块中的内容，转化成我们插件中对象的类似java bean的东西。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://docs.gradle.org/current/userguide/custom_plugins.html\" target=\"_blank\" rel=\"external\">Writing Custom Plugins</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前面也有介绍一些gradle的简单知识，但是这还不够，我们要想编写一些gradle插件，还是需要一些技巧，今天接着学习gradle。内容来自于官方文档。</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h3><p>这里只介绍mac下的环境变量配置。首先进入到~目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div></pre></td></tr></table></figure>\n<p>然后用vim打开.bash_profile文件，如果没有，vim会为我们创建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim .bash_profile</div></pre></td></tr></table></figure>\n<p>在里面加入如下配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">GRADLE_HOME=/Applications/Android\\ Studio.app/Contents/gradle/gradle-2.14.1</div><div class=\"line\">export GRADLE_HOME</div><div class=\"line\">export PATH=$&#123;PATH&#125;:$&#123;GRADLE_HOME&#125;/bin</div></pre></td></tr></table></figure>\n<ul>\n<li>注意将上面gradle的路径换成你自己的路径,保存退出</li>\n</ul>\n<p>最后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">source .bash_profile</div></pre></td></tr></table></figure>\n<p>同步配置,gradle -version测试一下。</p>\n<h3 id=\"编写简单的plugin\"><a href=\"#编写简单的plugin\" class=\"headerlink\" title=\"编写简单的plugin\"></a>编写简单的plugin</h3><p>继承Plugin类，并实现apply方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: GreetingPlugin</div><div class=\"line\"></div><div class=\"line\">class GreetingPlugin implements Plugin&lt;Project&gt; &#123;</div><div class=\"line\">    void apply(Project project) &#123;</div><div class=\"line\">        project.task(&apos;hello&apos;) &#123;</div><div class=\"line\">            doLast &#123;</div><div class=\"line\">                println &quot;Hello from the GreetingPlugin&quot;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用gradle -q hello 去运行这个task</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; gradle -q hello</div><div class=\"line\">Hello from the GreetingPlugin</div></pre></td></tr></table></figure>\n<h3 id=\"获取build中的输入\"><a href=\"#获取build中的输入\" class=\"headerlink\" title=\"获取build中的输入\"></a>获取build中的输入</h3><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: GreetingPlugin</div><div class=\"line\"></div><div class=\"line\">greeting &#123;</div><div class=\"line\">    message = &apos;Hi&apos;</div><div class=\"line\">    greeter = &apos;Gradle&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class GreetingPlugin implements Plugin&lt;Project&gt; &#123;</div><div class=\"line\">    void apply(Project project) &#123;</div><div class=\"line\">        project.extensions.create(&quot;greeting&quot;, GreetingPluginExtension)</div><div class=\"line\">        project.task(&apos;hello&apos;) &#123;</div><div class=\"line\">            doLast &#123;</div><div class=\"line\">                println &quot;$&#123;project.greeting.message&#125; from $&#123;project.greeting.greeter&#125;&quot;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class GreetingPluginExtension &#123;</div><div class=\"line\">    String message</div><div class=\"line\">    String greeter</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不难理解，我们能从构建脚本中获取对应块中的内容，转化成我们插件中对象的类似java bean的东西。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://docs.gradle.org/current/userguide/custom_plugins.html\">Writing Custom Plugins</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解gradle（二）-扩展gradle","date":"2016-12-06T03:41:32.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n```Groovy\ntask printString(type:GettingTask)\n```\n\n那么问题来了，我们如何向其中传递参数呢？\n\n* 首先，我们在class里面加成员变量\n* 然后，我们调用的时候，传入值\n\n\n\n\t```Groovy\n\ttask testPrint(type:GettingTask){\n\t// 这里用＝ 或者空格\n    string = \"guolei\"\n}\n\nclass GettingTask extends DefaultTask{\n\n    String string = \"xxxx\"\n\n    @TaskAction\n    def greet(){\n        println string\n    }\n}\n\t```\n\t\n\t\n\n### 2. 编写独立的插件程序\n\n可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。\n\n然后，在gradle中，依赖groovy\n\n```Groovy\napply plugin: 'groovy'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n```\n\n在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。\n\n接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建\"plugin_id\".properties目录，用来配置gradle插件，在文件中配置插件。\n\n```Groovy\nimplementation-class=com.gl.HelloPlugin\n```\n后面对应插件实现。\n\n最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。\n\n```Groovy\napply plugin: 'groovy'\napply plugin: 'maven'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n\nrepositories {\n    mavenCentral()\n}\n\ngroup='com.gl.HelloPlugin'\nversion='1.0.0'\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri('../repo'))\n        }\n    }\n}\n\n```\n\n在右侧图形界面或者命令执行uploadArchives，就发布成功了。\n\n如何使用，首先我们在跟目录下配置mevan仓库。\n\n```Groovy\nmaven {\n            url uri('./repo')\n        }\n        \n```\n\n然后依赖插件\n\n```Groovy\nclasspath 'com.gl.HelloPlugin:gradleplugin:1.0.0'\n```\n\n解释一下，后面分为三个部分\n\n* 第一部分，插件实现的路径\n* 你创建插件时候的model 名\n* 插件版本\n\n\n这三个也可以通过查看 repo下的路径得到，\n\n最后，在我们想用的地方\n\n```Groovy\napply plugin:'com.gl.plugin'\n```\n\n* 后面跟的是pluginid，也就是我们上面properties文件的前半部分。\n\n\n可以看到，开发过程基本和apt 编译时注解流程一致。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/了解gradle（二）-扩展gradle.md","raw":"---\ntitle: 了解gradle（二）-扩展gradle\ndate: 2016-12-06 11:41:32\ncategories: Gradle\ntags: gradle\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n```Groovy\ntask printString(type:GettingTask)\n```\n\n那么问题来了，我们如何向其中传递参数呢？\n\n* 首先，我们在class里面加成员变量\n* 然后，我们调用的时候，传入值\n\n\n\n\t```Groovy\n\ttask testPrint(type:GettingTask){\n\t// 这里用＝ 或者空格\n    string = \"guolei\"\n}\n\nclass GettingTask extends DefaultTask{\n\n    String string = \"xxxx\"\n\n    @TaskAction\n    def greet(){\n        println string\n    }\n}\n\t```\n\t\n\t\n\n### 2. 编写独立的插件程序\n\n可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。\n\n然后，在gradle中，依赖groovy\n\n```Groovy\napply plugin: 'groovy'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n```\n\n在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。\n\n接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建\"plugin_id\".properties目录，用来配置gradle插件，在文件中配置插件。\n\n```Groovy\nimplementation-class=com.gl.HelloPlugin\n```\n后面对应插件实现。\n\n最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。\n\n```Groovy\napply plugin: 'groovy'\napply plugin: 'maven'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n\nrepositories {\n    mavenCentral()\n}\n\ngroup='com.gl.HelloPlugin'\nversion='1.0.0'\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri('../repo'))\n        }\n    }\n}\n\n```\n\n在右侧图形界面或者命令执行uploadArchives，就发布成功了。\n\n如何使用，首先我们在跟目录下配置mevan仓库。\n\n```Groovy\nmaven {\n            url uri('./repo')\n        }\n        \n```\n\n然后依赖插件\n\n```Groovy\nclasspath 'com.gl.HelloPlugin:gradleplugin:1.0.0'\n```\n\n解释一下，后面分为三个部分\n\n* 第一部分，插件实现的路径\n* 你创建插件时候的model 名\n* 插件版本\n\n\n这三个也可以通过查看 repo下的路径得到，\n\n最后，在我们想用的地方\n\n```Groovy\napply plugin:'com.gl.plugin'\n```\n\n* 后面跟的是pluginid，也就是我们上面properties文件的前半部分。\n\n\n可以看到，开发过程基本和apt 编译时注解流程一致。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"了解gradle（二）-扩展gradle","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm00005719fytq30atoh","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-如何编写一个task类\"><a href=\"#1-如何编写一个task类\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"1-如何编写一个task类-1\"><a href=\"#1-如何编写一个task类-1\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task printString(<span class=\"string\">type:</span>GettingTask)</div></pre></td></tr></table></figure>\n<p>那么问题来了，我们如何向其中传递参数呢？</p>\n<ul>\n<li>首先，我们在class里面加成员变量</li>\n<li>然后，我们调用的时候，传入值</li>\n</ul>\n<pre><code><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttask testPrint(<span class=\"string\">type:</span>GettingTask)&#123;</div><div class=\"line\">\t<span class=\"comment\">// 这里用＝ 或者空格</span></div><div class=\"line\">    string = <span class=\"string\">\"guolei\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\"></div><div class=\"line\">    String string = <span class=\"string\">\"xxxx\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println string</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</code></pre><h3 id=\"2-编写独立的插件程序\"><a href=\"#2-编写独立的插件程序\" class=\"headerlink\" title=\"2. 编写独立的插件程序\"></a>2. 编写独立的插件程序</h3><p>可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。</p>\n<p>然后，在gradle中，依赖groovy</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<project>接口，实现apply方法。</project></p>\n<p>接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建”plugin_id”.properties目录，用来配置gradle插件，在文件中配置插件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">implementation-<span class=\"class\"><span class=\"keyword\">class</span>=<span class=\"title\">com</span>.<span class=\"title\">gl</span>.<span class=\"title\">HelloPlugin</span></span></div></pre></td></tr></table></figure>\n<p>后面对应插件实现。</p>\n<p>最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'maven'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">group=<span class=\"string\">'com.gl.HelloPlugin'</span></div><div class=\"line\">version=<span class=\"string\">'1.0.0'</span></div><div class=\"line\">uploadArchives &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        mavenDeployer &#123;</div><div class=\"line\">            repository(<span class=\"string\">url:</span> uri(<span class=\"string\">'../repo'</span>))</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在右侧图形界面或者命令执行uploadArchives，就发布成功了。</p>\n<p>如何使用，首先我们在跟目录下配置mevan仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">maven &#123;</div><div class=\"line\">            url uri(<span class=\"string\">'./repo'</span>)</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>然后依赖插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classpath <span class=\"string\">'com.gl.HelloPlugin:gradleplugin:1.0.0'</span></div></pre></td></tr></table></figure>\n<p>解释一下，后面分为三个部分</p>\n<ul>\n<li>第一部分，插件实现的路径</li>\n<li>你创建插件时候的model 名</li>\n<li>插件版本</li>\n</ul>\n<p>这三个也可以通过查看 repo下的路径得到，</p>\n<p>最后，在我们想用的地方</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span><span class=\"string\">'com.gl.plugin'</span></div></pre></td></tr></table></figure>\n<ul>\n<li>后面跟的是pluginid，也就是我们上面properties文件的前半部分。</li>\n</ul>\n<p>可以看到，开发过程基本和apt 编译时注解流程一致。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-如何编写一个task类\"><a href=\"#1-如何编写一个task类\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"1-如何编写一个task类-1\"><a href=\"#1-如何编写一个task类-1\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task printString(<span class=\"string\">type:</span>GettingTask)</div></pre></td></tr></table></figure>\n<p>那么问题来了，我们如何向其中传递参数呢？</p>\n<ul>\n<li>首先，我们在class里面加成员变量</li>\n<li>然后，我们调用的时候，传入值</li>\n</ul>\n<pre><code><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttask testPrint(<span class=\"string\">type:</span>GettingTask)&#123;</div><div class=\"line\">\t<span class=\"comment\">// 这里用＝ 或者空格</span></div><div class=\"line\">    string = <span class=\"string\">\"guolei\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\"></div><div class=\"line\">    String string = <span class=\"string\">\"xxxx\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println string</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</code></pre><h3 id=\"2-编写独立的插件程序\"><a href=\"#2-编写独立的插件程序\" class=\"headerlink\" title=\"2. 编写独立的插件程序\"></a>2. 编写独立的插件程序</h3><p>可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。</p>\n<p>然后，在gradle中，依赖groovy</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。</p>\n<p>接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建”plugin_id”.properties目录，用来配置gradle插件，在文件中配置插件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">implementation-<span class=\"class\"><span class=\"keyword\">class</span>=<span class=\"title\">com</span>.<span class=\"title\">gl</span>.<span class=\"title\">HelloPlugin</span></span></div></pre></td></tr></table></figure>\n<p>后面对应插件实现。</p>\n<p>最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'maven'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">group=<span class=\"string\">'com.gl.HelloPlugin'</span></div><div class=\"line\">version=<span class=\"string\">'1.0.0'</span></div><div class=\"line\">uploadArchives &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        mavenDeployer &#123;</div><div class=\"line\">            repository(<span class=\"string\">url:</span> uri(<span class=\"string\">'../repo'</span>))</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在右侧图形界面或者命令执行uploadArchives，就发布成功了。</p>\n<p>如何使用，首先我们在跟目录下配置mevan仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">maven &#123;</div><div class=\"line\">            url uri(<span class=\"string\">'./repo'</span>)</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>然后依赖插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classpath <span class=\"string\">'com.gl.HelloPlugin:gradleplugin:1.0.0'</span></div></pre></td></tr></table></figure>\n<p>解释一下，后面分为三个部分</p>\n<ul>\n<li>第一部分，插件实现的路径</li>\n<li>你创建插件时候的model 名</li>\n<li>插件版本</li>\n</ul>\n<p>这三个也可以通过查看 repo下的路径得到，</p>\n<p>最后，在我们想用的地方</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span><span class=\"string\">'com.gl.plugin'</span></div></pre></td></tr></table></figure>\n<ul>\n<li>后面跟的是pluginid，也就是我们上面properties文件的前半部分。</li>\n</ul>\n<p>可以看到，开发过程基本和apt 编译时注解流程一致。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解gradle（四）-了解PatchPluginForZues","date":"2017-03-25T14:11:48.000Z","_content":"\n### 前言\n\n前面也有介绍一些gradle的简单知识，但是这还不够，我们要想编写一些gradle插件，还是需要一些技巧，今天接着学习gradle。内容来自于官方文档。\n<Excerpt in index | 首页摘要>\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n### 前言\n\n我们平时工作中会用到各种各样的gradle插件，但是你是否想过，这些插件是如何编写出来的。那么，今天，就来解析其中一个插件。叫做PatchPluginForZeus。这个是用来像class文件中注入一些代码，来解决qq空间的补丁方案中CLASS_ISPREVERIFIED的问题，关于qq空间的热补丁方案，大家自行google。下面就来学习下这个插件是如何编写的。\n\n### 代码分析\n\n首先看下apply方法\n\n```\n    public static final String EXTENSION_NAME = \"patchPlugin\";\n\n    @Override\n    public void apply(Project project) {\n        DefaultDomainObjectSet<ApplicationVariant> variants\n        if (project.getPlugins().hasPlugin(AppPlugin)) {\n            variants = project.android.applicationVariants;\n\n            project.extensions.create(EXTENSION_NAME, PatchExtension);\n\n            applyTask(project, variants);\n        }\n    }\n```\n\n上面的代码很简单，逻辑如下：\n\n* 检查project的插件中是否包含本插件\n* 创建extension扩展\n* apptask应用插件\n\n下面代码就比较长了，分开来看。\n\n```\n            PatchExtension patchConfig = PatchExtension.getConfig(project);\n            def includePackage = patchConfig.includePackage\n            def excludeClass = patchConfig.excludeClass\n            def excludePackage = patchConfig.excludePackage\n            def excludeJar = patchConfig.excludeJar\n```\n\n首先，从扩展中获取本插件相关的配置，就是在build.gradle中的配置节点。\n\n```\nif (patchConfig.enable) {\n\n                variants.all { variant ->\n                    def dexTask = project.tasks.findByName(PatchUtils.getDexTaskName(project, variant))\n                    def processManifestTask = project.tasks.findByName(PatchUtils.getProcessManifestTaskName(project, variant))\n\n                    def manifestFile = processManifestTask.outputs.files.files[0]\n                    Closure prepareClosure = {\n                        patchConfig.excludePackage.add(\"android\" + File.separator + \"support\")\n                        def applicationClassName = PatchUtils.getApplication(manifestFile);\n                        if (applicationClassName != null) {\n                            applicationClassName = applicationClassName.replace(\".\", File.separator) + SdkConstants.DOT_CLASS\n                            //过滤Application类\n                            patchConfig.excludeClass.add(applicationClassName)\n                        }\n                    }\n                    DebugUtils.debug(\"-------------------dexTask:\" + dexTask)\n                    if (dexTask != null) {\n                        def patchJarBeforeDex = \"patchJarBeforeDex${variant.name.capitalize()}\"\n                        project.task(patchJarBeforeDex) << {\n                            Set<File> inputFiles = PatchUtils.getDexTaskInputFiles(project, variant, dexTask)\n\n                            inputFiles.each { inputFile ->\n\n                                def path = inputFile.absolutePath\n                                DebugUtils.debug(\"patchJarBefore----->\" + path)\n                                if (path.endsWith(SdkConstants.DOT_JAR) && !PatchSetUtils.isExcludedJar(path, excludeJar)) {\n                                    PatchProcessor.processJar(inputFile, includePackage, excludePackage, excludeClass)\n                                } else if (inputFile.isDirectory()) {\n                                    //intermediates/classes/debug\n                                    def extensions = [SdkConstants.EXT_CLASS] as String[]\n\n                                    def inputClasses = FileUtils.listFiles(inputFile, extensions, true);\n                                    DebugUtils.debug(\"inputFile.isDirectory()----\" + inputClasses)\n                                    inputClasses.each {\n                                        inputClassFile ->\n                                            def classPath = inputClassFile.absolutePath\n                                            if (classPath.endsWith(\".class\") && !classPath.contains(File.separator + \"R\\$\") && !classPath.endsWith(File.separator + \"R.class\") && !classPath.endsWith(File.separator + \"BuildConfig.class\")) {\n                                                PatchProcessor.processClass(inputClassFile)\n                                            }\n                                    }\n                                }\n                            }\n                        }\n                        def patchJarBeforeDexTask = project.tasks[patchJarBeforeDex]\n                        DebugUtils.debug(\"-------------------patchJarBeforeDexTask:\" + patchJarBeforeDexTask)\n\n                        patchJarBeforeDexTask.dependsOn dexTask.taskDependencies.getDependencies(dexTask)\n                        dexTask.dependsOn patchJarBeforeDexTask\n                        patchJarBeforeDexTask.doFirst(prepareClosure)\n                    }\n                }\n            }\n```\n\n判断是够允许开启插件的asm注入功能。如果开启的话，就会进行接下来的处理。\n\n* 首先获取到processManifestTask这个task，并从这个task的输出文件中拿到AndroidManifest.xml文件，并通过解析xml文件，拿到我们应用的Application，这个class是不需要注入代码的。\n* 接着，创建一个task，这个task就是来执行我们的asm代码注入任务的。到这里，我们就需要寻找合适的切入点。想一下，我们什么时候作为写入点合适呢，当然是在生成dex文件之前，这个时候作为切入点，即不会class的编译过程，也不会破坏dex的生成过程，我们做的，就是拿到生成dex文件这个task的输入文件即可。这里需要判断是不是用了transformapi。具体的不说了，大家有兴趣的看下代码。\n* 然后，拿到文件之后，我们对其进行asm注入代码的操作，这个过程要区分单个的class文件还是jar包。显然，他俩的注入过程是不一样的。\n* 做下依赖，让我们诸如代码的task在dex生成的这个task之前\n\n### ASM代码注入？\n\n这是一项高端的技术，这里暂且不细说,我也没研究明白，不过在技术栈规划当中了。\n\n留个坑位，待补。\n\n### 总结\n\n有没有发现，java写多了，写gradle插件的时候，会不自觉的加;呢？看看你是不是中枪了。要是中枪，赶紧写两行python压压惊吧，毕竟听说python都冲到语言榜第三了呢。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/了解gradle（四）-了解PatchPluginForZues.md","raw":"---\ntitle: 了解gradle（四）-了解PatchPluginForZues\ndate: 2017-03-25 22:11:48\n\ncategories: Gradle\ntags: gradle\n\n---\n\n### 前言\n\n前面也有介绍一些gradle的简单知识，但是这还不够，我们要想编写一些gradle插件，还是需要一些技巧，今天接着学习gradle。内容来自于官方文档。\n<Excerpt in index | 首页摘要>\n\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n### 前言\n\n我们平时工作中会用到各种各样的gradle插件，但是你是否想过，这些插件是如何编写出来的。那么，今天，就来解析其中一个插件。叫做PatchPluginForZeus。这个是用来像class文件中注入一些代码，来解决qq空间的补丁方案中CLASS_ISPREVERIFIED的问题，关于qq空间的热补丁方案，大家自行google。下面就来学习下这个插件是如何编写的。\n\n### 代码分析\n\n首先看下apply方法\n\n```\n    public static final String EXTENSION_NAME = \"patchPlugin\";\n\n    @Override\n    public void apply(Project project) {\n        DefaultDomainObjectSet<ApplicationVariant> variants\n        if (project.getPlugins().hasPlugin(AppPlugin)) {\n            variants = project.android.applicationVariants;\n\n            project.extensions.create(EXTENSION_NAME, PatchExtension);\n\n            applyTask(project, variants);\n        }\n    }\n```\n\n上面的代码很简单，逻辑如下：\n\n* 检查project的插件中是否包含本插件\n* 创建extension扩展\n* apptask应用插件\n\n下面代码就比较长了，分开来看。\n\n```\n            PatchExtension patchConfig = PatchExtension.getConfig(project);\n            def includePackage = patchConfig.includePackage\n            def excludeClass = patchConfig.excludeClass\n            def excludePackage = patchConfig.excludePackage\n            def excludeJar = patchConfig.excludeJar\n```\n\n首先，从扩展中获取本插件相关的配置，就是在build.gradle中的配置节点。\n\n```\nif (patchConfig.enable) {\n\n                variants.all { variant ->\n                    def dexTask = project.tasks.findByName(PatchUtils.getDexTaskName(project, variant))\n                    def processManifestTask = project.tasks.findByName(PatchUtils.getProcessManifestTaskName(project, variant))\n\n                    def manifestFile = processManifestTask.outputs.files.files[0]\n                    Closure prepareClosure = {\n                        patchConfig.excludePackage.add(\"android\" + File.separator + \"support\")\n                        def applicationClassName = PatchUtils.getApplication(manifestFile);\n                        if (applicationClassName != null) {\n                            applicationClassName = applicationClassName.replace(\".\", File.separator) + SdkConstants.DOT_CLASS\n                            //过滤Application类\n                            patchConfig.excludeClass.add(applicationClassName)\n                        }\n                    }\n                    DebugUtils.debug(\"-------------------dexTask:\" + dexTask)\n                    if (dexTask != null) {\n                        def patchJarBeforeDex = \"patchJarBeforeDex${variant.name.capitalize()}\"\n                        project.task(patchJarBeforeDex) << {\n                            Set<File> inputFiles = PatchUtils.getDexTaskInputFiles(project, variant, dexTask)\n\n                            inputFiles.each { inputFile ->\n\n                                def path = inputFile.absolutePath\n                                DebugUtils.debug(\"patchJarBefore----->\" + path)\n                                if (path.endsWith(SdkConstants.DOT_JAR) && !PatchSetUtils.isExcludedJar(path, excludeJar)) {\n                                    PatchProcessor.processJar(inputFile, includePackage, excludePackage, excludeClass)\n                                } else if (inputFile.isDirectory()) {\n                                    //intermediates/classes/debug\n                                    def extensions = [SdkConstants.EXT_CLASS] as String[]\n\n                                    def inputClasses = FileUtils.listFiles(inputFile, extensions, true);\n                                    DebugUtils.debug(\"inputFile.isDirectory()----\" + inputClasses)\n                                    inputClasses.each {\n                                        inputClassFile ->\n                                            def classPath = inputClassFile.absolutePath\n                                            if (classPath.endsWith(\".class\") && !classPath.contains(File.separator + \"R\\$\") && !classPath.endsWith(File.separator + \"R.class\") && !classPath.endsWith(File.separator + \"BuildConfig.class\")) {\n                                                PatchProcessor.processClass(inputClassFile)\n                                            }\n                                    }\n                                }\n                            }\n                        }\n                        def patchJarBeforeDexTask = project.tasks[patchJarBeforeDex]\n                        DebugUtils.debug(\"-------------------patchJarBeforeDexTask:\" + patchJarBeforeDexTask)\n\n                        patchJarBeforeDexTask.dependsOn dexTask.taskDependencies.getDependencies(dexTask)\n                        dexTask.dependsOn patchJarBeforeDexTask\n                        patchJarBeforeDexTask.doFirst(prepareClosure)\n                    }\n                }\n            }\n```\n\n判断是够允许开启插件的asm注入功能。如果开启的话，就会进行接下来的处理。\n\n* 首先获取到processManifestTask这个task，并从这个task的输出文件中拿到AndroidManifest.xml文件，并通过解析xml文件，拿到我们应用的Application，这个class是不需要注入代码的。\n* 接着，创建一个task，这个task就是来执行我们的asm代码注入任务的。到这里，我们就需要寻找合适的切入点。想一下，我们什么时候作为写入点合适呢，当然是在生成dex文件之前，这个时候作为切入点，即不会class的编译过程，也不会破坏dex的生成过程，我们做的，就是拿到生成dex文件这个task的输入文件即可。这里需要判断是不是用了transformapi。具体的不说了，大家有兴趣的看下代码。\n* 然后，拿到文件之后，我们对其进行asm注入代码的操作，这个过程要区分单个的class文件还是jar包。显然，他俩的注入过程是不一样的。\n* 做下依赖，让我们诸如代码的task在dex生成的这个task之前\n\n### ASM代码注入？\n\n这是一项高端的技术，这里暂且不细说,我也没研究明白，不过在技术栈规划当中了。\n\n留个坑位，待补。\n\n### 总结\n\n有没有发现，java写多了，写gradle插件的时候，会不自觉的加;呢？看看你是不是中枪了。要是中枪，赶紧写两行python压压惊吧，毕竟听说python都冲到语言榜第三了呢。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"了解gradle（四）-了解PatchPluginForZues","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm01005a19fyu11jv0q5","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前面也有介绍一些gradle的简单知识，但是这还不够，我们要想编写一些gradle插件，还是需要一些技巧，今天接着学习gradle。内容来自于官方文档。</p>\n<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n\n\n<a id=\"more\"></a>\n<p><the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\"></the></p>\n<h3 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>我们平时工作中会用到各种各样的gradle插件，但是你是否想过，这些插件是如何编写出来的。那么，今天，就来解析其中一个插件。叫做PatchPluginForZeus。这个是用来像class文件中注入一些代码，来解决qq空间的补丁方案中CLASS_ISPREVERIFIED的问题，关于qq空间的热补丁方案，大家自行google。下面就来学习下这个插件是如何编写的。</p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>首先看下apply方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static final String EXTENSION_NAME = &quot;patchPlugin&quot;;</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">public void apply(Project project) &#123;</div><div class=\"line\">    DefaultDomainObjectSet&lt;ApplicationVariant&gt; variants</div><div class=\"line\">    if (project.getPlugins().hasPlugin(AppPlugin)) &#123;</div><div class=\"line\">        variants = project.android.applicationVariants;</div><div class=\"line\"></div><div class=\"line\">        project.extensions.create(EXTENSION_NAME, PatchExtension);</div><div class=\"line\"></div><div class=\"line\">        applyTask(project, variants);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码很简单，逻辑如下：</p>\n<ul>\n<li>检查project的插件中是否包含本插件</li>\n<li>创建extension扩展</li>\n<li>apptask应用插件</li>\n</ul>\n<p>下面代码就比较长了，分开来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">PatchExtension patchConfig = PatchExtension.getConfig(project);</div><div class=\"line\">def includePackage = patchConfig.includePackage</div><div class=\"line\">def excludeClass = patchConfig.excludeClass</div><div class=\"line\">def excludePackage = patchConfig.excludePackage</div><div class=\"line\">def excludeJar = patchConfig.excludeJar</div></pre></td></tr></table></figure>\n<p>首先，从扩展中获取本插件相关的配置，就是在build.gradle中的配置节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (patchConfig.enable) &#123;</div><div class=\"line\"></div><div class=\"line\">                variants.all &#123; variant -&gt;</div><div class=\"line\">                    def dexTask = project.tasks.findByName(PatchUtils.getDexTaskName(project, variant))</div><div class=\"line\">                    def processManifestTask = project.tasks.findByName(PatchUtils.getProcessManifestTaskName(project, variant))</div><div class=\"line\"></div><div class=\"line\">                    def manifestFile = processManifestTask.outputs.files.files[0]</div><div class=\"line\">                    Closure prepareClosure = &#123;</div><div class=\"line\">                        patchConfig.excludePackage.add(&quot;android&quot; + File.separator + &quot;support&quot;)</div><div class=\"line\">                        def applicationClassName = PatchUtils.getApplication(manifestFile);</div><div class=\"line\">                        if (applicationClassName != null) &#123;</div><div class=\"line\">                            applicationClassName = applicationClassName.replace(&quot;.&quot;, File.separator) + SdkConstants.DOT_CLASS</div><div class=\"line\">                            //过滤Application类</div><div class=\"line\">                            patchConfig.excludeClass.add(applicationClassName)</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    DebugUtils.debug(&quot;-------------------dexTask:&quot; + dexTask)</div><div class=\"line\">                    if (dexTask != null) &#123;</div><div class=\"line\">                        def patchJarBeforeDex = &quot;patchJarBeforeDex$&#123;variant.name.capitalize()&#125;&quot;</div><div class=\"line\">                        project.task(patchJarBeforeDex) &lt;&lt; &#123;</div><div class=\"line\">                            Set&lt;File&gt; inputFiles = PatchUtils.getDexTaskInputFiles(project, variant, dexTask)</div><div class=\"line\"></div><div class=\"line\">                            inputFiles.each &#123; inputFile -&gt;</div><div class=\"line\"></div><div class=\"line\">                                def path = inputFile.absolutePath</div><div class=\"line\">                                DebugUtils.debug(&quot;patchJarBefore-----&gt;&quot; + path)</div><div class=\"line\">                                if (path.endsWith(SdkConstants.DOT_JAR) &amp;&amp; !PatchSetUtils.isExcludedJar(path, excludeJar)) &#123;</div><div class=\"line\">                                    PatchProcessor.processJar(inputFile, includePackage, excludePackage, excludeClass)</div><div class=\"line\">                                &#125; else if (inputFile.isDirectory()) &#123;</div><div class=\"line\">                                    //intermediates/classes/debug</div><div class=\"line\">                                    def extensions = [SdkConstants.EXT_CLASS] as String[]</div><div class=\"line\"></div><div class=\"line\">                                    def inputClasses = FileUtils.listFiles(inputFile, extensions, true);</div><div class=\"line\">                                    DebugUtils.debug(&quot;inputFile.isDirectory()----&quot; + inputClasses)</div><div class=\"line\">                                    inputClasses.each &#123;</div><div class=\"line\">                                        inputClassFile -&gt;</div><div class=\"line\">                                            def classPath = inputClassFile.absolutePath</div><div class=\"line\">                                            if (classPath.endsWith(&quot;.class&quot;) &amp;&amp; !classPath.contains(File.separator + &quot;R\\$&quot;) &amp;&amp; !classPath.endsWith(File.separator + &quot;R.class&quot;) &amp;&amp; !classPath.endsWith(File.separator + &quot;BuildConfig.class&quot;)) &#123;</div><div class=\"line\">                                                PatchProcessor.processClass(inputClassFile)</div><div class=\"line\">                                            &#125;</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        def patchJarBeforeDexTask = project.tasks[patchJarBeforeDex]</div><div class=\"line\">                        DebugUtils.debug(&quot;-------------------patchJarBeforeDexTask:&quot; + patchJarBeforeDexTask)</div><div class=\"line\"></div><div class=\"line\">                        patchJarBeforeDexTask.dependsOn dexTask.taskDependencies.getDependencies(dexTask)</div><div class=\"line\">                        dexTask.dependsOn patchJarBeforeDexTask</div><div class=\"line\">                        patchJarBeforeDexTask.doFirst(prepareClosure)</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>判断是够允许开启插件的asm注入功能。如果开启的话，就会进行接下来的处理。</p>\n<ul>\n<li>首先获取到processManifestTask这个task，并从这个task的输出文件中拿到AndroidManifest.xml文件，并通过解析xml文件，拿到我们应用的Application，这个class是不需要注入代码的。</li>\n<li>接着，创建一个task，这个task就是来执行我们的asm代码注入任务的。到这里，我们就需要寻找合适的切入点。想一下，我们什么时候作为写入点合适呢，当然是在生成dex文件之前，这个时候作为切入点，即不会class的编译过程，也不会破坏dex的生成过程，我们做的，就是拿到生成dex文件这个task的输入文件即可。这里需要判断是不是用了transformapi。具体的不说了，大家有兴趣的看下代码。</li>\n<li>然后，拿到文件之后，我们对其进行asm注入代码的操作，这个过程要区分单个的class文件还是jar包。显然，他俩的注入过程是不一样的。</li>\n<li>做下依赖，让我们诸如代码的task在dex生成的这个task之前</li>\n</ul>\n<h3 id=\"ASM代码注入？\"><a href=\"#ASM代码注入？\" class=\"headerlink\" title=\"ASM代码注入？\"></a>ASM代码注入？</h3><p>这是一项高端的技术，这里暂且不细说,我也没研究明白，不过在技术栈规划当中了。</p>\n<p>留个坑位，待补。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>有没有发现，java写多了，写gradle插件的时候，会不自觉的加;呢？看看你是不是中枪了。要是中枪，赶紧写两行python压压惊吧，毕竟听说python都冲到语言榜第三了呢。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n</excerpt>","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前面也有介绍一些gradle的简单知识，但是这还不够，我们要想编写一些gradle插件，还是需要一些技巧，今天接着学习gradle。内容来自于官方文档。</p>\n<Excerpt in index | 首页摘要>","more":"<p><The rest of contents | 余下全文></p>\n<h3 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>我们平时工作中会用到各种各样的gradle插件，但是你是否想过，这些插件是如何编写出来的。那么，今天，就来解析其中一个插件。叫做PatchPluginForZeus。这个是用来像class文件中注入一些代码，来解决qq空间的补丁方案中CLASS_ISPREVERIFIED的问题，关于qq空间的热补丁方案，大家自行google。下面就来学习下这个插件是如何编写的。</p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>首先看下apply方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static final String EXTENSION_NAME = &quot;patchPlugin&quot;;</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">public void apply(Project project) &#123;</div><div class=\"line\">    DefaultDomainObjectSet&lt;ApplicationVariant&gt; variants</div><div class=\"line\">    if (project.getPlugins().hasPlugin(AppPlugin)) &#123;</div><div class=\"line\">        variants = project.android.applicationVariants;</div><div class=\"line\"></div><div class=\"line\">        project.extensions.create(EXTENSION_NAME, PatchExtension);</div><div class=\"line\"></div><div class=\"line\">        applyTask(project, variants);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码很简单，逻辑如下：</p>\n<ul>\n<li>检查project的插件中是否包含本插件</li>\n<li>创建extension扩展</li>\n<li>apptask应用插件</li>\n</ul>\n<p>下面代码就比较长了，分开来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">PatchExtension patchConfig = PatchExtension.getConfig(project);</div><div class=\"line\">def includePackage = patchConfig.includePackage</div><div class=\"line\">def excludeClass = patchConfig.excludeClass</div><div class=\"line\">def excludePackage = patchConfig.excludePackage</div><div class=\"line\">def excludeJar = patchConfig.excludeJar</div></pre></td></tr></table></figure>\n<p>首先，从扩展中获取本插件相关的配置，就是在build.gradle中的配置节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (patchConfig.enable) &#123;</div><div class=\"line\"></div><div class=\"line\">                variants.all &#123; variant -&gt;</div><div class=\"line\">                    def dexTask = project.tasks.findByName(PatchUtils.getDexTaskName(project, variant))</div><div class=\"line\">                    def processManifestTask = project.tasks.findByName(PatchUtils.getProcessManifestTaskName(project, variant))</div><div class=\"line\"></div><div class=\"line\">                    def manifestFile = processManifestTask.outputs.files.files[0]</div><div class=\"line\">                    Closure prepareClosure = &#123;</div><div class=\"line\">                        patchConfig.excludePackage.add(&quot;android&quot; + File.separator + &quot;support&quot;)</div><div class=\"line\">                        def applicationClassName = PatchUtils.getApplication(manifestFile);</div><div class=\"line\">                        if (applicationClassName != null) &#123;</div><div class=\"line\">                            applicationClassName = applicationClassName.replace(&quot;.&quot;, File.separator) + SdkConstants.DOT_CLASS</div><div class=\"line\">                            //过滤Application类</div><div class=\"line\">                            patchConfig.excludeClass.add(applicationClassName)</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    DebugUtils.debug(&quot;-------------------dexTask:&quot; + dexTask)</div><div class=\"line\">                    if (dexTask != null) &#123;</div><div class=\"line\">                        def patchJarBeforeDex = &quot;patchJarBeforeDex$&#123;variant.name.capitalize()&#125;&quot;</div><div class=\"line\">                        project.task(patchJarBeforeDex) &lt;&lt; &#123;</div><div class=\"line\">                            Set&lt;File&gt; inputFiles = PatchUtils.getDexTaskInputFiles(project, variant, dexTask)</div><div class=\"line\"></div><div class=\"line\">                            inputFiles.each &#123; inputFile -&gt;</div><div class=\"line\"></div><div class=\"line\">                                def path = inputFile.absolutePath</div><div class=\"line\">                                DebugUtils.debug(&quot;patchJarBefore-----&gt;&quot; + path)</div><div class=\"line\">                                if (path.endsWith(SdkConstants.DOT_JAR) &amp;&amp; !PatchSetUtils.isExcludedJar(path, excludeJar)) &#123;</div><div class=\"line\">                                    PatchProcessor.processJar(inputFile, includePackage, excludePackage, excludeClass)</div><div class=\"line\">                                &#125; else if (inputFile.isDirectory()) &#123;</div><div class=\"line\">                                    //intermediates/classes/debug</div><div class=\"line\">                                    def extensions = [SdkConstants.EXT_CLASS] as String[]</div><div class=\"line\"></div><div class=\"line\">                                    def inputClasses = FileUtils.listFiles(inputFile, extensions, true);</div><div class=\"line\">                                    DebugUtils.debug(&quot;inputFile.isDirectory()----&quot; + inputClasses)</div><div class=\"line\">                                    inputClasses.each &#123;</div><div class=\"line\">                                        inputClassFile -&gt;</div><div class=\"line\">                                            def classPath = inputClassFile.absolutePath</div><div class=\"line\">                                            if (classPath.endsWith(&quot;.class&quot;) &amp;&amp; !classPath.contains(File.separator + &quot;R\\$&quot;) &amp;&amp; !classPath.endsWith(File.separator + &quot;R.class&quot;) &amp;&amp; !classPath.endsWith(File.separator + &quot;BuildConfig.class&quot;)) &#123;</div><div class=\"line\">                                                PatchProcessor.processClass(inputClassFile)</div><div class=\"line\">                                            &#125;</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        def patchJarBeforeDexTask = project.tasks[patchJarBeforeDex]</div><div class=\"line\">                        DebugUtils.debug(&quot;-------------------patchJarBeforeDexTask:&quot; + patchJarBeforeDexTask)</div><div class=\"line\"></div><div class=\"line\">                        patchJarBeforeDexTask.dependsOn dexTask.taskDependencies.getDependencies(dexTask)</div><div class=\"line\">                        dexTask.dependsOn patchJarBeforeDexTask</div><div class=\"line\">                        patchJarBeforeDexTask.doFirst(prepareClosure)</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>判断是够允许开启插件的asm注入功能。如果开启的话，就会进行接下来的处理。</p>\n<ul>\n<li>首先获取到processManifestTask这个task，并从这个task的输出文件中拿到AndroidManifest.xml文件，并通过解析xml文件，拿到我们应用的Application，这个class是不需要注入代码的。</li>\n<li>接着，创建一个task，这个task就是来执行我们的asm代码注入任务的。到这里，我们就需要寻找合适的切入点。想一下，我们什么时候作为写入点合适呢，当然是在生成dex文件之前，这个时候作为切入点，即不会class的编译过程，也不会破坏dex的生成过程，我们做的，就是拿到生成dex文件这个task的输入文件即可。这里需要判断是不是用了transformapi。具体的不说了，大家有兴趣的看下代码。</li>\n<li>然后，拿到文件之后，我们对其进行asm注入代码的操作，这个过程要区分单个的class文件还是jar包。显然，他俩的注入过程是不一样的。</li>\n<li>做下依赖，让我们诸如代码的task在dex生成的这个task之前</li>\n</ul>\n<h3 id=\"ASM代码注入？\"><a href=\"#ASM代码注入？\" class=\"headerlink\" title=\"ASM代码注入？\"></a>ASM代码注入？</h3><p>这是一项高端的技术，这里暂且不细说,我也没研究明白，不过在技术栈规划当中了。</p>\n<p>留个坑位，待补。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>有没有发现，java写多了，写gradle插件的时候，会不自觉的加;呢？看看你是不是中枪了。要是中枪，赶紧写两行python压压惊吧，毕竟听说python都冲到语言榜第三了呢。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解对象池","date":"2017-02-15T15:34:44.000Z","_content":"<Excerpt in index | 首页摘要>\n### 认识对象池\n\n对象池是一种设计模式，预先初始化一组可重用的实体，而不是按需销毁后重建。主要是为了解决创建对象以及gc造成的性能损耗。适用于以下情景：\n\n* 创建对象消耗大量的资源，如线程，jdbc连接，socket连接\n* 创建小对象但是gc频繁，如内存抖动现象，如Android中的Message\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n对象池的设计中，涉及到以下几个方面：\n\n* 对象池容量\n* 从对象池中取对象\n* 向对象池中存对象\n* 高并发对象池\n\n因为本人是做客户端开发的，所以以Android中几种不同的对象池实现方式来了解下线程池。\n\n### Parcel类的对象池设计\n\n我们现在主要看这个类对对象池的设计。以obtain方法为例。\n\n```\n    public static Parcel obtain() {\n        final Parcel[] pool = sOwnedPool;\n        synchronized (pool) {\n            Parcel p;\n            for (int i=0; i<POOL_SIZE; i++) {\n                p = pool[i];\n                if (p != null) {\n                    pool[i] = null;\n                    if (DEBUG_RECYCLE) {\n                        p.mStack = new RuntimeException();\n                    }\n                    return p;\n                }\n            }\n        }\n        return new Parcel(0);\n    }\n```\n\n在这里，我们要注意到这里的池 是一个数组，从里提对象的时候，从头到尾扫描，找到不为null的对象，返回。再来看下recycle方法。\n\n```\n    public final void recycle() {\n        if (DEBUG_RECYCLE) mStack = null;\n        freeBuffer();\n\n        final Parcel[] pool;\n        if (mOwnsNativeParcelObject) {\n            pool = sOwnedPool;\n        } else {\n            mNativePtr = 0;\n            pool = sHolderPool;\n        }\n\n        synchronized (pool) {\n            for (int i=0; i<POOL_SIZE; i++) {\n                if (pool[i] == null) {\n                    pool[i] = this;\n                    return;\n                }\n            }\n        }\n    }\n```\n\n* 找数组中第一个为null的，插入进入。\n\n当然，上面的代码还存在可优化的地方，原因在对存取的时候时复杂度都是O(n)，那么下面我们就来看一种，稍微优化过的。\n\n### v4包中的Pools类\n\n同样，这里还是用数组来实现对象池。\n\n```\n        public T acquire() {\n            if (mPoolSize > 0) {\n                final int lastPooledIndex = mPoolSize - 1;\n                T instance = (T) mPool[lastPooledIndex];\n                mPool[lastPooledIndex] = null;\n                mPoolSize--;\n                return instance;\n            }\n            return null;\n        }\n```\n\n能看到优化么？这里和原先的不一样，我们现在不便利了，直接从后面取，取一个，size--、这样，时间复杂度就是0(1)了，确实做到了优化，当然，release方法也一样。\n\n```\n        public boolean release(T instance) {\n            if (isInPool(instance)) {\n                throw new IllegalStateException(\"Already in the pool!\");\n            }\n            if (mPoolSize < mPool.length) {\n                mPool[mPoolSize] = instance;\n                mPoolSize++;\n                return true;\n            }\n            return false;\n        }\n```\n除了使用数组的方式，Android代码中还有以单链表来实现对象池的类，就是俺们的Message。\n\n### Message-单链表的对象池设计\n\n我们看下他的取和存(回收)。\n\n```\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n```\n\n```\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize < MAX_POOL_SIZE) {\n                next = sPool;\n                sPool = this;\n                sPoolSize++;\n            }\n        }\n    }\n```\n\n* 取对象的时候，我们从链表头拿个对象\n* 回收的时候，相当于在头部插入一个节点。\n\n### 其他的一些设计\n\n其他的一些设计 如线程池，socket连接池这里就不说了。\n\n\n\n\n### 参考资料\n\n* [一个广为人知但鲜有人用的技巧：对象池](http://www.infoq.com/cn/news/2015/07/ClojureWerkz)\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/了解对象池.md","raw":"---\ntitle: 了解对象池\ndate: 2017-02-15 23:34:44\ntags: 程序设计\n\n---\n<Excerpt in index | 首页摘要>\n### 认识对象池\n\n对象池是一种设计模式，预先初始化一组可重用的实体，而不是按需销毁后重建。主要是为了解决创建对象以及gc造成的性能损耗。适用于以下情景：\n\n* 创建对象消耗大量的资源，如线程，jdbc连接，socket连接\n* 创建小对象但是gc频繁，如内存抖动现象，如Android中的Message\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n对象池的设计中，涉及到以下几个方面：\n\n* 对象池容量\n* 从对象池中取对象\n* 向对象池中存对象\n* 高并发对象池\n\n因为本人是做客户端开发的，所以以Android中几种不同的对象池实现方式来了解下线程池。\n\n### Parcel类的对象池设计\n\n我们现在主要看这个类对对象池的设计。以obtain方法为例。\n\n```\n    public static Parcel obtain() {\n        final Parcel[] pool = sOwnedPool;\n        synchronized (pool) {\n            Parcel p;\n            for (int i=0; i<POOL_SIZE; i++) {\n                p = pool[i];\n                if (p != null) {\n                    pool[i] = null;\n                    if (DEBUG_RECYCLE) {\n                        p.mStack = new RuntimeException();\n                    }\n                    return p;\n                }\n            }\n        }\n        return new Parcel(0);\n    }\n```\n\n在这里，我们要注意到这里的池 是一个数组，从里提对象的时候，从头到尾扫描，找到不为null的对象，返回。再来看下recycle方法。\n\n```\n    public final void recycle() {\n        if (DEBUG_RECYCLE) mStack = null;\n        freeBuffer();\n\n        final Parcel[] pool;\n        if (mOwnsNativeParcelObject) {\n            pool = sOwnedPool;\n        } else {\n            mNativePtr = 0;\n            pool = sHolderPool;\n        }\n\n        synchronized (pool) {\n            for (int i=0; i<POOL_SIZE; i++) {\n                if (pool[i] == null) {\n                    pool[i] = this;\n                    return;\n                }\n            }\n        }\n    }\n```\n\n* 找数组中第一个为null的，插入进入。\n\n当然，上面的代码还存在可优化的地方，原因在对存取的时候时复杂度都是O(n)，那么下面我们就来看一种，稍微优化过的。\n\n### v4包中的Pools类\n\n同样，这里还是用数组来实现对象池。\n\n```\n        public T acquire() {\n            if (mPoolSize > 0) {\n                final int lastPooledIndex = mPoolSize - 1;\n                T instance = (T) mPool[lastPooledIndex];\n                mPool[lastPooledIndex] = null;\n                mPoolSize--;\n                return instance;\n            }\n            return null;\n        }\n```\n\n能看到优化么？这里和原先的不一样，我们现在不便利了，直接从后面取，取一个，size--、这样，时间复杂度就是0(1)了，确实做到了优化，当然，release方法也一样。\n\n```\n        public boolean release(T instance) {\n            if (isInPool(instance)) {\n                throw new IllegalStateException(\"Already in the pool!\");\n            }\n            if (mPoolSize < mPool.length) {\n                mPool[mPoolSize] = instance;\n                mPoolSize++;\n                return true;\n            }\n            return false;\n        }\n```\n除了使用数组的方式，Android代码中还有以单链表来实现对象池的类，就是俺们的Message。\n\n### Message-单链表的对象池设计\n\n我们看下他的取和存(回收)。\n\n```\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n```\n\n```\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize < MAX_POOL_SIZE) {\n                next = sPool;\n                sPool = this;\n                sPoolSize++;\n            }\n        }\n    }\n```\n\n* 取对象的时候，我们从链表头拿个对象\n* 回收的时候，相当于在头部插入一个节点。\n\n### 其他的一些设计\n\n其他的一些设计 如线程池，socket连接池这里就不说了。\n\n\n\n\n### 参考资料\n\n* [一个广为人知但鲜有人用的技巧：对象池](http://www.infoq.com/cn/news/2015/07/ClojureWerkz)\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"了解对象池","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm03005d19fyl7399iv2","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"认识对象池\"><a href=\"#认识对象池\" class=\"headerlink\" title=\"认识对象池\"></a>认识对象池</h3><p>对象池是一种设计模式，预先初始化一组可重用的实体，而不是按需销毁后重建。主要是为了解决创建对象以及gc造成的性能损耗。适用于以下情景：</p>\n<ul>\n<li>创建对象消耗大量的资源，如线程，jdbc连接，socket连接</li>\n<li>创建小对象但是gc频繁，如内存抖动现象，如Android中的Message</li>\n</ul>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p>对象池的设计中，涉及到以下几个方面：</p>\n<ul>\n<li>对象池容量</li>\n<li>从对象池中取对象</li>\n<li>向对象池中存对象</li>\n<li>高并发对象池</li>\n</ul>\n<p>因为本人是做客户端开发的，所以以Android中几种不同的对象池实现方式来了解下线程池。</p>\n<h3 id=\"Parcel类的对象池设计\"><a href=\"#Parcel类的对象池设计\" class=\"headerlink\" title=\"Parcel类的对象池设计\"></a>Parcel类的对象池设计</h3><p>我们现在主要看这个类对对象池的设计。以obtain方法为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Parcel obtain() &#123;</div><div class=\"line\">    final Parcel[] pool = sOwnedPool;</div><div class=\"line\">    synchronized (pool) &#123;</div><div class=\"line\">        Parcel p;</div><div class=\"line\">        for (int i=0; i&lt;POOL_SIZE; i++) &#123;</div><div class=\"line\">            p = pool[i];</div><div class=\"line\">            if (p != null) &#123;</div><div class=\"line\">                pool[i] = null;</div><div class=\"line\">                if (DEBUG_RECYCLE) &#123;</div><div class=\"line\">                    p.mStack = new RuntimeException();</div><div class=\"line\">                &#125;</div><div class=\"line\">                return p;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return new Parcel(0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，我们要注意到这里的池 是一个数组，从里提对象的时候，从头到尾扫描，找到不为null的对象，返回。再来看下recycle方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void recycle() &#123;</div><div class=\"line\">    if (DEBUG_RECYCLE) mStack = null;</div><div class=\"line\">    freeBuffer();</div><div class=\"line\"></div><div class=\"line\">    final Parcel[] pool;</div><div class=\"line\">    if (mOwnsNativeParcelObject) &#123;</div><div class=\"line\">        pool = sOwnedPool;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mNativePtr = 0;</div><div class=\"line\">        pool = sHolderPool;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (pool) &#123;</div><div class=\"line\">        for (int i=0; i&lt;POOL_SIZE; i++) &#123;</div><div class=\"line\">            if (pool[i] == null) &#123;</div><div class=\"line\">                pool[i] = this;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>找数组中第一个为null的，插入进入。</li>\n</ul>\n<p>当然，上面的代码还存在可优化的地方，原因在对存取的时候时复杂度都是O(n)，那么下面我们就来看一种，稍微优化过的。</p>\n<h3 id=\"v4包中的Pools类\"><a href=\"#v4包中的Pools类\" class=\"headerlink\" title=\"v4包中的Pools类\"></a>v4包中的Pools类</h3><p>同样，这里还是用数组来实现对象池。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public T acquire() &#123;</div><div class=\"line\">    if (mPoolSize &gt; 0) &#123;</div><div class=\"line\">        final int lastPooledIndex = mPoolSize - 1;</div><div class=\"line\">        T instance = (T) mPool[lastPooledIndex];</div><div class=\"line\">        mPool[lastPooledIndex] = null;</div><div class=\"line\">        mPoolSize--;</div><div class=\"line\">        return instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>能看到优化么？这里和原先的不一样，我们现在不便利了，直接从后面取，取一个，size–、这样，时间复杂度就是0(1)了，确实做到了优化，当然，release方法也一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean release(T instance) &#123;</div><div class=\"line\">    if (isInPool(instance)) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;Already in the pool!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mPoolSize &lt; mPool.length) &#123;</div><div class=\"line\">        mPool[mPoolSize] = instance;</div><div class=\"line\">        mPoolSize++;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除了使用数组的方式，Android代码中还有以单链表来实现对象池的类，就是俺们的Message。</p>\n<h3 id=\"Message-单链表的对象池设计\"><a href=\"#Message-单链表的对象池设计\" class=\"headerlink\" title=\"Message-单链表的对象池设计\"></a>Message-单链表的对象池设计</h3><p>我们看下他的取和存(回收)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Message obtain() &#123;</div><div class=\"line\">    synchronized (sPoolSync) &#123;</div><div class=\"line\">        if (sPool != null) &#123;</div><div class=\"line\">            Message m = sPool;</div><div class=\"line\">            sPool = m.next;</div><div class=\"line\">            m.next = null;</div><div class=\"line\">            m.flags = 0; // clear in-use flag</div><div class=\"line\">            sPoolSize--;</div><div class=\"line\">            return m;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return new Message();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">void recycleUnchecked() &#123;</div><div class=\"line\">    // Mark the message as in use while it remains in the recycled object pool.</div><div class=\"line\">    // Clear out all other details.</div><div class=\"line\">    flags = FLAG_IN_USE;</div><div class=\"line\">    what = 0;</div><div class=\"line\">    arg1 = 0;</div><div class=\"line\">    arg2 = 0;</div><div class=\"line\">    obj = null;</div><div class=\"line\">    replyTo = null;</div><div class=\"line\">    sendingUid = -1;</div><div class=\"line\">    when = 0;</div><div class=\"line\">    target = null;</div><div class=\"line\">    callback = null;</div><div class=\"line\">    data = null;</div><div class=\"line\"></div><div class=\"line\">    synchronized (sPoolSync) &#123;</div><div class=\"line\">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class=\"line\">            next = sPool;</div><div class=\"line\">            sPool = this;</div><div class=\"line\">            sPoolSize++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>取对象的时候，我们从链表头拿个对象</li>\n<li>回收的时候，相当于在头部插入一个节点。</li>\n</ul>\n<h3 id=\"其他的一些设计\"><a href=\"#其他的一些设计\" class=\"headerlink\" title=\"其他的一些设计\"></a>其他的一些设计</h3><p>其他的一些设计 如线程池，socket连接池这里就不说了。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/news/2015/07/ClojureWerkz\" target=\"_blank\" rel=\"external\">一个广为人知但鲜有人用的技巧：对象池</a></li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"认识对象池\"><a href=\"#认识对象池\" class=\"headerlink\" title=\"认识对象池\"></a>认识对象池</h3><p>对象池是一种设计模式，预先初始化一组可重用的实体，而不是按需销毁后重建。主要是为了解决创建对象以及gc造成的性能损耗。适用于以下情景：</p>\n<ul>\n<li>创建对象消耗大量的资源，如线程，jdbc连接，socket连接</li>\n<li>创建小对象但是gc频繁，如内存抖动现象，如Android中的Message</li>\n</ul>","more":"<The rest of contents | 余下全文>\n\n\n<p>对象池的设计中，涉及到以下几个方面：</p>\n<ul>\n<li>对象池容量</li>\n<li>从对象池中取对象</li>\n<li>向对象池中存对象</li>\n<li>高并发对象池</li>\n</ul>\n<p>因为本人是做客户端开发的，所以以Android中几种不同的对象池实现方式来了解下线程池。</p>\n<h3 id=\"Parcel类的对象池设计\"><a href=\"#Parcel类的对象池设计\" class=\"headerlink\" title=\"Parcel类的对象池设计\"></a>Parcel类的对象池设计</h3><p>我们现在主要看这个类对对象池的设计。以obtain方法为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Parcel obtain() &#123;</div><div class=\"line\">    final Parcel[] pool = sOwnedPool;</div><div class=\"line\">    synchronized (pool) &#123;</div><div class=\"line\">        Parcel p;</div><div class=\"line\">        for (int i=0; i&lt;POOL_SIZE; i++) &#123;</div><div class=\"line\">            p = pool[i];</div><div class=\"line\">            if (p != null) &#123;</div><div class=\"line\">                pool[i] = null;</div><div class=\"line\">                if (DEBUG_RECYCLE) &#123;</div><div class=\"line\">                    p.mStack = new RuntimeException();</div><div class=\"line\">                &#125;</div><div class=\"line\">                return p;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return new Parcel(0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里，我们要注意到这里的池 是一个数组，从里提对象的时候，从头到尾扫描，找到不为null的对象，返回。再来看下recycle方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void recycle() &#123;</div><div class=\"line\">    if (DEBUG_RECYCLE) mStack = null;</div><div class=\"line\">    freeBuffer();</div><div class=\"line\"></div><div class=\"line\">    final Parcel[] pool;</div><div class=\"line\">    if (mOwnsNativeParcelObject) &#123;</div><div class=\"line\">        pool = sOwnedPool;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mNativePtr = 0;</div><div class=\"line\">        pool = sHolderPool;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (pool) &#123;</div><div class=\"line\">        for (int i=0; i&lt;POOL_SIZE; i++) &#123;</div><div class=\"line\">            if (pool[i] == null) &#123;</div><div class=\"line\">                pool[i] = this;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>找数组中第一个为null的，插入进入。</li>\n</ul>\n<p>当然，上面的代码还存在可优化的地方，原因在对存取的时候时复杂度都是O(n)，那么下面我们就来看一种，稍微优化过的。</p>\n<h3 id=\"v4包中的Pools类\"><a href=\"#v4包中的Pools类\" class=\"headerlink\" title=\"v4包中的Pools类\"></a>v4包中的Pools类</h3><p>同样，这里还是用数组来实现对象池。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public T acquire() &#123;</div><div class=\"line\">    if (mPoolSize &gt; 0) &#123;</div><div class=\"line\">        final int lastPooledIndex = mPoolSize - 1;</div><div class=\"line\">        T instance = (T) mPool[lastPooledIndex];</div><div class=\"line\">        mPool[lastPooledIndex] = null;</div><div class=\"line\">        mPoolSize--;</div><div class=\"line\">        return instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>能看到优化么？这里和原先的不一样，我们现在不便利了，直接从后面取，取一个，size–、这样，时间复杂度就是0(1)了，确实做到了优化，当然，release方法也一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean release(T instance) &#123;</div><div class=\"line\">    if (isInPool(instance)) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;Already in the pool!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (mPoolSize &lt; mPool.length) &#123;</div><div class=\"line\">        mPool[mPoolSize] = instance;</div><div class=\"line\">        mPoolSize++;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除了使用数组的方式，Android代码中还有以单链表来实现对象池的类，就是俺们的Message。</p>\n<h3 id=\"Message-单链表的对象池设计\"><a href=\"#Message-单链表的对象池设计\" class=\"headerlink\" title=\"Message-单链表的对象池设计\"></a>Message-单链表的对象池设计</h3><p>我们看下他的取和存(回收)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Message obtain() &#123;</div><div class=\"line\">    synchronized (sPoolSync) &#123;</div><div class=\"line\">        if (sPool != null) &#123;</div><div class=\"line\">            Message m = sPool;</div><div class=\"line\">            sPool = m.next;</div><div class=\"line\">            m.next = null;</div><div class=\"line\">            m.flags = 0; // clear in-use flag</div><div class=\"line\">            sPoolSize--;</div><div class=\"line\">            return m;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return new Message();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">void recycleUnchecked() &#123;</div><div class=\"line\">    // Mark the message as in use while it remains in the recycled object pool.</div><div class=\"line\">    // Clear out all other details.</div><div class=\"line\">    flags = FLAG_IN_USE;</div><div class=\"line\">    what = 0;</div><div class=\"line\">    arg1 = 0;</div><div class=\"line\">    arg2 = 0;</div><div class=\"line\">    obj = null;</div><div class=\"line\">    replyTo = null;</div><div class=\"line\">    sendingUid = -1;</div><div class=\"line\">    when = 0;</div><div class=\"line\">    target = null;</div><div class=\"line\">    callback = null;</div><div class=\"line\">    data = null;</div><div class=\"line\"></div><div class=\"line\">    synchronized (sPoolSync) &#123;</div><div class=\"line\">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class=\"line\">            next = sPool;</div><div class=\"line\">            sPool = this;</div><div class=\"line\">            sPoolSize++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>取对象的时候，我们从链表头拿个对象</li>\n<li>回收的时候，相当于在头部插入一个节点。</li>\n</ul>\n<h3 id=\"其他的一些设计\"><a href=\"#其他的一些设计\" class=\"headerlink\" title=\"其他的一些设计\"></a>其他的一些设计</h3><p>其他的一些设计 如线程池，socket连接池这里就不说了。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/news/2015/07/ClojureWerkz\">一个广为人知但鲜有人用的技巧：对象池</a></li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"使用cmake连接第三方so","date":"2017-06-22T15:35:41.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n在开发当中，我们难免会遇到需要使用别人提供so的时候，假如so只提供了纯c接口，怎么办。这一篇讲记录，如何使用cmake连接第三方so。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 准备工作\n\n* so一个，可以自己编译一个\n* so对应的头文件\n\n### 开发\n\n在我们自己的c++中，引入so提供出来的接口头文件，并调用其中的一些方法。\n\n### 编译\n\n编译的过程主要是编写cmakelist文件，这个按照android studio上的cmake教程，没连接成功，下面就看下，连接成功的一种方法。\n\n```\ncmake_minimum_required(VERSION 3.4.1)\nset(libs_DIR src/main/jnilib/${ANDROID_ABI})\nset(libs_include_DIR src/main/cpp)\ninclude_directories(${lib_include_DIR})\nlink_directories(${libs_DIR})\nadd_library( native-lib\n             SHARED\n             src/main/cpp/native-lib.cpp )\ntarget_link_libraries(native-lib\n                      demo )\nfind_library(log-lib\n              log )\ntarget_link_libraries(native-lib demo\n                      ${log-lib} )\n```\n\n步骤如下：\n\n* 指定版本\n* 设置提供给我们的so路径(第二行)\n* 设置提供给我们头文件路径(第三行)\n* 导入头文件（4）\n* 连接so（5）\n* 指定本次生成的so\n* 讲第三方so连接到本次生成的so中\n* 连接log\n\n连接log的一步可以去掉。如果没用到log的话。\n\n做完这些，还需要在gradle里面配置abifliter，默认生成全平台，如果别人提供的不是全平台，有没设置fliter的话，编译不通过。\n\n注意，别人提供的so，格式要对，libxxx.so的格式，别加奇怪的数字什么的。\n\n### demo\n\ndemo上传到github上了，[Demo地址](https://github.com/Guolei1130/Demo)\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/使用cmake连接第三方so.md","raw":"---\ntitle: 使用cmake连接第三方so\ndate: 2017-06-22 23:35:41\ntags: jni\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n在开发当中，我们难免会遇到需要使用别人提供so的时候，假如so只提供了纯c接口，怎么办。这一篇讲记录，如何使用cmake连接第三方so。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 准备工作\n\n* so一个，可以自己编译一个\n* so对应的头文件\n\n### 开发\n\n在我们自己的c++中，引入so提供出来的接口头文件，并调用其中的一些方法。\n\n### 编译\n\n编译的过程主要是编写cmakelist文件，这个按照android studio上的cmake教程，没连接成功，下面就看下，连接成功的一种方法。\n\n```\ncmake_minimum_required(VERSION 3.4.1)\nset(libs_DIR src/main/jnilib/${ANDROID_ABI})\nset(libs_include_DIR src/main/cpp)\ninclude_directories(${lib_include_DIR})\nlink_directories(${libs_DIR})\nadd_library( native-lib\n             SHARED\n             src/main/cpp/native-lib.cpp )\ntarget_link_libraries(native-lib\n                      demo )\nfind_library(log-lib\n              log )\ntarget_link_libraries(native-lib demo\n                      ${log-lib} )\n```\n\n步骤如下：\n\n* 指定版本\n* 设置提供给我们的so路径(第二行)\n* 设置提供给我们头文件路径(第三行)\n* 导入头文件（4）\n* 连接so（5）\n* 指定本次生成的so\n* 讲第三方so连接到本次生成的so中\n* 连接log\n\n连接log的一步可以去掉。如果没用到log的话。\n\n做完这些，还需要在gradle里面配置abifliter，默认生成全平台，如果别人提供的不是全平台，有没设置fliter的话，编译不通过。\n\n注意，别人提供的so，格式要对，libxxx.so的格式，别加奇怪的数字什么的。\n\n### demo\n\ndemo上传到github上了，[Demo地址](https://github.com/Guolei1130/Demo)\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"使用cmake连接第三方so","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm04005g19fy7rfxv6k4","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在开发当中，我们难免会遇到需要使用别人提供so的时候，假如so只提供了纯c接口，怎么办。这一篇讲记录，如何使用cmake连接第三方so。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><ul>\n<li>so一个，可以自己编译一个</li>\n<li>so对应的头文件</li>\n</ul>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>在我们自己的c++中，引入so提供出来的接口头文件，并调用其中的一些方法。</p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>编译的过程主要是编写cmakelist文件，这个按照android studio上的cmake教程，没连接成功，下面就看下，连接成功的一种方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cmake_minimum_required(VERSION 3.4.1)</div><div class=\"line\">set(libs_DIR src/main/jnilib/$&#123;ANDROID_ABI&#125;)</div><div class=\"line\">set(libs_include_DIR src/main/cpp)</div><div class=\"line\">include_directories($&#123;lib_include_DIR&#125;)</div><div class=\"line\">link_directories($&#123;libs_DIR&#125;)</div><div class=\"line\">add_library( native-lib</div><div class=\"line\">             SHARED</div><div class=\"line\">             src/main/cpp/native-lib.cpp )</div><div class=\"line\">target_link_libraries(native-lib</div><div class=\"line\">                      demo )</div><div class=\"line\">find_library(log-lib</div><div class=\"line\">              log )</div><div class=\"line\">target_link_libraries(native-lib demo</div><div class=\"line\">                      $&#123;log-lib&#125; )</div></pre></td></tr></table></figure>\n<p>步骤如下：</p>\n<ul>\n<li>指定版本</li>\n<li>设置提供给我们的so路径(第二行)</li>\n<li>设置提供给我们头文件路径(第三行)</li>\n<li>导入头文件（4）</li>\n<li>连接so（5）</li>\n<li>指定本次生成的so</li>\n<li>讲第三方so连接到本次生成的so中</li>\n<li>连接log</li>\n</ul>\n<p>连接log的一步可以去掉。如果没用到log的话。</p>\n<p>做完这些，还需要在gradle里面配置abifliter，默认生成全平台，如果别人提供的不是全平台，有没设置fliter的话，编译不通过。</p>\n<p>注意，别人提供的so，格式要对，libxxx.so的格式，别加奇怪的数字什么的。</p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p>demo上传到github上了，<a href=\"https://github.com/Guolei1130/Demo\" target=\"_blank\" rel=\"external\">Demo地址</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在开发当中，我们难免会遇到需要使用别人提供so的时候，假如so只提供了纯c接口，怎么办。这一篇讲记录，如何使用cmake连接第三方so。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><ul>\n<li>so一个，可以自己编译一个</li>\n<li>so对应的头文件</li>\n</ul>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>在我们自己的c++中，引入so提供出来的接口头文件，并调用其中的一些方法。</p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>编译的过程主要是编写cmakelist文件，这个按照android studio上的cmake教程，没连接成功，下面就看下，连接成功的一种方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cmake_minimum_required(VERSION 3.4.1)</div><div class=\"line\">set(libs_DIR src/main/jnilib/$&#123;ANDROID_ABI&#125;)</div><div class=\"line\">set(libs_include_DIR src/main/cpp)</div><div class=\"line\">include_directories($&#123;lib_include_DIR&#125;)</div><div class=\"line\">link_directories($&#123;libs_DIR&#125;)</div><div class=\"line\">add_library( native-lib</div><div class=\"line\">             SHARED</div><div class=\"line\">             src/main/cpp/native-lib.cpp )</div><div class=\"line\">target_link_libraries(native-lib</div><div class=\"line\">                      demo )</div><div class=\"line\">find_library(log-lib</div><div class=\"line\">              log )</div><div class=\"line\">target_link_libraries(native-lib demo</div><div class=\"line\">                      $&#123;log-lib&#125; )</div></pre></td></tr></table></figure>\n<p>步骤如下：</p>\n<ul>\n<li>指定版本</li>\n<li>设置提供给我们的so路径(第二行)</li>\n<li>设置提供给我们头文件路径(第三行)</li>\n<li>导入头文件（4）</li>\n<li>连接so（5）</li>\n<li>指定本次生成的so</li>\n<li>讲第三方so连接到本次生成的so中</li>\n<li>连接log</li>\n</ul>\n<p>连接log的一步可以去掉。如果没用到log的话。</p>\n<p>做完这些，还需要在gradle里面配置abifliter，默认生成全平台，如果别人提供的不是全平台，有没设置fliter的话，编译不通过。</p>\n<p>注意，别人提供的so，格式要对，libxxx.so的格式，别加奇怪的数字什么的。</p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p>demo上传到github上了，<a href=\"https://github.com/Guolei1130/Demo\">Demo地址</a></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"别再无脑拷贝代码","date":"2017-06-18T07:03:40.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n工作中发现，不少人喜欢无脑复制别人的代码，不管好坏。因此，写一篇博客记录下，干一行爱一行，不能仅仅是为了完成任务。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 背景\n\n在修改评论页面的时候发现，RecyclerView滑动巨卡，尤其是到了Emoji表情多的时候，很显然，是这里的问题。直接看下代码。\n\n```\n    private void dealExpression(Context context,\n                                SpannableString spannableString, Pattern patten, int start)\n            throws Exception {\n        Matcher matcher = patten.matcher(spannableString);\n        while (matcher.find()) {\n\n            String key = matcher.group();\n            if (matcher.start() < start) {\n                continue;\n            }\n            String value = emojiMap.get(key);\n            if (TextUtils.isEmpty(value)) {\n                continue;\n            }\n            // 通过上面匹配得到的字符串来生成图片资源id\n            int resId = context.getResources().getIdentifier(value, \"drawable\",\n                    context.getPackageName());\n            if (resId != 0) {\n                Drawable emoji = context.getResources().getDrawable(resId);\n                int w = (int) (emoji.getIntrinsicWidth() * 0.40);\n                int h = (int) (emoji.getIntrinsicHeight() * 0.40);\n                emoji.setBounds(0, 0, w, h);\n                // 通过图片资源id来得到bitmap，用一个ImageSpan来包装\n                VerticalImageSpan imageSpan = new VerticalImageSpan(emoji);\n                // 计算该图片名字的长度，也就是要替换的字符串的长度\n                int end = matcher.start() + key.length();\n                // 将该图片替换字符串中规定的位置中\n                spannableString.setSpan(imageSpan, matcher.start(), end,\n                        Spannable.SPAN_INCLUSIVE_EXCLUSIVE);\n                if (end < spannableString.length()) {\n                    dealExpression(context, spannableString, patten, end);\n                }\n                break;\n            }\n        }\n    }\n\n```\n\n解析部分代码如上，且不说其他相关连的low b代码，是在逗我么？正则匹配啥时候需要递归了。\n\n方法名，复制粘贴，很快找到了，来源。[来自这里](http://blog.csdn.net/caroline_wendy/article/details/68485011) 。\n\n万恶的博客，虽然写博客是好事，但是博客真的害了不少人.\n\n### 优化\n\n我们要想优化上面的代码也很简单，从耗时处出发。\n\n1. 去掉递归，根本不需要\n2. 加速ImageSpan的生成过程\n\n因此，我写下了如下代码。\n\n\n```\nSpannableString getStrOpt(Context context) {\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(text);\n        Resources resources = context.getResources();\n        SpannableString spanString = new SpannableString(text);\n        while (matcher.find()) {\n            String key = matcher.group();\n            EmojiImageSpan span = (EmojiImageSpan) mCache.get(key);\n            if (span == null) {\n                int value = emojiMap.get(key);\n                int id = resources.getIdentifier(\"icon\"+value,\"drawable\",context.getPackageName());\n                Drawable drawable = resources.getDrawable(id);\n                drawable.setBounds(0,0,40,40);\n                span = new EmojiImageSpan(drawable);\n                mCache.put(key,span);\n            }else {\n                try {\n                    span = span.clone();\n                } catch (CloneNotSupportedException e) {\n                    e.printStackTrace();\n                }\n            }\n            spanString.setSpan(span,matcher.start(),matcher.start() + key.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);\n        }\n        return spanString;\n    }\n```\n\n递归是完全不需要的，剩下的就是我们如何能快速生成ImageSpan。根据我们的知识，当然是cache了。这里选用LruCache，保证高频出现的emoji能快速提取出ImageSpan来。\n\n\n虽然说上述的代码，在包含大量emoji的RecyclerView里面，极快速度滑动的情况下，还是有轻微的延迟，但是至少不会卡屏不动。\n\n要想进一步优化，当然也是有方法的，我们可以选择延迟加载，大家一定都明白的。具体的做法这里就不说了。\n\n### 总结\n\n* 不要轻易copy别人的代码\n* 做一个有追求的程序员\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/别再无脑拷贝代码.md","raw":"---\ntitle: 别再无脑拷贝代码\ndate: 2017-06-18 15:03:40\ntags: 杂谈\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n工作中发现，不少人喜欢无脑复制别人的代码，不管好坏。因此，写一篇博客记录下，干一行爱一行，不能仅仅是为了完成任务。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 背景\n\n在修改评论页面的时候发现，RecyclerView滑动巨卡，尤其是到了Emoji表情多的时候，很显然，是这里的问题。直接看下代码。\n\n```\n    private void dealExpression(Context context,\n                                SpannableString spannableString, Pattern patten, int start)\n            throws Exception {\n        Matcher matcher = patten.matcher(spannableString);\n        while (matcher.find()) {\n\n            String key = matcher.group();\n            if (matcher.start() < start) {\n                continue;\n            }\n            String value = emojiMap.get(key);\n            if (TextUtils.isEmpty(value)) {\n                continue;\n            }\n            // 通过上面匹配得到的字符串来生成图片资源id\n            int resId = context.getResources().getIdentifier(value, \"drawable\",\n                    context.getPackageName());\n            if (resId != 0) {\n                Drawable emoji = context.getResources().getDrawable(resId);\n                int w = (int) (emoji.getIntrinsicWidth() * 0.40);\n                int h = (int) (emoji.getIntrinsicHeight() * 0.40);\n                emoji.setBounds(0, 0, w, h);\n                // 通过图片资源id来得到bitmap，用一个ImageSpan来包装\n                VerticalImageSpan imageSpan = new VerticalImageSpan(emoji);\n                // 计算该图片名字的长度，也就是要替换的字符串的长度\n                int end = matcher.start() + key.length();\n                // 将该图片替换字符串中规定的位置中\n                spannableString.setSpan(imageSpan, matcher.start(), end,\n                        Spannable.SPAN_INCLUSIVE_EXCLUSIVE);\n                if (end < spannableString.length()) {\n                    dealExpression(context, spannableString, patten, end);\n                }\n                break;\n            }\n        }\n    }\n\n```\n\n解析部分代码如上，且不说其他相关连的low b代码，是在逗我么？正则匹配啥时候需要递归了。\n\n方法名，复制粘贴，很快找到了，来源。[来自这里](http://blog.csdn.net/caroline_wendy/article/details/68485011) 。\n\n万恶的博客，虽然写博客是好事，但是博客真的害了不少人.\n\n### 优化\n\n我们要想优化上面的代码也很简单，从耗时处出发。\n\n1. 去掉递归，根本不需要\n2. 加速ImageSpan的生成过程\n\n因此，我写下了如下代码。\n\n\n```\nSpannableString getStrOpt(Context context) {\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(text);\n        Resources resources = context.getResources();\n        SpannableString spanString = new SpannableString(text);\n        while (matcher.find()) {\n            String key = matcher.group();\n            EmojiImageSpan span = (EmojiImageSpan) mCache.get(key);\n            if (span == null) {\n                int value = emojiMap.get(key);\n                int id = resources.getIdentifier(\"icon\"+value,\"drawable\",context.getPackageName());\n                Drawable drawable = resources.getDrawable(id);\n                drawable.setBounds(0,0,40,40);\n                span = new EmojiImageSpan(drawable);\n                mCache.put(key,span);\n            }else {\n                try {\n                    span = span.clone();\n                } catch (CloneNotSupportedException e) {\n                    e.printStackTrace();\n                }\n            }\n            spanString.setSpan(span,matcher.start(),matcher.start() + key.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);\n        }\n        return spanString;\n    }\n```\n\n递归是完全不需要的，剩下的就是我们如何能快速生成ImageSpan。根据我们的知识，当然是cache了。这里选用LruCache，保证高频出现的emoji能快速提取出ImageSpan来。\n\n\n虽然说上述的代码，在包含大量emoji的RecyclerView里面，极快速度滑动的情况下，还是有轻微的延迟，但是至少不会卡屏不动。\n\n要想进一步优化，当然也是有方法的，我们可以选择延迟加载，大家一定都明白的。具体的做法这里就不说了。\n\n### 总结\n\n* 不要轻易copy别人的代码\n* 做一个有追求的程序员\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"别再无脑拷贝代码","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm05005k19fyazoajbxr","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>工作中发现，不少人喜欢无脑复制别人的代码，不管好坏。因此，写一篇博客记录下，干一行爱一行，不能仅仅是为了完成任务。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在修改评论页面的时候发现，RecyclerView滑动巨卡，尤其是到了Emoji表情多的时候，很显然，是这里的问题。直接看下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void dealExpression(Context context,</div><div class=\"line\">                            SpannableString spannableString, Pattern patten, int start)</div><div class=\"line\">        throws Exception &#123;</div><div class=\"line\">    Matcher matcher = patten.matcher(spannableString);</div><div class=\"line\">    while (matcher.find()) &#123;</div><div class=\"line\"></div><div class=\"line\">        String key = matcher.group();</div><div class=\"line\">        if (matcher.start() &lt; start) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        String value = emojiMap.get(key);</div><div class=\"line\">        if (TextUtils.isEmpty(value)) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 通过上面匹配得到的字符串来生成图片资源id</div><div class=\"line\">        int resId = context.getResources().getIdentifier(value, &quot;drawable&quot;,</div><div class=\"line\">                context.getPackageName());</div><div class=\"line\">        if (resId != 0) &#123;</div><div class=\"line\">            Drawable emoji = context.getResources().getDrawable(resId);</div><div class=\"line\">            int w = (int) (emoji.getIntrinsicWidth() * 0.40);</div><div class=\"line\">            int h = (int) (emoji.getIntrinsicHeight() * 0.40);</div><div class=\"line\">            emoji.setBounds(0, 0, w, h);</div><div class=\"line\">            // 通过图片资源id来得到bitmap，用一个ImageSpan来包装</div><div class=\"line\">            VerticalImageSpan imageSpan = new VerticalImageSpan(emoji);</div><div class=\"line\">            // 计算该图片名字的长度，也就是要替换的字符串的长度</div><div class=\"line\">            int end = matcher.start() + key.length();</div><div class=\"line\">            // 将该图片替换字符串中规定的位置中</div><div class=\"line\">            spannableString.setSpan(imageSpan, matcher.start(), end,</div><div class=\"line\">                    Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</div><div class=\"line\">            if (end &lt; spannableString.length()) &#123;</div><div class=\"line\">                dealExpression(context, spannableString, patten, end);</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析部分代码如上，且不说其他相关连的low b代码，是在逗我么？正则匹配啥时候需要递归了。</p>\n<p>方法名，复制粘贴，很快找到了，来源。<a href=\"http://blog.csdn.net/caroline_wendy/article/details/68485011\" target=\"_blank\" rel=\"external\">来自这里</a> 。</p>\n<p>万恶的博客，虽然写博客是好事，但是博客真的害了不少人.</p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>我们要想优化上面的代码也很简单，从耗时处出发。</p>\n<ol>\n<li>去掉递归，根本不需要</li>\n<li>加速ImageSpan的生成过程</li>\n</ol>\n<p>因此，我写下了如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">SpannableString getStrOpt(Context context) &#123;</div><div class=\"line\">        Pattern pattern = Pattern.compile(regex);</div><div class=\"line\">        Matcher matcher = pattern.matcher(text);</div><div class=\"line\">        Resources resources = context.getResources();</div><div class=\"line\">        SpannableString spanString = new SpannableString(text);</div><div class=\"line\">        while (matcher.find()) &#123;</div><div class=\"line\">            String key = matcher.group();</div><div class=\"line\">            EmojiImageSpan span = (EmojiImageSpan) mCache.get(key);</div><div class=\"line\">            if (span == null) &#123;</div><div class=\"line\">                int value = emojiMap.get(key);</div><div class=\"line\">                int id = resources.getIdentifier(&quot;icon&quot;+value,&quot;drawable&quot;,context.getPackageName());</div><div class=\"line\">                Drawable drawable = resources.getDrawable(id);</div><div class=\"line\">                drawable.setBounds(0,0,40,40);</div><div class=\"line\">                span = new EmojiImageSpan(drawable);</div><div class=\"line\">                mCache.put(key,span);</div><div class=\"line\">            &#125;else &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    span = span.clone();</div><div class=\"line\">                &#125; catch (CloneNotSupportedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            spanString.setSpan(span,matcher.start(),matcher.start() + key.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return spanString;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>递归是完全不需要的，剩下的就是我们如何能快速生成ImageSpan。根据我们的知识，当然是cache了。这里选用LruCache，保证高频出现的emoji能快速提取出ImageSpan来。</p>\n<p>虽然说上述的代码，在包含大量emoji的RecyclerView里面，极快速度滑动的情况下，还是有轻微的延迟，但是至少不会卡屏不动。</p>\n<p>要想进一步优化，当然也是有方法的，我们可以选择延迟加载，大家一定都明白的。具体的做法这里就不说了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>不要轻易copy别人的代码</li>\n<li>做一个有追求的程序员<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></li>\n</ul>\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>工作中发现，不少人喜欢无脑复制别人的代码，不管好坏。因此，写一篇博客记录下，干一行爱一行，不能仅仅是为了完成任务。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在修改评论页面的时候发现，RecyclerView滑动巨卡，尤其是到了Emoji表情多的时候，很显然，是这里的问题。直接看下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void dealExpression(Context context,</div><div class=\"line\">                            SpannableString spannableString, Pattern patten, int start)</div><div class=\"line\">        throws Exception &#123;</div><div class=\"line\">    Matcher matcher = patten.matcher(spannableString);</div><div class=\"line\">    while (matcher.find()) &#123;</div><div class=\"line\"></div><div class=\"line\">        String key = matcher.group();</div><div class=\"line\">        if (matcher.start() &lt; start) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        String value = emojiMap.get(key);</div><div class=\"line\">        if (TextUtils.isEmpty(value)) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 通过上面匹配得到的字符串来生成图片资源id</div><div class=\"line\">        int resId = context.getResources().getIdentifier(value, &quot;drawable&quot;,</div><div class=\"line\">                context.getPackageName());</div><div class=\"line\">        if (resId != 0) &#123;</div><div class=\"line\">            Drawable emoji = context.getResources().getDrawable(resId);</div><div class=\"line\">            int w = (int) (emoji.getIntrinsicWidth() * 0.40);</div><div class=\"line\">            int h = (int) (emoji.getIntrinsicHeight() * 0.40);</div><div class=\"line\">            emoji.setBounds(0, 0, w, h);</div><div class=\"line\">            // 通过图片资源id来得到bitmap，用一个ImageSpan来包装</div><div class=\"line\">            VerticalImageSpan imageSpan = new VerticalImageSpan(emoji);</div><div class=\"line\">            // 计算该图片名字的长度，也就是要替换的字符串的长度</div><div class=\"line\">            int end = matcher.start() + key.length();</div><div class=\"line\">            // 将该图片替换字符串中规定的位置中</div><div class=\"line\">            spannableString.setSpan(imageSpan, matcher.start(), end,</div><div class=\"line\">                    Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</div><div class=\"line\">            if (end &lt; spannableString.length()) &#123;</div><div class=\"line\">                dealExpression(context, spannableString, patten, end);</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析部分代码如上，且不说其他相关连的low b代码，是在逗我么？正则匹配啥时候需要递归了。</p>\n<p>方法名，复制粘贴，很快找到了，来源。<a href=\"http://blog.csdn.net/caroline_wendy/article/details/68485011\">来自这里</a> 。</p>\n<p>万恶的博客，虽然写博客是好事，但是博客真的害了不少人.</p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>我们要想优化上面的代码也很简单，从耗时处出发。</p>\n<ol>\n<li>去掉递归，根本不需要</li>\n<li>加速ImageSpan的生成过程</li>\n</ol>\n<p>因此，我写下了如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">SpannableString getStrOpt(Context context) &#123;</div><div class=\"line\">        Pattern pattern = Pattern.compile(regex);</div><div class=\"line\">        Matcher matcher = pattern.matcher(text);</div><div class=\"line\">        Resources resources = context.getResources();</div><div class=\"line\">        SpannableString spanString = new SpannableString(text);</div><div class=\"line\">        while (matcher.find()) &#123;</div><div class=\"line\">            String key = matcher.group();</div><div class=\"line\">            EmojiImageSpan span = (EmojiImageSpan) mCache.get(key);</div><div class=\"line\">            if (span == null) &#123;</div><div class=\"line\">                int value = emojiMap.get(key);</div><div class=\"line\">                int id = resources.getIdentifier(&quot;icon&quot;+value,&quot;drawable&quot;,context.getPackageName());</div><div class=\"line\">                Drawable drawable = resources.getDrawable(id);</div><div class=\"line\">                drawable.setBounds(0,0,40,40);</div><div class=\"line\">                span = new EmojiImageSpan(drawable);</div><div class=\"line\">                mCache.put(key,span);</div><div class=\"line\">            &#125;else &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    span = span.clone();</div><div class=\"line\">                &#125; catch (CloneNotSupportedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            spanString.setSpan(span,matcher.start(),matcher.start() + key.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return spanString;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>递归是完全不需要的，剩下的就是我们如何能快速生成ImageSpan。根据我们的知识，当然是cache了。这里选用LruCache，保证高频出现的emoji能快速提取出ImageSpan来。</p>\n<p>虽然说上述的代码，在包含大量emoji的RecyclerView里面，极快速度滑动的情况下，还是有轻微的延迟，但是至少不会卡屏不动。</p>\n<p>要想进一步优化，当然也是有方法的，我们可以选择延迟加载，大家一定都明白的。具体的做法这里就不说了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>不要轻易copy别人的代码</li>\n<li>做一个有追求的程序员<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></li>\n</ul>"},{"title":"反编译随笔","date":"2017-08-21T15:52:55.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n前段时间反编译某个app的时候发现一点小技巧，记录一下，实际上，这对于代码保护是没有半点用处的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 发现的过程\n\n首先，按照反编译的过程，jadx-gui,选中要发编译的apk。手机启动那个app的具体Activity，我们想要的东西在这里，比如书一个View之类的。\n\n首先我们需要获取到这个activity的全限定路径。\n\n```\nadb shell dumpsys activity | grep '包名'\n```\n\n很简单的获取到路径，打开那个activity，追踪到view，jadx find class，没找到。。。这是，我们很清楚的知道，要么是进行了加壳，要么是动态加载。从source code的结构上来看，排除加壳。那么我们就从Application入手。查看动态加载以及那部分dex的生成过程。\n\n### 拔出代码\n\n在Application中，发现如下一段代码\n\n```\n    private void a() {\n        File dir = getDir(\"tbcache\", 0);\n        File dir2 = getDir(\"tbcache_optimized\", 0);\n        String str = dir.getAbsolutePath() + \"/result.dex\";\n        try {\n            b.a((Application) this);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            a.a(getClassLoader(), str, dir2.getAbsolutePath());\n        } catch (Exception e2) {\n            e2.printStackTrace();\n            Log.e(a, e2.toString());\n        }\n    }\n```\n很明显，我们不管result.dex是如何生成的，我们需要这段dex，通过adb导出，用jd-gui打开便可找到我们想看的代码。\n\n### 总结：\n\n那个App用到的技术点：\n\n1. multidex 打包，将核心或者是某些class打到一个dex中，\n2. 对那个dex进行操作，组装成一个不能直接打开的dex\n3. 取出，动态加载\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/反编译随笔.md","raw":"---\ntitle: 反编译随笔\ndate: 2017-08-21 23:52:55\ntags: Android\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n前段时间反编译某个app的时候发现一点小技巧，记录一下，实际上，这对于代码保护是没有半点用处的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 发现的过程\n\n首先，按照反编译的过程，jadx-gui,选中要发编译的apk。手机启动那个app的具体Activity，我们想要的东西在这里，比如书一个View之类的。\n\n首先我们需要获取到这个activity的全限定路径。\n\n```\nadb shell dumpsys activity | grep '包名'\n```\n\n很简单的获取到路径，打开那个activity，追踪到view，jadx find class，没找到。。。这是，我们很清楚的知道，要么是进行了加壳，要么是动态加载。从source code的结构上来看，排除加壳。那么我们就从Application入手。查看动态加载以及那部分dex的生成过程。\n\n### 拔出代码\n\n在Application中，发现如下一段代码\n\n```\n    private void a() {\n        File dir = getDir(\"tbcache\", 0);\n        File dir2 = getDir(\"tbcache_optimized\", 0);\n        String str = dir.getAbsolutePath() + \"/result.dex\";\n        try {\n            b.a((Application) this);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            a.a(getClassLoader(), str, dir2.getAbsolutePath());\n        } catch (Exception e2) {\n            e2.printStackTrace();\n            Log.e(a, e2.toString());\n        }\n    }\n```\n很明显，我们不管result.dex是如何生成的，我们需要这段dex，通过adb导出，用jd-gui打开便可找到我们想看的代码。\n\n### 总结：\n\n那个App用到的技术点：\n\n1. multidex 打包，将核心或者是某些class打到一个dex中，\n2. 对那个dex进行操作，组装成一个不能直接打开的dex\n3. 取出，动态加载\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"反编译随笔","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm08005o19fyg9xghw6n","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前段时间反编译某个app的时候发现一点小技巧，记录一下，实际上，这对于代码保护是没有半点用处的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"发现的过程\"><a href=\"#发现的过程\" class=\"headerlink\" title=\"发现的过程\"></a>发现的过程</h3><p>首先，按照反编译的过程，jadx-gui,选中要发编译的apk。手机启动那个app的具体Activity，我们想要的东西在这里，比如书一个View之类的。</p>\n<p>首先我们需要获取到这个activity的全限定路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell dumpsys activity | grep &apos;包名&apos;</div></pre></td></tr></table></figure>\n<p>很简单的获取到路径，打开那个activity，追踪到view，jadx find class，没找到。。。这是，我们很清楚的知道，要么是进行了加壳，要么是动态加载。从source code的结构上来看，排除加壳。那么我们就从Application入手。查看动态加载以及那部分dex的生成过程。</p>\n<h3 id=\"拔出代码\"><a href=\"#拔出代码\" class=\"headerlink\" title=\"拔出代码\"></a>拔出代码</h3><p>在Application中，发现如下一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void a() &#123;</div><div class=\"line\">    File dir = getDir(&quot;tbcache&quot;, 0);</div><div class=\"line\">    File dir2 = getDir(&quot;tbcache_optimized&quot;, 0);</div><div class=\"line\">    String str = dir.getAbsolutePath() + &quot;/result.dex&quot;;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        b.a((Application) this);</div><div class=\"line\">    &#125; catch (IOException e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        a.a(getClassLoader(), str, dir2.getAbsolutePath());</div><div class=\"line\">    &#125; catch (Exception e2) &#123;</div><div class=\"line\">        e2.printStackTrace();</div><div class=\"line\">        Log.e(a, e2.toString());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>很明显，我们不管result.dex是如何生成的，我们需要这段dex，通过adb导出，用jd-gui打开便可找到我们想看的代码。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>那个App用到的技术点：</p>\n<ol>\n<li>multidex 打包，将核心或者是某些class打到一个dex中，</li>\n<li>对那个dex进行操作，组装成一个不能直接打开的dex</li>\n<li>取出，动态加载</li>\n</ol>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前段时间反编译某个app的时候发现一点小技巧，记录一下，实际上，这对于代码保护是没有半点用处的。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"发现的过程\"><a href=\"#发现的过程\" class=\"headerlink\" title=\"发现的过程\"></a>发现的过程</h3><p>首先，按照反编译的过程，jadx-gui,选中要发编译的apk。手机启动那个app的具体Activity，我们想要的东西在这里，比如书一个View之类的。</p>\n<p>首先我们需要获取到这个activity的全限定路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell dumpsys activity | grep &apos;包名&apos;</div></pre></td></tr></table></figure>\n<p>很简单的获取到路径，打开那个activity，追踪到view，jadx find class，没找到。。。这是，我们很清楚的知道，要么是进行了加壳，要么是动态加载。从source code的结构上来看，排除加壳。那么我们就从Application入手。查看动态加载以及那部分dex的生成过程。</p>\n<h3 id=\"拔出代码\"><a href=\"#拔出代码\" class=\"headerlink\" title=\"拔出代码\"></a>拔出代码</h3><p>在Application中，发现如下一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void a() &#123;</div><div class=\"line\">    File dir = getDir(&quot;tbcache&quot;, 0);</div><div class=\"line\">    File dir2 = getDir(&quot;tbcache_optimized&quot;, 0);</div><div class=\"line\">    String str = dir.getAbsolutePath() + &quot;/result.dex&quot;;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        b.a((Application) this);</div><div class=\"line\">    &#125; catch (IOException e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        a.a(getClassLoader(), str, dir2.getAbsolutePath());</div><div class=\"line\">    &#125; catch (Exception e2) &#123;</div><div class=\"line\">        e2.printStackTrace();</div><div class=\"line\">        Log.e(a, e2.toString());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>很明显，我们不管result.dex是如何生成的，我们需要这段dex，通过adb导出，用jd-gui打开便可找到我们想看的代码。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>那个App用到的技术点：</p>\n<ol>\n<li>multidex 打包，将核心或者是某些class打到一个dex中，</li>\n<li>对那个dex进行操作，组装成一个不能直接打开的dex</li>\n<li>取出，动态加载</li>\n</ol>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"浅析Android热修复","date":"2018-04-09T08:44:47.000Z","_content":"<Excerpt in index | 首页摘要>\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n除摘要外其他内容_ _ _\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/浅析Android热修复.md","raw":"---\ntitle: 浅析Android热修复\ndate: 2018-04-09 16:44:47\ntags: Android\ncategories: 分类要填\n\n---\n<Excerpt in index | 首页摘要>\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n除摘要外其他内容_ _ _\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"浅析Android热修复","published":1,"updated":"2018-04-09T08:45:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm09005s19fyoayh8e0p","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n\n<a id=\"more\"></a>\n<p><the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\"><br>除摘要外其他内容<em> </em> _</the></p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></excerpt>","excerpt":"<Excerpt in index | 首页摘要>","more":"<p><The rest of contents | 余下全文><br>除摘要外其他内容<em> </em> _</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"浅谈客户端增量升级","date":"2017-04-16T07:28:51.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n大家应该都有注意到，各大应用市场都在使用增量升级的技术。那么，今天，就来记录下，bsdiff和bspatch。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 尝试\n\n我们先去[Binary diff/patch utility](http://www.daemonology.net/bsdiff/) 中，把相关的资源下载下来，下载下来之后，我们进行编译，在编译之前，我们需要修改一点东西。\n\nMakefile文件修改成如下：\n\n```\nCFLAGS\t\t+=\t-O3 -lbz2\n\nPREFIX\t\t?=\t/usr/local\nINSTALL_PROGRAM\t?=\t${INSTALL} -c -s -m 555\nINSTALL_MAN\t?=\t${INSTALL} -c -m 444\n\nall:\t\tbsdiff bspatch\nbsdiff:\t\tbsdiff.c\nbspatch:\tbspatch.c\n\ninstall:\n\t${INSTALL_PROGRAM} bsdiff bspatch ${PREFIX}/bin\n\t.ifndef WITHOUT_MAN\n\t${INSTALL_MAN} bsdiff.1 bspatch.1 ${PREFIX}/man/man1\n\t.endif\n\n```\n\n就是在倒数第一行和倒数第三行增加缩进。\n\n然后修改bspatch.c文件，增加如下代码：\n\n```\ntypedef unsigned char u_char;\n```\n\n然后就可以进行编译了。\n\n```\nmake\n```\n\n编译完成之后，我们就能进行初次尝试了。\n\n首先我们用as，生成两个新旧的apk,old.apk new.apk\n\n然后，我们终端进入bsdiff的目录，执行如下命令生成patch包。\n\n```\n#命令格式 bsdiff: usage: ./bsdiff oldfile newfile patchfile\n\n./bsdiff old.apk new.apk patch.apk\n```\n\n然后，我们再用旧的apk和patch包，生成新的new.apk\n\n```\n#命令格式 bspatch: usage: ./bspatch oldfile newfile patchfile\n\n./bspatch old.apk new_patch.apk patch.apk\n```\n\n最后，我们验证下new.apk 和我们生成的new_patch.apk的md5值和sha值\n\n```\nmd5 new.apk\nmd5 new_patch.apk\n\nshasum new.apk\nshasum new_patch.apk\n\n\n\n```\n\n观察值是否相同，进行测试。\n\n\n### 如何移植到Android\n\n我们客户端要关心的，就是合成的过程，也就是bspatch，那么我们如何移植到Android上呢。\n\n目前有两种移植到Android上的方案。\n\n* jni，讲bspatch.c稍微改造下，编译成so文件，但是我们这里需要注意的是，因为Android中没有bzip2相关的东西，我们需要将bzip2相关的源码也拿出来。具体参考[bzip](http://www.bzip.org/index.html)，源码也可在哪里下载。下载完成之后，将.c和.h等有效文件移植到我们的项目即可。\n* 使用bspatch.c的java翻译版本,tinker中有相关的翻译版本，我们可以使用.[java翻译版本](https://github.com/Tencent/tinker/blob/master/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java) ，我大致看了下，没有对magic进行校验，如果有需要，可自行加上校验，校验规则，参考bspatch.c\n\n### 总结\n\n* bsdiff生成的patch包，虽然比完整包小，但是还是比较大。\n* 版本多了之后，难以管理，建议控制在三个版本\n\n如果想了解原理 [可以阅读这篇文章](http://blog.csdn.net/add_ada/article/details/51232889)，并结合源码进行。\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul><Excerpt in index | 首页摘要>\n","source":"_posts/浅谈客户端增量升级.md","raw":"---\ntitle: 浅谈客户端增量升级\ndate: 2017-04-16 15:28:51\ntags: 增量升级\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n大家应该都有注意到，各大应用市场都在使用增量升级的技术。那么，今天，就来记录下，bsdiff和bspatch。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 尝试\n\n我们先去[Binary diff/patch utility](http://www.daemonology.net/bsdiff/) 中，把相关的资源下载下来，下载下来之后，我们进行编译，在编译之前，我们需要修改一点东西。\n\nMakefile文件修改成如下：\n\n```\nCFLAGS\t\t+=\t-O3 -lbz2\n\nPREFIX\t\t?=\t/usr/local\nINSTALL_PROGRAM\t?=\t${INSTALL} -c -s -m 555\nINSTALL_MAN\t?=\t${INSTALL} -c -m 444\n\nall:\t\tbsdiff bspatch\nbsdiff:\t\tbsdiff.c\nbspatch:\tbspatch.c\n\ninstall:\n\t${INSTALL_PROGRAM} bsdiff bspatch ${PREFIX}/bin\n\t.ifndef WITHOUT_MAN\n\t${INSTALL_MAN} bsdiff.1 bspatch.1 ${PREFIX}/man/man1\n\t.endif\n\n```\n\n就是在倒数第一行和倒数第三行增加缩进。\n\n然后修改bspatch.c文件，增加如下代码：\n\n```\ntypedef unsigned char u_char;\n```\n\n然后就可以进行编译了。\n\n```\nmake\n```\n\n编译完成之后，我们就能进行初次尝试了。\n\n首先我们用as，生成两个新旧的apk,old.apk new.apk\n\n然后，我们终端进入bsdiff的目录，执行如下命令生成patch包。\n\n```\n#命令格式 bsdiff: usage: ./bsdiff oldfile newfile patchfile\n\n./bsdiff old.apk new.apk patch.apk\n```\n\n然后，我们再用旧的apk和patch包，生成新的new.apk\n\n```\n#命令格式 bspatch: usage: ./bspatch oldfile newfile patchfile\n\n./bspatch old.apk new_patch.apk patch.apk\n```\n\n最后，我们验证下new.apk 和我们生成的new_patch.apk的md5值和sha值\n\n```\nmd5 new.apk\nmd5 new_patch.apk\n\nshasum new.apk\nshasum new_patch.apk\n\n\n\n```\n\n观察值是否相同，进行测试。\n\n\n### 如何移植到Android\n\n我们客户端要关心的，就是合成的过程，也就是bspatch，那么我们如何移植到Android上呢。\n\n目前有两种移植到Android上的方案。\n\n* jni，讲bspatch.c稍微改造下，编译成so文件，但是我们这里需要注意的是，因为Android中没有bzip2相关的东西，我们需要将bzip2相关的源码也拿出来。具体参考[bzip](http://www.bzip.org/index.html)，源码也可在哪里下载。下载完成之后，将.c和.h等有效文件移植到我们的项目即可。\n* 使用bspatch.c的java翻译版本,tinker中有相关的翻译版本，我们可以使用.[java翻译版本](https://github.com/Tencent/tinker/blob/master/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java) ，我大致看了下，没有对magic进行校验，如果有需要，可自行加上校验，校验规则，参考bspatch.c\n\n### 总结\n\n* bsdiff生成的patch包，虽然比完整包小，但是还是比较大。\n* 版本多了之后，难以管理，建议控制在三个版本\n\n如果想了解原理 [可以阅读这篇文章](http://blog.csdn.net/add_ada/article/details/51232889)，并结合源码进行。\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul><Excerpt in index | 首页摘要>\n","slug":"浅谈客户端增量升级","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm0a005u19fymf006yuq","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>大家应该都有注意到，各大应用市场都在使用增量升级的技术。那么，今天，就来记录下，bsdiff和bspatch。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"尝试\"><a href=\"#尝试\" class=\"headerlink\" title=\"尝试\"></a>尝试</h3><p>我们先去<a href=\"http://www.daemonology.net/bsdiff/\" target=\"_blank\" rel=\"external\">Binary diff/patch utility</a> 中，把相关的资源下载下来，下载下来之后，我们进行编译，在编译之前，我们需要修改一点东西。</p>\n<p>Makefile文件修改成如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFLAGS\t\t+=\t-O3 -lbz2</div><div class=\"line\"></div><div class=\"line\">PREFIX\t\t?=\t/usr/local</div><div class=\"line\">INSTALL_PROGRAM\t?=\t$&#123;INSTALL&#125; -c -s -m 555</div><div class=\"line\">INSTALL_MAN\t?=\t$&#123;INSTALL&#125; -c -m 444</div><div class=\"line\"></div><div class=\"line\">all:\t\tbsdiff bspatch</div><div class=\"line\">bsdiff:\t\tbsdiff.c</div><div class=\"line\">bspatch:\tbspatch.c</div><div class=\"line\"></div><div class=\"line\">install:</div><div class=\"line\">\t$&#123;INSTALL_PROGRAM&#125; bsdiff bspatch $&#123;PREFIX&#125;/bin</div><div class=\"line\">\t.ifndef WITHOUT_MAN</div><div class=\"line\">\t$&#123;INSTALL_MAN&#125; bsdiff.1 bspatch.1 $&#123;PREFIX&#125;/man/man1</div><div class=\"line\">\t.endif</div></pre></td></tr></table></figure>\n<p>就是在倒数第一行和倒数第三行增加缩进。</p>\n<p>然后修改bspatch.c文件，增加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char u_char;</div></pre></td></tr></table></figure>\n<p>然后就可以进行编译了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">make</div></pre></td></tr></table></figure>\n<p>编译完成之后，我们就能进行初次尝试了。</p>\n<p>首先我们用as，生成两个新旧的apk,old.apk new.apk</p>\n<p>然后，我们终端进入bsdiff的目录，执行如下命令生成patch包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#命令格式 bsdiff: usage: ./bsdiff oldfile newfile patchfile</div><div class=\"line\"></div><div class=\"line\">./bsdiff old.apk new.apk patch.apk</div></pre></td></tr></table></figure>\n<p>然后，我们再用旧的apk和patch包，生成新的new.apk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#命令格式 bspatch: usage: ./bspatch oldfile newfile patchfile</div><div class=\"line\"></div><div class=\"line\">./bspatch old.apk new_patch.apk patch.apk</div></pre></td></tr></table></figure>\n<p>最后，我们验证下new.apk 和我们生成的new_patch.apk的md5值和sha值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">md5 new.apk</div><div class=\"line\">md5 new_patch.apk</div><div class=\"line\"></div><div class=\"line\">shasum new.apk</div><div class=\"line\">shasum new_patch.apk</div></pre></td></tr></table></figure>\n<p>观察值是否相同，进行测试。</p>\n<h3 id=\"如何移植到Android\"><a href=\"#如何移植到Android\" class=\"headerlink\" title=\"如何移植到Android\"></a>如何移植到Android</h3><p>我们客户端要关心的，就是合成的过程，也就是bspatch，那么我们如何移植到Android上呢。</p>\n<p>目前有两种移植到Android上的方案。</p>\n<ul>\n<li>jni，讲bspatch.c稍微改造下，编译成so文件，但是我们这里需要注意的是，因为Android中没有bzip2相关的东西，我们需要将bzip2相关的源码也拿出来。具体参考<a href=\"http://www.bzip.org/index.html\" target=\"_blank\" rel=\"external\">bzip</a>，源码也可在哪里下载。下载完成之后，将.c和.h等有效文件移植到我们的项目即可。</li>\n<li>使用bspatch.c的java翻译版本,tinker中有相关的翻译版本，我们可以使用.<a href=\"https://github.com/Tencent/tinker/blob/master/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java\" target=\"_blank\" rel=\"external\">java翻译版本</a> ，我大致看了下，没有对magic进行校验，如果有需要，可自行加上校验，校验规则，参考bspatch.c</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>bsdiff生成的patch包，虽然比完整包小，但是还是比较大。</li>\n<li>版本多了之后，难以管理，建议控制在三个版本</li>\n</ul>\n<p>如果想了解原理 <a href=\"http://blog.csdn.net/add_ada/article/details/51232889\" target=\"_blank\" rel=\"external\">可以阅读这篇文章</a>，并结合源码进行。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><p><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>大家应该都有注意到，各大应用市场都在使用增量升级的技术。那么，今天，就来记录下，bsdiff和bspatch。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"尝试\"><a href=\"#尝试\" class=\"headerlink\" title=\"尝试\"></a>尝试</h3><p>我们先去<a href=\"http://www.daemonology.net/bsdiff/\">Binary diff/patch utility</a> 中，把相关的资源下载下来，下载下来之后，我们进行编译，在编译之前，我们需要修改一点东西。</p>\n<p>Makefile文件修改成如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFLAGS\t\t+=\t-O3 -lbz2</div><div class=\"line\"></div><div class=\"line\">PREFIX\t\t?=\t/usr/local</div><div class=\"line\">INSTALL_PROGRAM\t?=\t$&#123;INSTALL&#125; -c -s -m 555</div><div class=\"line\">INSTALL_MAN\t?=\t$&#123;INSTALL&#125; -c -m 444</div><div class=\"line\"></div><div class=\"line\">all:\t\tbsdiff bspatch</div><div class=\"line\">bsdiff:\t\tbsdiff.c</div><div class=\"line\">bspatch:\tbspatch.c</div><div class=\"line\"></div><div class=\"line\">install:</div><div class=\"line\">\t$&#123;INSTALL_PROGRAM&#125; bsdiff bspatch $&#123;PREFIX&#125;/bin</div><div class=\"line\">\t.ifndef WITHOUT_MAN</div><div class=\"line\">\t$&#123;INSTALL_MAN&#125; bsdiff.1 bspatch.1 $&#123;PREFIX&#125;/man/man1</div><div class=\"line\">\t.endif</div></pre></td></tr></table></figure>\n<p>就是在倒数第一行和倒数第三行增加缩进。</p>\n<p>然后修改bspatch.c文件，增加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char u_char;</div></pre></td></tr></table></figure>\n<p>然后就可以进行编译了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">make</div></pre></td></tr></table></figure>\n<p>编译完成之后，我们就能进行初次尝试了。</p>\n<p>首先我们用as，生成两个新旧的apk,old.apk new.apk</p>\n<p>然后，我们终端进入bsdiff的目录，执行如下命令生成patch包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#命令格式 bsdiff: usage: ./bsdiff oldfile newfile patchfile</div><div class=\"line\"></div><div class=\"line\">./bsdiff old.apk new.apk patch.apk</div></pre></td></tr></table></figure>\n<p>然后，我们再用旧的apk和patch包，生成新的new.apk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#命令格式 bspatch: usage: ./bspatch oldfile newfile patchfile</div><div class=\"line\"></div><div class=\"line\">./bspatch old.apk new_patch.apk patch.apk</div></pre></td></tr></table></figure>\n<p>最后，我们验证下new.apk 和我们生成的new_patch.apk的md5值和sha值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">md5 new.apk</div><div class=\"line\">md5 new_patch.apk</div><div class=\"line\"></div><div class=\"line\">shasum new.apk</div><div class=\"line\">shasum new_patch.apk</div></pre></td></tr></table></figure>\n<p>观察值是否相同，进行测试。</p>\n<h3 id=\"如何移植到Android\"><a href=\"#如何移植到Android\" class=\"headerlink\" title=\"如何移植到Android\"></a>如何移植到Android</h3><p>我们客户端要关心的，就是合成的过程，也就是bspatch，那么我们如何移植到Android上呢。</p>\n<p>目前有两种移植到Android上的方案。</p>\n<ul>\n<li>jni，讲bspatch.c稍微改造下，编译成so文件，但是我们这里需要注意的是，因为Android中没有bzip2相关的东西，我们需要将bzip2相关的源码也拿出来。具体参考<a href=\"http://www.bzip.org/index.html\">bzip</a>，源码也可在哪里下载。下载完成之后，将.c和.h等有效文件移植到我们的项目即可。</li>\n<li>使用bspatch.c的java翻译版本,tinker中有相关的翻译版本，我们可以使用.<a href=\"https://github.com/Tencent/tinker/blob/master/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java\">java翻译版本</a> ，我大致看了下，没有对magic进行校验，如果有需要，可自行加上校验，校验规则，参考bspatch.c</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>bsdiff生成的patch包，虽然比完整包小，但是还是比较大。</li>\n<li>版本多了之后，难以管理，建议控制在三个版本</li>\n</ul>\n<p>如果想了解原理 <a href=\"http://blog.csdn.net/add_ada/article/details/51232889\">可以阅读这篇文章</a>，并结合源码进行。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><p><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul><Excerpt in index | 首页摘要></p>"},{"title":"浅谈Android插件化","date":"2018-04-03T12:30:04.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 前言\n\nAndroid P preview版本中，已限制对@hide api的反射调用，具体的原理可以阅读[Android P调用隐藏API限制原理](https://mp.weixin.qq.com/s/sktB0x5yBexkn4ORQ1YofA)这篇文章。由于最近团队分享也在分享插件化、热修复相关的东西。因此，写一篇文章，好好记录一下。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 准备知识\n\n* 反射、动态代理\n* Android中的几个相关的ClassLoader,注意PathClassLoader在ART虚拟机上是可以加载未安装的APK的，Dalvik虚拟机则不可以。\n* Android中四大组件的相关原理\n* PackageManagerServer\n* 资源加载、资源打包\n* 其他\n\n**文章中所涉及到的代码均通过Nexus 5(dalvik虚拟机) Android 6.0版本的测试**\n\n文章中所涉及到的一切资源都在[这个仓库下](https://github.com/Guolei1130/blog_resource/tree/master/source_code/plugin_about)\n\n\n特别说明，本博客不会特别解释过多原理性的东西。如果读者不具备相关的知识储备，建议先阅读weishu和gityuan两位大神的博客,资源打包的知识可以阅读 老罗的博客。\n\n* [Weishu's Notes](http://weishu.me/)\n* [gityuan](http://gityuan.com/)\n\n### Activity的插件化\n\n首先需要说明一点的是，启动一个完全没有在AndroidManifest注册的Activity是不可能的。因为在启动的过程中，存在一个校验的过程，而这个校验则是由PMS来完成的，这个我们无法干预。因此，Activity的插件化方案大多使用占坑的思想。不同的是如何在检验之前替换，在生成对象的时候还原。就目前来看，有三种方案：\n\n* Hook Instrumentation方案\n* Hook CallBack方案\n* 干预startActivity等方法，干预ClassLoader findClass的方案\n\n\n这里说一下Hook Instrumentation方法。根据上面提到的想法，我们需要在先绕过检查，那么，我们如何绕过检查呢？通过分析Activity的启动流程会发现，在Instrumentation#execStartActivity中，会有个checkStartActivityResult的方法去检查错误，因此，我们可以复写这个方法，让启动参数能通过系统的检查。那么，我们如何做呢？首先，我们需要检查要启动的Intent能不能匹配到，匹配不到的话，将ClassName修改为我们预先在AndroidManifest中配置的占坑Activity，并且吧当前的这个ClassName放到当前intent的extra中，以便后续做恢复，看下代码。\n\n```\n    public ActivityResult execStartActivity(\n            Context who, IBinder contextThread, IBinder token, Activity target,\n            Intent intent, int requestCode, Bundle options) {\n        List<ResolveInfo> infos = mPackageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL);\n        if (infos == null || infos.size() == 0) {\n            //没查到，要启动的这个没注册\n            intent.putExtra(TARGET_ACTIVITY, intent.getComponent().getClassName());\n            intent.setClassName(who, \"com.guolei.plugindemo.StubActivity\");\n        }\n\n        Class instrumentationClz = Instrumentation.class;\n        try {\n            Method execMethod = instrumentationClz.getDeclaredMethod(\"execStartActivity\",\n                    Context.class, IBinder.class, IBinder.class, Activity.class, Intent.class, int.class, Bundle.class);\n            return (ActivityResult) execMethod.invoke(mOriginInstrumentation, who, contextThread, token,\n                    target, intent, requestCode, options);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n\n我们绕过检测了，现在需要解决的问题是还原，我们知道，系统启动Activity的最后会调用到ActivityThread里面，在这里，会通过Instrumentation#newActivity方法去反射构造一个Activity的对象，因此，我们只需要在这里还原即可。代码如下：\n\n```\n    @Override\n    public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException,\n            IllegalAccessException, ClassNotFoundException {\n        if (!TextUtils.isEmpty(intent.getStringExtra(TARGET_ACTIVITY))) {\n            return super.newActivity(cl, intent.getStringExtra(TARGET_ACTIVITY), intent);\n        }\n        return super.newActivity(cl, className, intent);\n    }\n```\n\n一切准备就绪，我们最后的问题是，如何替换掉系统的Instrumentation。要替换掉也简单，替换掉ActivityThread中的mInstrumentation字段即可。\n\n```\n    private void hookInstrumentation() {\n        Context context = getBaseContext();\n        try {\n            Class contextImplClz = Class.forName(\"android.app.ContextImpl\");\n            Field mMainThread = contextImplClz.getDeclaredField(\"mMainThread\");\n            mMainThread.setAccessible(true);\n            Object activityThread = mMainThread.get(context);\n            Class activityThreadClz = Class.forName(\"android.app.ActivityThread\");\n            Field mInstrumentationField = activityThreadClz.getDeclaredField(\"mInstrumentation\");\n            mInstrumentationField.setAccessible(true);\n            mInstrumentationField.set(activityThread,\n                    new HookInstrumentation((Instrumentation) mInstrumentationField.get(activityThread),\n                            context.getPackageManager()));\n        } catch (Exception e) {\n            e.printStackTrace();\n            Log.e(\"plugin\", \"hookInstrumentation: error\");\n        }\n    }\n```\n\n这样，我们就能启动一个没有注册在AndroidManifest文件中的Activity了，但是这里要注意一下，由于我们这里使用的ClassLoader是宿主的ClassLoader，这样的话，我们需要将插件的dex文件添加到我们宿主中。这一点很重要。有一些多ClassLoader架构的实现，这里的代码需要变下。\n\n### Service的插件化\n\n启动一个未注册的Service，并不会崩溃退出，只不过有点警告。并且，service启动直接由ContextImpl交给AMS处理了，我们看下代码。\n\n```\n    private ComponentName startServiceCommon(Intent service, UserHandle user) {\n        try {\n            validateServiceIntent(service);\n            service.prepareToLeaveProcess(this);\n            ComponentName cn = ActivityManagerNative.getDefault().startService(\n                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(\n                            getContentResolver()), getOpPackageName(), user.getIdentifier());\n            if (cn != null) {\n                if (cn.getPackageName().equals(\"!\")) {\n                    throw new SecurityException(\n                            \"Not allowed to start service \" + service\n                            + \" without permission \" + cn.getClassName());\n                } else if (cn.getPackageName().equals(\"!!\")) {\n                    throw new SecurityException(\n                            \"Unable to start service \" + service\n                            + \": \" + cn.getClassName());\n                }\n            }\n            return cn;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n```\n\n并且创建对象的过程不由Instrumentation来创建了，而直接在ActivityThread#handleCreateService反射生成。那么，Activity的思路我们就不能用了，怎么办呢？既然我们无法做替换还原，那么，我们可以考虑代理，我们启动一个真实注册了的Service，我们启动这个Service，并让这个Service，就按照系统服务Service的处理，原模原样的处理我们插件的Service。\n\n说做就做，我们以startService为例。我们首先要做的是，hook掉AMS，因为AMS启动service的时候，假如要启动插件的Service，我们需要怎么做呢？把插件service替换成真是的代理Service，这样，代理Service就启动起来了，我们在代理Service中，构建插件的Service，并调用attach、onCreate等方法。\n\nHook AMS代码如下：\n\n```\n    private void hookAMS() {\n        try {\n            Class activityManagerNative = Class.forName(\"android.app.ActivityManagerNative\");\n            Field gDefaultField = activityManagerNative.getDeclaredField(\"gDefault\");\n            gDefaultField.setAccessible(true);\n            Object origin = gDefaultField.get(null);\n            Class singleton = Class.forName(\"android.util.Singleton\");\n            Field mInstanceField = singleton.getDeclaredField(\"mInstance\");\n            mInstanceField.setAccessible(true);\n            Object originAMN = mInstanceField.get(origin);\n            Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                    new Class[]{Class.forName(\"android.app.IActivityManager\")},\n                    new ActivityManagerProxy(getPackageManager(),originAMN));\n            mInstanceField.set(origin, proxy);\n            Log.e(TAG, \"hookAMS: success\" );\n        } catch (Exception e) {\n            Log.e(TAG, \"hookAMS: \" + e.getMessage());\n        }\n    }\n```\n\n我们在看一下ActivityManagerProxy这个代理。\n\n```\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getName().equals(\"startService\")) {\n            Intent intent = (Intent) args[1];\n            List<ResolveInfo> infos = mPackageManager.queryIntentServices(intent, PackageManager.MATCH_ALL);\n            if (infos == null || infos.size() == 0) {\n                intent.putExtra(TARGET_SERVICE, intent.getComponent().getClassName());\n                intent.setClassName(\"com.guolei.plugindemo\", \"com.guolei.plugindemo.StubService\");\n            }\n\n        }\n        return method.invoke(mOrigin, args);\n    }\n```\n\n代码很清晰、也很简单，不需要在做多余的了，那么，我们看下代理Service是如何启动并且调用我们的插件Service的。\n\n\n```\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Log.e(TAG, \"onStartCommand: stub service \");\n        if (intent != null && !TextUtils.isEmpty(intent.getStringExtra(TARGET_SERVICE))) {\n            //启动真正的service\n            String serviceName = intent.getStringExtra(TARGET_SERVICE);\n            try {\n                Class activityThreadClz = Class.forName(\"android.app.ActivityThread\");\n                Method getActivityThreadMethod = activityThreadClz.getDeclaredMethod(\"getApplicationThread\");\n                getActivityThreadMethod.setAccessible(true);\n                //获取ActivityThread\n                Class contextImplClz = Class.forName(\"android.app.ContextImpl\");\n                Field mMainThread = contextImplClz.getDeclaredField(\"mMainThread\");\n                mMainThread.setAccessible(true);\n                Object activityThread = mMainThread.get(getBaseContext());\n                Object applicationThread = getActivityThreadMethod.invoke(activityThread);\n                //获取token值\n                Class iInterfaceClz = Class.forName(\"android.os.IInterface\");\n                Method asBinderMethod = iInterfaceClz.getDeclaredMethod(\"asBinder\");\n                asBinderMethod.setAccessible(true);\n                Object token = asBinderMethod.invoke(applicationThread);\n                //Service的attach方法\n                Class serviceClz = Class.forName(\"android.app.Service\");\n                Method attachMethod = serviceClz.getDeclaredMethod(\"attach\",\n                        Context.class, activityThreadClz, String.class, IBinder.class, Application.class, Object.class);\n                attachMethod.setAccessible(true);\n                Class activityManagerNative = Class.forName(\"android.app.ActivityManagerNative\");\n                Field gDefaultField = activityManagerNative.getDeclaredField(\"gDefault\");\n                gDefaultField.setAccessible(true);\n                Object origin = gDefaultField.get(null);\n                Class singleton = Class.forName(\"android.util.Singleton\");\n                Field mInstanceField = singleton.getDeclaredField(\"mInstance\");\n                mInstanceField.setAccessible(true);\n                Object originAMN = mInstanceField.get(origin);\n                Service targetService = (Service) Class.forName(serviceName).newInstance();\n                attachMethod.invoke(targetService, this, activityThread, intent.getComponent().getClassName(), token,\n                        getApplication(), originAMN);\n                //service的oncreate方法\n                Method onCreateMethod = serviceClz.getDeclaredMethod(\"onCreate\");\n                onCreateMethod.setAccessible(true);\n                onCreateMethod.invoke(targetService);\n                targetService.onStartCommand(intent, flags, startId);\n            } catch (Exception e) {\n                e.printStackTrace();\n                Log.e(TAG, \"onStartCommand: \" + e.getMessage());\n            }\n        }\n        return super.onStartCommand(intent, flags, startId);\n    }\n```\n\n代码较长，逻辑如下：\n\n* 检测到需要启动插件Service\n* 构建插件Service attach方法需要的参数\n* 构造一个插件Service\n* 调用插件Service的attach方法\n* 调用插件Service的onCreate方法\n\n这样，一个插件Service就启动起来了。\n\n### BroadcastReceiver的插件化\n\nBroadcastReceiver分为两种，静态注册，和动态注册。静态注册的是PMS在安装或者系统启动的时候扫描APK，解析配置文件，并存储在PMS端的，这个我们无法干预，并且，我们的插件由于未安装，静态注册的是无法通过系统正常行为装载的。而动态注册的，由于没有检测这一步，因此，也不需要我们干预。我们现在需要解决的问题就是，怎么能装载插件中静态注册的。\n\n我们可以通过解析配置文件，自己调用动态注册的方法去注册这个。\n\n代码这里就不贴了，和下面ContentProvider的一起贴。\n\n\n### ContentProvider的插件化\n\n和其他三个组件不一样的是，ContentProvider是在进程启动入口，也就是ActivityThread中进行安装的。那么我们可以按照这个思路，自己去进行安装的操作。\n\n代码如下。\n\n```\n          Field providersField = packageClz.getDeclaredField(\"providers\");\n            providersField.setAccessible(true);\n            ArrayList providers = (ArrayList) providersField.get(packageObject);\n\n            Class providerClz = Class.forName(\"android.content.pm.PackageParser$Provider\");\n            Field providerInfoField = providerClz.getDeclaredField(\"info\");\n            providersField.setAccessible(true);\n            List<ProviderInfo> providerInfos = new ArrayList<>();\n            for (int i = 0; i < providers.size(); i++) {\n                ProviderInfo providerInfo = (ProviderInfo) providerInfoField.get(providers.get(i));\n                providerInfo.applicationInfo = getApplicationInfo();\n                providerInfos.add(providerInfo);\n            }\n            Class contextImplClz = Class.forName(\"android.app.ContextImpl\");\n            Field mMainThread = contextImplClz.getDeclaredField(\"mMainThread\");\n            mMainThread.setAccessible(true);\n            Object activityThread = mMainThread.get(this.getBaseContext());\n            Class activityThreadClz = Class.forName(\"android.app.ActivityThread\");\n            Method installContentProvidersMethod = activityThreadClz.getDeclaredMethod(\"installContentProviders\", Context.class, List.class);\n            installContentProvidersMethod.setAccessible(true);\n            installContentProvidersMethod.invoke(activityThread, this, providerInfos);\n```\n\n\n贴一下整体的代码,这里的代码，包括Multidex方法加dex，BroadcastReceiver的插件化以及ContentProvider的插件化。\n\n```\n    private void loadClassByHostClassLoader() {\n        File apkFile = new File(\"/sdcard/plugin_1.apk\");\n        ClassLoader baseClassLoader = this.getClassLoader();\n        try {\n            Field pathListField = baseClassLoader.getClass().getSuperclass().getDeclaredField(\"pathList\");\n            pathListField.setAccessible(true);\n            Object pathList = pathListField.get(baseClassLoader);\n\n            Class clz = Class.forName(\"dalvik.system.DexPathList\");\n            Field dexElementsField = clz.getDeclaredField(\"dexElements\");\n            dexElementsField.setAccessible(true);\n            Object[] dexElements = (Object[]) dexElementsField.get(pathList);\n\n            Class elementClz = dexElements.getClass().getComponentType();\n            Object[] newDexElements = (Object[]) Array.newInstance(elementClz, dexElements.length + 1);\n            Constructor<?> constructor = elementClz.getConstructor(File.class, boolean.class, File.class, DexFile.class);\n            File file = new File(getFilesDir(), \"test.dex\");\n            if (file.exists()) {\n                file.delete();\n            }\n            file.createNewFile();\n            Object pluginElement = constructor.newInstance(apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(),\n                    file.getAbsolutePath(), 0));\n            Object[] toAddElementArray = new Object[]{pluginElement};\n            System.arraycopy(dexElements, 0, newDexElements, 0, dexElements.length);\n            // 插件的那个element复制进去\n            System.arraycopy(toAddElementArray, 0, newDexElements, dexElements.length, toAddElementArray.length);\n            dexElementsField.set(pathList, newDexElements);\n\n            AssetManager assetManager = getResources().getAssets();\n            Method method = assetManager.getClass().getDeclaredMethod(\"addAssetPath\", String.class);\n            method.invoke(assetManager, apkFile.getPath());\n\n//            PackageInfo packageInfo = getPackageManager().getPackageArchiveInfo(apkFile.getAbsolutePath(), PackageManager.GET_RECEIVERS);\n//            if (packageInfo != null) {\n//                for (ActivityInfo info : packageInfo.receivers) {\n//                    Log.e(TAG, \"loadClassByHostClassLoader: \" + info.name );\n//\n//                }\n//            }\n            Class packageParseClz = Class.forName(\"android.content.pm.PackageParser\");\n            Object packageParser = packageParseClz.newInstance();\n            Method parseMethod = packageParseClz.getDeclaredMethod(\"parsePackage\", File.class, int.class);\n            parseMethod.setAccessible(true);\n            Object packageObject = parseMethod.invoke(packageParser, apkFile, 1 << 2);\n            Class packageClz = Class.forName(\"android.content.pm.PackageParser$Package\");\n            Field receiversField = packageClz.getDeclaredField(\"receivers\");\n            receiversField.setAccessible(true);\n            ArrayList receives = (ArrayList) receiversField.get(packageObject);\n\n            Class componentClz = Class.forName(\"android.content.pm.PackageParser$Component\");\n            Field intents = componentClz.getDeclaredField(\"intents\");\n            intents.setAccessible(true);\n            Field classNameField = componentClz.getDeclaredField(\"className\");\n            classNameField.setAccessible(true);\n            for (int i = 0; i < receives.size(); i++) {\n                ArrayList<IntentFilter> intentFilters = (ArrayList<IntentFilter>) intents.get(receives.get(i));\n                String className = (String) classNameField.get(receives.get(i));\n                registerReceiver((BroadcastReceiver) getClassLoader().loadClass(className).newInstance(), intentFilters.get(0));\n            }\n\n            // 安装ContentProvider\n            Field providersField = packageClz.getDeclaredField(\"providers\");\n            providersField.setAccessible(true);\n            ArrayList providers = (ArrayList) providersField.get(packageObject);\n\n            Class providerClz = Class.forName(\"android.content.pm.PackageParser$Provider\");\n            Field providerInfoField = providerClz.getDeclaredField(\"info\");\n            providersField.setAccessible(true);\n            List<ProviderInfo> providerInfos = new ArrayList<>();\n            for (int i = 0; i < providers.size(); i++) {\n                ProviderInfo providerInfo = (ProviderInfo) providerInfoField.get(providers.get(i));\n                providerInfo.applicationInfo = getApplicationInfo();\n                providerInfos.add(providerInfo);\n            }\n            Class contextImplClz = Class.forName(\"android.app.ContextImpl\");\n            Field mMainThread = contextImplClz.getDeclaredField(\"mMainThread\");\n            mMainThread.setAccessible(true);\n            Object activityThread = mMainThread.get(this.getBaseContext());\n            Class activityThreadClz = Class.forName(\"android.app.ActivityThread\");\n            Method installContentProvidersMethod = activityThreadClz.getDeclaredMethod(\"installContentProviders\", Context.class, List.class);\n            installContentProvidersMethod.setAccessible(true);\n            installContentProvidersMethod.invoke(activityThread, this, providerInfos);\n        } catch (Exception e) {\n            e.printStackTrace();\n            Log.e(TAG, \"loadClassByHostClassLoader: \" + e.getMessage());\n        }\n    }\n```\n\n\n\n>到这里，四大组件的插件化方案介绍了一点点，虽然每种组件只介绍了一种方法。上面的内容忽略了大部分源码细节。这部分内容需要大家自己去补。\n\n\n### 资源的插件化方案\n\n资源的插件化方案，目前有两种\n\n* 合并资源方案\n* 各个插件构造自己的资源方案\n\n今天，我们介绍第一种方案，合并资源方案，合并资源方案，我们只需要往现有的AssetManager中调用addAsset添加一个资源即可，当然，存在比较多适配问题，我们暂时忽略。合并资源方案最大的问题就是资源冲突。要解决资源冲突，有两种办法。\n\n* 修改AAPT，能自由修改PP段\n* 干预编译过程，修改ASRC和R文件\n\n\n为了简单演示，我直接只用VirtualApk的编译插件去做。实际上VirtualApk的编译插件来自以Small的编译插件。只要对文件格式熟悉，这个还是很好写的。\n\n\n```\n            AssetManager assetManager = getResources().getAssets();\n            Method method = assetManager.getClass().getDeclaredMethod(\"addAssetPath\", String.class);\n            method.invoke(assetManager, apkFile.getPath());\n```\n\n我们只需要上面简单的代码，就能完成资源的插件化。当然，这里忽略了版本差异。\n\n\n### SO的插件化方案\n\nso的插件化方案，我这里介绍修改dexpathlist的方案。我们要做的是什么呢？只需要往nativeLibraryPathElements中添加SO的Element，并且往nativeLibraryDirectories添加so路径就可以了。\n代码如下。\n\n\n```\n            Method findLibMethod = elementClz.getDeclaredMethod(\"findNativeLibrary\",String.class);\n            findLibMethod.setAccessible(true);\n//            Object soElement = constructor.newInstance(new File(\"/sdcard/\"), true, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(),\n//                    file.getAbsolutePath(), 0));\n//            findLibMethod.invoke(pluginElement,System.mapLibraryName(\"native-lib\"));\n            ZipFile zipFile = new ZipFile(apkFile);\n            ZipEntry zipEntry = zipFile.getEntry(\"lib/armeabi/libnative-lib.so\");\n            InputStream inputStream = zipFile.getInputStream(zipEntry);\n            File outSoFile = new File(getFilesDir(), \"libnative-lib.so\");\n            if (outSoFile.exists()) {\n                outSoFile.delete();\n            }\n            FileOutputStream outputStream = new FileOutputStream(outSoFile);\n            byte[] cache = new byte[2048];\n            int count = 0;\n            while ((count = inputStream.read(cache)) != -1) {\n                outputStream.write(cache, 0, count);\n            }\n            outputStream.flush();\n            outputStream.close();\n            inputStream.close();\n            // 构造Element\n            Object soElement = constructor.newInstance(getFilesDir(), true, null, null);\n//            findLibMethod.invoke(soElement,System.mapLibraryName(\"native-lib\"));\n\n            // 将soElement填充到nativeLibraryPathElements中,\n            Field soElementField = clz.getDeclaredField(\"nativeLibraryPathElements\");\n            soElementField.setAccessible(true);\n            Object[] soElements = (Object[]) soElementField.get(pathList);\n            Object[] newSoElements = (Object[]) Array.newInstance(elementClz, soElements.length + 1);\n            Object[] toAddSoElementArray = new Object[]{soElement};\n            System.arraycopy(soElements, 0, newSoElements, 0, soElements.length);\n            // 插件的那个element复制进去\n            System.arraycopy(toAddSoElementArray, 0, newSoElements, soElements.length, toAddSoElementArray.length);\n            soElementField.set(pathList, newSoElements);\n\n            //将so的文件夹填充到nativeLibraryDirectories中\n            Field libDir = clz.getDeclaredField(\"nativeLibraryDirectories\");\n            libDir.setAccessible(true);\n            List libDirs = (List) libDir.get(pathList);\n            libDirs.add(getFilesDir());\n            libDir.set(pathList,libDirs);\n```\n\n\n### 总结\n\n在前人的精心研究下，插件化方案已经很成熟了。插件化方案的难点主要在适配方面。其他倒还好。\n\nPS:热修复的相关知识，PPT已经写好了，下篇应该会浅析一下热修复。\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/浅谈Android插件化.md","raw":"---\ntitle: 浅谈Android插件化\ndate: 2018-04-03 20:30:04\ntags: 插件化\ncategories: Android\n\n---\n<Excerpt in index | 首页摘要>\n\n### 前言\n\nAndroid P preview版本中，已限制对@hide api的反射调用，具体的原理可以阅读[Android P调用隐藏API限制原理](https://mp.weixin.qq.com/s/sktB0x5yBexkn4ORQ1YofA)这篇文章。由于最近团队分享也在分享插件化、热修复相关的东西。因此，写一篇文章，好好记录一下。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 准备知识\n\n* 反射、动态代理\n* Android中的几个相关的ClassLoader,注意PathClassLoader在ART虚拟机上是可以加载未安装的APK的，Dalvik虚拟机则不可以。\n* Android中四大组件的相关原理\n* PackageManagerServer\n* 资源加载、资源打包\n* 其他\n\n**文章中所涉及到的代码均通过Nexus 5(dalvik虚拟机) Android 6.0版本的测试**\n\n文章中所涉及到的一切资源都在[这个仓库下](https://github.com/Guolei1130/blog_resource/tree/master/source_code/plugin_about)\n\n\n特别说明，本博客不会特别解释过多原理性的东西。如果读者不具备相关的知识储备，建议先阅读weishu和gityuan两位大神的博客,资源打包的知识可以阅读 老罗的博客。\n\n* [Weishu's Notes](http://weishu.me/)\n* [gityuan](http://gityuan.com/)\n\n### Activity的插件化\n\n首先需要说明一点的是，启动一个完全没有在AndroidManifest注册的Activity是不可能的。因为在启动的过程中，存在一个校验的过程，而这个校验则是由PMS来完成的，这个我们无法干预。因此，Activity的插件化方案大多使用占坑的思想。不同的是如何在检验之前替换，在生成对象的时候还原。就目前来看，有三种方案：\n\n* Hook Instrumentation方案\n* Hook CallBack方案\n* 干预startActivity等方法，干预ClassLoader findClass的方案\n\n\n这里说一下Hook Instrumentation方法。根据上面提到的想法，我们需要在先绕过检查，那么，我们如何绕过检查呢？通过分析Activity的启动流程会发现，在Instrumentation#execStartActivity中，会有个checkStartActivityResult的方法去检查错误，因此，我们可以复写这个方法，让启动参数能通过系统的检查。那么，我们如何做呢？首先，我们需要检查要启动的Intent能不能匹配到，匹配不到的话，将ClassName修改为我们预先在AndroidManifest中配置的占坑Activity，并且吧当前的这个ClassName放到当前intent的extra中，以便后续做恢复，看下代码。\n\n```\n    public ActivityResult execStartActivity(\n            Context who, IBinder contextThread, IBinder token, Activity target,\n            Intent intent, int requestCode, Bundle options) {\n        List<ResolveInfo> infos = mPackageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL);\n        if (infos == null || infos.size() == 0) {\n            //没查到，要启动的这个没注册\n            intent.putExtra(TARGET_ACTIVITY, intent.getComponent().getClassName());\n            intent.setClassName(who, \"com.guolei.plugindemo.StubActivity\");\n        }\n\n        Class instrumentationClz = Instrumentation.class;\n        try {\n            Method execMethod = instrumentationClz.getDeclaredMethod(\"execStartActivity\",\n                    Context.class, IBinder.class, IBinder.class, Activity.class, Intent.class, int.class, Bundle.class);\n            return (ActivityResult) execMethod.invoke(mOriginInstrumentation, who, contextThread, token,\n                    target, intent, requestCode, options);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n\n我们绕过检测了，现在需要解决的问题是还原，我们知道，系统启动Activity的最后会调用到ActivityThread里面，在这里，会通过Instrumentation#newActivity方法去反射构造一个Activity的对象，因此，我们只需要在这里还原即可。代码如下：\n\n```\n    @Override\n    public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException,\n            IllegalAccessException, ClassNotFoundException {\n        if (!TextUtils.isEmpty(intent.getStringExtra(TARGET_ACTIVITY))) {\n            return super.newActivity(cl, intent.getStringExtra(TARGET_ACTIVITY), intent);\n        }\n        return super.newActivity(cl, className, intent);\n    }\n```\n\n一切准备就绪，我们最后的问题是，如何替换掉系统的Instrumentation。要替换掉也简单，替换掉ActivityThread中的mInstrumentation字段即可。\n\n```\n    private void hookInstrumentation() {\n        Context context = getBaseContext();\n        try {\n            Class contextImplClz = Class.forName(\"android.app.ContextImpl\");\n            Field mMainThread = contextImplClz.getDeclaredField(\"mMainThread\");\n            mMainThread.setAccessible(true);\n            Object activityThread = mMainThread.get(context);\n            Class activityThreadClz = Class.forName(\"android.app.ActivityThread\");\n            Field mInstrumentationField = activityThreadClz.getDeclaredField(\"mInstrumentation\");\n            mInstrumentationField.setAccessible(true);\n            mInstrumentationField.set(activityThread,\n                    new HookInstrumentation((Instrumentation) mInstrumentationField.get(activityThread),\n                            context.getPackageManager()));\n        } catch (Exception e) {\n            e.printStackTrace();\n            Log.e(\"plugin\", \"hookInstrumentation: error\");\n        }\n    }\n```\n\n这样，我们就能启动一个没有注册在AndroidManifest文件中的Activity了，但是这里要注意一下，由于我们这里使用的ClassLoader是宿主的ClassLoader，这样的话，我们需要将插件的dex文件添加到我们宿主中。这一点很重要。有一些多ClassLoader架构的实现，这里的代码需要变下。\n\n### Service的插件化\n\n启动一个未注册的Service，并不会崩溃退出，只不过有点警告。并且，service启动直接由ContextImpl交给AMS处理了，我们看下代码。\n\n```\n    private ComponentName startServiceCommon(Intent service, UserHandle user) {\n        try {\n            validateServiceIntent(service);\n            service.prepareToLeaveProcess(this);\n            ComponentName cn = ActivityManagerNative.getDefault().startService(\n                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(\n                            getContentResolver()), getOpPackageName(), user.getIdentifier());\n            if (cn != null) {\n                if (cn.getPackageName().equals(\"!\")) {\n                    throw new SecurityException(\n                            \"Not allowed to start service \" + service\n                            + \" without permission \" + cn.getClassName());\n                } else if (cn.getPackageName().equals(\"!!\")) {\n                    throw new SecurityException(\n                            \"Unable to start service \" + service\n                            + \": \" + cn.getClassName());\n                }\n            }\n            return cn;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n```\n\n并且创建对象的过程不由Instrumentation来创建了，而直接在ActivityThread#handleCreateService反射生成。那么，Activity的思路我们就不能用了，怎么办呢？既然我们无法做替换还原，那么，我们可以考虑代理，我们启动一个真实注册了的Service，我们启动这个Service，并让这个Service，就按照系统服务Service的处理，原模原样的处理我们插件的Service。\n\n说做就做，我们以startService为例。我们首先要做的是，hook掉AMS，因为AMS启动service的时候，假如要启动插件的Service，我们需要怎么做呢？把插件service替换成真是的代理Service，这样，代理Service就启动起来了，我们在代理Service中，构建插件的Service，并调用attach、onCreate等方法。\n\nHook AMS代码如下：\n\n```\n    private void hookAMS() {\n        try {\n            Class activityManagerNative = Class.forName(\"android.app.ActivityManagerNative\");\n            Field gDefaultField = activityManagerNative.getDeclaredField(\"gDefault\");\n            gDefaultField.setAccessible(true);\n            Object origin = gDefaultField.get(null);\n            Class singleton = Class.forName(\"android.util.Singleton\");\n            Field mInstanceField = singleton.getDeclaredField(\"mInstance\");\n            mInstanceField.setAccessible(true);\n            Object originAMN = mInstanceField.get(origin);\n            Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                    new Class[]{Class.forName(\"android.app.IActivityManager\")},\n                    new ActivityManagerProxy(getPackageManager(),originAMN));\n            mInstanceField.set(origin, proxy);\n            Log.e(TAG, \"hookAMS: success\" );\n        } catch (Exception e) {\n            Log.e(TAG, \"hookAMS: \" + e.getMessage());\n        }\n    }\n```\n\n我们在看一下ActivityManagerProxy这个代理。\n\n```\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getName().equals(\"startService\")) {\n            Intent intent = (Intent) args[1];\n            List<ResolveInfo> infos = mPackageManager.queryIntentServices(intent, PackageManager.MATCH_ALL);\n            if (infos == null || infos.size() == 0) {\n                intent.putExtra(TARGET_SERVICE, intent.getComponent().getClassName());\n                intent.setClassName(\"com.guolei.plugindemo\", \"com.guolei.plugindemo.StubService\");\n            }\n\n        }\n        return method.invoke(mOrigin, args);\n    }\n```\n\n代码很清晰、也很简单，不需要在做多余的了，那么，我们看下代理Service是如何启动并且调用我们的插件Service的。\n\n\n```\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Log.e(TAG, \"onStartCommand: stub service \");\n        if (intent != null && !TextUtils.isEmpty(intent.getStringExtra(TARGET_SERVICE))) {\n            //启动真正的service\n            String serviceName = intent.getStringExtra(TARGET_SERVICE);\n            try {\n                Class activityThreadClz = Class.forName(\"android.app.ActivityThread\");\n                Method getActivityThreadMethod = activityThreadClz.getDeclaredMethod(\"getApplicationThread\");\n                getActivityThreadMethod.setAccessible(true);\n                //获取ActivityThread\n                Class contextImplClz = Class.forName(\"android.app.ContextImpl\");\n                Field mMainThread = contextImplClz.getDeclaredField(\"mMainThread\");\n                mMainThread.setAccessible(true);\n                Object activityThread = mMainThread.get(getBaseContext());\n                Object applicationThread = getActivityThreadMethod.invoke(activityThread);\n                //获取token值\n                Class iInterfaceClz = Class.forName(\"android.os.IInterface\");\n                Method asBinderMethod = iInterfaceClz.getDeclaredMethod(\"asBinder\");\n                asBinderMethod.setAccessible(true);\n                Object token = asBinderMethod.invoke(applicationThread);\n                //Service的attach方法\n                Class serviceClz = Class.forName(\"android.app.Service\");\n                Method attachMethod = serviceClz.getDeclaredMethod(\"attach\",\n                        Context.class, activityThreadClz, String.class, IBinder.class, Application.class, Object.class);\n                attachMethod.setAccessible(true);\n                Class activityManagerNative = Class.forName(\"android.app.ActivityManagerNative\");\n                Field gDefaultField = activityManagerNative.getDeclaredField(\"gDefault\");\n                gDefaultField.setAccessible(true);\n                Object origin = gDefaultField.get(null);\n                Class singleton = Class.forName(\"android.util.Singleton\");\n                Field mInstanceField = singleton.getDeclaredField(\"mInstance\");\n                mInstanceField.setAccessible(true);\n                Object originAMN = mInstanceField.get(origin);\n                Service targetService = (Service) Class.forName(serviceName).newInstance();\n                attachMethod.invoke(targetService, this, activityThread, intent.getComponent().getClassName(), token,\n                        getApplication(), originAMN);\n                //service的oncreate方法\n                Method onCreateMethod = serviceClz.getDeclaredMethod(\"onCreate\");\n                onCreateMethod.setAccessible(true);\n                onCreateMethod.invoke(targetService);\n                targetService.onStartCommand(intent, flags, startId);\n            } catch (Exception e) {\n                e.printStackTrace();\n                Log.e(TAG, \"onStartCommand: \" + e.getMessage());\n            }\n        }\n        return super.onStartCommand(intent, flags, startId);\n    }\n```\n\n代码较长，逻辑如下：\n\n* 检测到需要启动插件Service\n* 构建插件Service attach方法需要的参数\n* 构造一个插件Service\n* 调用插件Service的attach方法\n* 调用插件Service的onCreate方法\n\n这样，一个插件Service就启动起来了。\n\n### BroadcastReceiver的插件化\n\nBroadcastReceiver分为两种，静态注册，和动态注册。静态注册的是PMS在安装或者系统启动的时候扫描APK，解析配置文件，并存储在PMS端的，这个我们无法干预，并且，我们的插件由于未安装，静态注册的是无法通过系统正常行为装载的。而动态注册的，由于没有检测这一步，因此，也不需要我们干预。我们现在需要解决的问题就是，怎么能装载插件中静态注册的。\n\n我们可以通过解析配置文件，自己调用动态注册的方法去注册这个。\n\n代码这里就不贴了，和下面ContentProvider的一起贴。\n\n\n### ContentProvider的插件化\n\n和其他三个组件不一样的是，ContentProvider是在进程启动入口，也就是ActivityThread中进行安装的。那么我们可以按照这个思路，自己去进行安装的操作。\n\n代码如下。\n\n```\n          Field providersField = packageClz.getDeclaredField(\"providers\");\n            providersField.setAccessible(true);\n            ArrayList providers = (ArrayList) providersField.get(packageObject);\n\n            Class providerClz = Class.forName(\"android.content.pm.PackageParser$Provider\");\n            Field providerInfoField = providerClz.getDeclaredField(\"info\");\n            providersField.setAccessible(true);\n            List<ProviderInfo> providerInfos = new ArrayList<>();\n            for (int i = 0; i < providers.size(); i++) {\n                ProviderInfo providerInfo = (ProviderInfo) providerInfoField.get(providers.get(i));\n                providerInfo.applicationInfo = getApplicationInfo();\n                providerInfos.add(providerInfo);\n            }\n            Class contextImplClz = Class.forName(\"android.app.ContextImpl\");\n            Field mMainThread = contextImplClz.getDeclaredField(\"mMainThread\");\n            mMainThread.setAccessible(true);\n            Object activityThread = mMainThread.get(this.getBaseContext());\n            Class activityThreadClz = Class.forName(\"android.app.ActivityThread\");\n            Method installContentProvidersMethod = activityThreadClz.getDeclaredMethod(\"installContentProviders\", Context.class, List.class);\n            installContentProvidersMethod.setAccessible(true);\n            installContentProvidersMethod.invoke(activityThread, this, providerInfos);\n```\n\n\n贴一下整体的代码,这里的代码，包括Multidex方法加dex，BroadcastReceiver的插件化以及ContentProvider的插件化。\n\n```\n    private void loadClassByHostClassLoader() {\n        File apkFile = new File(\"/sdcard/plugin_1.apk\");\n        ClassLoader baseClassLoader = this.getClassLoader();\n        try {\n            Field pathListField = baseClassLoader.getClass().getSuperclass().getDeclaredField(\"pathList\");\n            pathListField.setAccessible(true);\n            Object pathList = pathListField.get(baseClassLoader);\n\n            Class clz = Class.forName(\"dalvik.system.DexPathList\");\n            Field dexElementsField = clz.getDeclaredField(\"dexElements\");\n            dexElementsField.setAccessible(true);\n            Object[] dexElements = (Object[]) dexElementsField.get(pathList);\n\n            Class elementClz = dexElements.getClass().getComponentType();\n            Object[] newDexElements = (Object[]) Array.newInstance(elementClz, dexElements.length + 1);\n            Constructor<?> constructor = elementClz.getConstructor(File.class, boolean.class, File.class, DexFile.class);\n            File file = new File(getFilesDir(), \"test.dex\");\n            if (file.exists()) {\n                file.delete();\n            }\n            file.createNewFile();\n            Object pluginElement = constructor.newInstance(apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(),\n                    file.getAbsolutePath(), 0));\n            Object[] toAddElementArray = new Object[]{pluginElement};\n            System.arraycopy(dexElements, 0, newDexElements, 0, dexElements.length);\n            // 插件的那个element复制进去\n            System.arraycopy(toAddElementArray, 0, newDexElements, dexElements.length, toAddElementArray.length);\n            dexElementsField.set(pathList, newDexElements);\n\n            AssetManager assetManager = getResources().getAssets();\n            Method method = assetManager.getClass().getDeclaredMethod(\"addAssetPath\", String.class);\n            method.invoke(assetManager, apkFile.getPath());\n\n//            PackageInfo packageInfo = getPackageManager().getPackageArchiveInfo(apkFile.getAbsolutePath(), PackageManager.GET_RECEIVERS);\n//            if (packageInfo != null) {\n//                for (ActivityInfo info : packageInfo.receivers) {\n//                    Log.e(TAG, \"loadClassByHostClassLoader: \" + info.name );\n//\n//                }\n//            }\n            Class packageParseClz = Class.forName(\"android.content.pm.PackageParser\");\n            Object packageParser = packageParseClz.newInstance();\n            Method parseMethod = packageParseClz.getDeclaredMethod(\"parsePackage\", File.class, int.class);\n            parseMethod.setAccessible(true);\n            Object packageObject = parseMethod.invoke(packageParser, apkFile, 1 << 2);\n            Class packageClz = Class.forName(\"android.content.pm.PackageParser$Package\");\n            Field receiversField = packageClz.getDeclaredField(\"receivers\");\n            receiversField.setAccessible(true);\n            ArrayList receives = (ArrayList) receiversField.get(packageObject);\n\n            Class componentClz = Class.forName(\"android.content.pm.PackageParser$Component\");\n            Field intents = componentClz.getDeclaredField(\"intents\");\n            intents.setAccessible(true);\n            Field classNameField = componentClz.getDeclaredField(\"className\");\n            classNameField.setAccessible(true);\n            for (int i = 0; i < receives.size(); i++) {\n                ArrayList<IntentFilter> intentFilters = (ArrayList<IntentFilter>) intents.get(receives.get(i));\n                String className = (String) classNameField.get(receives.get(i));\n                registerReceiver((BroadcastReceiver) getClassLoader().loadClass(className).newInstance(), intentFilters.get(0));\n            }\n\n            // 安装ContentProvider\n            Field providersField = packageClz.getDeclaredField(\"providers\");\n            providersField.setAccessible(true);\n            ArrayList providers = (ArrayList) providersField.get(packageObject);\n\n            Class providerClz = Class.forName(\"android.content.pm.PackageParser$Provider\");\n            Field providerInfoField = providerClz.getDeclaredField(\"info\");\n            providersField.setAccessible(true);\n            List<ProviderInfo> providerInfos = new ArrayList<>();\n            for (int i = 0; i < providers.size(); i++) {\n                ProviderInfo providerInfo = (ProviderInfo) providerInfoField.get(providers.get(i));\n                providerInfo.applicationInfo = getApplicationInfo();\n                providerInfos.add(providerInfo);\n            }\n            Class contextImplClz = Class.forName(\"android.app.ContextImpl\");\n            Field mMainThread = contextImplClz.getDeclaredField(\"mMainThread\");\n            mMainThread.setAccessible(true);\n            Object activityThread = mMainThread.get(this.getBaseContext());\n            Class activityThreadClz = Class.forName(\"android.app.ActivityThread\");\n            Method installContentProvidersMethod = activityThreadClz.getDeclaredMethod(\"installContentProviders\", Context.class, List.class);\n            installContentProvidersMethod.setAccessible(true);\n            installContentProvidersMethod.invoke(activityThread, this, providerInfos);\n        } catch (Exception e) {\n            e.printStackTrace();\n            Log.e(TAG, \"loadClassByHostClassLoader: \" + e.getMessage());\n        }\n    }\n```\n\n\n\n>到这里，四大组件的插件化方案介绍了一点点，虽然每种组件只介绍了一种方法。上面的内容忽略了大部分源码细节。这部分内容需要大家自己去补。\n\n\n### 资源的插件化方案\n\n资源的插件化方案，目前有两种\n\n* 合并资源方案\n* 各个插件构造自己的资源方案\n\n今天，我们介绍第一种方案，合并资源方案，合并资源方案，我们只需要往现有的AssetManager中调用addAsset添加一个资源即可，当然，存在比较多适配问题，我们暂时忽略。合并资源方案最大的问题就是资源冲突。要解决资源冲突，有两种办法。\n\n* 修改AAPT，能自由修改PP段\n* 干预编译过程，修改ASRC和R文件\n\n\n为了简单演示，我直接只用VirtualApk的编译插件去做。实际上VirtualApk的编译插件来自以Small的编译插件。只要对文件格式熟悉，这个还是很好写的。\n\n\n```\n            AssetManager assetManager = getResources().getAssets();\n            Method method = assetManager.getClass().getDeclaredMethod(\"addAssetPath\", String.class);\n            method.invoke(assetManager, apkFile.getPath());\n```\n\n我们只需要上面简单的代码，就能完成资源的插件化。当然，这里忽略了版本差异。\n\n\n### SO的插件化方案\n\nso的插件化方案，我这里介绍修改dexpathlist的方案。我们要做的是什么呢？只需要往nativeLibraryPathElements中添加SO的Element，并且往nativeLibraryDirectories添加so路径就可以了。\n代码如下。\n\n\n```\n            Method findLibMethod = elementClz.getDeclaredMethod(\"findNativeLibrary\",String.class);\n            findLibMethod.setAccessible(true);\n//            Object soElement = constructor.newInstance(new File(\"/sdcard/\"), true, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(),\n//                    file.getAbsolutePath(), 0));\n//            findLibMethod.invoke(pluginElement,System.mapLibraryName(\"native-lib\"));\n            ZipFile zipFile = new ZipFile(apkFile);\n            ZipEntry zipEntry = zipFile.getEntry(\"lib/armeabi/libnative-lib.so\");\n            InputStream inputStream = zipFile.getInputStream(zipEntry);\n            File outSoFile = new File(getFilesDir(), \"libnative-lib.so\");\n            if (outSoFile.exists()) {\n                outSoFile.delete();\n            }\n            FileOutputStream outputStream = new FileOutputStream(outSoFile);\n            byte[] cache = new byte[2048];\n            int count = 0;\n            while ((count = inputStream.read(cache)) != -1) {\n                outputStream.write(cache, 0, count);\n            }\n            outputStream.flush();\n            outputStream.close();\n            inputStream.close();\n            // 构造Element\n            Object soElement = constructor.newInstance(getFilesDir(), true, null, null);\n//            findLibMethod.invoke(soElement,System.mapLibraryName(\"native-lib\"));\n\n            // 将soElement填充到nativeLibraryPathElements中,\n            Field soElementField = clz.getDeclaredField(\"nativeLibraryPathElements\");\n            soElementField.setAccessible(true);\n            Object[] soElements = (Object[]) soElementField.get(pathList);\n            Object[] newSoElements = (Object[]) Array.newInstance(elementClz, soElements.length + 1);\n            Object[] toAddSoElementArray = new Object[]{soElement};\n            System.arraycopy(soElements, 0, newSoElements, 0, soElements.length);\n            // 插件的那个element复制进去\n            System.arraycopy(toAddSoElementArray, 0, newSoElements, soElements.length, toAddSoElementArray.length);\n            soElementField.set(pathList, newSoElements);\n\n            //将so的文件夹填充到nativeLibraryDirectories中\n            Field libDir = clz.getDeclaredField(\"nativeLibraryDirectories\");\n            libDir.setAccessible(true);\n            List libDirs = (List) libDir.get(pathList);\n            libDirs.add(getFilesDir());\n            libDir.set(pathList,libDirs);\n```\n\n\n### 总结\n\n在前人的精心研究下，插件化方案已经很成熟了。插件化方案的难点主要在适配方面。其他倒还好。\n\nPS:热修复的相关知识，PPT已经写好了，下篇应该会浅析一下热修复。\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"浅谈Android插件化","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm0c005z19fyhr0qlven","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Android P preview版本中，已限制对@hide api的反射调用，具体的原理可以阅读<a href=\"https://mp.weixin.qq.com/s/sktB0x5yBexkn4ORQ1YofA\" target=\"_blank\" rel=\"external\">Android P调用隐藏API限制原理</a>这篇文章。由于最近团队分享也在分享插件化、热修复相关的东西。因此，写一篇文章，好好记录一下。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"准备知识\"><a href=\"#准备知识\" class=\"headerlink\" title=\"准备知识\"></a>准备知识</h3><ul>\n<li>反射、动态代理</li>\n<li>Android中的几个相关的ClassLoader,注意PathClassLoader在ART虚拟机上是可以加载未安装的APK的，Dalvik虚拟机则不可以。</li>\n<li>Android中四大组件的相关原理</li>\n<li>PackageManagerServer</li>\n<li>资源加载、资源打包</li>\n<li>其他</li>\n</ul>\n<p><strong>文章中所涉及到的代码均通过Nexus 5(dalvik虚拟机) Android 6.0版本的测试</strong></p>\n<p>文章中所涉及到的一切资源都在<a href=\"https://github.com/Guolei1130/blog_resource/tree/master/source_code/plugin_about\" target=\"_blank\" rel=\"external\">这个仓库下</a></p>\n<p>特别说明，本博客不会特别解释过多原理性的东西。如果读者不具备相关的知识储备，建议先阅读weishu和gityuan两位大神的博客,资源打包的知识可以阅读 老罗的博客。</p>\n<ul>\n<li><a href=\"http://weishu.me/\" target=\"_blank\" rel=\"external\">Weishu’s Notes</a></li>\n<li><a href=\"http://gityuan.com/\" target=\"_blank\" rel=\"external\">gityuan</a></li>\n</ul>\n<h3 id=\"Activity的插件化\"><a href=\"#Activity的插件化\" class=\"headerlink\" title=\"Activity的插件化\"></a>Activity的插件化</h3><p>首先需要说明一点的是，启动一个完全没有在AndroidManifest注册的Activity是不可能的。因为在启动的过程中，存在一个校验的过程，而这个校验则是由PMS来完成的，这个我们无法干预。因此，Activity的插件化方案大多使用占坑的思想。不同的是如何在检验之前替换，在生成对象的时候还原。就目前来看，有三种方案：</p>\n<ul>\n<li>Hook Instrumentation方案</li>\n<li>Hook CallBack方案</li>\n<li>干预startActivity等方法，干预ClassLoader findClass的方案</li>\n</ul>\n<p>这里说一下Hook Instrumentation方法。根据上面提到的想法，我们需要在先绕过检查，那么，我们如何绕过检查呢？通过分析Activity的启动流程会发现，在Instrumentation#execStartActivity中，会有个checkStartActivityResult的方法去检查错误，因此，我们可以复写这个方法，让启动参数能通过系统的检查。那么，我们如何做呢？首先，我们需要检查要启动的Intent能不能匹配到，匹配不到的话，将ClassName修改为我们预先在AndroidManifest中配置的占坑Activity，并且吧当前的这个ClassName放到当前intent的extra中，以便后续做恢复，看下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ActivityResult execStartActivity(</div><div class=\"line\">        Context who, IBinder contextThread, IBinder token, Activity target,</div><div class=\"line\">        Intent intent, int requestCode, Bundle options) &#123;</div><div class=\"line\">    List&lt;ResolveInfo&gt; infos = mPackageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL);</div><div class=\"line\">    if (infos == null || infos.size() == 0) &#123;</div><div class=\"line\">        //没查到，要启动的这个没注册</div><div class=\"line\">        intent.putExtra(TARGET_ACTIVITY, intent.getComponent().getClassName());</div><div class=\"line\">        intent.setClassName(who, &quot;com.guolei.plugindemo.StubActivity&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Class instrumentationClz = Instrumentation.class;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Method execMethod = instrumentationClz.getDeclaredMethod(&quot;execStartActivity&quot;,</div><div class=\"line\">                Context.class, IBinder.class, IBinder.class, Activity.class, Intent.class, int.class, Bundle.class);</div><div class=\"line\">        return (ActivityResult) execMethod.invoke(mOriginInstrumentation, who, contextThread, token,</div><div class=\"line\">                target, intent, requestCode, options);</div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们绕过检测了，现在需要解决的问题是还原，我们知道，系统启动Activity的最后会调用到ActivityThread里面，在这里，会通过Instrumentation#newActivity方法去反射构造一个Activity的对象，因此，我们只需要在这里还原即可。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException,</div><div class=\"line\">        IllegalAccessException, ClassNotFoundException &#123;</div><div class=\"line\">    if (!TextUtils.isEmpty(intent.getStringExtra(TARGET_ACTIVITY))) &#123;</div><div class=\"line\">        return super.newActivity(cl, intent.getStringExtra(TARGET_ACTIVITY), intent);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return super.newActivity(cl, className, intent);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一切准备就绪，我们最后的问题是，如何替换掉系统的Instrumentation。要替换掉也简单，替换掉ActivityThread中的mInstrumentation字段即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void hookInstrumentation() &#123;</div><div class=\"line\">    Context context = getBaseContext();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Class contextImplClz = Class.forName(&quot;android.app.ContextImpl&quot;);</div><div class=\"line\">        Field mMainThread = contextImplClz.getDeclaredField(&quot;mMainThread&quot;);</div><div class=\"line\">        mMainThread.setAccessible(true);</div><div class=\"line\">        Object activityThread = mMainThread.get(context);</div><div class=\"line\">        Class activityThreadClz = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class=\"line\">        Field mInstrumentationField = activityThreadClz.getDeclaredField(&quot;mInstrumentation&quot;);</div><div class=\"line\">        mInstrumentationField.setAccessible(true);</div><div class=\"line\">        mInstrumentationField.set(activityThread,</div><div class=\"line\">                new HookInstrumentation((Instrumentation) mInstrumentationField.get(activityThread),</div><div class=\"line\">                        context.getPackageManager()));</div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">        Log.e(&quot;plugin&quot;, &quot;hookInstrumentation: error&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，我们就能启动一个没有注册在AndroidManifest文件中的Activity了，但是这里要注意一下，由于我们这里使用的ClassLoader是宿主的ClassLoader，这样的话，我们需要将插件的dex文件添加到我们宿主中。这一点很重要。有一些多ClassLoader架构的实现，这里的代码需要变下。</p>\n<h3 id=\"Service的插件化\"><a href=\"#Service的插件化\" class=\"headerlink\" title=\"Service的插件化\"></a>Service的插件化</h3><p>启动一个未注册的Service，并不会崩溃退出，只不过有点警告。并且，service启动直接由ContextImpl交给AMS处理了，我们看下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">private ComponentName startServiceCommon(Intent service, UserHandle user) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        validateServiceIntent(service);</div><div class=\"line\">        service.prepareToLeaveProcess(this);</div><div class=\"line\">        ComponentName cn = ActivityManagerNative.getDefault().startService(</div><div class=\"line\">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</div><div class=\"line\">                        getContentResolver()), getOpPackageName(), user.getIdentifier());</div><div class=\"line\">        if (cn != null) &#123;</div><div class=\"line\">            if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</div><div class=\"line\">                throw new SecurityException(</div><div class=\"line\">                        &quot;Not allowed to start service &quot; + service</div><div class=\"line\">                        + &quot; without permission &quot; + cn.getClassName());</div><div class=\"line\">            &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</div><div class=\"line\">                throw new SecurityException(</div><div class=\"line\">                        &quot;Unable to start service &quot; + service</div><div class=\"line\">                        + &quot;: &quot; + cn.getClassName());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cn;</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        throw e.rethrowFromSystemServer();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并且创建对象的过程不由Instrumentation来创建了，而直接在ActivityThread#handleCreateService反射生成。那么，Activity的思路我们就不能用了，怎么办呢？既然我们无法做替换还原，那么，我们可以考虑代理，我们启动一个真实注册了的Service，我们启动这个Service，并让这个Service，就按照系统服务Service的处理，原模原样的处理我们插件的Service。</p>\n<p>说做就做，我们以startService为例。我们首先要做的是，hook掉AMS，因为AMS启动service的时候，假如要启动插件的Service，我们需要怎么做呢？把插件service替换成真是的代理Service，这样，代理Service就启动起来了，我们在代理Service中，构建插件的Service，并调用attach、onCreate等方法。</p>\n<p>Hook AMS代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void hookAMS() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Class activityManagerNative = Class.forName(&quot;android.app.ActivityManagerNative&quot;);</div><div class=\"line\">        Field gDefaultField = activityManagerNative.getDeclaredField(&quot;gDefault&quot;);</div><div class=\"line\">        gDefaultField.setAccessible(true);</div><div class=\"line\">        Object origin = gDefaultField.get(null);</div><div class=\"line\">        Class singleton = Class.forName(&quot;android.util.Singleton&quot;);</div><div class=\"line\">        Field mInstanceField = singleton.getDeclaredField(&quot;mInstance&quot;);</div><div class=\"line\">        mInstanceField.setAccessible(true);</div><div class=\"line\">        Object originAMN = mInstanceField.get(origin);</div><div class=\"line\">        Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</div><div class=\"line\">                new Class[]&#123;Class.forName(&quot;android.app.IActivityManager&quot;)&#125;,</div><div class=\"line\">                new ActivityManagerProxy(getPackageManager(),originAMN));</div><div class=\"line\">        mInstanceField.set(origin, proxy);</div><div class=\"line\">        Log.e(TAG, &quot;hookAMS: success&quot; );</div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;hookAMS: &quot; + e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在看一下ActivityManagerProxy这个代理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class=\"line\">    if (method.getName().equals(&quot;startService&quot;)) &#123;</div><div class=\"line\">        Intent intent = (Intent) args[1];</div><div class=\"line\">        List&lt;ResolveInfo&gt; infos = mPackageManager.queryIntentServices(intent, PackageManager.MATCH_ALL);</div><div class=\"line\">        if (infos == null || infos.size() == 0) &#123;</div><div class=\"line\">            intent.putExtra(TARGET_SERVICE, intent.getComponent().getClassName());</div><div class=\"line\">            intent.setClassName(&quot;com.guolei.plugindemo&quot;, &quot;com.guolei.plugindemo.StubService&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    return method.invoke(mOrigin, args);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码很清晰、也很简单，不需要在做多余的了，那么，我们看下代理Service是如何启动并且调用我们的插件Service的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public int onStartCommand(Intent intent, int flags, int startId) &#123;</div><div class=\"line\">    Log.e(TAG, &quot;onStartCommand: stub service &quot;);</div><div class=\"line\">    if (intent != null &amp;&amp; !TextUtils.isEmpty(intent.getStringExtra(TARGET_SERVICE))) &#123;</div><div class=\"line\">        //启动真正的service</div><div class=\"line\">        String serviceName = intent.getStringExtra(TARGET_SERVICE);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Class activityThreadClz = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class=\"line\">            Method getActivityThreadMethod = activityThreadClz.getDeclaredMethod(&quot;getApplicationThread&quot;);</div><div class=\"line\">            getActivityThreadMethod.setAccessible(true);</div><div class=\"line\">            //获取ActivityThread</div><div class=\"line\">            Class contextImplClz = Class.forName(&quot;android.app.ContextImpl&quot;);</div><div class=\"line\">            Field mMainThread = contextImplClz.getDeclaredField(&quot;mMainThread&quot;);</div><div class=\"line\">            mMainThread.setAccessible(true);</div><div class=\"line\">            Object activityThread = mMainThread.get(getBaseContext());</div><div class=\"line\">            Object applicationThread = getActivityThreadMethod.invoke(activityThread);</div><div class=\"line\">            //获取token值</div><div class=\"line\">            Class iInterfaceClz = Class.forName(&quot;android.os.IInterface&quot;);</div><div class=\"line\">            Method asBinderMethod = iInterfaceClz.getDeclaredMethod(&quot;asBinder&quot;);</div><div class=\"line\">            asBinderMethod.setAccessible(true);</div><div class=\"line\">            Object token = asBinderMethod.invoke(applicationThread);</div><div class=\"line\">            //Service的attach方法</div><div class=\"line\">            Class serviceClz = Class.forName(&quot;android.app.Service&quot;);</div><div class=\"line\">            Method attachMethod = serviceClz.getDeclaredMethod(&quot;attach&quot;,</div><div class=\"line\">                    Context.class, activityThreadClz, String.class, IBinder.class, Application.class, Object.class);</div><div class=\"line\">            attachMethod.setAccessible(true);</div><div class=\"line\">            Class activityManagerNative = Class.forName(&quot;android.app.ActivityManagerNative&quot;);</div><div class=\"line\">            Field gDefaultField = activityManagerNative.getDeclaredField(&quot;gDefault&quot;);</div><div class=\"line\">            gDefaultField.setAccessible(true);</div><div class=\"line\">            Object origin = gDefaultField.get(null);</div><div class=\"line\">            Class singleton = Class.forName(&quot;android.util.Singleton&quot;);</div><div class=\"line\">            Field mInstanceField = singleton.getDeclaredField(&quot;mInstance&quot;);</div><div class=\"line\">            mInstanceField.setAccessible(true);</div><div class=\"line\">            Object originAMN = mInstanceField.get(origin);</div><div class=\"line\">            Service targetService = (Service) Class.forName(serviceName).newInstance();</div><div class=\"line\">            attachMethod.invoke(targetService, this, activityThread, intent.getComponent().getClassName(), token,</div><div class=\"line\">                    getApplication(), originAMN);</div><div class=\"line\">            //service的oncreate方法</div><div class=\"line\">            Method onCreateMethod = serviceClz.getDeclaredMethod(&quot;onCreate&quot;);</div><div class=\"line\">            onCreateMethod.setAccessible(true);</div><div class=\"line\">            onCreateMethod.invoke(targetService);</div><div class=\"line\">            targetService.onStartCommand(intent, flags, startId);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">            Log.e(TAG, &quot;onStartCommand: &quot; + e.getMessage());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return super.onStartCommand(intent, flags, startId);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码较长，逻辑如下：</p>\n<ul>\n<li>检测到需要启动插件Service</li>\n<li>构建插件Service attach方法需要的参数</li>\n<li>构造一个插件Service</li>\n<li>调用插件Service的attach方法</li>\n<li>调用插件Service的onCreate方法</li>\n</ul>\n<p>这样，一个插件Service就启动起来了。</p>\n<h3 id=\"BroadcastReceiver的插件化\"><a href=\"#BroadcastReceiver的插件化\" class=\"headerlink\" title=\"BroadcastReceiver的插件化\"></a>BroadcastReceiver的插件化</h3><p>BroadcastReceiver分为两种，静态注册，和动态注册。静态注册的是PMS在安装或者系统启动的时候扫描APK，解析配置文件，并存储在PMS端的，这个我们无法干预，并且，我们的插件由于未安装，静态注册的是无法通过系统正常行为装载的。而动态注册的，由于没有检测这一步，因此，也不需要我们干预。我们现在需要解决的问题就是，怎么能装载插件中静态注册的。</p>\n<p>我们可以通过解析配置文件，自己调用动态注册的方法去注册这个。</p>\n<p>代码这里就不贴了，和下面ContentProvider的一起贴。</p>\n<h3 id=\"ContentProvider的插件化\"><a href=\"#ContentProvider的插件化\" class=\"headerlink\" title=\"ContentProvider的插件化\"></a>ContentProvider的插件化</h3><p>和其他三个组件不一样的是，ContentProvider是在进程启动入口，也就是ActivityThread中进行安装的。那么我们可以按照这个思路，自己去进行安装的操作。</p>\n<p>代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">Field providersField = packageClz.getDeclaredField(&quot;providers&quot;);</div><div class=\"line\">  providersField.setAccessible(true);</div><div class=\"line\">  ArrayList providers = (ArrayList) providersField.get(packageObject);</div><div class=\"line\"></div><div class=\"line\">  Class providerClz = Class.forName(&quot;android.content.pm.PackageParser$Provider&quot;);</div><div class=\"line\">  Field providerInfoField = providerClz.getDeclaredField(&quot;info&quot;);</div><div class=\"line\">  providersField.setAccessible(true);</div><div class=\"line\">  List&lt;ProviderInfo&gt; providerInfos = new ArrayList&lt;&gt;();</div><div class=\"line\">  for (int i = 0; i &lt; providers.size(); i++) &#123;</div><div class=\"line\">      ProviderInfo providerInfo = (ProviderInfo) providerInfoField.get(providers.get(i));</div><div class=\"line\">      providerInfo.applicationInfo = getApplicationInfo();</div><div class=\"line\">      providerInfos.add(providerInfo);</div><div class=\"line\">  &#125;</div><div class=\"line\">  Class contextImplClz = Class.forName(&quot;android.app.ContextImpl&quot;);</div><div class=\"line\">  Field mMainThread = contextImplClz.getDeclaredField(&quot;mMainThread&quot;);</div><div class=\"line\">  mMainThread.setAccessible(true);</div><div class=\"line\">  Object activityThread = mMainThread.get(this.getBaseContext());</div><div class=\"line\">  Class activityThreadClz = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class=\"line\">  Method installContentProvidersMethod = activityThreadClz.getDeclaredMethod(&quot;installContentProviders&quot;, Context.class, List.class);</div><div class=\"line\">  installContentProvidersMethod.setAccessible(true);</div><div class=\"line\">  installContentProvidersMethod.invoke(activityThread, this, providerInfos);</div></pre></td></tr></table></figure>\n<p>贴一下整体的代码,这里的代码，包括Multidex方法加dex，BroadcastReceiver的插件化以及ContentProvider的插件化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div></pre></td><td class=\"code\"><pre><div class=\"line\">    private void loadClassByHostClassLoader() &#123;</div><div class=\"line\">        File apkFile = new File(&quot;/sdcard/plugin_1.apk&quot;);</div><div class=\"line\">        ClassLoader baseClassLoader = this.getClassLoader();</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Field pathListField = baseClassLoader.getClass().getSuperclass().getDeclaredField(&quot;pathList&quot;);</div><div class=\"line\">            pathListField.setAccessible(true);</div><div class=\"line\">            Object pathList = pathListField.get(baseClassLoader);</div><div class=\"line\"></div><div class=\"line\">            Class clz = Class.forName(&quot;dalvik.system.DexPathList&quot;);</div><div class=\"line\">            Field dexElementsField = clz.getDeclaredField(&quot;dexElements&quot;);</div><div class=\"line\">            dexElementsField.setAccessible(true);</div><div class=\"line\">            Object[] dexElements = (Object[]) dexElementsField.get(pathList);</div><div class=\"line\"></div><div class=\"line\">            Class elementClz = dexElements.getClass().getComponentType();</div><div class=\"line\">            Object[] newDexElements = (Object[]) Array.newInstance(elementClz, dexElements.length + 1);</div><div class=\"line\">            Constructor&lt;?&gt; constructor = elementClz.getConstructor(File.class, boolean.class, File.class, DexFile.class);</div><div class=\"line\">            File file = new File(getFilesDir(), &quot;test.dex&quot;);</div><div class=\"line\">            if (file.exists()) &#123;</div><div class=\"line\">                file.delete();</div><div class=\"line\">            &#125;</div><div class=\"line\">            file.createNewFile();</div><div class=\"line\">            Object pluginElement = constructor.newInstance(apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(),</div><div class=\"line\">                    file.getAbsolutePath(), 0));</div><div class=\"line\">            Object[] toAddElementArray = new Object[]&#123;pluginElement&#125;;</div><div class=\"line\">            System.arraycopy(dexElements, 0, newDexElements, 0, dexElements.length);</div><div class=\"line\">            // 插件的那个element复制进去</div><div class=\"line\">            System.arraycopy(toAddElementArray, 0, newDexElements, dexElements.length, toAddElementArray.length);</div><div class=\"line\">            dexElementsField.set(pathList, newDexElements);</div><div class=\"line\"></div><div class=\"line\">            AssetManager assetManager = getResources().getAssets();</div><div class=\"line\">            Method method = assetManager.getClass().getDeclaredMethod(&quot;addAssetPath&quot;, String.class);</div><div class=\"line\">            method.invoke(assetManager, apkFile.getPath());</div><div class=\"line\"></div><div class=\"line\">//            PackageInfo packageInfo = getPackageManager().getPackageArchiveInfo(apkFile.getAbsolutePath(), PackageManager.GET_RECEIVERS);</div><div class=\"line\">//            if (packageInfo != null) &#123;</div><div class=\"line\">//                for (ActivityInfo info : packageInfo.receivers) &#123;</div><div class=\"line\">//                    Log.e(TAG, &quot;loadClassByHostClassLoader: &quot; + info.name );</div><div class=\"line\">//</div><div class=\"line\">//                &#125;</div><div class=\"line\">//            &#125;</div><div class=\"line\">            Class packageParseClz = Class.forName(&quot;android.content.pm.PackageParser&quot;);</div><div class=\"line\">            Object packageParser = packageParseClz.newInstance();</div><div class=\"line\">            Method parseMethod = packageParseClz.getDeclaredMethod(&quot;parsePackage&quot;, File.class, int.class);</div><div class=\"line\">            parseMethod.setAccessible(true);</div><div class=\"line\">            Object packageObject = parseMethod.invoke(packageParser, apkFile, 1 &lt;&lt; 2);</div><div class=\"line\">            Class packageClz = Class.forName(&quot;android.content.pm.PackageParser$Package&quot;);</div><div class=\"line\">            Field receiversField = packageClz.getDeclaredField(&quot;receivers&quot;);</div><div class=\"line\">            receiversField.setAccessible(true);</div><div class=\"line\">            ArrayList receives = (ArrayList) receiversField.get(packageObject);</div><div class=\"line\"></div><div class=\"line\">            Class componentClz = Class.forName(&quot;android.content.pm.PackageParser$Component&quot;);</div><div class=\"line\">            Field intents = componentClz.getDeclaredField(&quot;intents&quot;);</div><div class=\"line\">            intents.setAccessible(true);</div><div class=\"line\">            Field classNameField = componentClz.getDeclaredField(&quot;className&quot;);</div><div class=\"line\">            classNameField.setAccessible(true);</div><div class=\"line\">            for (int i = 0; i &lt; receives.size(); i++) &#123;</div><div class=\"line\">                ArrayList&lt;IntentFilter&gt; intentFilters = (ArrayList&lt;IntentFilter&gt;) intents.get(receives.get(i));</div><div class=\"line\">                String className = (String) classNameField.get(receives.get(i));</div><div class=\"line\">                registerReceiver((BroadcastReceiver) getClassLoader().loadClass(className).newInstance(), intentFilters.get(0));</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // 安装ContentProvider</div><div class=\"line\">            Field providersField = packageClz.getDeclaredField(&quot;providers&quot;);</div><div class=\"line\">            providersField.setAccessible(true);</div><div class=\"line\">            ArrayList providers = (ArrayList) providersField.get(packageObject);</div><div class=\"line\"></div><div class=\"line\">            Class providerClz = Class.forName(&quot;android.content.pm.PackageParser$Provider&quot;);</div><div class=\"line\">            Field providerInfoField = providerClz.getDeclaredField(&quot;info&quot;);</div><div class=\"line\">            providersField.setAccessible(true);</div><div class=\"line\">            List&lt;ProviderInfo&gt; providerInfos = new ArrayList&lt;&gt;();</div><div class=\"line\">            for (int i = 0; i &lt; providers.size(); i++) &#123;</div><div class=\"line\">                ProviderInfo providerInfo = (ProviderInfo) providerInfoField.get(providers.get(i));</div><div class=\"line\">                providerInfo.applicationInfo = getApplicationInfo();</div><div class=\"line\">                providerInfos.add(providerInfo);</div><div class=\"line\">            &#125;</div><div class=\"line\">            Class contextImplClz = Class.forName(&quot;android.app.ContextImpl&quot;);</div><div class=\"line\">            Field mMainThread = contextImplClz.getDeclaredField(&quot;mMainThread&quot;);</div><div class=\"line\">            mMainThread.setAccessible(true);</div><div class=\"line\">            Object activityThread = mMainThread.get(this.getBaseContext());</div><div class=\"line\">            Class activityThreadClz = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class=\"line\">            Method installContentProvidersMethod = activityThreadClz.getDeclaredMethod(&quot;installContentProviders&quot;, Context.class, List.class);</div><div class=\"line\">            installContentProvidersMethod.setAccessible(true);</div><div class=\"line\">            installContentProvidersMethod.invoke(activityThread, this, providerInfos);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">            Log.e(TAG, &quot;loadClassByHostClassLoader: &quot; + e.getMessage());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>到这里，四大组件的插件化方案介绍了一点点，虽然每种组件只介绍了一种方法。上面的内容忽略了大部分源码细节。这部分内容需要大家自己去补。</p>\n</blockquote>\n<h3 id=\"资源的插件化方案\"><a href=\"#资源的插件化方案\" class=\"headerlink\" title=\"资源的插件化方案\"></a>资源的插件化方案</h3><p>资源的插件化方案，目前有两种</p>\n<ul>\n<li>合并资源方案</li>\n<li>各个插件构造自己的资源方案</li>\n</ul>\n<p>今天，我们介绍第一种方案，合并资源方案，合并资源方案，我们只需要往现有的AssetManager中调用addAsset添加一个资源即可，当然，存在比较多适配问题，我们暂时忽略。合并资源方案最大的问题就是资源冲突。要解决资源冲突，有两种办法。</p>\n<ul>\n<li>修改AAPT，能自由修改PP段</li>\n<li>干预编译过程，修改ASRC和R文件</li>\n</ul>\n<p>为了简单演示，我直接只用VirtualApk的编译插件去做。实际上VirtualApk的编译插件来自以Small的编译插件。只要对文件格式熟悉，这个还是很好写的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">AssetManager assetManager = getResources().getAssets();</div><div class=\"line\">Method method = assetManager.getClass().getDeclaredMethod(&quot;addAssetPath&quot;, String.class);</div><div class=\"line\">method.invoke(assetManager, apkFile.getPath());</div></pre></td></tr></table></figure>\n<p>我们只需要上面简单的代码，就能完成资源的插件化。当然，这里忽略了版本差异。</p>\n<h3 id=\"SO的插件化方案\"><a href=\"#SO的插件化方案\" class=\"headerlink\" title=\"SO的插件化方案\"></a>SO的插件化方案</h3><p>so的插件化方案，我这里介绍修改dexpathlist的方案。我们要做的是什么呢？只需要往nativeLibraryPathElements中添加SO的Element，并且往nativeLibraryDirectories添加so路径就可以了。<br>代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">            Method findLibMethod = elementClz.getDeclaredMethod(&quot;findNativeLibrary&quot;,String.class);</div><div class=\"line\">            findLibMethod.setAccessible(true);</div><div class=\"line\">//            Object soElement = constructor.newInstance(new File(&quot;/sdcard/&quot;), true, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(),</div><div class=\"line\">//                    file.getAbsolutePath(), 0));</div><div class=\"line\">//            findLibMethod.invoke(pluginElement,System.mapLibraryName(&quot;native-lib&quot;));</div><div class=\"line\">            ZipFile zipFile = new ZipFile(apkFile);</div><div class=\"line\">            ZipEntry zipEntry = zipFile.getEntry(&quot;lib/armeabi/libnative-lib.so&quot;);</div><div class=\"line\">            InputStream inputStream = zipFile.getInputStream(zipEntry);</div><div class=\"line\">            File outSoFile = new File(getFilesDir(), &quot;libnative-lib.so&quot;);</div><div class=\"line\">            if (outSoFile.exists()) &#123;</div><div class=\"line\">                outSoFile.delete();</div><div class=\"line\">            &#125;</div><div class=\"line\">            FileOutputStream outputStream = new FileOutputStream(outSoFile);</div><div class=\"line\">            byte[] cache = new byte[2048];</div><div class=\"line\">            int count = 0;</div><div class=\"line\">            while ((count = inputStream.read(cache)) != -1) &#123;</div><div class=\"line\">                outputStream.write(cache, 0, count);</div><div class=\"line\">            &#125;</div><div class=\"line\">            outputStream.flush();</div><div class=\"line\">            outputStream.close();</div><div class=\"line\">            inputStream.close();</div><div class=\"line\">            // 构造Element</div><div class=\"line\">            Object soElement = constructor.newInstance(getFilesDir(), true, null, null);</div><div class=\"line\">//            findLibMethod.invoke(soElement,System.mapLibraryName(&quot;native-lib&quot;));</div><div class=\"line\"></div><div class=\"line\">            // 将soElement填充到nativeLibraryPathElements中,</div><div class=\"line\">            Field soElementField = clz.getDeclaredField(&quot;nativeLibraryPathElements&quot;);</div><div class=\"line\">            soElementField.setAccessible(true);</div><div class=\"line\">            Object[] soElements = (Object[]) soElementField.get(pathList);</div><div class=\"line\">            Object[] newSoElements = (Object[]) Array.newInstance(elementClz, soElements.length + 1);</div><div class=\"line\">            Object[] toAddSoElementArray = new Object[]&#123;soElement&#125;;</div><div class=\"line\">            System.arraycopy(soElements, 0, newSoElements, 0, soElements.length);</div><div class=\"line\">            // 插件的那个element复制进去</div><div class=\"line\">            System.arraycopy(toAddSoElementArray, 0, newSoElements, soElements.length, toAddSoElementArray.length);</div><div class=\"line\">            soElementField.set(pathList, newSoElements);</div><div class=\"line\"></div><div class=\"line\">            //将so的文件夹填充到nativeLibraryDirectories中</div><div class=\"line\">            Field libDir = clz.getDeclaredField(&quot;nativeLibraryDirectories&quot;);</div><div class=\"line\">            libDir.setAccessible(true);</div><div class=\"line\">            List libDirs = (List) libDir.get(pathList);</div><div class=\"line\">            libDirs.add(getFilesDir());</div><div class=\"line\">            libDir.set(pathList,libDirs);</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在前人的精心研究下，插件化方案已经很成熟了。插件化方案的难点主要在适配方面。其他倒还好。</p>\n<p>PS:热修复的相关知识，PPT已经写好了，下篇应该会浅析一下热修复。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Android P preview版本中，已限制对@hide api的反射调用，具体的原理可以阅读<a href=\"https://mp.weixin.qq.com/s/sktB0x5yBexkn4ORQ1YofA\">Android P调用隐藏API限制原理</a>这篇文章。由于最近团队分享也在分享插件化、热修复相关的东西。因此，写一篇文章，好好记录一下。</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"准备知识\"><a href=\"#准备知识\" class=\"headerlink\" title=\"准备知识\"></a>准备知识</h3><ul>\n<li>反射、动态代理</li>\n<li>Android中的几个相关的ClassLoader,注意PathClassLoader在ART虚拟机上是可以加载未安装的APK的，Dalvik虚拟机则不可以。</li>\n<li>Android中四大组件的相关原理</li>\n<li>PackageManagerServer</li>\n<li>资源加载、资源打包</li>\n<li>其他</li>\n</ul>\n<p><strong>文章中所涉及到的代码均通过Nexus 5(dalvik虚拟机) Android 6.0版本的测试</strong></p>\n<p>文章中所涉及到的一切资源都在<a href=\"https://github.com/Guolei1130/blog_resource/tree/master/source_code/plugin_about\">这个仓库下</a></p>\n<p>特别说明，本博客不会特别解释过多原理性的东西。如果读者不具备相关的知识储备，建议先阅读weishu和gityuan两位大神的博客,资源打包的知识可以阅读 老罗的博客。</p>\n<ul>\n<li><a href=\"http://weishu.me/\">Weishu’s Notes</a></li>\n<li><a href=\"http://gityuan.com/\">gityuan</a></li>\n</ul>\n<h3 id=\"Activity的插件化\"><a href=\"#Activity的插件化\" class=\"headerlink\" title=\"Activity的插件化\"></a>Activity的插件化</h3><p>首先需要说明一点的是，启动一个完全没有在AndroidManifest注册的Activity是不可能的。因为在启动的过程中，存在一个校验的过程，而这个校验则是由PMS来完成的，这个我们无法干预。因此，Activity的插件化方案大多使用占坑的思想。不同的是如何在检验之前替换，在生成对象的时候还原。就目前来看，有三种方案：</p>\n<ul>\n<li>Hook Instrumentation方案</li>\n<li>Hook CallBack方案</li>\n<li>干预startActivity等方法，干预ClassLoader findClass的方案</li>\n</ul>\n<p>这里说一下Hook Instrumentation方法。根据上面提到的想法，我们需要在先绕过检查，那么，我们如何绕过检查呢？通过分析Activity的启动流程会发现，在Instrumentation#execStartActivity中，会有个checkStartActivityResult的方法去检查错误，因此，我们可以复写这个方法，让启动参数能通过系统的检查。那么，我们如何做呢？首先，我们需要检查要启动的Intent能不能匹配到，匹配不到的话，将ClassName修改为我们预先在AndroidManifest中配置的占坑Activity，并且吧当前的这个ClassName放到当前intent的extra中，以便后续做恢复，看下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ActivityResult execStartActivity(</div><div class=\"line\">        Context who, IBinder contextThread, IBinder token, Activity target,</div><div class=\"line\">        Intent intent, int requestCode, Bundle options) &#123;</div><div class=\"line\">    List&lt;ResolveInfo&gt; infos = mPackageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL);</div><div class=\"line\">    if (infos == null || infos.size() == 0) &#123;</div><div class=\"line\">        //没查到，要启动的这个没注册</div><div class=\"line\">        intent.putExtra(TARGET_ACTIVITY, intent.getComponent().getClassName());</div><div class=\"line\">        intent.setClassName(who, &quot;com.guolei.plugindemo.StubActivity&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Class instrumentationClz = Instrumentation.class;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Method execMethod = instrumentationClz.getDeclaredMethod(&quot;execStartActivity&quot;,</div><div class=\"line\">                Context.class, IBinder.class, IBinder.class, Activity.class, Intent.class, int.class, Bundle.class);</div><div class=\"line\">        return (ActivityResult) execMethod.invoke(mOriginInstrumentation, who, contextThread, token,</div><div class=\"line\">                target, intent, requestCode, options);</div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们绕过检测了，现在需要解决的问题是还原，我们知道，系统启动Activity的最后会调用到ActivityThread里面，在这里，会通过Instrumentation#newActivity方法去反射构造一个Activity的对象，因此，我们只需要在这里还原即可。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException,</div><div class=\"line\">        IllegalAccessException, ClassNotFoundException &#123;</div><div class=\"line\">    if (!TextUtils.isEmpty(intent.getStringExtra(TARGET_ACTIVITY))) &#123;</div><div class=\"line\">        return super.newActivity(cl, intent.getStringExtra(TARGET_ACTIVITY), intent);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return super.newActivity(cl, className, intent);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一切准备就绪，我们最后的问题是，如何替换掉系统的Instrumentation。要替换掉也简单，替换掉ActivityThread中的mInstrumentation字段即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void hookInstrumentation() &#123;</div><div class=\"line\">    Context context = getBaseContext();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Class contextImplClz = Class.forName(&quot;android.app.ContextImpl&quot;);</div><div class=\"line\">        Field mMainThread = contextImplClz.getDeclaredField(&quot;mMainThread&quot;);</div><div class=\"line\">        mMainThread.setAccessible(true);</div><div class=\"line\">        Object activityThread = mMainThread.get(context);</div><div class=\"line\">        Class activityThreadClz = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class=\"line\">        Field mInstrumentationField = activityThreadClz.getDeclaredField(&quot;mInstrumentation&quot;);</div><div class=\"line\">        mInstrumentationField.setAccessible(true);</div><div class=\"line\">        mInstrumentationField.set(activityThread,</div><div class=\"line\">                new HookInstrumentation((Instrumentation) mInstrumentationField.get(activityThread),</div><div class=\"line\">                        context.getPackageManager()));</div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">        Log.e(&quot;plugin&quot;, &quot;hookInstrumentation: error&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，我们就能启动一个没有注册在AndroidManifest文件中的Activity了，但是这里要注意一下，由于我们这里使用的ClassLoader是宿主的ClassLoader，这样的话，我们需要将插件的dex文件添加到我们宿主中。这一点很重要。有一些多ClassLoader架构的实现，这里的代码需要变下。</p>\n<h3 id=\"Service的插件化\"><a href=\"#Service的插件化\" class=\"headerlink\" title=\"Service的插件化\"></a>Service的插件化</h3><p>启动一个未注册的Service，并不会崩溃退出，只不过有点警告。并且，service启动直接由ContextImpl交给AMS处理了，我们看下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">private ComponentName startServiceCommon(Intent service, UserHandle user) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        validateServiceIntent(service);</div><div class=\"line\">        service.prepareToLeaveProcess(this);</div><div class=\"line\">        ComponentName cn = ActivityManagerNative.getDefault().startService(</div><div class=\"line\">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</div><div class=\"line\">                        getContentResolver()), getOpPackageName(), user.getIdentifier());</div><div class=\"line\">        if (cn != null) &#123;</div><div class=\"line\">            if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</div><div class=\"line\">                throw new SecurityException(</div><div class=\"line\">                        &quot;Not allowed to start service &quot; + service</div><div class=\"line\">                        + &quot; without permission &quot; + cn.getClassName());</div><div class=\"line\">            &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</div><div class=\"line\">                throw new SecurityException(</div><div class=\"line\">                        &quot;Unable to start service &quot; + service</div><div class=\"line\">                        + &quot;: &quot; + cn.getClassName());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cn;</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        throw e.rethrowFromSystemServer();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并且创建对象的过程不由Instrumentation来创建了，而直接在ActivityThread#handleCreateService反射生成。那么，Activity的思路我们就不能用了，怎么办呢？既然我们无法做替换还原，那么，我们可以考虑代理，我们启动一个真实注册了的Service，我们启动这个Service，并让这个Service，就按照系统服务Service的处理，原模原样的处理我们插件的Service。</p>\n<p>说做就做，我们以startService为例。我们首先要做的是，hook掉AMS，因为AMS启动service的时候，假如要启动插件的Service，我们需要怎么做呢？把插件service替换成真是的代理Service，这样，代理Service就启动起来了，我们在代理Service中，构建插件的Service，并调用attach、onCreate等方法。</p>\n<p>Hook AMS代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void hookAMS() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Class activityManagerNative = Class.forName(&quot;android.app.ActivityManagerNative&quot;);</div><div class=\"line\">        Field gDefaultField = activityManagerNative.getDeclaredField(&quot;gDefault&quot;);</div><div class=\"line\">        gDefaultField.setAccessible(true);</div><div class=\"line\">        Object origin = gDefaultField.get(null);</div><div class=\"line\">        Class singleton = Class.forName(&quot;android.util.Singleton&quot;);</div><div class=\"line\">        Field mInstanceField = singleton.getDeclaredField(&quot;mInstance&quot;);</div><div class=\"line\">        mInstanceField.setAccessible(true);</div><div class=\"line\">        Object originAMN = mInstanceField.get(origin);</div><div class=\"line\">        Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</div><div class=\"line\">                new Class[]&#123;Class.forName(&quot;android.app.IActivityManager&quot;)&#125;,</div><div class=\"line\">                new ActivityManagerProxy(getPackageManager(),originAMN));</div><div class=\"line\">        mInstanceField.set(origin, proxy);</div><div class=\"line\">        Log.e(TAG, &quot;hookAMS: success&quot; );</div><div class=\"line\">    &#125; catch (Exception e) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;hookAMS: &quot; + e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在看一下ActivityManagerProxy这个代理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class=\"line\">    if (method.getName().equals(&quot;startService&quot;)) &#123;</div><div class=\"line\">        Intent intent = (Intent) args[1];</div><div class=\"line\">        List&lt;ResolveInfo&gt; infos = mPackageManager.queryIntentServices(intent, PackageManager.MATCH_ALL);</div><div class=\"line\">        if (infos == null || infos.size() == 0) &#123;</div><div class=\"line\">            intent.putExtra(TARGET_SERVICE, intent.getComponent().getClassName());</div><div class=\"line\">            intent.setClassName(&quot;com.guolei.plugindemo&quot;, &quot;com.guolei.plugindemo.StubService&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    return method.invoke(mOrigin, args);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码很清晰、也很简单，不需要在做多余的了，那么，我们看下代理Service是如何启动并且调用我们的插件Service的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public int onStartCommand(Intent intent, int flags, int startId) &#123;</div><div class=\"line\">    Log.e(TAG, &quot;onStartCommand: stub service &quot;);</div><div class=\"line\">    if (intent != null &amp;&amp; !TextUtils.isEmpty(intent.getStringExtra(TARGET_SERVICE))) &#123;</div><div class=\"line\">        //启动真正的service</div><div class=\"line\">        String serviceName = intent.getStringExtra(TARGET_SERVICE);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Class activityThreadClz = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class=\"line\">            Method getActivityThreadMethod = activityThreadClz.getDeclaredMethod(&quot;getApplicationThread&quot;);</div><div class=\"line\">            getActivityThreadMethod.setAccessible(true);</div><div class=\"line\">            //获取ActivityThread</div><div class=\"line\">            Class contextImplClz = Class.forName(&quot;android.app.ContextImpl&quot;);</div><div class=\"line\">            Field mMainThread = contextImplClz.getDeclaredField(&quot;mMainThread&quot;);</div><div class=\"line\">            mMainThread.setAccessible(true);</div><div class=\"line\">            Object activityThread = mMainThread.get(getBaseContext());</div><div class=\"line\">            Object applicationThread = getActivityThreadMethod.invoke(activityThread);</div><div class=\"line\">            //获取token值</div><div class=\"line\">            Class iInterfaceClz = Class.forName(&quot;android.os.IInterface&quot;);</div><div class=\"line\">            Method asBinderMethod = iInterfaceClz.getDeclaredMethod(&quot;asBinder&quot;);</div><div class=\"line\">            asBinderMethod.setAccessible(true);</div><div class=\"line\">            Object token = asBinderMethod.invoke(applicationThread);</div><div class=\"line\">            //Service的attach方法</div><div class=\"line\">            Class serviceClz = Class.forName(&quot;android.app.Service&quot;);</div><div class=\"line\">            Method attachMethod = serviceClz.getDeclaredMethod(&quot;attach&quot;,</div><div class=\"line\">                    Context.class, activityThreadClz, String.class, IBinder.class, Application.class, Object.class);</div><div class=\"line\">            attachMethod.setAccessible(true);</div><div class=\"line\">            Class activityManagerNative = Class.forName(&quot;android.app.ActivityManagerNative&quot;);</div><div class=\"line\">            Field gDefaultField = activityManagerNative.getDeclaredField(&quot;gDefault&quot;);</div><div class=\"line\">            gDefaultField.setAccessible(true);</div><div class=\"line\">            Object origin = gDefaultField.get(null);</div><div class=\"line\">            Class singleton = Class.forName(&quot;android.util.Singleton&quot;);</div><div class=\"line\">            Field mInstanceField = singleton.getDeclaredField(&quot;mInstance&quot;);</div><div class=\"line\">            mInstanceField.setAccessible(true);</div><div class=\"line\">            Object originAMN = mInstanceField.get(origin);</div><div class=\"line\">            Service targetService = (Service) Class.forName(serviceName).newInstance();</div><div class=\"line\">            attachMethod.invoke(targetService, this, activityThread, intent.getComponent().getClassName(), token,</div><div class=\"line\">                    getApplication(), originAMN);</div><div class=\"line\">            //service的oncreate方法</div><div class=\"line\">            Method onCreateMethod = serviceClz.getDeclaredMethod(&quot;onCreate&quot;);</div><div class=\"line\">            onCreateMethod.setAccessible(true);</div><div class=\"line\">            onCreateMethod.invoke(targetService);</div><div class=\"line\">            targetService.onStartCommand(intent, flags, startId);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">            Log.e(TAG, &quot;onStartCommand: &quot; + e.getMessage());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return super.onStartCommand(intent, flags, startId);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码较长，逻辑如下：</p>\n<ul>\n<li>检测到需要启动插件Service</li>\n<li>构建插件Service attach方法需要的参数</li>\n<li>构造一个插件Service</li>\n<li>调用插件Service的attach方法</li>\n<li>调用插件Service的onCreate方法</li>\n</ul>\n<p>这样，一个插件Service就启动起来了。</p>\n<h3 id=\"BroadcastReceiver的插件化\"><a href=\"#BroadcastReceiver的插件化\" class=\"headerlink\" title=\"BroadcastReceiver的插件化\"></a>BroadcastReceiver的插件化</h3><p>BroadcastReceiver分为两种，静态注册，和动态注册。静态注册的是PMS在安装或者系统启动的时候扫描APK，解析配置文件，并存储在PMS端的，这个我们无法干预，并且，我们的插件由于未安装，静态注册的是无法通过系统正常行为装载的。而动态注册的，由于没有检测这一步，因此，也不需要我们干预。我们现在需要解决的问题就是，怎么能装载插件中静态注册的。</p>\n<p>我们可以通过解析配置文件，自己调用动态注册的方法去注册这个。</p>\n<p>代码这里就不贴了，和下面ContentProvider的一起贴。</p>\n<h3 id=\"ContentProvider的插件化\"><a href=\"#ContentProvider的插件化\" class=\"headerlink\" title=\"ContentProvider的插件化\"></a>ContentProvider的插件化</h3><p>和其他三个组件不一样的是，ContentProvider是在进程启动入口，也就是ActivityThread中进行安装的。那么我们可以按照这个思路，自己去进行安装的操作。</p>\n<p>代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">Field providersField = packageClz.getDeclaredField(&quot;providers&quot;);</div><div class=\"line\">  providersField.setAccessible(true);</div><div class=\"line\">  ArrayList providers = (ArrayList) providersField.get(packageObject);</div><div class=\"line\"></div><div class=\"line\">  Class providerClz = Class.forName(&quot;android.content.pm.PackageParser$Provider&quot;);</div><div class=\"line\">  Field providerInfoField = providerClz.getDeclaredField(&quot;info&quot;);</div><div class=\"line\">  providersField.setAccessible(true);</div><div class=\"line\">  List&lt;ProviderInfo&gt; providerInfos = new ArrayList&lt;&gt;();</div><div class=\"line\">  for (int i = 0; i &lt; providers.size(); i++) &#123;</div><div class=\"line\">      ProviderInfo providerInfo = (ProviderInfo) providerInfoField.get(providers.get(i));</div><div class=\"line\">      providerInfo.applicationInfo = getApplicationInfo();</div><div class=\"line\">      providerInfos.add(providerInfo);</div><div class=\"line\">  &#125;</div><div class=\"line\">  Class contextImplClz = Class.forName(&quot;android.app.ContextImpl&quot;);</div><div class=\"line\">  Field mMainThread = contextImplClz.getDeclaredField(&quot;mMainThread&quot;);</div><div class=\"line\">  mMainThread.setAccessible(true);</div><div class=\"line\">  Object activityThread = mMainThread.get(this.getBaseContext());</div><div class=\"line\">  Class activityThreadClz = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class=\"line\">  Method installContentProvidersMethod = activityThreadClz.getDeclaredMethod(&quot;installContentProviders&quot;, Context.class, List.class);</div><div class=\"line\">  installContentProvidersMethod.setAccessible(true);</div><div class=\"line\">  installContentProvidersMethod.invoke(activityThread, this, providerInfos);</div></pre></td></tr></table></figure>\n<p>贴一下整体的代码,这里的代码，包括Multidex方法加dex，BroadcastReceiver的插件化以及ContentProvider的插件化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div></pre></td><td class=\"code\"><pre><div class=\"line\">    private void loadClassByHostClassLoader() &#123;</div><div class=\"line\">        File apkFile = new File(&quot;/sdcard/plugin_1.apk&quot;);</div><div class=\"line\">        ClassLoader baseClassLoader = this.getClassLoader();</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Field pathListField = baseClassLoader.getClass().getSuperclass().getDeclaredField(&quot;pathList&quot;);</div><div class=\"line\">            pathListField.setAccessible(true);</div><div class=\"line\">            Object pathList = pathListField.get(baseClassLoader);</div><div class=\"line\"></div><div class=\"line\">            Class clz = Class.forName(&quot;dalvik.system.DexPathList&quot;);</div><div class=\"line\">            Field dexElementsField = clz.getDeclaredField(&quot;dexElements&quot;);</div><div class=\"line\">            dexElementsField.setAccessible(true);</div><div class=\"line\">            Object[] dexElements = (Object[]) dexElementsField.get(pathList);</div><div class=\"line\"></div><div class=\"line\">            Class elementClz = dexElements.getClass().getComponentType();</div><div class=\"line\">            Object[] newDexElements = (Object[]) Array.newInstance(elementClz, dexElements.length + 1);</div><div class=\"line\">            Constructor&lt;?&gt; constructor = elementClz.getConstructor(File.class, boolean.class, File.class, DexFile.class);</div><div class=\"line\">            File file = new File(getFilesDir(), &quot;test.dex&quot;);</div><div class=\"line\">            if (file.exists()) &#123;</div><div class=\"line\">                file.delete();</div><div class=\"line\">            &#125;</div><div class=\"line\">            file.createNewFile();</div><div class=\"line\">            Object pluginElement = constructor.newInstance(apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(),</div><div class=\"line\">                    file.getAbsolutePath(), 0));</div><div class=\"line\">            Object[] toAddElementArray = new Object[]&#123;pluginElement&#125;;</div><div class=\"line\">            System.arraycopy(dexElements, 0, newDexElements, 0, dexElements.length);</div><div class=\"line\">            // 插件的那个element复制进去</div><div class=\"line\">            System.arraycopy(toAddElementArray, 0, newDexElements, dexElements.length, toAddElementArray.length);</div><div class=\"line\">            dexElementsField.set(pathList, newDexElements);</div><div class=\"line\"></div><div class=\"line\">            AssetManager assetManager = getResources().getAssets();</div><div class=\"line\">            Method method = assetManager.getClass().getDeclaredMethod(&quot;addAssetPath&quot;, String.class);</div><div class=\"line\">            method.invoke(assetManager, apkFile.getPath());</div><div class=\"line\"></div><div class=\"line\">//            PackageInfo packageInfo = getPackageManager().getPackageArchiveInfo(apkFile.getAbsolutePath(), PackageManager.GET_RECEIVERS);</div><div class=\"line\">//            if (packageInfo != null) &#123;</div><div class=\"line\">//                for (ActivityInfo info : packageInfo.receivers) &#123;</div><div class=\"line\">//                    Log.e(TAG, &quot;loadClassByHostClassLoader: &quot; + info.name );</div><div class=\"line\">//</div><div class=\"line\">//                &#125;</div><div class=\"line\">//            &#125;</div><div class=\"line\">            Class packageParseClz = Class.forName(&quot;android.content.pm.PackageParser&quot;);</div><div class=\"line\">            Object packageParser = packageParseClz.newInstance();</div><div class=\"line\">            Method parseMethod = packageParseClz.getDeclaredMethod(&quot;parsePackage&quot;, File.class, int.class);</div><div class=\"line\">            parseMethod.setAccessible(true);</div><div class=\"line\">            Object packageObject = parseMethod.invoke(packageParser, apkFile, 1 &lt;&lt; 2);</div><div class=\"line\">            Class packageClz = Class.forName(&quot;android.content.pm.PackageParser$Package&quot;);</div><div class=\"line\">            Field receiversField = packageClz.getDeclaredField(&quot;receivers&quot;);</div><div class=\"line\">            receiversField.setAccessible(true);</div><div class=\"line\">            ArrayList receives = (ArrayList) receiversField.get(packageObject);</div><div class=\"line\"></div><div class=\"line\">            Class componentClz = Class.forName(&quot;android.content.pm.PackageParser$Component&quot;);</div><div class=\"line\">            Field intents = componentClz.getDeclaredField(&quot;intents&quot;);</div><div class=\"line\">            intents.setAccessible(true);</div><div class=\"line\">            Field classNameField = componentClz.getDeclaredField(&quot;className&quot;);</div><div class=\"line\">            classNameField.setAccessible(true);</div><div class=\"line\">            for (int i = 0; i &lt; receives.size(); i++) &#123;</div><div class=\"line\">                ArrayList&lt;IntentFilter&gt; intentFilters = (ArrayList&lt;IntentFilter&gt;) intents.get(receives.get(i));</div><div class=\"line\">                String className = (String) classNameField.get(receives.get(i));</div><div class=\"line\">                registerReceiver((BroadcastReceiver) getClassLoader().loadClass(className).newInstance(), intentFilters.get(0));</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // 安装ContentProvider</div><div class=\"line\">            Field providersField = packageClz.getDeclaredField(&quot;providers&quot;);</div><div class=\"line\">            providersField.setAccessible(true);</div><div class=\"line\">            ArrayList providers = (ArrayList) providersField.get(packageObject);</div><div class=\"line\"></div><div class=\"line\">            Class providerClz = Class.forName(&quot;android.content.pm.PackageParser$Provider&quot;);</div><div class=\"line\">            Field providerInfoField = providerClz.getDeclaredField(&quot;info&quot;);</div><div class=\"line\">            providersField.setAccessible(true);</div><div class=\"line\">            List&lt;ProviderInfo&gt; providerInfos = new ArrayList&lt;&gt;();</div><div class=\"line\">            for (int i = 0; i &lt; providers.size(); i++) &#123;</div><div class=\"line\">                ProviderInfo providerInfo = (ProviderInfo) providerInfoField.get(providers.get(i));</div><div class=\"line\">                providerInfo.applicationInfo = getApplicationInfo();</div><div class=\"line\">                providerInfos.add(providerInfo);</div><div class=\"line\">            &#125;</div><div class=\"line\">            Class contextImplClz = Class.forName(&quot;android.app.ContextImpl&quot;);</div><div class=\"line\">            Field mMainThread = contextImplClz.getDeclaredField(&quot;mMainThread&quot;);</div><div class=\"line\">            mMainThread.setAccessible(true);</div><div class=\"line\">            Object activityThread = mMainThread.get(this.getBaseContext());</div><div class=\"line\">            Class activityThreadClz = Class.forName(&quot;android.app.ActivityThread&quot;);</div><div class=\"line\">            Method installContentProvidersMethod = activityThreadClz.getDeclaredMethod(&quot;installContentProviders&quot;, Context.class, List.class);</div><div class=\"line\">            installContentProvidersMethod.setAccessible(true);</div><div class=\"line\">            installContentProvidersMethod.invoke(activityThread, this, providerInfos);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">            Log.e(TAG, &quot;loadClassByHostClassLoader: &quot; + e.getMessage());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>到这里，四大组件的插件化方案介绍了一点点，虽然每种组件只介绍了一种方法。上面的内容忽略了大部分源码细节。这部分内容需要大家自己去补。</p>\n</blockquote>\n<h3 id=\"资源的插件化方案\"><a href=\"#资源的插件化方案\" class=\"headerlink\" title=\"资源的插件化方案\"></a>资源的插件化方案</h3><p>资源的插件化方案，目前有两种</p>\n<ul>\n<li>合并资源方案</li>\n<li>各个插件构造自己的资源方案</li>\n</ul>\n<p>今天，我们介绍第一种方案，合并资源方案，合并资源方案，我们只需要往现有的AssetManager中调用addAsset添加一个资源即可，当然，存在比较多适配问题，我们暂时忽略。合并资源方案最大的问题就是资源冲突。要解决资源冲突，有两种办法。</p>\n<ul>\n<li>修改AAPT，能自由修改PP段</li>\n<li>干预编译过程，修改ASRC和R文件</li>\n</ul>\n<p>为了简单演示，我直接只用VirtualApk的编译插件去做。实际上VirtualApk的编译插件来自以Small的编译插件。只要对文件格式熟悉，这个还是很好写的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">AssetManager assetManager = getResources().getAssets();</div><div class=\"line\">Method method = assetManager.getClass().getDeclaredMethod(&quot;addAssetPath&quot;, String.class);</div><div class=\"line\">method.invoke(assetManager, apkFile.getPath());</div></pre></td></tr></table></figure>\n<p>我们只需要上面简单的代码，就能完成资源的插件化。当然，这里忽略了版本差异。</p>\n<h3 id=\"SO的插件化方案\"><a href=\"#SO的插件化方案\" class=\"headerlink\" title=\"SO的插件化方案\"></a>SO的插件化方案</h3><p>so的插件化方案，我这里介绍修改dexpathlist的方案。我们要做的是什么呢？只需要往nativeLibraryPathElements中添加SO的Element，并且往nativeLibraryDirectories添加so路径就可以了。<br>代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">            Method findLibMethod = elementClz.getDeclaredMethod(&quot;findNativeLibrary&quot;,String.class);</div><div class=\"line\">            findLibMethod.setAccessible(true);</div><div class=\"line\">//            Object soElement = constructor.newInstance(new File(&quot;/sdcard/&quot;), true, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(),</div><div class=\"line\">//                    file.getAbsolutePath(), 0));</div><div class=\"line\">//            findLibMethod.invoke(pluginElement,System.mapLibraryName(&quot;native-lib&quot;));</div><div class=\"line\">            ZipFile zipFile = new ZipFile(apkFile);</div><div class=\"line\">            ZipEntry zipEntry = zipFile.getEntry(&quot;lib/armeabi/libnative-lib.so&quot;);</div><div class=\"line\">            InputStream inputStream = zipFile.getInputStream(zipEntry);</div><div class=\"line\">            File outSoFile = new File(getFilesDir(), &quot;libnative-lib.so&quot;);</div><div class=\"line\">            if (outSoFile.exists()) &#123;</div><div class=\"line\">                outSoFile.delete();</div><div class=\"line\">            &#125;</div><div class=\"line\">            FileOutputStream outputStream = new FileOutputStream(outSoFile);</div><div class=\"line\">            byte[] cache = new byte[2048];</div><div class=\"line\">            int count = 0;</div><div class=\"line\">            while ((count = inputStream.read(cache)) != -1) &#123;</div><div class=\"line\">                outputStream.write(cache, 0, count);</div><div class=\"line\">            &#125;</div><div class=\"line\">            outputStream.flush();</div><div class=\"line\">            outputStream.close();</div><div class=\"line\">            inputStream.close();</div><div class=\"line\">            // 构造Element</div><div class=\"line\">            Object soElement = constructor.newInstance(getFilesDir(), true, null, null);</div><div class=\"line\">//            findLibMethod.invoke(soElement,System.mapLibraryName(&quot;native-lib&quot;));</div><div class=\"line\"></div><div class=\"line\">            // 将soElement填充到nativeLibraryPathElements中,</div><div class=\"line\">            Field soElementField = clz.getDeclaredField(&quot;nativeLibraryPathElements&quot;);</div><div class=\"line\">            soElementField.setAccessible(true);</div><div class=\"line\">            Object[] soElements = (Object[]) soElementField.get(pathList);</div><div class=\"line\">            Object[] newSoElements = (Object[]) Array.newInstance(elementClz, soElements.length + 1);</div><div class=\"line\">            Object[] toAddSoElementArray = new Object[]&#123;soElement&#125;;</div><div class=\"line\">            System.arraycopy(soElements, 0, newSoElements, 0, soElements.length);</div><div class=\"line\">            // 插件的那个element复制进去</div><div class=\"line\">            System.arraycopy(toAddSoElementArray, 0, newSoElements, soElements.length, toAddSoElementArray.length);</div><div class=\"line\">            soElementField.set(pathList, newSoElements);</div><div class=\"line\"></div><div class=\"line\">            //将so的文件夹填充到nativeLibraryDirectories中</div><div class=\"line\">            Field libDir = clz.getDeclaredField(&quot;nativeLibraryDirectories&quot;);</div><div class=\"line\">            libDir.setAccessible(true);</div><div class=\"line\">            List libDirs = (List) libDir.get(pathList);</div><div class=\"line\">            libDirs.add(getFilesDir());</div><div class=\"line\">            libDir.set(pathList,libDirs);</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在前人的精心研究下，插件化方案已经很成熟了。插件化方案的难点主要在适配方面。其他倒还好。</p>\n<p>PS:热修复的相关知识，PPT已经写好了，下篇应该会浅析一下热修复。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"消息机制在多进程的应用","date":"2017-01-01T13:40:11.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2. 如何使用Messenger\n\n#### 2.1 Messenger 服务端\n\n首先我们需要一个messenger，并传入一个handler。\n\n```java\nprivate Messenger messenger = new Messenger(new MessengerHandler());\n```\n\n其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。\n\n```java\n    @Override\n    public IBinder onBind(Intent intent) {\n        return messenger.getBinder();\n    }\n```\n\n在这个handler的handleMessage方法中，获取客户端发送的消息。\n\n```java\n    private class MessengerHandler extends Handler{\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_CLIENT:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    Messenger client = msg.replyTo;\n                    if (client != null){\n                        Message message = Message.obtain(null,Constants.MSG_FROM_SERVER);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(Constants.MSG_DATA,\"from server\");\n                        message.setData(bundle);\n                        try {\n                            client.send(message);\n                        } catch (RemoteException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    }\n```\n\n最后，在配置文件中，将这个service开启process，开启另一个进程。\n\n#### 2.2 客户端\n\n想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，\n\n```java\n    public Handler getFromServer = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_SERVER:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    };\n\n    private Messenger getReplyMessenger = new Messenger(getFromServer);\n\n    public ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            messenger = new Messenger(service);\n            Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);\n            Bundle bundle = new Bundle();\n            bundle.putString(Constants.MSG_DATA,\"from client\");\n            msg.setData(bundle);\n            msg.replyTo=getReplyMessenger;\n            try {\n                messenger.send(msg);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n```\n\n### 3. 简单分析\n\n之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。\n\n首先是Messenger的getBinder方法，这个方法返回一个binder对象。\n\n```java\n    public IBinder getBinder() {\n        return mTarget.asBinder();\n    }\n```\n\n其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。\n\n```java\n    private final class MessengerImpl extends IMessenger.Stub {\n        public void send(Message msg) {\n            msg.sendingUid = Binder.getCallingUid();\n            Handler.this.sendMessage(msg);\n        }\n    }\n```\n\n而Messenger的send方法。就是调用这里的send方法。\n\n\n### 4. 总结\n\n其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","source":"_posts/消息机制在多进程的应用.md","raw":"---\ntitle: 消息机制在多进程的应用\ndate: 2017-01-01 21:40:11\ncategories: Android\ntags: [android,消息机制]\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2. 如何使用Messenger\n\n#### 2.1 Messenger 服务端\n\n首先我们需要一个messenger，并传入一个handler。\n\n```java\nprivate Messenger messenger = new Messenger(new MessengerHandler());\n```\n\n其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。\n\n```java\n    @Override\n    public IBinder onBind(Intent intent) {\n        return messenger.getBinder();\n    }\n```\n\n在这个handler的handleMessage方法中，获取客户端发送的消息。\n\n```java\n    private class MessengerHandler extends Handler{\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_CLIENT:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    Messenger client = msg.replyTo;\n                    if (client != null){\n                        Message message = Message.obtain(null,Constants.MSG_FROM_SERVER);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(Constants.MSG_DATA,\"from server\");\n                        message.setData(bundle);\n                        try {\n                            client.send(message);\n                        } catch (RemoteException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    }\n```\n\n最后，在配置文件中，将这个service开启process，开启另一个进程。\n\n#### 2.2 客户端\n\n想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，\n\n```java\n    public Handler getFromServer = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_SERVER:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    };\n\n    private Messenger getReplyMessenger = new Messenger(getFromServer);\n\n    public ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            messenger = new Messenger(service);\n            Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);\n            Bundle bundle = new Bundle();\n            bundle.putString(Constants.MSG_DATA,\"from client\");\n            msg.setData(bundle);\n            msg.replyTo=getReplyMessenger;\n            try {\n                messenger.send(msg);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n```\n\n### 3. 简单分析\n\n之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。\n\n首先是Messenger的getBinder方法，这个方法返回一个binder对象。\n\n```java\n    public IBinder getBinder() {\n        return mTarget.asBinder();\n    }\n```\n\n其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。\n\n```java\n    private final class MessengerImpl extends IMessenger.Stub {\n        public void send(Message msg) {\n            msg.sendingUid = Binder.getCallingUid();\n            Handler.this.sendMessage(msg);\n        }\n    }\n```\n\n而Messenger的send方法。就是调用这里的send方法。\n\n\n### 4. 总结\n\n其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","slug":"消息机制在多进程的应用","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm0d006119fyf77oetcf","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"2-如何使用Messenger\"><a href=\"#2-如何使用Messenger\" class=\"headerlink\" title=\"2. 如何使用Messenger\"></a>2. 如何使用Messenger</h3><h4 id=\"2-1-Messenger-服务端\"><a href=\"#2-1-Messenger-服务端\" class=\"headerlink\" title=\"2.1 Messenger 服务端\"></a>2.1 Messenger 服务端</h4><p>首先我们需要一个messenger，并传入一个handler。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Messenger messenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> MessengerHandler());</div></pre></td></tr></table></figure>\n<p>其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> messenger.getBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个handler的handleMessage方法中，获取客户端发送的消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_CLIENT:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                Messenger client = msg.replyTo;</div><div class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">                    Message message = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_SERVER);</div><div class=\"line\">                    Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">                    bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from server\"</span>);</div><div class=\"line\">                    message.setData(bundle);</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        client.send(message);</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">                        e.printStackTrace();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在配置文件中，将这个service开启process，开启另一个进程。</p>\n<h4 id=\"2-2-客户端\"><a href=\"#2-2-客户端\" class=\"headerlink\" title=\"2.2 客户端\"></a>2.2 客户端</h4><p>想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> Handler getFromServer = <span class=\"keyword\">new</span> Handler()&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_SERVER:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Messenger getReplyMessenger = <span class=\"keyword\">new</span> Messenger(getFromServer);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> ServiceConnection connection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class=\"line\">        messenger = <span class=\"keyword\">new</span> Messenger(service);</div><div class=\"line\">        Message msg = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_CLIENT);</div><div class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">        bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from client\"</span>);</div><div class=\"line\">        msg.setData(bundle);</div><div class=\"line\">        msg.replyTo=getReplyMessenger;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            messenger.send(msg);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-简单分析\"><a href=\"#3-简单分析\" class=\"headerlink\" title=\"3. 简单分析\"></a>3. 简单分析</h3><p>之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。</p>\n<p>首先是Messenger的getBinder方法，这个方法返回一个binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">getBinder</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mTarget.asBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        msg.sendingUid = Binder.getCallingUid();</div><div class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而Messenger的send方法。就是调用这里的send方法。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"2-如何使用Messenger\"><a href=\"#2-如何使用Messenger\" class=\"headerlink\" title=\"2. 如何使用Messenger\"></a>2. 如何使用Messenger</h3><h4 id=\"2-1-Messenger-服务端\"><a href=\"#2-1-Messenger-服务端\" class=\"headerlink\" title=\"2.1 Messenger 服务端\"></a>2.1 Messenger 服务端</h4><p>首先我们需要一个messenger，并传入一个handler。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Messenger messenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> MessengerHandler());</div></pre></td></tr></table></figure>\n<p>其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> messenger.getBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个handler的handleMessage方法中，获取客户端发送的消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_CLIENT:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                Messenger client = msg.replyTo;</div><div class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">                    Message message = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_SERVER);</div><div class=\"line\">                    Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">                    bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from server\"</span>);</div><div class=\"line\">                    message.setData(bundle);</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        client.send(message);</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">                        e.printStackTrace();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在配置文件中，将这个service开启process，开启另一个进程。</p>\n<h4 id=\"2-2-客户端\"><a href=\"#2-2-客户端\" class=\"headerlink\" title=\"2.2 客户端\"></a>2.2 客户端</h4><p>想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> Handler getFromServer = <span class=\"keyword\">new</span> Handler()&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_SERVER:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Messenger getReplyMessenger = <span class=\"keyword\">new</span> Messenger(getFromServer);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> ServiceConnection connection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class=\"line\">        messenger = <span class=\"keyword\">new</span> Messenger(service);</div><div class=\"line\">        Message msg = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_CLIENT);</div><div class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">        bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from client\"</span>);</div><div class=\"line\">        msg.setData(bundle);</div><div class=\"line\">        msg.replyTo=getReplyMessenger;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            messenger.send(msg);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-简单分析\"><a href=\"#3-简单分析\" class=\"headerlink\" title=\"3. 简单分析\"></a>3. 简单分析</h3><p>之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。</p>\n<p>首先是Messenger的getBinder方法，这个方法返回一个binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">getBinder</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mTarget.asBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        msg.sendingUid = Binder.getCallingUid();</div><div class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而Messenger的send方法。就是调用这里的send方法。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"系统资源的预加载过程","date":"2017-01-09T04:29:31.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n在Zygote进程那篇文章中，提到过，在初始化的时候会预加载系统资源，这样，应用进程在fork了之后，不需要通过加载过程，就可以直接使用这些资源，那么，今天就来看下，这个过程是怎么样的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n \n\n### ZygoteInit#preloadResources\n\n```\n    private static void preloadResources() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        try {\n            mResources = Resources.getSystem();\n            mResources.startPreloading();\n            if (PRELOAD_RESOURCES) {\n                Log.i(TAG, \"Preloading resources...\");\n\n                long startTime = SystemClock.uptimeMillis();\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);\n                int N = preloadDrawables(runtime, ar);\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");\n\n                startTime = SystemClock.uptimeMillis();\n                ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_color_state_lists);\n                N = preloadColorStateLists(runtime, ar);\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");\n            }\n            mResources.finishPreloading();\n        } catch (RuntimeException e) {\n            Log.w(TAG, \"Failure preloading resources\", e);\n        }\n    }\n```\n\n上面的过程分为三步\n\n* 得到Resources对象\n* 得到TypedArray对象\n* preloadDrawables，preloadColorStateLists 加载资源\n\n现在，按照上面的三部分来学习下。\n\n### Resources#getSystem\n\nResources代码资源，提供了许多方法让我们获取，这里获取的是经过映射的资源，resources.arsc。\n\n```\n    public static Resources getSystem() {\n        synchronized (sSync) {\n            Resources ret = mSystem;\n            if (ret == null) {\n                ret = new Resources();\n                mSystem = ret;\n            }\n\n            return ret;\n        }\n    }\n```\n\n在这里初始化了一个Resources对象，并且赋值给mSystem变量，那么我们现在看下Resources的构造方法。\n\n```\n    private Resources() {\n        mAssets = AssetManager.getSystem();\n        // NOTE: Intentionally leaving this uninitialized (all values set\n        // to zero), so that anyone who tries to do something that requires\n        // metrics will get a very wrong value.\n        mConfiguration.setToDefaults();\n        mMetrics.setToDefaults();\n        updateConfiguration(null, null);\n        mAssets.ensureStringBlocks();\n    }\n```\n\n在初始化方法中，通过AssetManager.getSystem获取一个AssetManager对象，这个是用来访问原始资源的(assets目录)。并且，将Configuration和DisplayMetrics都设置默认，更新配置，初始化StringBlocks。那么，我们来看下AssetManager.getSystem。这个方法中调用ensureSystemAssets，ensureSystemAssets代码如下：\n\n```\n    private static void ensureSystemAssets() {\n        synchronized (sSync) {\n            if (sSystem == null) {\n                AssetManager system = new AssetManager(true);\n                system.makeStringBlocks(null);\n                sSystem = system;\n            }\n        }\n    }\n\n```\n\n可以看到，这里初始化了一个AssetManager，好吧，接着看AssetManager的构造函数。\n\n```\n    private AssetManager(boolean isSystem) {\n        if (DEBUG_REFS) {\n            synchronized (this) {\n                mNumRefs = 0;\n                incRefsLocked(this.hashCode());\n            }\n        }\n        init(true);\n        if (localLOGV) Log.v(TAG, \"New asset manager: \" + this);\n    }\n```\n\n这里调用init去初始化，这是个native函数，实现在android_util_AssetManager.cpp中，对应的方法为android_content_AssetManager_init\n\n#### android_content_AssetManager_init\n\n```\nstatic void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)\n{\n    if (isSystem) {\n        verifySystemIdmaps();\n    }\n    AssetManager* am = new AssetManager();\n    if (am == NULL) {\n        jniThrowException(env, \"java/lang/OutOfMemoryError\", \"\");\n        return;\n    }\n\n    am->addDefaultAssets();\n\n    ALOGV(\"Created AssetManager %p for Java object %p\\n\", am, clazz);\n    env->SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast<jlong>(am));\n}\n```\n\n从代码中来看，分为四步\n\n* 验证idmaps\n* 生成c++的AssetManager对象\n* 添加默认的assets\n* 设置java层AssetManager的mObject为c++的AssetManager地址。\n\n我们看添加默认的assets那一步。\n\n```\nbool AssetManager::addDefaultAssets()\n{\n    const char* root = getenv(\"ANDROID_ROOT\");\n    LOG_ALWAYS_FATAL_IF(root == NULL, \"ANDROID_ROOT not set\");\n\n    String8 path(root);\n    path.appendPath(kSystemAssets);\n\n    return addAssetPath(path, NULL);\n}\n```\n\n* ANDROID_ROOT为system\n* static const char* kSystemAssets = \"framework/framework-res.apk\";\n\n然后调用addAssetPath两个参数的方法，将framework-res.apk加进去。\n\n```\nbool AssetManager::addAssetPath(const String8& path, int32_t* cookie)\n{\n    AutoMutex _l(mLock);\n\n    asset_path ap;\n\n    String8 realPath(path);\n    if (kAppZipName) {\n        realPath.appendPath(kAppZipName);\n    }\n    ap.type = ::getFileType(realPath.string());\n    if (ap.type == kFileTypeRegular) {\n        ap.path = realPath;\n    } else {\n        ap.path = path;\n        ap.type = ::getFileType(path.string());\n        if (ap.type != kFileTypeDirectory && ap.type != kFileTypeRegular) {\n            ALOGW(\"Asset path %s is neither a directory nor file (type=%d).\",\n                 path.string(), (int)ap.type);\n            return false;\n        }\n    }\n\n    // Skip if we have it already.\n    for (size_t i=0; i<mAssetPaths.size(); i++) {\n        if (mAssetPaths[i].path == ap.path) {\n            if (cookie) {\n                *cookie = static_cast<int32_t>(i+1);\n            }\n            return true;\n        }\n    }\n\n    ALOGV(\"In %p Asset %s path: %s\", this,\n         ap.type == kFileTypeDirectory ? \"dir\" : \"zip\", ap.path.string());\n\n    // Check that the path has an AndroidManifest.xml\n    Asset* manifestAsset = const_cast<AssetManager*>(this)->openNonAssetInPathLocked(\n            kAndroidManifest, Asset::ACCESS_BUFFER, ap);\n    if (manifestAsset == NULL) {\n        // This asset path does not contain any resources.\n        delete manifestAsset;\n        return false;\n    }\n    delete manifestAsset;\n\n    mAssetPaths.add(ap);\n\n    // new paths are always added at the end\n    if (cookie) {\n        *cookie = static_cast<int32_t>(mAssetPaths.size());\n    }\n\n#ifdef HAVE_ANDROID_OS\n    // Load overlays, if any\n    asset_path oap;\n    for (size_t idx = 0; mZipSet.getOverlay(ap.path, idx, &oap); idx++) {\n        mAssetPaths.add(oap);\n    }\n#endif\n\n    if (mResources != NULL) {\n        appendPathToResTable(ap);\n    }\n\n    return true;\n}\n```\n\n* asset_path结构体存储文件路径、文件类型等，结构体定义如下\n\n\t```\n    struct asset_path\n    {\n        asset_path() : path(\"\"), type(kFileTypeRegular), idmap(\"\"), isSystemOverlay(false) {}\n        String8 path;\n        FileType type;\n        String8 idmap;\n        bool isSystemOverlay;\n    };\n```\n* kAppZipName一般为null，static const char* kAppZipName = NULL; //\"classes.jar\";\n* 如果已经在mAssetPaths，就反悔\n* 如果路径下没有AndroidManifest.xml文件，返回false\n* 添加到mAssetPaths中\n* appendPathToResTable将资源进行解析添加\n\n#### AssetManager::appendPathToResTable\n\n```\nbool AssetManager::appendPathToResTable(const asset_path& ap) const {\n    // skip those ap's that correspond to system overlays\n    if (ap.isSystemOverlay) {\n        return true;\n    }\n\n    Asset* ass = NULL;\n    ResTable* sharedRes = NULL;\n    bool shared = true;\n    bool onlyEmptyResources = true;\n    MY_TRACE_BEGIN(ap.path.string());\n    Asset* idmap = openIdmapLocked(ap);\n    size_t nextEntryIdx = mResources->getTableCount();\n    ALOGV(\"Looking for resource asset in '%s'\\n\", ap.path.string());\n    if (ap.type != kFileTypeDirectory) {\n        if (nextEntryIdx == 0) {\n            // The first item is typically the framework resources,\n            // which we want to avoid parsing every time.\n            sharedRes = const_cast<AssetManager*>(this)->\n                mZipSet.getZipResourceTable(ap.path);\n            if (sharedRes != NULL) {\n                // skip ahead the number of system overlay packages preloaded\n                nextEntryIdx = sharedRes->getTableCount();\n            }\n        }\n        if (sharedRes == NULL) {\n            ass = const_cast<AssetManager*>(this)->\n                mZipSet.getZipResourceTableAsset(ap.path);\n            if (ass == NULL) {\n                ALOGV(\"loading resource table %s\\n\", ap.path.string());\n                ass = const_cast<AssetManager*>(this)->\n                    openNonAssetInPathLocked(\"resources.arsc\",\n                                             Asset::ACCESS_BUFFER,\n                                             ap);\n                if (ass != NULL && ass != kExcludedAsset) {\n                    ass = const_cast<AssetManager*>(this)->\n                        mZipSet.setZipResourceTableAsset(ap.path, ass);\n                }\n            }\n            \n            if (nextEntryIdx == 0 && ass != NULL) {\n                // If this is the first resource table in the asset\n                // manager, then we are going to cache it so that we\n                // can quickly copy it out for others.\n                ALOGV(\"Creating shared resources for %s\", ap.path.string());\n                sharedRes = new ResTable();\n                sharedRes->add(ass, idmap, nextEntryIdx + 1, false);\n#ifdef HAVE_ANDROID_OS\n                const char* data = getenv(\"ANDROID_DATA\");\n                LOG_ALWAYS_FATAL_IF(data == NULL, \"ANDROID_DATA not set\");\n                String8 overlaysListPath(data);\n                overlaysListPath.appendPath(kResourceCache);\n                overlaysListPath.appendPath(\"overlays.list\");\n                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);\n#endif\n                sharedRes = const_cast<AssetManager*>(this)->\n                    mZipSet.setZipResourceTable(ap.path, sharedRes);\n            }\n        }\n    } else {\n        ALOGV(\"loading resource table %s\\n\", ap.path.string());\n        ass = const_cast<AssetManager*>(this)->\n            openNonAssetInPathLocked(\"resources.arsc\",\n                                     Asset::ACCESS_BUFFER,\n                                     ap);\n        shared = false;\n    }\n\n    if ((ass != NULL || sharedRes != NULL) && ass != kExcludedAsset) {\n        ALOGV(\"Installing resource asset %p in to table %p\\n\", ass, mResources);\n        if (sharedRes != NULL) {\n            ALOGV(\"Copying existing resources for %s\", ap.path.string());\n            mResources->add(sharedRes);\n        } else {\n            ALOGV(\"Parsing resources for %s\", ap.path.string());\n            mResources->add(ass, idmap, nextEntryIdx + 1, !shared);\n        }\n        onlyEmptyResources = false;\n\n        if (!shared) {\n            delete ass;\n        }\n    } else {\n        ALOGV(\"Installing empty resources in to table %p\\n\", mResources);\n        mResources->addEmpty(nextEntryIdx + 1);\n    }\n\n    if (idmap != NULL) {\n        delete idmap;\n    }\n    MY_TRACE_END();\n\n    return onlyEmptyResources;\n}\n```\n\n* 通过openIdmapLocked解析资源包中的idmap表\n* ap.type != kFileTypeDirectory，不是目录，就是资源包，如果nextEntryIdx为0，则为framework.apk资源包，解析并保存在sharedRes中，这个是共享的资源。\n* sharedRes == NULL 表示为应用资源包，这解析保存在ass中，\n* nextEntryIdx == 0 && ass != NULL，在zygote进程第一次调用才成立，也就是预加载资源，这个时候把framework.apk的资源索引表创建起来，并添加到mZipSet中\n* 如果是目录，就创建resources.arsc的asset对象，这个不是共享的。\n* 如果存在sharedRes，就保存到mResources中，否则，这是应用的资源，则把应用的资源加入到mResources中。\n\n上面的比较乱，总结一下。简单来说就是这样的，就是对资源包进行解析，并加入到mResources中，如果是framework.apk，就是共享的，否则就是应用的资源包，不共享。\n\n### TypedArray\n\n```\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);\n```\nmResources.obtainTypedArray的代码如下：\n\n```\n    public TypedArray obtainTypedArray(@ArrayRes int id)\n            throws NotFoundException {\n        int len = mAssets.getArraySize(id);\n        if (len < 0) {\n            throw new NotFoundException(\"Array resource ID #0x\"\n                                        + Integer.toHexString(id));\n        }\n        \n        TypedArray array = TypedArray.obtain(this, len);\n        array.mLength = mAssets.retrieveArray(id, array.mData);\n        array.mIndices[0] = 0;\n        \n        return array;\n    }\n```\n\n* 先获取id对应的数组长度\n* 然后根据长度生成TypedArray\n* 最后mAssets.retrieveArray赋值，将资源对应的id写入到java层array.mData中。写入部分代码如下\n\n\t```\n\t    dest[STYLE_TYPE] = value.dataType;\n        dest[STYLE_DATA] = value.data;\n        dest[STYLE_ASSET_COOKIE] = block != kXmlBlock ?\n            static_cast<jint>(res.getTableCookie(block)) : -1;\n        dest[STYLE_RESOURCE_ID] = resid;\n        dest[STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;\n        dest[STYLE_DENSITY] = config.density;\n```\n\n\n\n\n#### getArraySize获取资源id对应的数组长度\n\n这是个native方法，对应的实现在android_util_AssetManager.cpp的android_content_AssetManager_getArraySize方法中，代码如下：\n\n```\nstatic jint android_content_AssetManager_getArraySize(JNIEnv* env, jobject clazz,\n                                                       jint id)\n{\n    AssetManager* am = assetManagerForJavaObject(env, clazz);\n    if (am == NULL) {\n        return 0;\n    }\n    const ResTable& res(am->getResources());\n\n    res.lock();\n    const ResTable::bag_entry* defStyleEnt = NULL;\n    ssize_t bagOff = res.getBagLocked(id, &defStyleEnt);\n    res.unlock();\n\n    return static_cast<jint>(bagOff);\n}\n```\n\n* 首先将java对象转换为对应的c++对象，上面有说到过，AssetManager中的mobject字段存的是对应c++中，AssetManager对象的地址，因此，我们很容易做到转换\n* 通过ResTable的getBagLocked方法获取id，对应的数组长度(该方法的实现在ResourceTypes.cpp中)，实现太长，看不懂，略过。\n\n### preloadDrawables来说明资源的预加载过程\n\n```\n    private static int preloadDrawables(VMRuntime runtime, TypedArray ar) {\n        int N = ar.length();\n        for (int i=0; i<N; i++) {\n            int id = ar.getResourceId(i, 0);\n            if (false) {\n                Log.v(TAG, \"Preloading resource #\" + Integer.toHexString(id));\n            }\n            if (id != 0) {\n                if (mResources.getDrawable(id, null) == null) {\n                    throw new IllegalArgumentException(\n                            \"Unable to find preloaded drawable resource #0x\"\n                            + Integer.toHexString(id)\n                            + \" (\" + ar.getString(i) + \")\");\n                }\n            }\n        }\n        return N;\n    }\n```\n\n* 首先通过getResourceId获取资源id\n* getDrawable获取资源\n\n#### getResourceId 获取资源id\n\n```\n    public int getResourceId(int index, int defValue) {\n        if (mRecycled) {\n            throw new RuntimeException(\"Cannot make calls to a recycled instance!\");\n        }\n\n        index *= AssetManager.STYLE_NUM_ENTRIES;\n        final int[] data = mData;\n        if (data[index+AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {\n            final int resid = data[index+AssetManager.STYLE_RESOURCE_ID];\n            if (resid != 0) {\n                return resid;\n            }\n        }\n        return defValue;\n    }\n```\n\n* 其中STYLE_NUM_ENTRIES为6，\n* 从赋值id的代码中，知道第四个为id值，因此STYLE_RESOURCE_ID为3\n\n\n\n#### getDrawable\n\n```\n    public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme) throws NotFoundException {\n        TypedValue value;\n        synchronized (mAccessLock) {\n            value = mTmpValue;\n            if (value == null) {\n                value = new TypedValue();\n            } else {\n                mTmpValue = null;\n            }\n            getValue(id, value, true);\n        }\n        final Drawable res = loadDrawable(value, id, theme);\n        synchronized (mAccessLock) {\n            if (mTmpValue == null) {\n                mTmpValue = value;\n            }\n        }\n        return res;\n    }\n```\n\n* getValue查找与id对应的资源，没找到对应的就抛出NotFoundException异常\n* loadDrawable 去加载\n\n在getValue中，会调用AssetManager的getResourceValue方法，这个是native方法，实现在android_uitl_AssetManager.cpp的android_content_AssetManager_loadResourceValue中\n\n##### android_content_AssetManager_loadResourceValue\n\n```\nstatic jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,\n                                                           jint ident,\n                                                           jshort density,\n                                                           jobject outValue,\n                                                           jboolean resolve)\n{\n    if (outValue == NULL) {\n         jniThrowNullPointerException(env, \"outValue\");\n         return 0;\n    }\n    AssetManager* am = assetManagerForJavaObject(env, clazz);\n    if (am == NULL) {\n        return 0;\n    }\n    const ResTable& res(am->getResources());\n\n    Res_value value;\n    ResTable_config config;\n    uint32_t typeSpecFlags;\n    ssize_t block = res.getResource(ident, &value, false, density, &typeSpecFlags, &config);\n    if (kThrowOnBadId) {\n        if (block == BAD_INDEX) {\n            jniThrowException(env, \"java/lang/IllegalStateException\", \"Bad resource!\");\n            return 0;\n        }\n    }\n    uint32_t ref = ident;\n    if (resolve) {\n        block = res.resolveReference(&value, block, &ref, &typeSpecFlags, &config);\n        if (kThrowOnBadId) {\n            if (block == BAD_INDEX) {\n                jniThrowException(env, \"java/lang/IllegalStateException\", \"Bad resource!\");\n                return 0;\n            }\n        }\n    }\n    if (block >= 0) {\n        return copyValue(env, outValue, &res, value, ref, block, typeSpecFlags, &config);\n    }\n\n    return static_cast<jint>(block);\n}\n```\n\n* 得到ResTable对象\n* resolveReference查找是否有匹配的资源\n* 如果有，就将数据复制给copyValue这个java层对象\n\n具体的代码就不往下追了。\n\n##### loadDrawable\n\n经过上面的步骤，资源的信息就保存在了TypedValue中，解析来就是通过loadDrawable去加载了。\n\n```\n    Drawable loadDrawable(TypedValue value, int id, Theme theme) throws NotFoundException {\n        if (TRACE_FOR_PRELOAD) {\n            // Log only framework resources\n            if ((id >>> 24) == 0x1) {\n                final String name = getResourceName(id);\n                if (name != null) {\n                    Log.d(\"PreloadDrawable\", name);\n                }\n            }\n        }\n\n        final boolean isColorDrawable;\n        final DrawableCache caches;\n        final long key;\n        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT\n                && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {\n            isColorDrawable = true;\n            caches = mColorDrawableCache;\n            key = value.data;\n        } else {\n            isColorDrawable = false;\n            caches = mDrawableCache;\n            key = (((long) value.assetCookie) << 32) | value.data;\n        }\n\n        // First, check whether we have a cached version of this drawable\n        // that was inflated against the specified theme.\n        if (!mPreloading) {\n            final Drawable cachedDrawable = caches.getInstance(key, theme);\n            if (cachedDrawable != null) {\n                return cachedDrawable;\n            }\n        }\n\n        // Next, check preloaded drawables. These may contain unresolved theme\n        // attributes.\n        final ConstantState cs;\n        if (isColorDrawable) {\n            cs = sPreloadedColorDrawables.get(key);\n        } else {\n            cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);\n        }\n\n        Drawable dr;\n        if (cs != null) {\n            dr = cs.newDrawable(this);\n        } else if (isColorDrawable) {\n            dr = new ColorDrawable(value.data);\n        } else {\n            dr = loadDrawableForCookie(value, id, null);\n        }\n\n        // Determine if the drawable has unresolved theme attributes. If it\n        // does, we'll need to apply a theme and store it in a theme-specific\n        // cache.\n        final boolean canApplyTheme = dr != null && dr.canApplyTheme();\n        if (canApplyTheme && theme != null) {\n            dr = dr.mutate();\n            dr.applyTheme(theme);\n            dr.clearMutated();\n        }\n\n        // If we were able to obtain a drawable, store it in the appropriate\n        // cache: preload, not themed, null theme, or theme-specific.\n        if (dr != null) {\n            dr.setChangingConfigurations(value.changingConfigurations);\n            cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);\n        }\n\n        return dr;\n    }\n```\n\n* 根据判断是否是ColorDrawable，赋值不同的cache和key\n* 如果不是预加载，就从cache中找，找到返回\n* 从预加载数组中得到key对应的ConstantState\n* 根据cs是否为null以及是不是ColorDrawable，来得到的Drawable\n* 设置主题相关的\n* 进行缓存\n\n而我们预加载资源的主要过程是loadDrawableForCookie。这个方法是从xml或者流里面加载Drawable。\n\n核心代码如下：\n\n```\n            if (file.endsWith(\".xml\")) {\n                final XmlResourceParser rp = loadXmlResourceParser(\n                        file, id, value.assetCookie, \"drawable\");\n                dr = Drawable.createFromXml(this, rp, theme);\n                rp.close();\n            } else {\n                final InputStream is = mAssets.openNonAsset(\n                        value.assetCookie, file, AssetManager.ACCESS_STREAMING);\n                dr = Drawable.createFromResourceStream(this, value, is, file, null);\n                is.close();\n            }\n```\n\n关于Drawable的生成过程，这里就不说了。\n\n### 占坑\n\n* aapt资源打包过程\n* 其他\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/系统资源的预加载过程.md","raw":"---\ntitle: 系统资源的预加载过程\ndate: 2017-01-09 12:29:31\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n在Zygote进程那篇文章中，提到过，在初始化的时候会预加载系统资源，这样，应用进程在fork了之后，不需要通过加载过程，就可以直接使用这些资源，那么，今天就来看下，这个过程是怎么样的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n \n\n### ZygoteInit#preloadResources\n\n```\n    private static void preloadResources() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        try {\n            mResources = Resources.getSystem();\n            mResources.startPreloading();\n            if (PRELOAD_RESOURCES) {\n                Log.i(TAG, \"Preloading resources...\");\n\n                long startTime = SystemClock.uptimeMillis();\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);\n                int N = preloadDrawables(runtime, ar);\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");\n\n                startTime = SystemClock.uptimeMillis();\n                ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_color_state_lists);\n                N = preloadColorStateLists(runtime, ar);\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");\n            }\n            mResources.finishPreloading();\n        } catch (RuntimeException e) {\n            Log.w(TAG, \"Failure preloading resources\", e);\n        }\n    }\n```\n\n上面的过程分为三步\n\n* 得到Resources对象\n* 得到TypedArray对象\n* preloadDrawables，preloadColorStateLists 加载资源\n\n现在，按照上面的三部分来学习下。\n\n### Resources#getSystem\n\nResources代码资源，提供了许多方法让我们获取，这里获取的是经过映射的资源，resources.arsc。\n\n```\n    public static Resources getSystem() {\n        synchronized (sSync) {\n            Resources ret = mSystem;\n            if (ret == null) {\n                ret = new Resources();\n                mSystem = ret;\n            }\n\n            return ret;\n        }\n    }\n```\n\n在这里初始化了一个Resources对象，并且赋值给mSystem变量，那么我们现在看下Resources的构造方法。\n\n```\n    private Resources() {\n        mAssets = AssetManager.getSystem();\n        // NOTE: Intentionally leaving this uninitialized (all values set\n        // to zero), so that anyone who tries to do something that requires\n        // metrics will get a very wrong value.\n        mConfiguration.setToDefaults();\n        mMetrics.setToDefaults();\n        updateConfiguration(null, null);\n        mAssets.ensureStringBlocks();\n    }\n```\n\n在初始化方法中，通过AssetManager.getSystem获取一个AssetManager对象，这个是用来访问原始资源的(assets目录)。并且，将Configuration和DisplayMetrics都设置默认，更新配置，初始化StringBlocks。那么，我们来看下AssetManager.getSystem。这个方法中调用ensureSystemAssets，ensureSystemAssets代码如下：\n\n```\n    private static void ensureSystemAssets() {\n        synchronized (sSync) {\n            if (sSystem == null) {\n                AssetManager system = new AssetManager(true);\n                system.makeStringBlocks(null);\n                sSystem = system;\n            }\n        }\n    }\n\n```\n\n可以看到，这里初始化了一个AssetManager，好吧，接着看AssetManager的构造函数。\n\n```\n    private AssetManager(boolean isSystem) {\n        if (DEBUG_REFS) {\n            synchronized (this) {\n                mNumRefs = 0;\n                incRefsLocked(this.hashCode());\n            }\n        }\n        init(true);\n        if (localLOGV) Log.v(TAG, \"New asset manager: \" + this);\n    }\n```\n\n这里调用init去初始化，这是个native函数，实现在android_util_AssetManager.cpp中，对应的方法为android_content_AssetManager_init\n\n#### android_content_AssetManager_init\n\n```\nstatic void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)\n{\n    if (isSystem) {\n        verifySystemIdmaps();\n    }\n    AssetManager* am = new AssetManager();\n    if (am == NULL) {\n        jniThrowException(env, \"java/lang/OutOfMemoryError\", \"\");\n        return;\n    }\n\n    am->addDefaultAssets();\n\n    ALOGV(\"Created AssetManager %p for Java object %p\\n\", am, clazz);\n    env->SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast<jlong>(am));\n}\n```\n\n从代码中来看，分为四步\n\n* 验证idmaps\n* 生成c++的AssetManager对象\n* 添加默认的assets\n* 设置java层AssetManager的mObject为c++的AssetManager地址。\n\n我们看添加默认的assets那一步。\n\n```\nbool AssetManager::addDefaultAssets()\n{\n    const char* root = getenv(\"ANDROID_ROOT\");\n    LOG_ALWAYS_FATAL_IF(root == NULL, \"ANDROID_ROOT not set\");\n\n    String8 path(root);\n    path.appendPath(kSystemAssets);\n\n    return addAssetPath(path, NULL);\n}\n```\n\n* ANDROID_ROOT为system\n* static const char* kSystemAssets = \"framework/framework-res.apk\";\n\n然后调用addAssetPath两个参数的方法，将framework-res.apk加进去。\n\n```\nbool AssetManager::addAssetPath(const String8& path, int32_t* cookie)\n{\n    AutoMutex _l(mLock);\n\n    asset_path ap;\n\n    String8 realPath(path);\n    if (kAppZipName) {\n        realPath.appendPath(kAppZipName);\n    }\n    ap.type = ::getFileType(realPath.string());\n    if (ap.type == kFileTypeRegular) {\n        ap.path = realPath;\n    } else {\n        ap.path = path;\n        ap.type = ::getFileType(path.string());\n        if (ap.type != kFileTypeDirectory && ap.type != kFileTypeRegular) {\n            ALOGW(\"Asset path %s is neither a directory nor file (type=%d).\",\n                 path.string(), (int)ap.type);\n            return false;\n        }\n    }\n\n    // Skip if we have it already.\n    for (size_t i=0; i<mAssetPaths.size(); i++) {\n        if (mAssetPaths[i].path == ap.path) {\n            if (cookie) {\n                *cookie = static_cast<int32_t>(i+1);\n            }\n            return true;\n        }\n    }\n\n    ALOGV(\"In %p Asset %s path: %s\", this,\n         ap.type == kFileTypeDirectory ? \"dir\" : \"zip\", ap.path.string());\n\n    // Check that the path has an AndroidManifest.xml\n    Asset* manifestAsset = const_cast<AssetManager*>(this)->openNonAssetInPathLocked(\n            kAndroidManifest, Asset::ACCESS_BUFFER, ap);\n    if (manifestAsset == NULL) {\n        // This asset path does not contain any resources.\n        delete manifestAsset;\n        return false;\n    }\n    delete manifestAsset;\n\n    mAssetPaths.add(ap);\n\n    // new paths are always added at the end\n    if (cookie) {\n        *cookie = static_cast<int32_t>(mAssetPaths.size());\n    }\n\n#ifdef HAVE_ANDROID_OS\n    // Load overlays, if any\n    asset_path oap;\n    for (size_t idx = 0; mZipSet.getOverlay(ap.path, idx, &oap); idx++) {\n        mAssetPaths.add(oap);\n    }\n#endif\n\n    if (mResources != NULL) {\n        appendPathToResTable(ap);\n    }\n\n    return true;\n}\n```\n\n* asset_path结构体存储文件路径、文件类型等，结构体定义如下\n\n\t```\n    struct asset_path\n    {\n        asset_path() : path(\"\"), type(kFileTypeRegular), idmap(\"\"), isSystemOverlay(false) {}\n        String8 path;\n        FileType type;\n        String8 idmap;\n        bool isSystemOverlay;\n    };\n```\n* kAppZipName一般为null，static const char* kAppZipName = NULL; //\"classes.jar\";\n* 如果已经在mAssetPaths，就反悔\n* 如果路径下没有AndroidManifest.xml文件，返回false\n* 添加到mAssetPaths中\n* appendPathToResTable将资源进行解析添加\n\n#### AssetManager::appendPathToResTable\n\n```\nbool AssetManager::appendPathToResTable(const asset_path& ap) const {\n    // skip those ap's that correspond to system overlays\n    if (ap.isSystemOverlay) {\n        return true;\n    }\n\n    Asset* ass = NULL;\n    ResTable* sharedRes = NULL;\n    bool shared = true;\n    bool onlyEmptyResources = true;\n    MY_TRACE_BEGIN(ap.path.string());\n    Asset* idmap = openIdmapLocked(ap);\n    size_t nextEntryIdx = mResources->getTableCount();\n    ALOGV(\"Looking for resource asset in '%s'\\n\", ap.path.string());\n    if (ap.type != kFileTypeDirectory) {\n        if (nextEntryIdx == 0) {\n            // The first item is typically the framework resources,\n            // which we want to avoid parsing every time.\n            sharedRes = const_cast<AssetManager*>(this)->\n                mZipSet.getZipResourceTable(ap.path);\n            if (sharedRes != NULL) {\n                // skip ahead the number of system overlay packages preloaded\n                nextEntryIdx = sharedRes->getTableCount();\n            }\n        }\n        if (sharedRes == NULL) {\n            ass = const_cast<AssetManager*>(this)->\n                mZipSet.getZipResourceTableAsset(ap.path);\n            if (ass == NULL) {\n                ALOGV(\"loading resource table %s\\n\", ap.path.string());\n                ass = const_cast<AssetManager*>(this)->\n                    openNonAssetInPathLocked(\"resources.arsc\",\n                                             Asset::ACCESS_BUFFER,\n                                             ap);\n                if (ass != NULL && ass != kExcludedAsset) {\n                    ass = const_cast<AssetManager*>(this)->\n                        mZipSet.setZipResourceTableAsset(ap.path, ass);\n                }\n            }\n            \n            if (nextEntryIdx == 0 && ass != NULL) {\n                // If this is the first resource table in the asset\n                // manager, then we are going to cache it so that we\n                // can quickly copy it out for others.\n                ALOGV(\"Creating shared resources for %s\", ap.path.string());\n                sharedRes = new ResTable();\n                sharedRes->add(ass, idmap, nextEntryIdx + 1, false);\n#ifdef HAVE_ANDROID_OS\n                const char* data = getenv(\"ANDROID_DATA\");\n                LOG_ALWAYS_FATAL_IF(data == NULL, \"ANDROID_DATA not set\");\n                String8 overlaysListPath(data);\n                overlaysListPath.appendPath(kResourceCache);\n                overlaysListPath.appendPath(\"overlays.list\");\n                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);\n#endif\n                sharedRes = const_cast<AssetManager*>(this)->\n                    mZipSet.setZipResourceTable(ap.path, sharedRes);\n            }\n        }\n    } else {\n        ALOGV(\"loading resource table %s\\n\", ap.path.string());\n        ass = const_cast<AssetManager*>(this)->\n            openNonAssetInPathLocked(\"resources.arsc\",\n                                     Asset::ACCESS_BUFFER,\n                                     ap);\n        shared = false;\n    }\n\n    if ((ass != NULL || sharedRes != NULL) && ass != kExcludedAsset) {\n        ALOGV(\"Installing resource asset %p in to table %p\\n\", ass, mResources);\n        if (sharedRes != NULL) {\n            ALOGV(\"Copying existing resources for %s\", ap.path.string());\n            mResources->add(sharedRes);\n        } else {\n            ALOGV(\"Parsing resources for %s\", ap.path.string());\n            mResources->add(ass, idmap, nextEntryIdx + 1, !shared);\n        }\n        onlyEmptyResources = false;\n\n        if (!shared) {\n            delete ass;\n        }\n    } else {\n        ALOGV(\"Installing empty resources in to table %p\\n\", mResources);\n        mResources->addEmpty(nextEntryIdx + 1);\n    }\n\n    if (idmap != NULL) {\n        delete idmap;\n    }\n    MY_TRACE_END();\n\n    return onlyEmptyResources;\n}\n```\n\n* 通过openIdmapLocked解析资源包中的idmap表\n* ap.type != kFileTypeDirectory，不是目录，就是资源包，如果nextEntryIdx为0，则为framework.apk资源包，解析并保存在sharedRes中，这个是共享的资源。\n* sharedRes == NULL 表示为应用资源包，这解析保存在ass中，\n* nextEntryIdx == 0 && ass != NULL，在zygote进程第一次调用才成立，也就是预加载资源，这个时候把framework.apk的资源索引表创建起来，并添加到mZipSet中\n* 如果是目录，就创建resources.arsc的asset对象，这个不是共享的。\n* 如果存在sharedRes，就保存到mResources中，否则，这是应用的资源，则把应用的资源加入到mResources中。\n\n上面的比较乱，总结一下。简单来说就是这样的，就是对资源包进行解析，并加入到mResources中，如果是framework.apk，就是共享的，否则就是应用的资源包，不共享。\n\n### TypedArray\n\n```\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);\n```\nmResources.obtainTypedArray的代码如下：\n\n```\n    public TypedArray obtainTypedArray(@ArrayRes int id)\n            throws NotFoundException {\n        int len = mAssets.getArraySize(id);\n        if (len < 0) {\n            throw new NotFoundException(\"Array resource ID #0x\"\n                                        + Integer.toHexString(id));\n        }\n        \n        TypedArray array = TypedArray.obtain(this, len);\n        array.mLength = mAssets.retrieveArray(id, array.mData);\n        array.mIndices[0] = 0;\n        \n        return array;\n    }\n```\n\n* 先获取id对应的数组长度\n* 然后根据长度生成TypedArray\n* 最后mAssets.retrieveArray赋值，将资源对应的id写入到java层array.mData中。写入部分代码如下\n\n\t```\n\t    dest[STYLE_TYPE] = value.dataType;\n        dest[STYLE_DATA] = value.data;\n        dest[STYLE_ASSET_COOKIE] = block != kXmlBlock ?\n            static_cast<jint>(res.getTableCookie(block)) : -1;\n        dest[STYLE_RESOURCE_ID] = resid;\n        dest[STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;\n        dest[STYLE_DENSITY] = config.density;\n```\n\n\n\n\n#### getArraySize获取资源id对应的数组长度\n\n这是个native方法，对应的实现在android_util_AssetManager.cpp的android_content_AssetManager_getArraySize方法中，代码如下：\n\n```\nstatic jint android_content_AssetManager_getArraySize(JNIEnv* env, jobject clazz,\n                                                       jint id)\n{\n    AssetManager* am = assetManagerForJavaObject(env, clazz);\n    if (am == NULL) {\n        return 0;\n    }\n    const ResTable& res(am->getResources());\n\n    res.lock();\n    const ResTable::bag_entry* defStyleEnt = NULL;\n    ssize_t bagOff = res.getBagLocked(id, &defStyleEnt);\n    res.unlock();\n\n    return static_cast<jint>(bagOff);\n}\n```\n\n* 首先将java对象转换为对应的c++对象，上面有说到过，AssetManager中的mobject字段存的是对应c++中，AssetManager对象的地址，因此，我们很容易做到转换\n* 通过ResTable的getBagLocked方法获取id，对应的数组长度(该方法的实现在ResourceTypes.cpp中)，实现太长，看不懂，略过。\n\n### preloadDrawables来说明资源的预加载过程\n\n```\n    private static int preloadDrawables(VMRuntime runtime, TypedArray ar) {\n        int N = ar.length();\n        for (int i=0; i<N; i++) {\n            int id = ar.getResourceId(i, 0);\n            if (false) {\n                Log.v(TAG, \"Preloading resource #\" + Integer.toHexString(id));\n            }\n            if (id != 0) {\n                if (mResources.getDrawable(id, null) == null) {\n                    throw new IllegalArgumentException(\n                            \"Unable to find preloaded drawable resource #0x\"\n                            + Integer.toHexString(id)\n                            + \" (\" + ar.getString(i) + \")\");\n                }\n            }\n        }\n        return N;\n    }\n```\n\n* 首先通过getResourceId获取资源id\n* getDrawable获取资源\n\n#### getResourceId 获取资源id\n\n```\n    public int getResourceId(int index, int defValue) {\n        if (mRecycled) {\n            throw new RuntimeException(\"Cannot make calls to a recycled instance!\");\n        }\n\n        index *= AssetManager.STYLE_NUM_ENTRIES;\n        final int[] data = mData;\n        if (data[index+AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {\n            final int resid = data[index+AssetManager.STYLE_RESOURCE_ID];\n            if (resid != 0) {\n                return resid;\n            }\n        }\n        return defValue;\n    }\n```\n\n* 其中STYLE_NUM_ENTRIES为6，\n* 从赋值id的代码中，知道第四个为id值，因此STYLE_RESOURCE_ID为3\n\n\n\n#### getDrawable\n\n```\n    public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme) throws NotFoundException {\n        TypedValue value;\n        synchronized (mAccessLock) {\n            value = mTmpValue;\n            if (value == null) {\n                value = new TypedValue();\n            } else {\n                mTmpValue = null;\n            }\n            getValue(id, value, true);\n        }\n        final Drawable res = loadDrawable(value, id, theme);\n        synchronized (mAccessLock) {\n            if (mTmpValue == null) {\n                mTmpValue = value;\n            }\n        }\n        return res;\n    }\n```\n\n* getValue查找与id对应的资源，没找到对应的就抛出NotFoundException异常\n* loadDrawable 去加载\n\n在getValue中，会调用AssetManager的getResourceValue方法，这个是native方法，实现在android_uitl_AssetManager.cpp的android_content_AssetManager_loadResourceValue中\n\n##### android_content_AssetManager_loadResourceValue\n\n```\nstatic jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,\n                                                           jint ident,\n                                                           jshort density,\n                                                           jobject outValue,\n                                                           jboolean resolve)\n{\n    if (outValue == NULL) {\n         jniThrowNullPointerException(env, \"outValue\");\n         return 0;\n    }\n    AssetManager* am = assetManagerForJavaObject(env, clazz);\n    if (am == NULL) {\n        return 0;\n    }\n    const ResTable& res(am->getResources());\n\n    Res_value value;\n    ResTable_config config;\n    uint32_t typeSpecFlags;\n    ssize_t block = res.getResource(ident, &value, false, density, &typeSpecFlags, &config);\n    if (kThrowOnBadId) {\n        if (block == BAD_INDEX) {\n            jniThrowException(env, \"java/lang/IllegalStateException\", \"Bad resource!\");\n            return 0;\n        }\n    }\n    uint32_t ref = ident;\n    if (resolve) {\n        block = res.resolveReference(&value, block, &ref, &typeSpecFlags, &config);\n        if (kThrowOnBadId) {\n            if (block == BAD_INDEX) {\n                jniThrowException(env, \"java/lang/IllegalStateException\", \"Bad resource!\");\n                return 0;\n            }\n        }\n    }\n    if (block >= 0) {\n        return copyValue(env, outValue, &res, value, ref, block, typeSpecFlags, &config);\n    }\n\n    return static_cast<jint>(block);\n}\n```\n\n* 得到ResTable对象\n* resolveReference查找是否有匹配的资源\n* 如果有，就将数据复制给copyValue这个java层对象\n\n具体的代码就不往下追了。\n\n##### loadDrawable\n\n经过上面的步骤，资源的信息就保存在了TypedValue中，解析来就是通过loadDrawable去加载了。\n\n```\n    Drawable loadDrawable(TypedValue value, int id, Theme theme) throws NotFoundException {\n        if (TRACE_FOR_PRELOAD) {\n            // Log only framework resources\n            if ((id >>> 24) == 0x1) {\n                final String name = getResourceName(id);\n                if (name != null) {\n                    Log.d(\"PreloadDrawable\", name);\n                }\n            }\n        }\n\n        final boolean isColorDrawable;\n        final DrawableCache caches;\n        final long key;\n        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT\n                && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {\n            isColorDrawable = true;\n            caches = mColorDrawableCache;\n            key = value.data;\n        } else {\n            isColorDrawable = false;\n            caches = mDrawableCache;\n            key = (((long) value.assetCookie) << 32) | value.data;\n        }\n\n        // First, check whether we have a cached version of this drawable\n        // that was inflated against the specified theme.\n        if (!mPreloading) {\n            final Drawable cachedDrawable = caches.getInstance(key, theme);\n            if (cachedDrawable != null) {\n                return cachedDrawable;\n            }\n        }\n\n        // Next, check preloaded drawables. These may contain unresolved theme\n        // attributes.\n        final ConstantState cs;\n        if (isColorDrawable) {\n            cs = sPreloadedColorDrawables.get(key);\n        } else {\n            cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);\n        }\n\n        Drawable dr;\n        if (cs != null) {\n            dr = cs.newDrawable(this);\n        } else if (isColorDrawable) {\n            dr = new ColorDrawable(value.data);\n        } else {\n            dr = loadDrawableForCookie(value, id, null);\n        }\n\n        // Determine if the drawable has unresolved theme attributes. If it\n        // does, we'll need to apply a theme and store it in a theme-specific\n        // cache.\n        final boolean canApplyTheme = dr != null && dr.canApplyTheme();\n        if (canApplyTheme && theme != null) {\n            dr = dr.mutate();\n            dr.applyTheme(theme);\n            dr.clearMutated();\n        }\n\n        // If we were able to obtain a drawable, store it in the appropriate\n        // cache: preload, not themed, null theme, or theme-specific.\n        if (dr != null) {\n            dr.setChangingConfigurations(value.changingConfigurations);\n            cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);\n        }\n\n        return dr;\n    }\n```\n\n* 根据判断是否是ColorDrawable，赋值不同的cache和key\n* 如果不是预加载，就从cache中找，找到返回\n* 从预加载数组中得到key对应的ConstantState\n* 根据cs是否为null以及是不是ColorDrawable，来得到的Drawable\n* 设置主题相关的\n* 进行缓存\n\n而我们预加载资源的主要过程是loadDrawableForCookie。这个方法是从xml或者流里面加载Drawable。\n\n核心代码如下：\n\n```\n            if (file.endsWith(\".xml\")) {\n                final XmlResourceParser rp = loadXmlResourceParser(\n                        file, id, value.assetCookie, \"drawable\");\n                dr = Drawable.createFromXml(this, rp, theme);\n                rp.close();\n            } else {\n                final InputStream is = mAssets.openNonAsset(\n                        value.assetCookie, file, AssetManager.ACCESS_STREAMING);\n                dr = Drawable.createFromResourceStream(this, value, is, file, null);\n                is.close();\n            }\n```\n\n关于Drawable的生成过程，这里就不说了。\n\n### 占坑\n\n* aapt资源打包过程\n* 其他\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"系统资源的预加载过程","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm0e006419fyaahqwk30","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在Zygote进程那篇文章中，提到过，在初始化的时候会预加载系统资源，这样，应用进程在fork了之后，不需要通过加载过程，就可以直接使用这些资源，那么，今天就来看下，这个过程是怎么样的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"ZygoteInit-preloadResources\"><a href=\"#ZygoteInit-preloadResources\" class=\"headerlink\" title=\"ZygoteInit#preloadResources\"></a>ZygoteInit#preloadResources</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void preloadResources() &#123;</div><div class=\"line\">    final VMRuntime runtime = VMRuntime.getRuntime();</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        mResources = Resources.getSystem();</div><div class=\"line\">        mResources.startPreloading();</div><div class=\"line\">        if (PRELOAD_RESOURCES) &#123;</div><div class=\"line\">            Log.i(TAG, &quot;Preloading resources...&quot;);</div><div class=\"line\"></div><div class=\"line\">            long startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_drawables);</div><div class=\"line\">            int N = preloadDrawables(runtime, ar);</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);</div><div class=\"line\"></div><div class=\"line\">            startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_color_state_lists);</div><div class=\"line\">            N = preloadColorStateLists(runtime, ar);</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mResources.finishPreloading();</div><div class=\"line\">    &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">        Log.w(TAG, &quot;Failure preloading resources&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的过程分为三步</p>\n<ul>\n<li>得到Resources对象</li>\n<li>得到TypedArray对象</li>\n<li>preloadDrawables，preloadColorStateLists 加载资源</li>\n</ul>\n<p>现在，按照上面的三部分来学习下。</p>\n<h3 id=\"Resources-getSystem\"><a href=\"#Resources-getSystem\" class=\"headerlink\" title=\"Resources#getSystem\"></a>Resources#getSystem</h3><p>Resources代码资源，提供了许多方法让我们获取，这里获取的是经过映射的资源，resources.arsc。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Resources getSystem() &#123;</div><div class=\"line\">    synchronized (sSync) &#123;</div><div class=\"line\">        Resources ret = mSystem;</div><div class=\"line\">        if (ret == null) &#123;</div><div class=\"line\">            ret = new Resources();</div><div class=\"line\">            mSystem = ret;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里初始化了一个Resources对象，并且赋值给mSystem变量，那么我们现在看下Resources的构造方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Resources() &#123;</div><div class=\"line\">    mAssets = AssetManager.getSystem();</div><div class=\"line\">    // NOTE: Intentionally leaving this uninitialized (all values set</div><div class=\"line\">    // to zero), so that anyone who tries to do something that requires</div><div class=\"line\">    // metrics will get a very wrong value.</div><div class=\"line\">    mConfiguration.setToDefaults();</div><div class=\"line\">    mMetrics.setToDefaults();</div><div class=\"line\">    updateConfiguration(null, null);</div><div class=\"line\">    mAssets.ensureStringBlocks();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在初始化方法中，通过AssetManager.getSystem获取一个AssetManager对象，这个是用来访问原始资源的(assets目录)。并且，将Configuration和DisplayMetrics都设置默认，更新配置，初始化StringBlocks。那么，我们来看下AssetManager.getSystem。这个方法中调用ensureSystemAssets，ensureSystemAssets代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void ensureSystemAssets() &#123;</div><div class=\"line\">    synchronized (sSync) &#123;</div><div class=\"line\">        if (sSystem == null) &#123;</div><div class=\"line\">            AssetManager system = new AssetManager(true);</div><div class=\"line\">            system.makeStringBlocks(null);</div><div class=\"line\">            sSystem = system;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这里初始化了一个AssetManager，好吧，接着看AssetManager的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AssetManager(boolean isSystem) &#123;</div><div class=\"line\">    if (DEBUG_REFS) &#123;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            mNumRefs = 0;</div><div class=\"line\">            incRefsLocked(this.hashCode());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    init(true);</div><div class=\"line\">    if (localLOGV) Log.v(TAG, &quot;New asset manager: &quot; + this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里调用init去初始化，这是个native函数，实现在android_util_AssetManager.cpp中，对应的方法为android_content_AssetManager_init</p>\n<h4 id=\"android-content-AssetManager-init\"><a href=\"#android-content-AssetManager-init\" class=\"headerlink\" title=\"android_content_AssetManager_init\"></a>android_content_AssetManager_init</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (isSystem) &#123;</div><div class=\"line\">        verifySystemIdmaps();</div><div class=\"line\">    &#125;</div><div class=\"line\">    AssetManager* am = new AssetManager();</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        jniThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, &quot;&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    am-&gt;addDefaultAssets();</div><div class=\"line\"></div><div class=\"line\">    ALOGV(&quot;Created AssetManager %p for Java object %p\\n&quot;, am, clazz);</div><div class=\"line\">    env-&gt;SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast&lt;jlong&gt;(am));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从代码中来看，分为四步</p>\n<ul>\n<li>验证idmaps</li>\n<li>生成c++的AssetManager对象</li>\n<li>添加默认的assets</li>\n<li>设置java层AssetManager的mObject为c++的AssetManager地址。</li>\n</ul>\n<p>我们看添加默认的assets那一步。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::addDefaultAssets()</div><div class=\"line\">&#123;</div><div class=\"line\">    const char* root = getenv(&quot;ANDROID_ROOT&quot;);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(root == NULL, &quot;ANDROID_ROOT not set&quot;);</div><div class=\"line\"></div><div class=\"line\">    String8 path(root);</div><div class=\"line\">    path.appendPath(kSystemAssets);</div><div class=\"line\"></div><div class=\"line\">    return addAssetPath(path, NULL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>ANDROID_ROOT为system</li>\n<li>static const char* kSystemAssets = “framework/framework-res.apk”;</li>\n</ul>\n<p>然后调用addAssetPath两个参数的方法，将framework-res.apk加进去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::addAssetPath(const String8&amp; path, int32_t* cookie)</div><div class=\"line\">&#123;</div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\"></div><div class=\"line\">    asset_path ap;</div><div class=\"line\"></div><div class=\"line\">    String8 realPath(path);</div><div class=\"line\">    if (kAppZipName) &#123;</div><div class=\"line\">        realPath.appendPath(kAppZipName);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ap.type = ::getFileType(realPath.string());</div><div class=\"line\">    if (ap.type == kFileTypeRegular) &#123;</div><div class=\"line\">        ap.path = realPath;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ap.path = path;</div><div class=\"line\">        ap.type = ::getFileType(path.string());</div><div class=\"line\">        if (ap.type != kFileTypeDirectory &amp;&amp; ap.type != kFileTypeRegular) &#123;</div><div class=\"line\">            ALOGW(&quot;Asset path %s is neither a directory nor file (type=%d).&quot;,</div><div class=\"line\">                 path.string(), (int)ap.type);</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Skip if we have it already.</div><div class=\"line\">    for (size_t i=0; i&lt;mAssetPaths.size(); i++) &#123;</div><div class=\"line\">        if (mAssetPaths[i].path == ap.path) &#123;</div><div class=\"line\">            if (cookie) &#123;</div><div class=\"line\">                *cookie = static_cast&lt;int32_t&gt;(i+1);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ALOGV(&quot;In %p Asset %s path: %s&quot;, this,</div><div class=\"line\">         ap.type == kFileTypeDirectory ? &quot;dir&quot; : &quot;zip&quot;, ap.path.string());</div><div class=\"line\"></div><div class=\"line\">    // Check that the path has an AndroidManifest.xml</div><div class=\"line\">    Asset* manifestAsset = const_cast&lt;AssetManager*&gt;(this)-&gt;openNonAssetInPathLocked(</div><div class=\"line\">            kAndroidManifest, Asset::ACCESS_BUFFER, ap);</div><div class=\"line\">    if (manifestAsset == NULL) &#123;</div><div class=\"line\">        // This asset path does not contain any resources.</div><div class=\"line\">        delete manifestAsset;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    delete manifestAsset;</div><div class=\"line\"></div><div class=\"line\">    mAssetPaths.add(ap);</div><div class=\"line\"></div><div class=\"line\">    // new paths are always added at the end</div><div class=\"line\">    if (cookie) &#123;</div><div class=\"line\">        *cookie = static_cast&lt;int32_t&gt;(mAssetPaths.size());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">#ifdef HAVE_ANDROID_OS</div><div class=\"line\">    // Load overlays, if any</div><div class=\"line\">    asset_path oap;</div><div class=\"line\">    for (size_t idx = 0; mZipSet.getOverlay(ap.path, idx, &amp;oap); idx++) &#123;</div><div class=\"line\">        mAssetPaths.add(oap);</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">    if (mResources != NULL) &#123;</div><div class=\"line\">        appendPathToResTable(ap);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>asset_path结构体存储文件路径、文件类型等，结构体定义如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct asset_path</div><div class=\"line\">&#123;</div><div class=\"line\">    asset_path() : path(&quot;&quot;), type(kFileTypeRegular), idmap(&quot;&quot;), isSystemOverlay(false) &#123;&#125;</div><div class=\"line\">    String8 path;</div><div class=\"line\">    FileType type;</div><div class=\"line\">    String8 idmap;</div><div class=\"line\">    bool isSystemOverlay;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>kAppZipName一般为null，static const char* kAppZipName = NULL; //“classes.jar”;</p>\n</li>\n<li>如果已经在mAssetPaths，就反悔</li>\n<li>如果路径下没有AndroidManifest.xml文件，返回false</li>\n<li>添加到mAssetPaths中</li>\n<li>appendPathToResTable将资源进行解析添加</li>\n</ul>\n<h4 id=\"AssetManager-appendPathToResTable\"><a href=\"#AssetManager-appendPathToResTable\" class=\"headerlink\" title=\"AssetManager::appendPathToResTable\"></a>AssetManager::appendPathToResTable</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::appendPathToResTable(const asset_path&amp; ap) const &#123;</div><div class=\"line\">    // skip those ap&apos;s that correspond to system overlays</div><div class=\"line\">    if (ap.isSystemOverlay) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Asset* ass = NULL;</div><div class=\"line\">    ResTable* sharedRes = NULL;</div><div class=\"line\">    bool shared = true;</div><div class=\"line\">    bool onlyEmptyResources = true;</div><div class=\"line\">    MY_TRACE_BEGIN(ap.path.string());</div><div class=\"line\">    Asset* idmap = openIdmapLocked(ap);</div><div class=\"line\">    size_t nextEntryIdx = mResources-&gt;getTableCount();</div><div class=\"line\">    ALOGV(&quot;Looking for resource asset in &apos;%s&apos;\\n&quot;, ap.path.string());</div><div class=\"line\">    if (ap.type != kFileTypeDirectory) &#123;</div><div class=\"line\">        if (nextEntryIdx == 0) &#123;</div><div class=\"line\">            // The first item is typically the framework resources,</div><div class=\"line\">            // which we want to avoid parsing every time.</div><div class=\"line\">            sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                mZipSet.getZipResourceTable(ap.path);</div><div class=\"line\">            if (sharedRes != NULL) &#123;</div><div class=\"line\">                // skip ahead the number of system overlay packages preloaded</div><div class=\"line\">                nextEntryIdx = sharedRes-&gt;getTableCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (sharedRes == NULL) &#123;</div><div class=\"line\">            ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                mZipSet.getZipResourceTableAsset(ap.path);</div><div class=\"line\">            if (ass == NULL) &#123;</div><div class=\"line\">                ALOGV(&quot;loading resource table %s\\n&quot;, ap.path.string());</div><div class=\"line\">                ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                    openNonAssetInPathLocked(&quot;resources.arsc&quot;,</div><div class=\"line\">                                             Asset::ACCESS_BUFFER,</div><div class=\"line\">                                             ap);</div><div class=\"line\">                if (ass != NULL &amp;&amp; ass != kExcludedAsset) &#123;</div><div class=\"line\">                    ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                        mZipSet.setZipResourceTableAsset(ap.path, ass);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            if (nextEntryIdx == 0 &amp;&amp; ass != NULL) &#123;</div><div class=\"line\">                // If this is the first resource table in the asset</div><div class=\"line\">                // manager, then we are going to cache it so that we</div><div class=\"line\">                // can quickly copy it out for others.</div><div class=\"line\">                ALOGV(&quot;Creating shared resources for %s&quot;, ap.path.string());</div><div class=\"line\">                sharedRes = new ResTable();</div><div class=\"line\">                sharedRes-&gt;add(ass, idmap, nextEntryIdx + 1, false);</div><div class=\"line\">#ifdef HAVE_ANDROID_OS</div><div class=\"line\">                const char* data = getenv(&quot;ANDROID_DATA&quot;);</div><div class=\"line\">                LOG_ALWAYS_FATAL_IF(data == NULL, &quot;ANDROID_DATA not set&quot;);</div><div class=\"line\">                String8 overlaysListPath(data);</div><div class=\"line\">                overlaysListPath.appendPath(kResourceCache);</div><div class=\"line\">                overlaysListPath.appendPath(&quot;overlays.list&quot;);</div><div class=\"line\">                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);</div><div class=\"line\">#endif</div><div class=\"line\">                sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                    mZipSet.setZipResourceTable(ap.path, sharedRes);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ALOGV(&quot;loading resource table %s\\n&quot;, ap.path.string());</div><div class=\"line\">        ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">            openNonAssetInPathLocked(&quot;resources.arsc&quot;,</div><div class=\"line\">                                     Asset::ACCESS_BUFFER,</div><div class=\"line\">                                     ap);</div><div class=\"line\">        shared = false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if ((ass != NULL || sharedRes != NULL) &amp;&amp; ass != kExcludedAsset) &#123;</div><div class=\"line\">        ALOGV(&quot;Installing resource asset %p in to table %p\\n&quot;, ass, mResources);</div><div class=\"line\">        if (sharedRes != NULL) &#123;</div><div class=\"line\">            ALOGV(&quot;Copying existing resources for %s&quot;, ap.path.string());</div><div class=\"line\">            mResources-&gt;add(sharedRes);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ALOGV(&quot;Parsing resources for %s&quot;, ap.path.string());</div><div class=\"line\">            mResources-&gt;add(ass, idmap, nextEntryIdx + 1, !shared);</div><div class=\"line\">        &#125;</div><div class=\"line\">        onlyEmptyResources = false;</div><div class=\"line\"></div><div class=\"line\">        if (!shared) &#123;</div><div class=\"line\">            delete ass;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ALOGV(&quot;Installing empty resources in to table %p\\n&quot;, mResources);</div><div class=\"line\">        mResources-&gt;addEmpty(nextEntryIdx + 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (idmap != NULL) &#123;</div><div class=\"line\">        delete idmap;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MY_TRACE_END();</div><div class=\"line\"></div><div class=\"line\">    return onlyEmptyResources;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过openIdmapLocked解析资源包中的idmap表</li>\n<li>ap.type != kFileTypeDirectory，不是目录，就是资源包，如果nextEntryIdx为0，则为framework.apk资源包，解析并保存在sharedRes中，这个是共享的资源。</li>\n<li>sharedRes == NULL 表示为应用资源包，这解析保存在ass中，</li>\n<li>nextEntryIdx == 0 &amp;&amp; ass != NULL，在zygote进程第一次调用才成立，也就是预加载资源，这个时候把framework.apk的资源索引表创建起来，并添加到mZipSet中</li>\n<li>如果是目录，就创建resources.arsc的asset对象，这个不是共享的。</li>\n<li>如果存在sharedRes，就保存到mResources中，否则，这是应用的资源，则把应用的资源加入到mResources中。</li>\n</ul>\n<p>上面的比较乱，总结一下。简单来说就是这样的，就是对资源包进行解析，并加入到mResources中，如果是framework.apk，就是共享的，否则就是应用的资源包，不共享。</p>\n<h3 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">        com.android.internal.R.array.preloaded_drawables);</div></pre></td></tr></table></figure>\n<p>mResources.obtainTypedArray的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public TypedArray obtainTypedArray(@ArrayRes int id)</div><div class=\"line\">        throws NotFoundException &#123;</div><div class=\"line\">    int len = mAssets.getArraySize(id);</div><div class=\"line\">    if (len &lt; 0) &#123;</div><div class=\"line\">        throw new NotFoundException(&quot;Array resource ID #0x&quot;</div><div class=\"line\">                                    + Integer.toHexString(id));</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    TypedArray array = TypedArray.obtain(this, len);</div><div class=\"line\">    array.mLength = mAssets.retrieveArray(id, array.mData);</div><div class=\"line\">    array.mIndices[0] = 0;</div><div class=\"line\">    </div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先获取id对应的数组长度</li>\n<li>然后根据长度生成TypedArray</li>\n<li><p>最后mAssets.retrieveArray赋值，将资源对应的id写入到java层array.mData中。写入部分代码如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dest[STYLE_TYPE] = value.dataType;</div><div class=\"line\">   dest[STYLE_DATA] = value.data;</div><div class=\"line\">   dest[STYLE_ASSET_COOKIE] = block != kXmlBlock ?</div><div class=\"line\">       static_cast&lt;jint&gt;(res.getTableCookie(block)) : -1;</div><div class=\"line\">   dest[STYLE_RESOURCE_ID] = resid;</div><div class=\"line\">   dest[STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;</div><div class=\"line\">   dest[STYLE_DENSITY] = config.density;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"getArraySize获取资源id对应的数组长度\"><a href=\"#getArraySize获取资源id对应的数组长度\" class=\"headerlink\" title=\"getArraySize获取资源id对应的数组长度\"></a>getArraySize获取资源id对应的数组长度</h4><p>这是个native方法，对应的实现在android_util_AssetManager.cpp的android_content_AssetManager_getArraySize方法中，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jint android_content_AssetManager_getArraySize(JNIEnv* env, jobject clazz,</div><div class=\"line\">                                                       jint id)</div><div class=\"line\">&#123;</div><div class=\"line\">    AssetManager* am = assetManagerForJavaObject(env, clazz);</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const ResTable&amp; res(am-&gt;getResources());</div><div class=\"line\"></div><div class=\"line\">    res.lock();</div><div class=\"line\">    const ResTable::bag_entry* defStyleEnt = NULL;</div><div class=\"line\">    ssize_t bagOff = res.getBagLocked(id, &amp;defStyleEnt);</div><div class=\"line\">    res.unlock();</div><div class=\"line\"></div><div class=\"line\">    return static_cast&lt;jint&gt;(bagOff);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先将java对象转换为对应的c++对象，上面有说到过，AssetManager中的mobject字段存的是对应c++中，AssetManager对象的地址，因此，我们很容易做到转换</li>\n<li>通过ResTable的getBagLocked方法获取id，对应的数组长度(该方法的实现在ResourceTypes.cpp中)，实现太长，看不懂，略过。</li>\n</ul>\n<h3 id=\"preloadDrawables来说明资源的预加载过程\"><a href=\"#preloadDrawables来说明资源的预加载过程\" class=\"headerlink\" title=\"preloadDrawables来说明资源的预加载过程\"></a>preloadDrawables来说明资源的预加载过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static int preloadDrawables(VMRuntime runtime, TypedArray ar) &#123;</div><div class=\"line\">    int N = ar.length();</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        int id = ar.getResourceId(i, 0);</div><div class=\"line\">        if (false) &#123;</div><div class=\"line\">            Log.v(TAG, &quot;Preloading resource #&quot; + Integer.toHexString(id));</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (id != 0) &#123;</div><div class=\"line\">            if (mResources.getDrawable(id, null) == null) &#123;</div><div class=\"line\">                throw new IllegalArgumentException(</div><div class=\"line\">                        &quot;Unable to find preloaded drawable resource #0x&quot;</div><div class=\"line\">                        + Integer.toHexString(id)</div><div class=\"line\">                        + &quot; (&quot; + ar.getString(i) + &quot;)&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return N;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先通过getResourceId获取资源id</li>\n<li>getDrawable获取资源</li>\n</ul>\n<h4 id=\"getResourceId-获取资源id\"><a href=\"#getResourceId-获取资源id\" class=\"headerlink\" title=\"getResourceId 获取资源id\"></a>getResourceId 获取资源id</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int getResourceId(int index, int defValue) &#123;</div><div class=\"line\">    if (mRecycled) &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Cannot make calls to a recycled instance!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    index *= AssetManager.STYLE_NUM_ENTRIES;</div><div class=\"line\">    final int[] data = mData;</div><div class=\"line\">    if (data[index+AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) &#123;</div><div class=\"line\">        final int resid = data[index+AssetManager.STYLE_RESOURCE_ID];</div><div class=\"line\">        if (resid != 0) &#123;</div><div class=\"line\">            return resid;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return defValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>其中STYLE_NUM_ENTRIES为6，</li>\n<li>从赋值id的代码中，知道第四个为id值，因此STYLE_RESOURCE_ID为3</li>\n</ul>\n<h4 id=\"getDrawable\"><a href=\"#getDrawable\" class=\"headerlink\" title=\"getDrawable\"></a>getDrawable</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme) throws NotFoundException &#123;</div><div class=\"line\">    TypedValue value;</div><div class=\"line\">    synchronized (mAccessLock) &#123;</div><div class=\"line\">        value = mTmpValue;</div><div class=\"line\">        if (value == null) &#123;</div><div class=\"line\">            value = new TypedValue();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mTmpValue = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        getValue(id, value, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    final Drawable res = loadDrawable(value, id, theme);</div><div class=\"line\">    synchronized (mAccessLock) &#123;</div><div class=\"line\">        if (mTmpValue == null) &#123;</div><div class=\"line\">            mTmpValue = value;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getValue查找与id对应的资源，没找到对应的就抛出NotFoundException异常</li>\n<li>loadDrawable 去加载</li>\n</ul>\n<p>在getValue中，会调用AssetManager的getResourceValue方法，这个是native方法，实现在android_uitl_AssetManager.cpp的android_content_AssetManager_loadResourceValue中</p>\n<h5 id=\"android-content-AssetManager-loadResourceValue\"><a href=\"#android-content-AssetManager-loadResourceValue\" class=\"headerlink\" title=\"android_content_AssetManager_loadResourceValue\"></a>android_content_AssetManager_loadResourceValue</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,</div><div class=\"line\">                                                           jint ident,</div><div class=\"line\">                                                           jshort density,</div><div class=\"line\">                                                           jobject outValue,</div><div class=\"line\">                                                           jboolean resolve)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (outValue == NULL) &#123;</div><div class=\"line\">         jniThrowNullPointerException(env, &quot;outValue&quot;);</div><div class=\"line\">         return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    AssetManager* am = assetManagerForJavaObject(env, clazz);</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const ResTable&amp; res(am-&gt;getResources());</div><div class=\"line\"></div><div class=\"line\">    Res_value value;</div><div class=\"line\">    ResTable_config config;</div><div class=\"line\">    uint32_t typeSpecFlags;</div><div class=\"line\">    ssize_t block = res.getResource(ident, &amp;value, false, density, &amp;typeSpecFlags, &amp;config);</div><div class=\"line\">    if (kThrowOnBadId) &#123;</div><div class=\"line\">        if (block == BAD_INDEX) &#123;</div><div class=\"line\">            jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    uint32_t ref = ident;</div><div class=\"line\">    if (resolve) &#123;</div><div class=\"line\">        block = res.resolveReference(&amp;value, block, &amp;ref, &amp;typeSpecFlags, &amp;config);</div><div class=\"line\">        if (kThrowOnBadId) &#123;</div><div class=\"line\">            if (block == BAD_INDEX) &#123;</div><div class=\"line\">                jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (block &gt;= 0) &#123;</div><div class=\"line\">        return copyValue(env, outValue, &amp;res, value, ref, block, typeSpecFlags, &amp;config);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return static_cast&lt;jint&gt;(block);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>得到ResTable对象</li>\n<li>resolveReference查找是否有匹配的资源</li>\n<li>如果有，就将数据复制给copyValue这个java层对象</li>\n</ul>\n<p>具体的代码就不往下追了。</p>\n<h5 id=\"loadDrawable\"><a href=\"#loadDrawable\" class=\"headerlink\" title=\"loadDrawable\"></a>loadDrawable</h5><p>经过上面的步骤，资源的信息就保存在了TypedValue中，解析来就是通过loadDrawable去加载了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\">Drawable loadDrawable(TypedValue value, int id, Theme theme) throws NotFoundException &#123;</div><div class=\"line\">    if (TRACE_FOR_PRELOAD) &#123;</div><div class=\"line\">        // Log only framework resources</div><div class=\"line\">        if ((id &gt;&gt;&gt; 24) == 0x1) &#123;</div><div class=\"line\">            final String name = getResourceName(id);</div><div class=\"line\">            if (name != null) &#123;</div><div class=\"line\">                Log.d(&quot;PreloadDrawable&quot;, name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final boolean isColorDrawable;</div><div class=\"line\">    final DrawableCache caches;</div><div class=\"line\">    final long key;</div><div class=\"line\">    if (value.type &gt;= TypedValue.TYPE_FIRST_COLOR_INT</div><div class=\"line\">            &amp;&amp; value.type &lt;= TypedValue.TYPE_LAST_COLOR_INT) &#123;</div><div class=\"line\">        isColorDrawable = true;</div><div class=\"line\">        caches = mColorDrawableCache;</div><div class=\"line\">        key = value.data;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        isColorDrawable = false;</div><div class=\"line\">        caches = mDrawableCache;</div><div class=\"line\">        key = (((long) value.assetCookie) &lt;&lt; 32) | value.data;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // First, check whether we have a cached version of this drawable</div><div class=\"line\">    // that was inflated against the specified theme.</div><div class=\"line\">    if (!mPreloading) &#123;</div><div class=\"line\">        final Drawable cachedDrawable = caches.getInstance(key, theme);</div><div class=\"line\">        if (cachedDrawable != null) &#123;</div><div class=\"line\">            return cachedDrawable;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Next, check preloaded drawables. These may contain unresolved theme</div><div class=\"line\">    // attributes.</div><div class=\"line\">    final ConstantState cs;</div><div class=\"line\">    if (isColorDrawable) &#123;</div><div class=\"line\">        cs = sPreloadedColorDrawables.get(key);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Drawable dr;</div><div class=\"line\">    if (cs != null) &#123;</div><div class=\"line\">        dr = cs.newDrawable(this);</div><div class=\"line\">    &#125; else if (isColorDrawable) &#123;</div><div class=\"line\">        dr = new ColorDrawable(value.data);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        dr = loadDrawableForCookie(value, id, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Determine if the drawable has unresolved theme attributes. If it</div><div class=\"line\">    // does, we&apos;ll need to apply a theme and store it in a theme-specific</div><div class=\"line\">    // cache.</div><div class=\"line\">    final boolean canApplyTheme = dr != null &amp;&amp; dr.canApplyTheme();</div><div class=\"line\">    if (canApplyTheme &amp;&amp; theme != null) &#123;</div><div class=\"line\">        dr = dr.mutate();</div><div class=\"line\">        dr.applyTheme(theme);</div><div class=\"line\">        dr.clearMutated();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If we were able to obtain a drawable, store it in the appropriate</div><div class=\"line\">    // cache: preload, not themed, null theme, or theme-specific.</div><div class=\"line\">    if (dr != null) &#123;</div><div class=\"line\">        dr.setChangingConfigurations(value.changingConfigurations);</div><div class=\"line\">        cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return dr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据判断是否是ColorDrawable，赋值不同的cache和key</li>\n<li>如果不是预加载，就从cache中找，找到返回</li>\n<li>从预加载数组中得到key对应的ConstantState</li>\n<li>根据cs是否为null以及是不是ColorDrawable，来得到的Drawable</li>\n<li>设置主题相关的</li>\n<li>进行缓存</li>\n</ul>\n<p>而我们预加载资源的主要过程是loadDrawableForCookie。这个方法是从xml或者流里面加载Drawable。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (file.endsWith(&quot;.xml&quot;)) &#123;</div><div class=\"line\">    final XmlResourceParser rp = loadXmlResourceParser(</div><div class=\"line\">            file, id, value.assetCookie, &quot;drawable&quot;);</div><div class=\"line\">    dr = Drawable.createFromXml(this, rp, theme);</div><div class=\"line\">    rp.close();</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    final InputStream is = mAssets.openNonAsset(</div><div class=\"line\">            value.assetCookie, file, AssetManager.ACCESS_STREAMING);</div><div class=\"line\">    dr = Drawable.createFromResourceStream(this, value, is, file, null);</div><div class=\"line\">    is.close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于Drawable的生成过程，这里就不说了。</p>\n<h3 id=\"占坑\"><a href=\"#占坑\" class=\"headerlink\" title=\"占坑\"></a>占坑</h3><ul>\n<li>aapt资源打包过程</li>\n<li>其他</li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在Zygote进程那篇文章中，提到过，在初始化的时候会预加载系统资源，这样，应用进程在fork了之后，不需要通过加载过程，就可以直接使用这些资源，那么，今天就来看下，这个过程是怎么样的。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"ZygoteInit-preloadResources\"><a href=\"#ZygoteInit-preloadResources\" class=\"headerlink\" title=\"ZygoteInit#preloadResources\"></a>ZygoteInit#preloadResources</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void preloadResources() &#123;</div><div class=\"line\">    final VMRuntime runtime = VMRuntime.getRuntime();</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        mResources = Resources.getSystem();</div><div class=\"line\">        mResources.startPreloading();</div><div class=\"line\">        if (PRELOAD_RESOURCES) &#123;</div><div class=\"line\">            Log.i(TAG, &quot;Preloading resources...&quot;);</div><div class=\"line\"></div><div class=\"line\">            long startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_drawables);</div><div class=\"line\">            int N = preloadDrawables(runtime, ar);</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);</div><div class=\"line\"></div><div class=\"line\">            startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_color_state_lists);</div><div class=\"line\">            N = preloadColorStateLists(runtime, ar);</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mResources.finishPreloading();</div><div class=\"line\">    &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">        Log.w(TAG, &quot;Failure preloading resources&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的过程分为三步</p>\n<ul>\n<li>得到Resources对象</li>\n<li>得到TypedArray对象</li>\n<li>preloadDrawables，preloadColorStateLists 加载资源</li>\n</ul>\n<p>现在，按照上面的三部分来学习下。</p>\n<h3 id=\"Resources-getSystem\"><a href=\"#Resources-getSystem\" class=\"headerlink\" title=\"Resources#getSystem\"></a>Resources#getSystem</h3><p>Resources代码资源，提供了许多方法让我们获取，这里获取的是经过映射的资源，resources.arsc。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Resources getSystem() &#123;</div><div class=\"line\">    synchronized (sSync) &#123;</div><div class=\"line\">        Resources ret = mSystem;</div><div class=\"line\">        if (ret == null) &#123;</div><div class=\"line\">            ret = new Resources();</div><div class=\"line\">            mSystem = ret;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里初始化了一个Resources对象，并且赋值给mSystem变量，那么我们现在看下Resources的构造方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Resources() &#123;</div><div class=\"line\">    mAssets = AssetManager.getSystem();</div><div class=\"line\">    // NOTE: Intentionally leaving this uninitialized (all values set</div><div class=\"line\">    // to zero), so that anyone who tries to do something that requires</div><div class=\"line\">    // metrics will get a very wrong value.</div><div class=\"line\">    mConfiguration.setToDefaults();</div><div class=\"line\">    mMetrics.setToDefaults();</div><div class=\"line\">    updateConfiguration(null, null);</div><div class=\"line\">    mAssets.ensureStringBlocks();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在初始化方法中，通过AssetManager.getSystem获取一个AssetManager对象，这个是用来访问原始资源的(assets目录)。并且，将Configuration和DisplayMetrics都设置默认，更新配置，初始化StringBlocks。那么，我们来看下AssetManager.getSystem。这个方法中调用ensureSystemAssets，ensureSystemAssets代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void ensureSystemAssets() &#123;</div><div class=\"line\">    synchronized (sSync) &#123;</div><div class=\"line\">        if (sSystem == null) &#123;</div><div class=\"line\">            AssetManager system = new AssetManager(true);</div><div class=\"line\">            system.makeStringBlocks(null);</div><div class=\"line\">            sSystem = system;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这里初始化了一个AssetManager，好吧，接着看AssetManager的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AssetManager(boolean isSystem) &#123;</div><div class=\"line\">    if (DEBUG_REFS) &#123;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            mNumRefs = 0;</div><div class=\"line\">            incRefsLocked(this.hashCode());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    init(true);</div><div class=\"line\">    if (localLOGV) Log.v(TAG, &quot;New asset manager: &quot; + this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里调用init去初始化，这是个native函数，实现在android_util_AssetManager.cpp中，对应的方法为android_content_AssetManager_init</p>\n<h4 id=\"android-content-AssetManager-init\"><a href=\"#android-content-AssetManager-init\" class=\"headerlink\" title=\"android_content_AssetManager_init\"></a>android_content_AssetManager_init</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (isSystem) &#123;</div><div class=\"line\">        verifySystemIdmaps();</div><div class=\"line\">    &#125;</div><div class=\"line\">    AssetManager* am = new AssetManager();</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        jniThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, &quot;&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    am-&gt;addDefaultAssets();</div><div class=\"line\"></div><div class=\"line\">    ALOGV(&quot;Created AssetManager %p for Java object %p\\n&quot;, am, clazz);</div><div class=\"line\">    env-&gt;SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast&lt;jlong&gt;(am));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从代码中来看，分为四步</p>\n<ul>\n<li>验证idmaps</li>\n<li>生成c++的AssetManager对象</li>\n<li>添加默认的assets</li>\n<li>设置java层AssetManager的mObject为c++的AssetManager地址。</li>\n</ul>\n<p>我们看添加默认的assets那一步。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::addDefaultAssets()</div><div class=\"line\">&#123;</div><div class=\"line\">    const char* root = getenv(&quot;ANDROID_ROOT&quot;);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(root == NULL, &quot;ANDROID_ROOT not set&quot;);</div><div class=\"line\"></div><div class=\"line\">    String8 path(root);</div><div class=\"line\">    path.appendPath(kSystemAssets);</div><div class=\"line\"></div><div class=\"line\">    return addAssetPath(path, NULL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>ANDROID_ROOT为system</li>\n<li>static const char* kSystemAssets = “framework/framework-res.apk”;</li>\n</ul>\n<p>然后调用addAssetPath两个参数的方法，将framework-res.apk加进去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::addAssetPath(const String8&amp; path, int32_t* cookie)</div><div class=\"line\">&#123;</div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\"></div><div class=\"line\">    asset_path ap;</div><div class=\"line\"></div><div class=\"line\">    String8 realPath(path);</div><div class=\"line\">    if (kAppZipName) &#123;</div><div class=\"line\">        realPath.appendPath(kAppZipName);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ap.type = ::getFileType(realPath.string());</div><div class=\"line\">    if (ap.type == kFileTypeRegular) &#123;</div><div class=\"line\">        ap.path = realPath;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ap.path = path;</div><div class=\"line\">        ap.type = ::getFileType(path.string());</div><div class=\"line\">        if (ap.type != kFileTypeDirectory &amp;&amp; ap.type != kFileTypeRegular) &#123;</div><div class=\"line\">            ALOGW(&quot;Asset path %s is neither a directory nor file (type=%d).&quot;,</div><div class=\"line\">                 path.string(), (int)ap.type);</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Skip if we have it already.</div><div class=\"line\">    for (size_t i=0; i&lt;mAssetPaths.size(); i++) &#123;</div><div class=\"line\">        if (mAssetPaths[i].path == ap.path) &#123;</div><div class=\"line\">            if (cookie) &#123;</div><div class=\"line\">                *cookie = static_cast&lt;int32_t&gt;(i+1);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ALOGV(&quot;In %p Asset %s path: %s&quot;, this,</div><div class=\"line\">         ap.type == kFileTypeDirectory ? &quot;dir&quot; : &quot;zip&quot;, ap.path.string());</div><div class=\"line\"></div><div class=\"line\">    // Check that the path has an AndroidManifest.xml</div><div class=\"line\">    Asset* manifestAsset = const_cast&lt;AssetManager*&gt;(this)-&gt;openNonAssetInPathLocked(</div><div class=\"line\">            kAndroidManifest, Asset::ACCESS_BUFFER, ap);</div><div class=\"line\">    if (manifestAsset == NULL) &#123;</div><div class=\"line\">        // This asset path does not contain any resources.</div><div class=\"line\">        delete manifestAsset;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    delete manifestAsset;</div><div class=\"line\"></div><div class=\"line\">    mAssetPaths.add(ap);</div><div class=\"line\"></div><div class=\"line\">    // new paths are always added at the end</div><div class=\"line\">    if (cookie) &#123;</div><div class=\"line\">        *cookie = static_cast&lt;int32_t&gt;(mAssetPaths.size());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">#ifdef HAVE_ANDROID_OS</div><div class=\"line\">    // Load overlays, if any</div><div class=\"line\">    asset_path oap;</div><div class=\"line\">    for (size_t idx = 0; mZipSet.getOverlay(ap.path, idx, &amp;oap); idx++) &#123;</div><div class=\"line\">        mAssetPaths.add(oap);</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">    if (mResources != NULL) &#123;</div><div class=\"line\">        appendPathToResTable(ap);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>asset_path结构体存储文件路径、文件类型等，结构体定义如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct asset_path</div><div class=\"line\">&#123;</div><div class=\"line\">    asset_path() : path(&quot;&quot;), type(kFileTypeRegular), idmap(&quot;&quot;), isSystemOverlay(false) &#123;&#125;</div><div class=\"line\">    String8 path;</div><div class=\"line\">    FileType type;</div><div class=\"line\">    String8 idmap;</div><div class=\"line\">    bool isSystemOverlay;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>kAppZipName一般为null，static const char* kAppZipName = NULL; //“classes.jar”;</p>\n</li>\n<li>如果已经在mAssetPaths，就反悔</li>\n<li>如果路径下没有AndroidManifest.xml文件，返回false</li>\n<li>添加到mAssetPaths中</li>\n<li>appendPathToResTable将资源进行解析添加</li>\n</ul>\n<h4 id=\"AssetManager-appendPathToResTable\"><a href=\"#AssetManager-appendPathToResTable\" class=\"headerlink\" title=\"AssetManager::appendPathToResTable\"></a>AssetManager::appendPathToResTable</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::appendPathToResTable(const asset_path&amp; ap) const &#123;</div><div class=\"line\">    // skip those ap&apos;s that correspond to system overlays</div><div class=\"line\">    if (ap.isSystemOverlay) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Asset* ass = NULL;</div><div class=\"line\">    ResTable* sharedRes = NULL;</div><div class=\"line\">    bool shared = true;</div><div class=\"line\">    bool onlyEmptyResources = true;</div><div class=\"line\">    MY_TRACE_BEGIN(ap.path.string());</div><div class=\"line\">    Asset* idmap = openIdmapLocked(ap);</div><div class=\"line\">    size_t nextEntryIdx = mResources-&gt;getTableCount();</div><div class=\"line\">    ALOGV(&quot;Looking for resource asset in &apos;%s&apos;\\n&quot;, ap.path.string());</div><div class=\"line\">    if (ap.type != kFileTypeDirectory) &#123;</div><div class=\"line\">        if (nextEntryIdx == 0) &#123;</div><div class=\"line\">            // The first item is typically the framework resources,</div><div class=\"line\">            // which we want to avoid parsing every time.</div><div class=\"line\">            sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                mZipSet.getZipResourceTable(ap.path);</div><div class=\"line\">            if (sharedRes != NULL) &#123;</div><div class=\"line\">                // skip ahead the number of system overlay packages preloaded</div><div class=\"line\">                nextEntryIdx = sharedRes-&gt;getTableCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (sharedRes == NULL) &#123;</div><div class=\"line\">            ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                mZipSet.getZipResourceTableAsset(ap.path);</div><div class=\"line\">            if (ass == NULL) &#123;</div><div class=\"line\">                ALOGV(&quot;loading resource table %s\\n&quot;, ap.path.string());</div><div class=\"line\">                ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                    openNonAssetInPathLocked(&quot;resources.arsc&quot;,</div><div class=\"line\">                                             Asset::ACCESS_BUFFER,</div><div class=\"line\">                                             ap);</div><div class=\"line\">                if (ass != NULL &amp;&amp; ass != kExcludedAsset) &#123;</div><div class=\"line\">                    ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                        mZipSet.setZipResourceTableAsset(ap.path, ass);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            if (nextEntryIdx == 0 &amp;&amp; ass != NULL) &#123;</div><div class=\"line\">                // If this is the first resource table in the asset</div><div class=\"line\">                // manager, then we are going to cache it so that we</div><div class=\"line\">                // can quickly copy it out for others.</div><div class=\"line\">                ALOGV(&quot;Creating shared resources for %s&quot;, ap.path.string());</div><div class=\"line\">                sharedRes = new ResTable();</div><div class=\"line\">                sharedRes-&gt;add(ass, idmap, nextEntryIdx + 1, false);</div><div class=\"line\">#ifdef HAVE_ANDROID_OS</div><div class=\"line\">                const char* data = getenv(&quot;ANDROID_DATA&quot;);</div><div class=\"line\">                LOG_ALWAYS_FATAL_IF(data == NULL, &quot;ANDROID_DATA not set&quot;);</div><div class=\"line\">                String8 overlaysListPath(data);</div><div class=\"line\">                overlaysListPath.appendPath(kResourceCache);</div><div class=\"line\">                overlaysListPath.appendPath(&quot;overlays.list&quot;);</div><div class=\"line\">                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);</div><div class=\"line\">#endif</div><div class=\"line\">                sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                    mZipSet.setZipResourceTable(ap.path, sharedRes);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ALOGV(&quot;loading resource table %s\\n&quot;, ap.path.string());</div><div class=\"line\">        ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">            openNonAssetInPathLocked(&quot;resources.arsc&quot;,</div><div class=\"line\">                                     Asset::ACCESS_BUFFER,</div><div class=\"line\">                                     ap);</div><div class=\"line\">        shared = false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if ((ass != NULL || sharedRes != NULL) &amp;&amp; ass != kExcludedAsset) &#123;</div><div class=\"line\">        ALOGV(&quot;Installing resource asset %p in to table %p\\n&quot;, ass, mResources);</div><div class=\"line\">        if (sharedRes != NULL) &#123;</div><div class=\"line\">            ALOGV(&quot;Copying existing resources for %s&quot;, ap.path.string());</div><div class=\"line\">            mResources-&gt;add(sharedRes);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ALOGV(&quot;Parsing resources for %s&quot;, ap.path.string());</div><div class=\"line\">            mResources-&gt;add(ass, idmap, nextEntryIdx + 1, !shared);</div><div class=\"line\">        &#125;</div><div class=\"line\">        onlyEmptyResources = false;</div><div class=\"line\"></div><div class=\"line\">        if (!shared) &#123;</div><div class=\"line\">            delete ass;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ALOGV(&quot;Installing empty resources in to table %p\\n&quot;, mResources);</div><div class=\"line\">        mResources-&gt;addEmpty(nextEntryIdx + 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (idmap != NULL) &#123;</div><div class=\"line\">        delete idmap;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MY_TRACE_END();</div><div class=\"line\"></div><div class=\"line\">    return onlyEmptyResources;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过openIdmapLocked解析资源包中的idmap表</li>\n<li>ap.type != kFileTypeDirectory，不是目录，就是资源包，如果nextEntryIdx为0，则为framework.apk资源包，解析并保存在sharedRes中，这个是共享的资源。</li>\n<li>sharedRes == NULL 表示为应用资源包，这解析保存在ass中，</li>\n<li>nextEntryIdx == 0 &amp;&amp; ass != NULL，在zygote进程第一次调用才成立，也就是预加载资源，这个时候把framework.apk的资源索引表创建起来，并添加到mZipSet中</li>\n<li>如果是目录，就创建resources.arsc的asset对象，这个不是共享的。</li>\n<li>如果存在sharedRes，就保存到mResources中，否则，这是应用的资源，则把应用的资源加入到mResources中。</li>\n</ul>\n<p>上面的比较乱，总结一下。简单来说就是这样的，就是对资源包进行解析，并加入到mResources中，如果是framework.apk，就是共享的，否则就是应用的资源包，不共享。</p>\n<h3 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">        com.android.internal.R.array.preloaded_drawables);</div></pre></td></tr></table></figure>\n<p>mResources.obtainTypedArray的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public TypedArray obtainTypedArray(@ArrayRes int id)</div><div class=\"line\">        throws NotFoundException &#123;</div><div class=\"line\">    int len = mAssets.getArraySize(id);</div><div class=\"line\">    if (len &lt; 0) &#123;</div><div class=\"line\">        throw new NotFoundException(&quot;Array resource ID #0x&quot;</div><div class=\"line\">                                    + Integer.toHexString(id));</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    TypedArray array = TypedArray.obtain(this, len);</div><div class=\"line\">    array.mLength = mAssets.retrieveArray(id, array.mData);</div><div class=\"line\">    array.mIndices[0] = 0;</div><div class=\"line\">    </div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先获取id对应的数组长度</li>\n<li>然后根据长度生成TypedArray</li>\n<li><p>最后mAssets.retrieveArray赋值，将资源对应的id写入到java层array.mData中。写入部分代码如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dest[STYLE_TYPE] = value.dataType;</div><div class=\"line\">   dest[STYLE_DATA] = value.data;</div><div class=\"line\">   dest[STYLE_ASSET_COOKIE] = block != kXmlBlock ?</div><div class=\"line\">       static_cast&lt;jint&gt;(res.getTableCookie(block)) : -1;</div><div class=\"line\">   dest[STYLE_RESOURCE_ID] = resid;</div><div class=\"line\">   dest[STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;</div><div class=\"line\">   dest[STYLE_DENSITY] = config.density;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"getArraySize获取资源id对应的数组长度\"><a href=\"#getArraySize获取资源id对应的数组长度\" class=\"headerlink\" title=\"getArraySize获取资源id对应的数组长度\"></a>getArraySize获取资源id对应的数组长度</h4><p>这是个native方法，对应的实现在android_util_AssetManager.cpp的android_content_AssetManager_getArraySize方法中，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jint android_content_AssetManager_getArraySize(JNIEnv* env, jobject clazz,</div><div class=\"line\">                                                       jint id)</div><div class=\"line\">&#123;</div><div class=\"line\">    AssetManager* am = assetManagerForJavaObject(env, clazz);</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const ResTable&amp; res(am-&gt;getResources());</div><div class=\"line\"></div><div class=\"line\">    res.lock();</div><div class=\"line\">    const ResTable::bag_entry* defStyleEnt = NULL;</div><div class=\"line\">    ssize_t bagOff = res.getBagLocked(id, &amp;defStyleEnt);</div><div class=\"line\">    res.unlock();</div><div class=\"line\"></div><div class=\"line\">    return static_cast&lt;jint&gt;(bagOff);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先将java对象转换为对应的c++对象，上面有说到过，AssetManager中的mobject字段存的是对应c++中，AssetManager对象的地址，因此，我们很容易做到转换</li>\n<li>通过ResTable的getBagLocked方法获取id，对应的数组长度(该方法的实现在ResourceTypes.cpp中)，实现太长，看不懂，略过。</li>\n</ul>\n<h3 id=\"preloadDrawables来说明资源的预加载过程\"><a href=\"#preloadDrawables来说明资源的预加载过程\" class=\"headerlink\" title=\"preloadDrawables来说明资源的预加载过程\"></a>preloadDrawables来说明资源的预加载过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static int preloadDrawables(VMRuntime runtime, TypedArray ar) &#123;</div><div class=\"line\">    int N = ar.length();</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        int id = ar.getResourceId(i, 0);</div><div class=\"line\">        if (false) &#123;</div><div class=\"line\">            Log.v(TAG, &quot;Preloading resource #&quot; + Integer.toHexString(id));</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (id != 0) &#123;</div><div class=\"line\">            if (mResources.getDrawable(id, null) == null) &#123;</div><div class=\"line\">                throw new IllegalArgumentException(</div><div class=\"line\">                        &quot;Unable to find preloaded drawable resource #0x&quot;</div><div class=\"line\">                        + Integer.toHexString(id)</div><div class=\"line\">                        + &quot; (&quot; + ar.getString(i) + &quot;)&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return N;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先通过getResourceId获取资源id</li>\n<li>getDrawable获取资源</li>\n</ul>\n<h4 id=\"getResourceId-获取资源id\"><a href=\"#getResourceId-获取资源id\" class=\"headerlink\" title=\"getResourceId 获取资源id\"></a>getResourceId 获取资源id</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int getResourceId(int index, int defValue) &#123;</div><div class=\"line\">    if (mRecycled) &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Cannot make calls to a recycled instance!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    index *= AssetManager.STYLE_NUM_ENTRIES;</div><div class=\"line\">    final int[] data = mData;</div><div class=\"line\">    if (data[index+AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) &#123;</div><div class=\"line\">        final int resid = data[index+AssetManager.STYLE_RESOURCE_ID];</div><div class=\"line\">        if (resid != 0) &#123;</div><div class=\"line\">            return resid;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return defValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>其中STYLE_NUM_ENTRIES为6，</li>\n<li>从赋值id的代码中，知道第四个为id值，因此STYLE_RESOURCE_ID为3</li>\n</ul>\n<h4 id=\"getDrawable\"><a href=\"#getDrawable\" class=\"headerlink\" title=\"getDrawable\"></a>getDrawable</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme) throws NotFoundException &#123;</div><div class=\"line\">    TypedValue value;</div><div class=\"line\">    synchronized (mAccessLock) &#123;</div><div class=\"line\">        value = mTmpValue;</div><div class=\"line\">        if (value == null) &#123;</div><div class=\"line\">            value = new TypedValue();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mTmpValue = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        getValue(id, value, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    final Drawable res = loadDrawable(value, id, theme);</div><div class=\"line\">    synchronized (mAccessLock) &#123;</div><div class=\"line\">        if (mTmpValue == null) &#123;</div><div class=\"line\">            mTmpValue = value;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getValue查找与id对应的资源，没找到对应的就抛出NotFoundException异常</li>\n<li>loadDrawable 去加载</li>\n</ul>\n<p>在getValue中，会调用AssetManager的getResourceValue方法，这个是native方法，实现在android_uitl_AssetManager.cpp的android_content_AssetManager_loadResourceValue中</p>\n<h5 id=\"android-content-AssetManager-loadResourceValue\"><a href=\"#android-content-AssetManager-loadResourceValue\" class=\"headerlink\" title=\"android_content_AssetManager_loadResourceValue\"></a>android_content_AssetManager_loadResourceValue</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,</div><div class=\"line\">                                                           jint ident,</div><div class=\"line\">                                                           jshort density,</div><div class=\"line\">                                                           jobject outValue,</div><div class=\"line\">                                                           jboolean resolve)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (outValue == NULL) &#123;</div><div class=\"line\">         jniThrowNullPointerException(env, &quot;outValue&quot;);</div><div class=\"line\">         return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    AssetManager* am = assetManagerForJavaObject(env, clazz);</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const ResTable&amp; res(am-&gt;getResources());</div><div class=\"line\"></div><div class=\"line\">    Res_value value;</div><div class=\"line\">    ResTable_config config;</div><div class=\"line\">    uint32_t typeSpecFlags;</div><div class=\"line\">    ssize_t block = res.getResource(ident, &amp;value, false, density, &amp;typeSpecFlags, &amp;config);</div><div class=\"line\">    if (kThrowOnBadId) &#123;</div><div class=\"line\">        if (block == BAD_INDEX) &#123;</div><div class=\"line\">            jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    uint32_t ref = ident;</div><div class=\"line\">    if (resolve) &#123;</div><div class=\"line\">        block = res.resolveReference(&amp;value, block, &amp;ref, &amp;typeSpecFlags, &amp;config);</div><div class=\"line\">        if (kThrowOnBadId) &#123;</div><div class=\"line\">            if (block == BAD_INDEX) &#123;</div><div class=\"line\">                jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (block &gt;= 0) &#123;</div><div class=\"line\">        return copyValue(env, outValue, &amp;res, value, ref, block, typeSpecFlags, &amp;config);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return static_cast&lt;jint&gt;(block);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>得到ResTable对象</li>\n<li>resolveReference查找是否有匹配的资源</li>\n<li>如果有，就将数据复制给copyValue这个java层对象</li>\n</ul>\n<p>具体的代码就不往下追了。</p>\n<h5 id=\"loadDrawable\"><a href=\"#loadDrawable\" class=\"headerlink\" title=\"loadDrawable\"></a>loadDrawable</h5><p>经过上面的步骤，资源的信息就保存在了TypedValue中，解析来就是通过loadDrawable去加载了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\">Drawable loadDrawable(TypedValue value, int id, Theme theme) throws NotFoundException &#123;</div><div class=\"line\">    if (TRACE_FOR_PRELOAD) &#123;</div><div class=\"line\">        // Log only framework resources</div><div class=\"line\">        if ((id &gt;&gt;&gt; 24) == 0x1) &#123;</div><div class=\"line\">            final String name = getResourceName(id);</div><div class=\"line\">            if (name != null) &#123;</div><div class=\"line\">                Log.d(&quot;PreloadDrawable&quot;, name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final boolean isColorDrawable;</div><div class=\"line\">    final DrawableCache caches;</div><div class=\"line\">    final long key;</div><div class=\"line\">    if (value.type &gt;= TypedValue.TYPE_FIRST_COLOR_INT</div><div class=\"line\">            &amp;&amp; value.type &lt;= TypedValue.TYPE_LAST_COLOR_INT) &#123;</div><div class=\"line\">        isColorDrawable = true;</div><div class=\"line\">        caches = mColorDrawableCache;</div><div class=\"line\">        key = value.data;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        isColorDrawable = false;</div><div class=\"line\">        caches = mDrawableCache;</div><div class=\"line\">        key = (((long) value.assetCookie) &lt;&lt; 32) | value.data;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // First, check whether we have a cached version of this drawable</div><div class=\"line\">    // that was inflated against the specified theme.</div><div class=\"line\">    if (!mPreloading) &#123;</div><div class=\"line\">        final Drawable cachedDrawable = caches.getInstance(key, theme);</div><div class=\"line\">        if (cachedDrawable != null) &#123;</div><div class=\"line\">            return cachedDrawable;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Next, check preloaded drawables. These may contain unresolved theme</div><div class=\"line\">    // attributes.</div><div class=\"line\">    final ConstantState cs;</div><div class=\"line\">    if (isColorDrawable) &#123;</div><div class=\"line\">        cs = sPreloadedColorDrawables.get(key);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Drawable dr;</div><div class=\"line\">    if (cs != null) &#123;</div><div class=\"line\">        dr = cs.newDrawable(this);</div><div class=\"line\">    &#125; else if (isColorDrawable) &#123;</div><div class=\"line\">        dr = new ColorDrawable(value.data);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        dr = loadDrawableForCookie(value, id, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Determine if the drawable has unresolved theme attributes. If it</div><div class=\"line\">    // does, we&apos;ll need to apply a theme and store it in a theme-specific</div><div class=\"line\">    // cache.</div><div class=\"line\">    final boolean canApplyTheme = dr != null &amp;&amp; dr.canApplyTheme();</div><div class=\"line\">    if (canApplyTheme &amp;&amp; theme != null) &#123;</div><div class=\"line\">        dr = dr.mutate();</div><div class=\"line\">        dr.applyTheme(theme);</div><div class=\"line\">        dr.clearMutated();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If we were able to obtain a drawable, store it in the appropriate</div><div class=\"line\">    // cache: preload, not themed, null theme, or theme-specific.</div><div class=\"line\">    if (dr != null) &#123;</div><div class=\"line\">        dr.setChangingConfigurations(value.changingConfigurations);</div><div class=\"line\">        cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return dr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据判断是否是ColorDrawable，赋值不同的cache和key</li>\n<li>如果不是预加载，就从cache中找，找到返回</li>\n<li>从预加载数组中得到key对应的ConstantState</li>\n<li>根据cs是否为null以及是不是ColorDrawable，来得到的Drawable</li>\n<li>设置主题相关的</li>\n<li>进行缓存</li>\n</ul>\n<p>而我们预加载资源的主要过程是loadDrawableForCookie。这个方法是从xml或者流里面加载Drawable。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (file.endsWith(&quot;.xml&quot;)) &#123;</div><div class=\"line\">    final XmlResourceParser rp = loadXmlResourceParser(</div><div class=\"line\">            file, id, value.assetCookie, &quot;drawable&quot;);</div><div class=\"line\">    dr = Drawable.createFromXml(this, rp, theme);</div><div class=\"line\">    rp.close();</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    final InputStream is = mAssets.openNonAsset(</div><div class=\"line\">            value.assetCookie, file, AssetManager.ACCESS_STREAMING);</div><div class=\"line\">    dr = Drawable.createFromResourceStream(this, value, is, file, null);</div><div class=\"line\">    is.close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于Drawable的生成过程，这里就不说了。</p>\n<h3 id=\"占坑\"><a href=\"#占坑\" class=\"headerlink\" title=\"占坑\"></a>占坑</h3><ul>\n<li>aapt资源打包过程</li>\n<li>其他</li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"脚本打怪-shell篇","date":"2016-12-02T17:05:38.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.什么是shell\n\n什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.shell能干什么\n\nshell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。\n\n### 3.shell基础语法\n\n#### 3.1 变量\n```shell\n#变量名＝变量值\nmyname=\"guolei\"\necho ${myname}\n```\nshell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。\n\n如果我们想要定义一个数组怎么办？\n\n```shell\narr=(1 2 3 4)\necho $arr[0]\n```\n\n注意，元素之间没有逗号。\n\n#### 3.2 传递参数\n\n作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0... ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件\n\n\n#### 3.3 输出\n\nshell中有两种输出方式，\n\n* echo \n* printf\n\necho是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。\n\n\n\n### 4.shell运算符\n\n这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 ` `之内，如\n\n```shell\n`expr 2 + 2`\n```\n\n要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。\n\n而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算\n\n* -eq 是否相等,\n* -ne 是否不等\n* -gt 左边是否大于右边\n* -ge 左边是否大于等于右边\n* -lt 左边是否小于右边\n* -le 左边是否小于等于右边\n\n\n老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。\n\n布尔运算也是同理。\n\n* ! 非\n* -o 或\n* -a 与\n\nshell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。\n\n\n\n### 5.shell流程控制\n\nshell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。\n\n```shell\nif\nthen\n\tcommend...\nelse\n\tcommend...\nelif\n\tcommend...\nfi\n\nfor var in 1 2 3 4\ndo\n\tcommend...\ndone\n\nwhile xxx\ndo\n\tcommend...\ndone\n\n//until循环，\nuntil xxx\ndo\n\tcommend\ndone\n\n//case 比较恶心，我很不喜欢，需要用我再去学，嘿\n\nbreak，continue 什么也是有的\n```\n\n\n\n### 6.函数\n\n```shell\nsay(){\n\techo $i\n}\n\nsay 1\n```\n没错，上面就是函数的简单用法。\n\n* 我们不需要手动指定参数\n* 同样用$i 去获取参数\n* 像命令一样say 1 2 3，传递参数\n\n但是，从${10}开始，我们需要用大括号，扩起来。。\n\n### 7. 输入输出重定向\n\n略过略过，> < 将输入输出定向到其他位置（文件）\n\n### 8. 总结\n\nshell脚本学起来 编写起来都挺简单的。\n\n* \\* @，这些都表示全部，比如 $* $@,\n* \\# 哈，可以表示长度，如字符串长度，数组容量\n* 变量赋值 key=value 注意 中间不能有空格\n* 大小比较 -ge那些\n* 函数，通过$? 能获取到返回值，而不能通过赋值来获取\n* 如果参数大于10个，要用$(n)去获取\n\n不过，shell最好的一点是批命令处理。\n\n### 9. 举个小例子？\n\n```shell\ngit pull\n\ngit add ./\n\ngit commit -m \"xxx\"\n\ngit push\n```\n\n很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？\n\n```shell\ncms=\"update\"\n\nhexo g\n\ngit add ./\n\nif [ $# -ge 1 ]\nthen\n\tcms=$1\nfi\n\ngit commit -m $cms\n\ngit push\n\n```\n\n这不，我们通过shell 脚本，每次./update.sh ,多方便啊。\n\n### 10. 想法\n\n想什么呢？还不赶紧去get shell脚本这个技巧。\n\n不写脚本释放双手的程序员，不是好程序员。\n\n\n### 11. 入门链接\n\n[入门教程，看了还不会就可以转行了](http://www.runoob.com/linux/linux-shell.html)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/脚本打怪-shell篇.md","raw":"---\ntitle: 脚本打怪-shell篇\ndate: 2016-12-03 01:05:38\ncategories: shell\ntags: shell\n\n---\n<Excerpt in index | 首页摘要>\n### 1.什么是shell\n\n什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.shell能干什么\n\nshell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。\n\n### 3.shell基础语法\n\n#### 3.1 变量\n```shell\n#变量名＝变量值\nmyname=\"guolei\"\necho ${myname}\n```\nshell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。\n\n如果我们想要定义一个数组怎么办？\n\n```shell\narr=(1 2 3 4)\necho $arr[0]\n```\n\n注意，元素之间没有逗号。\n\n#### 3.2 传递参数\n\n作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0... ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件\n\n\n#### 3.3 输出\n\nshell中有两种输出方式，\n\n* echo \n* printf\n\necho是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。\n\n\n\n### 4.shell运算符\n\n这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 ` `之内，如\n\n```shell\n`expr 2 + 2`\n```\n\n要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。\n\n而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算\n\n* -eq 是否相等,\n* -ne 是否不等\n* -gt 左边是否大于右边\n* -ge 左边是否大于等于右边\n* -lt 左边是否小于右边\n* -le 左边是否小于等于右边\n\n\n老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。\n\n布尔运算也是同理。\n\n* ! 非\n* -o 或\n* -a 与\n\nshell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。\n\n\n\n### 5.shell流程控制\n\nshell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。\n\n```shell\nif\nthen\n\tcommend...\nelse\n\tcommend...\nelif\n\tcommend...\nfi\n\nfor var in 1 2 3 4\ndo\n\tcommend...\ndone\n\nwhile xxx\ndo\n\tcommend...\ndone\n\n//until循环，\nuntil xxx\ndo\n\tcommend\ndone\n\n//case 比较恶心，我很不喜欢，需要用我再去学，嘿\n\nbreak，continue 什么也是有的\n```\n\n\n\n### 6.函数\n\n```shell\nsay(){\n\techo $i\n}\n\nsay 1\n```\n没错，上面就是函数的简单用法。\n\n* 我们不需要手动指定参数\n* 同样用$i 去获取参数\n* 像命令一样say 1 2 3，传递参数\n\n但是，从${10}开始，我们需要用大括号，扩起来。。\n\n### 7. 输入输出重定向\n\n略过略过，> < 将输入输出定向到其他位置（文件）\n\n### 8. 总结\n\nshell脚本学起来 编写起来都挺简单的。\n\n* \\* @，这些都表示全部，比如 $* $@,\n* \\# 哈，可以表示长度，如字符串长度，数组容量\n* 变量赋值 key=value 注意 中间不能有空格\n* 大小比较 -ge那些\n* 函数，通过$? 能获取到返回值，而不能通过赋值来获取\n* 如果参数大于10个，要用$(n)去获取\n\n不过，shell最好的一点是批命令处理。\n\n### 9. 举个小例子？\n\n```shell\ngit pull\n\ngit add ./\n\ngit commit -m \"xxx\"\n\ngit push\n```\n\n很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？\n\n```shell\ncms=\"update\"\n\nhexo g\n\ngit add ./\n\nif [ $# -ge 1 ]\nthen\n\tcms=$1\nfi\n\ngit commit -m $cms\n\ngit push\n\n```\n\n这不，我们通过shell 脚本，每次./update.sh ,多方便啊。\n\n### 10. 想法\n\n想什么呢？还不赶紧去get shell脚本这个技巧。\n\n不写脚本释放双手的程序员，不是好程序员。\n\n\n### 11. 入门链接\n\n[入门教程，看了还不会就可以转行了](http://www.runoob.com/linux/linux-shell.html)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"脚本打怪-shell篇","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm0f006719fy6uhreofc","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-什么是shell\"><a href=\"#1-什么是shell\" class=\"headerlink\" title=\"1.什么是shell\"></a>1.什么是shell</h3><p>什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"2-shell能干什么\"><a href=\"#2-shell能干什么\" class=\"headerlink\" title=\"2.shell能干什么\"></a>2.shell能干什么</h3><p>shell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。</p>\n<h3 id=\"3-shell基础语法\"><a href=\"#3-shell基础语法\" class=\"headerlink\" title=\"3.shell基础语法\"></a>3.shell基础语法</h3><h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#变量名＝变量值</div><div class=\"line\">myname=&quot;guolei&quot;</div><div class=\"line\">echo $&#123;myname&#125;</div></pre></td></tr></table></figure>\n<p>shell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。</p>\n<p>如果我们想要定义一个数组怎么办？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr=(1 2 3 4)</div><div class=\"line\">echo $arr[0]</div></pre></td></tr></table></figure>\n<p>注意，元素之间没有逗号。</p>\n<h4 id=\"3-2-传递参数\"><a href=\"#3-2-传递参数\" class=\"headerlink\" title=\"3.2 传递参数\"></a>3.2 传递参数</h4><p>作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0… ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件</p>\n<h4 id=\"3-3-输出\"><a href=\"#3-3-输出\" class=\"headerlink\" title=\"3.3 输出\"></a>3.3 输出</h4><p>shell中有两种输出方式，</p>\n<ul>\n<li>echo </li>\n<li>printf</li>\n</ul>\n<p>echo是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。</p>\n<h3 id=\"4-shell运算符\"><a href=\"#4-shell运算符\" class=\"headerlink\" title=\"4.shell运算符\"></a>4.shell运算符</h3><p>这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 <code> </code>之内，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">`expr 2 + 2`</div></pre></td></tr></table></figure>\n<p>要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。</p>\n<p>而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算</p>\n<ul>\n<li>-eq 是否相等,</li>\n<li>-ne 是否不等</li>\n<li>-gt 左边是否大于右边</li>\n<li>-ge 左边是否大于等于右边</li>\n<li>-lt 左边是否小于右边</li>\n<li>-le 左边是否小于等于右边</li>\n</ul>\n<p>老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。</p>\n<p>布尔运算也是同理。</p>\n<ul>\n<li>! 非</li>\n<li>-o 或</li>\n<li>-a 与</li>\n</ul>\n<p>shell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。</p>\n<h3 id=\"5-shell流程控制\"><a href=\"#5-shell流程控制\" class=\"headerlink\" title=\"5.shell流程控制\"></a>5.shell流程控制</h3><p>shell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">if</div><div class=\"line\">then</div><div class=\"line\">\tcommend...</div><div class=\"line\">else</div><div class=\"line\">\tcommend...</div><div class=\"line\">elif</div><div class=\"line\">\tcommend...</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">for var in 1 2 3 4</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">while xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//until循环，</div><div class=\"line\">until xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//case 比较恶心，我很不喜欢，需要用我再去学，嘿</div><div class=\"line\"></div><div class=\"line\">break，continue 什么也是有的</div></pre></td></tr></table></figure>\n<h3 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6.函数\"></a>6.函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">say()&#123;</div><div class=\"line\">\techo $i</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">say 1</div></pre></td></tr></table></figure>\n<p>没错，上面就是函数的简单用法。</p>\n<ul>\n<li>我们不需要手动指定参数</li>\n<li>同样用$i 去获取参数</li>\n<li>像命令一样say 1 2 3，传递参数</li>\n</ul>\n<p>但是，从${10}开始，我们需要用大括号，扩起来。。</p>\n<h3 id=\"7-输入输出重定向\"><a href=\"#7-输入输出重定向\" class=\"headerlink\" title=\"7. 输入输出重定向\"></a>7. 输入输出重定向</h3><p>略过略过，&gt; &lt; 将输入输出定向到其他位置（文件）</p>\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h3><p>shell脚本学起来 编写起来都挺简单的。</p>\n<ul>\n<li>* @，这些都表示全部，比如 $* $@,</li>\n<li># 哈，可以表示长度，如字符串长度，数组容量</li>\n<li>变量赋值 key=value 注意 中间不能有空格</li>\n<li>大小比较 -ge那些</li>\n<li>函数，通过$? 能获取到返回值，而不能通过赋值来获取</li>\n<li>如果参数大于10个，要用$(n)去获取</li>\n</ul>\n<p>不过，shell最好的一点是批命令处理。</p>\n<h3 id=\"9-举个小例子？\"><a href=\"#9-举个小例子？\" class=\"headerlink\" title=\"9. 举个小例子？\"></a>9. 举个小例子？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">git commit -m &quot;xxx&quot;</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cms=&quot;update&quot;</div><div class=\"line\"></div><div class=\"line\">hexo g</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">if [ $# -ge 1 ]</div><div class=\"line\">then</div><div class=\"line\">\tcms=$1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">git commit -m $cms</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>这不，我们通过shell 脚本，每次./update.sh ,多方便啊。</p>\n<h3 id=\"10-想法\"><a href=\"#10-想法\" class=\"headerlink\" title=\"10. 想法\"></a>10. 想法</h3><p>想什么呢？还不赶紧去get shell脚本这个技巧。</p>\n<p>不写脚本释放双手的程序员，不是好程序员。</p>\n<h3 id=\"11-入门链接\"><a href=\"#11-入门链接\" class=\"headerlink\" title=\"11. 入门链接\"></a>11. 入门链接</h3><p><a href=\"http://www.runoob.com/linux/linux-shell.html\" target=\"_blank\" rel=\"external\">入门教程，看了还不会就可以转行了</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-什么是shell\"><a href=\"#1-什么是shell\" class=\"headerlink\" title=\"1.什么是shell\"></a>1.什么是shell</h3><p>什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"2-shell能干什么\"><a href=\"#2-shell能干什么\" class=\"headerlink\" title=\"2.shell能干什么\"></a>2.shell能干什么</h3><p>shell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。</p>\n<h3 id=\"3-shell基础语法\"><a href=\"#3-shell基础语法\" class=\"headerlink\" title=\"3.shell基础语法\"></a>3.shell基础语法</h3><h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#变量名＝变量值</div><div class=\"line\">myname=&quot;guolei&quot;</div><div class=\"line\">echo $&#123;myname&#125;</div></pre></td></tr></table></figure>\n<p>shell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。</p>\n<p>如果我们想要定义一个数组怎么办？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr=(1 2 3 4)</div><div class=\"line\">echo $arr[0]</div></pre></td></tr></table></figure>\n<p>注意，元素之间没有逗号。</p>\n<h4 id=\"3-2-传递参数\"><a href=\"#3-2-传递参数\" class=\"headerlink\" title=\"3.2 传递参数\"></a>3.2 传递参数</h4><p>作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0… ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件</p>\n<h4 id=\"3-3-输出\"><a href=\"#3-3-输出\" class=\"headerlink\" title=\"3.3 输出\"></a>3.3 输出</h4><p>shell中有两种输出方式，</p>\n<ul>\n<li>echo </li>\n<li>printf</li>\n</ul>\n<p>echo是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。</p>\n<h3 id=\"4-shell运算符\"><a href=\"#4-shell运算符\" class=\"headerlink\" title=\"4.shell运算符\"></a>4.shell运算符</h3><p>这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 <code> </code>之内，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">`expr 2 + 2`</div></pre></td></tr></table></figure>\n<p>要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。</p>\n<p>而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算</p>\n<ul>\n<li>-eq 是否相等,</li>\n<li>-ne 是否不等</li>\n<li>-gt 左边是否大于右边</li>\n<li>-ge 左边是否大于等于右边</li>\n<li>-lt 左边是否小于右边</li>\n<li>-le 左边是否小于等于右边</li>\n</ul>\n<p>老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。</p>\n<p>布尔运算也是同理。</p>\n<ul>\n<li>! 非</li>\n<li>-o 或</li>\n<li>-a 与</li>\n</ul>\n<p>shell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。</p>\n<h3 id=\"5-shell流程控制\"><a href=\"#5-shell流程控制\" class=\"headerlink\" title=\"5.shell流程控制\"></a>5.shell流程控制</h3><p>shell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">if</div><div class=\"line\">then</div><div class=\"line\">\tcommend...</div><div class=\"line\">else</div><div class=\"line\">\tcommend...</div><div class=\"line\">elif</div><div class=\"line\">\tcommend...</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">for var in 1 2 3 4</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">while xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//until循环，</div><div class=\"line\">until xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//case 比较恶心，我很不喜欢，需要用我再去学，嘿</div><div class=\"line\"></div><div class=\"line\">break，continue 什么也是有的</div></pre></td></tr></table></figure>\n<h3 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6.函数\"></a>6.函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">say()&#123;</div><div class=\"line\">\techo $i</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">say 1</div></pre></td></tr></table></figure>\n<p>没错，上面就是函数的简单用法。</p>\n<ul>\n<li>我们不需要手动指定参数</li>\n<li>同样用$i 去获取参数</li>\n<li>像命令一样say 1 2 3，传递参数</li>\n</ul>\n<p>但是，从${10}开始，我们需要用大括号，扩起来。。</p>\n<h3 id=\"7-输入输出重定向\"><a href=\"#7-输入输出重定向\" class=\"headerlink\" title=\"7. 输入输出重定向\"></a>7. 输入输出重定向</h3><p>略过略过，&gt; &lt; 将输入输出定向到其他位置（文件）</p>\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h3><p>shell脚本学起来 编写起来都挺简单的。</p>\n<ul>\n<li>* @，这些都表示全部，比如 $* $@,</li>\n<li># 哈，可以表示长度，如字符串长度，数组容量</li>\n<li>变量赋值 key=value 注意 中间不能有空格</li>\n<li>大小比较 -ge那些</li>\n<li>函数，通过$? 能获取到返回值，而不能通过赋值来获取</li>\n<li>如果参数大于10个，要用$(n)去获取</li>\n</ul>\n<p>不过，shell最好的一点是批命令处理。</p>\n<h3 id=\"9-举个小例子？\"><a href=\"#9-举个小例子？\" class=\"headerlink\" title=\"9. 举个小例子？\"></a>9. 举个小例子？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">git commit -m &quot;xxx&quot;</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cms=&quot;update&quot;</div><div class=\"line\"></div><div class=\"line\">hexo g</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">if [ $# -ge 1 ]</div><div class=\"line\">then</div><div class=\"line\">\tcms=$1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">git commit -m $cms</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>这不，我们通过shell 脚本，每次./update.sh ,多方便啊。</p>\n<h3 id=\"10-想法\"><a href=\"#10-想法\" class=\"headerlink\" title=\"10. 想法\"></a>10. 想法</h3><p>想什么呢？还不赶紧去get shell脚本这个技巧。</p>\n<p>不写脚本释放双手的程序员，不是好程序员。</p>\n<h3 id=\"11-入门链接\"><a href=\"#11-入门链接\" class=\"headerlink\" title=\"11. 入门链接\"></a>11. 入门链接</h3><p><a href=\"http://www.runoob.com/linux/linux-shell.html\">入门教程，看了还不会就可以转行了</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"记一次折腾之旅-item2","date":"2017-04-01T16:41:32.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n平常的开发学习当中，难免会于终端打交道，但是mac下自带的是在的弱，因此就有了这次的折腾之旅。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 开胃小菜\n\n* item2\n* oh-my-zsh\n\n\n首先我们下载好item2并安装，[item2地址](https://www.iterm2.com/)。然后，我们需要安装下oh-my-zsh.[oh-my-zsh地址](https://github.com/robbyrussell/oh-my-zsh)\n\n这两个步骤都比较简单。没什么可说的。接下来需要配置下item2的配色方案，我这里选的是[solarized](http://ethanschoonover.com/solarized),下载好之后，在item2->preference->profile->color->右下角进行导入并选择。\n\n### powerline\n\n接下来需要安装这个，这个是今天折腾的关键，在安装之前，我们需要确保我们的python环境在2.7版本以上。\n\n```\npython --version\n```\n\n然后，就安装powerline-status这个玩意，这里我们有几种安装的方式.\n\n* pip install powerline-status\n* pip install --user git+git://github.com/powerline/powerline\n* ..其他自行查看文档https://powerline.readthedocs.io/en/latest/installation.html\n\n安装好之后，我们就需要进行配置了，这里需要注意的是，我们这要配置zsh theme，[oh-my-zsh-powerline-theme](https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme)。这里的配置很简单，就是配置.zshrc文件\n\n```\ncd ~\nvim .zshrc\n\n```\n\n打开文件之后，我们进行配置。\n\n```\n ZSH_THEME=\"powerline\"\n #POWERLINE_RIGHT_A=\"data\"\n #POWERLINE_RIGHT_B=\"none\"\n POWERLINE_HIDE_USER_NAME=\"true\"\n POWERLINE_HIDE_HOST_NAME=\"true\"\n POWERLINE_DISABLE_RPROMPT=\"true\"\n```\n\n首先我们设置THEME为powerline。然后在根据需要设置其他的属性，具体请查看[oh-my-zsh-powerline-theme的readme](https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme)\n\n然后,source .zshrc 生效\n\n### 配置字体\n\n在上诉配置之后，会出现乱码，我们还需要配置下字体.\n\n[在这里](https://github.com/powerline/fonts)\n\n然后，在item2的配置选项里，选择字体，即可。\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/记一次折腾之旅-item2.md","raw":"---\ntitle: 记一次折腾之旅-item2\ndate: 2017-04-02 00:41:32\ntags: 杂技\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n平常的开发学习当中，难免会于终端打交道，但是mac下自带的是在的弱，因此就有了这次的折腾之旅。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 开胃小菜\n\n* item2\n* oh-my-zsh\n\n\n首先我们下载好item2并安装，[item2地址](https://www.iterm2.com/)。然后，我们需要安装下oh-my-zsh.[oh-my-zsh地址](https://github.com/robbyrussell/oh-my-zsh)\n\n这两个步骤都比较简单。没什么可说的。接下来需要配置下item2的配色方案，我这里选的是[solarized](http://ethanschoonover.com/solarized),下载好之后，在item2->preference->profile->color->右下角进行导入并选择。\n\n### powerline\n\n接下来需要安装这个，这个是今天折腾的关键，在安装之前，我们需要确保我们的python环境在2.7版本以上。\n\n```\npython --version\n```\n\n然后，就安装powerline-status这个玩意，这里我们有几种安装的方式.\n\n* pip install powerline-status\n* pip install --user git+git://github.com/powerline/powerline\n* ..其他自行查看文档https://powerline.readthedocs.io/en/latest/installation.html\n\n安装好之后，我们就需要进行配置了，这里需要注意的是，我们这要配置zsh theme，[oh-my-zsh-powerline-theme](https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme)。这里的配置很简单，就是配置.zshrc文件\n\n```\ncd ~\nvim .zshrc\n\n```\n\n打开文件之后，我们进行配置。\n\n```\n ZSH_THEME=\"powerline\"\n #POWERLINE_RIGHT_A=\"data\"\n #POWERLINE_RIGHT_B=\"none\"\n POWERLINE_HIDE_USER_NAME=\"true\"\n POWERLINE_HIDE_HOST_NAME=\"true\"\n POWERLINE_DISABLE_RPROMPT=\"true\"\n```\n\n首先我们设置THEME为powerline。然后在根据需要设置其他的属性，具体请查看[oh-my-zsh-powerline-theme的readme](https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme)\n\n然后,source .zshrc 生效\n\n### 配置字体\n\n在上诉配置之后，会出现乱码，我们还需要配置下字体.\n\n[在这里](https://github.com/powerline/fonts)\n\n然后，在item2的配置选项里，选择字体，即可。\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"记一次折腾之旅-item2","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm0g006b19fyodpt8uzw","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>平常的开发学习当中，难免会于终端打交道，但是mac下自带的是在的弱，因此就有了这次的折腾之旅。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"开胃小菜\"><a href=\"#开胃小菜\" class=\"headerlink\" title=\"开胃小菜\"></a>开胃小菜</h3><ul>\n<li>item2</li>\n<li>oh-my-zsh</li>\n</ul>\n<p>首先我们下载好item2并安装，<a href=\"https://www.iterm2.com/\" target=\"_blank\" rel=\"external\">item2地址</a>。然后，我们需要安装下oh-my-zsh.<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"external\">oh-my-zsh地址</a></p>\n<p>这两个步骤都比较简单。没什么可说的。接下来需要配置下item2的配色方案，我这里选的是<a href=\"http://ethanschoonover.com/solarized\" target=\"_blank\" rel=\"external\">solarized</a>,下载好之后，在item2-&gt;preference-&gt;profile-&gt;color-&gt;右下角进行导入并选择。</p>\n<h3 id=\"powerline\"><a href=\"#powerline\" class=\"headerlink\" title=\"powerline\"></a>powerline</h3><p>接下来需要安装这个，这个是今天折腾的关键，在安装之前，我们需要确保我们的python环境在2.7版本以上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python --version</div></pre></td></tr></table></figure>\n<p>然后，就安装powerline-status这个玩意，这里我们有几种安装的方式.</p>\n<ul>\n<li>pip install powerline-status</li>\n<li>pip install –user git+git://github.com/powerline/powerline</li>\n<li>..其他自行查看文档<a href=\"https://powerline.readthedocs.io/en/latest/installation.html\" target=\"_blank\" rel=\"external\">https://powerline.readthedocs.io/en/latest/installation.html</a></li>\n</ul>\n<p>安装好之后，我们就需要进行配置了，这里需要注意的是，我们这要配置zsh theme，<a href=\"https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme\" target=\"_blank\" rel=\"external\">oh-my-zsh-powerline-theme</a>。这里的配置很简单，就是配置.zshrc文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div><div class=\"line\">vim .zshrc</div></pre></td></tr></table></figure>\n<p>打开文件之后，我们进行配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZSH_THEME=&quot;powerline&quot;</div><div class=\"line\">#POWERLINE_RIGHT_A=&quot;data&quot;</div><div class=\"line\">#POWERLINE_RIGHT_B=&quot;none&quot;</div><div class=\"line\">POWERLINE_HIDE_USER_NAME=&quot;true&quot;</div><div class=\"line\">POWERLINE_HIDE_HOST_NAME=&quot;true&quot;</div><div class=\"line\">POWERLINE_DISABLE_RPROMPT=&quot;true&quot;</div></pre></td></tr></table></figure>\n<p>首先我们设置THEME为powerline。然后在根据需要设置其他的属性，具体请查看<a href=\"https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme\" target=\"_blank\" rel=\"external\">oh-my-zsh-powerline-theme的readme</a></p>\n<p>然后,source .zshrc 生效</p>\n<h3 id=\"配置字体\"><a href=\"#配置字体\" class=\"headerlink\" title=\"配置字体\"></a>配置字体</h3><p>在上诉配置之后，会出现乱码，我们还需要配置下字体.</p>\n<p><a href=\"https://github.com/powerline/fonts\" target=\"_blank\" rel=\"external\">在这里</a></p>\n<p>然后，在item2的配置选项里，选择字体，即可。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>平常的开发学习当中，难免会于终端打交道，但是mac下自带的是在的弱，因此就有了这次的折腾之旅。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"开胃小菜\"><a href=\"#开胃小菜\" class=\"headerlink\" title=\"开胃小菜\"></a>开胃小菜</h3><ul>\n<li>item2</li>\n<li>oh-my-zsh</li>\n</ul>\n<p>首先我们下载好item2并安装，<a href=\"https://www.iterm2.com/\">item2地址</a>。然后，我们需要安装下oh-my-zsh.<a href=\"https://github.com/robbyrussell/oh-my-zsh\">oh-my-zsh地址</a></p>\n<p>这两个步骤都比较简单。没什么可说的。接下来需要配置下item2的配色方案，我这里选的是<a href=\"http://ethanschoonover.com/solarized\">solarized</a>,下载好之后，在item2-&gt;preference-&gt;profile-&gt;color-&gt;右下角进行导入并选择。</p>\n<h3 id=\"powerline\"><a href=\"#powerline\" class=\"headerlink\" title=\"powerline\"></a>powerline</h3><p>接下来需要安装这个，这个是今天折腾的关键，在安装之前，我们需要确保我们的python环境在2.7版本以上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python --version</div></pre></td></tr></table></figure>\n<p>然后，就安装powerline-status这个玩意，这里我们有几种安装的方式.</p>\n<ul>\n<li>pip install powerline-status</li>\n<li>pip install –user git+git://github.com/powerline/powerline</li>\n<li>..其他自行查看文档<a href=\"https://powerline.readthedocs.io/en/latest/installation.html\">https://powerline.readthedocs.io/en/latest/installation.html</a></li>\n</ul>\n<p>安装好之后，我们就需要进行配置了，这里需要注意的是，我们这要配置zsh theme，<a href=\"https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme\">oh-my-zsh-powerline-theme</a>。这里的配置很简单，就是配置.zshrc文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div><div class=\"line\">vim .zshrc</div></pre></td></tr></table></figure>\n<p>打开文件之后，我们进行配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZSH_THEME=&quot;powerline&quot;</div><div class=\"line\">#POWERLINE_RIGHT_A=&quot;data&quot;</div><div class=\"line\">#POWERLINE_RIGHT_B=&quot;none&quot;</div><div class=\"line\">POWERLINE_HIDE_USER_NAME=&quot;true&quot;</div><div class=\"line\">POWERLINE_HIDE_HOST_NAME=&quot;true&quot;</div><div class=\"line\">POWERLINE_DISABLE_RPROMPT=&quot;true&quot;</div></pre></td></tr></table></figure>\n<p>首先我们设置THEME为powerline。然后在根据需要设置其他的属性，具体请查看<a href=\"https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme\">oh-my-zsh-powerline-theme的readme</a></p>\n<p>然后,source .zshrc 生效</p>\n<h3 id=\"配置字体\"><a href=\"#配置字体\" class=\"headerlink\" title=\"配置字体\"></a>配置字体</h3><p>在上诉配置之后，会出现乱码，我们还需要配置下字体.</p>\n<p><a href=\"https://github.com/powerline/fonts\">在这里</a></p>\n<p>然后，在item2的配置选项里，选择字体，即可。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"记不住adb命令？试试shell吧","date":"2016-12-20T15:06:36.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. push and pull file\n\n要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。\n\n```shell\n#!/bin/bash\n\nbasedir=\"pull_dir\"\n\nmkdir ${basedir}\n\ntopath=\"./${basedir}/\"\n\nif [ $# = 0 ]\nthen\n\techo 'please input fromfile'\n\texit\nfi\n\nfrompath=$1\n\nadb pull $1 ${topath}\n\n```\n\n```shell\ntopath=\"sdcard/\"\n\nif [ $# = 0 ]\nthen\n\techo \"please input file path\"\n\texit\nfi\n\nfilepath=$1\n\nif [ $# = 2 ]\nthen\n\ttopath=$2\nfi\n\nadb push ${filepath} ${topath}\n\n```\n\n### 3. dumps 一些信息\n\n有时候我们需要dump一些信息出来，比如内存，电量等等。\n\n```shell\n\nfilepath=`./custom.sh`\n\nresult=\"\"\n\nfilename=\"\"\n\nif [ $# = 0 ]\nthen\n\tfilename=\"meminfo_all\"\n\tresult=`adb shell dumpsys meminfo`\nelse\n\tfilename=\"memoinfo_pkg\"\n\tresult=`adb shell dumpsys meminfo $1`\nfi\n\n#echo \"hello\" >> \"${filepath}${filename}\"\necho \"$result\" >> \"${filepath}${filename}\"\n```\n\n```shell\nfilepath=`./custom.sh`\n\nresult=`adb shell dumpsys power`\n\nfilename=\"power_state\"\n\n```\n\n### 4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\n\n[Android测试中常用到的脚本](https://github.com/gb112211/AndroidTestScripts)\n\n### 5. 总结\n\n总之，用shell 和 python等一些脚本，能够做出很多好玩的事。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/记不住adb命令？试试shell吧.md","raw":"---\ntitle: 记不住adb命令？试试shell吧\ndate: 2016-12-20 23:06:36\ncategories: shell\ntags: shell\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. push and pull file\n\n要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。\n\n```shell\n#!/bin/bash\n\nbasedir=\"pull_dir\"\n\nmkdir ${basedir}\n\ntopath=\"./${basedir}/\"\n\nif [ $# = 0 ]\nthen\n\techo 'please input fromfile'\n\texit\nfi\n\nfrompath=$1\n\nadb pull $1 ${topath}\n\n```\n\n```shell\ntopath=\"sdcard/\"\n\nif [ $# = 0 ]\nthen\n\techo \"please input file path\"\n\texit\nfi\n\nfilepath=$1\n\nif [ $# = 2 ]\nthen\n\ttopath=$2\nfi\n\nadb push ${filepath} ${topath}\n\n```\n\n### 3. dumps 一些信息\n\n有时候我们需要dump一些信息出来，比如内存，电量等等。\n\n```shell\n\nfilepath=`./custom.sh`\n\nresult=\"\"\n\nfilename=\"\"\n\nif [ $# = 0 ]\nthen\n\tfilename=\"meminfo_all\"\n\tresult=`adb shell dumpsys meminfo`\nelse\n\tfilename=\"memoinfo_pkg\"\n\tresult=`adb shell dumpsys meminfo $1`\nfi\n\n#echo \"hello\" >> \"${filepath}${filename}\"\necho \"$result\" >> \"${filepath}${filename}\"\n```\n\n```shell\nfilepath=`./custom.sh`\n\nresult=`adb shell dumpsys power`\n\nfilename=\"power_state\"\n\n```\n\n### 4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\n\n[Android测试中常用到的脚本](https://github.com/gb112211/AndroidTestScripts)\n\n### 5. 总结\n\n总之，用shell 和 python等一些脚本，能够做出很多好玩的事。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"记不住adb命令？试试shell吧","published":1,"updated":"2018-04-09T08:34:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfrzsm0h006f19fyfqv27aj6","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"2-push-and-pull-file\"><a href=\"#2-push-and-pull-file\" class=\"headerlink\" title=\"2. push and pull file\"></a>2. push and pull file</h3><p>要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">basedir=&quot;pull_dir&quot;</div><div class=\"line\"></div><div class=\"line\">mkdir $&#123;basedir&#125;</div><div class=\"line\"></div><div class=\"line\">topath=&quot;./$&#123;basedir&#125;/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &apos;please input fromfile&apos;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">frompath=$1</div><div class=\"line\"></div><div class=\"line\">adb pull $1 $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">topath=&quot;sdcard/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &quot;please input file path&quot;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">filepath=$1</div><div class=\"line\"></div><div class=\"line\">if [ $# = 2 ]</div><div class=\"line\">then</div><div class=\"line\">\ttopath=$2</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">adb push $&#123;filepath&#125; $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-dumps-一些信息\"><a href=\"#3-dumps-一些信息\" class=\"headerlink\" title=\"3. dumps 一些信息\"></a>3. dumps 一些信息</h3><p>有时候我们需要dump一些信息出来，比如内存，电量等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">filename=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\tfilename=&quot;meminfo_all&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo`</div><div class=\"line\">else</div><div class=\"line\">\tfilename=&quot;memoinfo_pkg&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo $1`</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">#echo &quot;hello&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div><div class=\"line\">echo &quot;$result&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=`adb shell dumpsys power`</div><div class=\"line\"></div><div class=\"line\">filename=&quot;power_state&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"4-可以利用python-＋-adb命令，实现自动化一些自动化测试\"><a href=\"#4-可以利用python-＋-adb命令，实现自动化一些自动化测试\" class=\"headerlink\" title=\"4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\"></a>4. 可以利用python ＋ adb命令，实现自动化一些自动化测试</h3><p><a href=\"https://github.com/gb112211/AndroidTestScripts\" target=\"_blank\" rel=\"external\">Android测试中常用到的脚本</a></p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>总之，用shell 和 python等一些脚本，能够做出很多好玩的事。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"2-push-and-pull-file\"><a href=\"#2-push-and-pull-file\" class=\"headerlink\" title=\"2. push and pull file\"></a>2. push and pull file</h3><p>要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">basedir=&quot;pull_dir&quot;</div><div class=\"line\"></div><div class=\"line\">mkdir $&#123;basedir&#125;</div><div class=\"line\"></div><div class=\"line\">topath=&quot;./$&#123;basedir&#125;/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &apos;please input fromfile&apos;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">frompath=$1</div><div class=\"line\"></div><div class=\"line\">adb pull $1 $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">topath=&quot;sdcard/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &quot;please input file path&quot;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">filepath=$1</div><div class=\"line\"></div><div class=\"line\">if [ $# = 2 ]</div><div class=\"line\">then</div><div class=\"line\">\ttopath=$2</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">adb push $&#123;filepath&#125; $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-dumps-一些信息\"><a href=\"#3-dumps-一些信息\" class=\"headerlink\" title=\"3. dumps 一些信息\"></a>3. dumps 一些信息</h3><p>有时候我们需要dump一些信息出来，比如内存，电量等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">filename=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\tfilename=&quot;meminfo_all&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo`</div><div class=\"line\">else</div><div class=\"line\">\tfilename=&quot;memoinfo_pkg&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo $1`</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">#echo &quot;hello&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div><div class=\"line\">echo &quot;$result&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=`adb shell dumpsys power`</div><div class=\"line\"></div><div class=\"line\">filename=&quot;power_state&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"4-可以利用python-＋-adb命令，实现自动化一些自动化测试\"><a href=\"#4-可以利用python-＋-adb命令，实现自动化一些自动化测试\" class=\"headerlink\" title=\"4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\"></a>4. 可以利用python ＋ adb命令，实现自动化一些自动化测试</h3><p><a href=\"https://github.com/gb112211/AndroidTestScripts\">Android测试中常用到的脚本</a></p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>总之，用shell 和 python等一些脚本，能够做出很多好玩的事。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjfrzslwn000319fycsmqu1zc","category_id":"cjfrzslwz000819fyidwziwc0","_id":"cjfrzslx5000h19fyydsjew8l"},{"post_id":"cjfrzslx4000f19fy01ygixdy","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxe000n19fytfhxvtxn"},{"post_id":"cjfrzslwu000619fyet5dbx4x","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxg000q19fyl9qkyk2z"},{"post_id":"cjfrzslx6000i19fy6y3usx68","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxi000t19fy0xycaznv"},{"post_id":"cjfrzslxc000l19fykwjch8gf","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxk000x19fykpyymthx"},{"post_id":"cjfrzslx0000a19fy749me5ts","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxl001019fy81s470ag"},{"post_id":"cjfrzslxh000r19fy6vdfvhl0","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxm001419fy1oi6g9z2"},{"post_id":"cjfrzslxj000v19fyx9gi6z2q","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxn001719fyl94tty2y"},{"post_id":"cjfrzslxk000y19fy7ktk6vus","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxp001b19fyqqvw2oud"},{"post_id":"cjfrzslxe000o19fyhxrwc89a","category_id":"cjfrzslxi000s19fynjk93z5v","_id":"cjfrzslxs001e19fy19yppmrr"},{"post_id":"cjfrzslxl001219fyr8cfd1km","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxw001i19fy7bc474ck"},{"post_id":"cjfrzslxm001519fypujie73t","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxy001l19fywx1nfqcr"},{"post_id":"cjfrzslxo001919fyx47eqgif","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslxz001p19fyobfzx2kv"},{"post_id":"cjfrzslxp001c19fydkbl3yi9","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsly1001s19fy175m2io7"},{"post_id":"cjfrzslxs001f19fyd9b7r737","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsly3001w19fyfdloagly"},{"post_id":"cjfrzslxw001j19fykuq2t59y","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsly6001z19fyjuw2kntn"},{"post_id":"cjfrzslxy001m19fyizwbv5es","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsly7002219fyddjksfzn"},{"post_id":"cjfrzslxz001q19fya3x5ssh5","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsly9002619fy0qjvwu7n"},{"post_id":"cjfrzsly1001t19fy1u7pf8fs","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslya002919fy7lyh9g89"},{"post_id":"cjfrzsly4001x19fyflvc3276","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyd002d19fye7nvjh3i"},{"post_id":"cjfrzsly6002019fyfqen4frh","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyh002g19fyht9e74av"},{"post_id":"cjfrzslya002b19fyvt3mcd6a","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyk002k19fybhle3kbu"},{"post_id":"cjfrzslyd002e19fy70r5vv2c","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyl002n19fycuwzqrt7"},{"post_id":"cjfrzslyh002i19fyst01z3iy","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyn002r19fy9p1u4gem"},{"post_id":"cjfrzslyk002l19fyjbg3xd8e","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyo002u19fy56l7qo2x"},{"post_id":"cjfrzslym002p19fyihgnlu3k","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyp002y19fy9ugdqkaa"},{"post_id":"cjfrzslyn002s19fy5anmbtlj","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyr003119fy3lh78eyo"},{"post_id":"cjfrzslyo002w19fyutmbr8ch","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyt003519fy9qq3batb"},{"post_id":"cjfrzslyp002z19fy5l9dt38d","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyv003819fygch6vezk"},{"post_id":"cjfrzslyr003219fyqw72e2z3","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyw003c19fybjzw1bgr"},{"post_id":"cjfrzslyu003619fy80ts6pj8","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyy003f19fy8evqii5u"},{"post_id":"cjfrzslyv003919fy99k30i5i","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslyz003j19fyvtni4a61"},{"post_id":"cjfrzslyx003d19fy9rukjkjs","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslz1003m19fyavfb2qp6"},{"post_id":"cjfrzslyy003g19fyg8e3c313","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslz3003p19fycw1cg1h9"},{"post_id":"cjfrzslz0003k19fyis7gjzz6","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzslz5003t19fyguu7k34b"},{"post_id":"cjfrzslz4003r19fyu1ppvr1s","category_id":"cjfrzslz6003v19fyiuux455h","_id":"cjfrzslzd004519fydn6v35kj"},{"post_id":"cjfrzslzc004419fysyg8ry1o","category_id":"cjfrzslzb004119fy3pt3jqie","_id":"cjfrzslzg004b19fynk5imjhw"},{"post_id":"cjfrzslz5003u19fypit0nxtj","category_id":"cjfrzslzb004119fy3pt3jqie","_id":"cjfrzslzh004g19fyyikg06hb"},{"post_id":"cjfrzslzd004619fy74dp4448","category_id":"cjfrzslzb004119fy3pt3jqie","_id":"cjfrzslzi004j19fy7xbpj02v"},{"post_id":"cjfrzslz6003w19fylpbrj8zp","category_id":"cjfrzslzb004119fy3pt3jqie","_id":"cjfrzslzk004n19fybwvq8vqe"},{"post_id":"cjfrzslz8003z19fy9ec656gv","category_id":"cjfrzslzb004119fy3pt3jqie","_id":"cjfrzslzm004r19fyefyc3xge"},{"post_id":"cjfrzslza004019fybbzc3r8c","category_id":"cjfrzslzb004119fy3pt3jqie","_id":"cjfrzslzp004x19fy48ltch1m"},{"post_id":"cjfrzslze004a19fyz9yun3yz","category_id":"cjfrzslzm004t19fyk9oixgti","_id":"cjfrzslzy005319fy6sq6xtkd"},{"post_id":"cjfrzslzo004w19fykfwhlq3a","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsm00005819fy0by0de0v"},{"post_id":"cjfrzsm01005a19fyu11jv0q5","category_id":"cjfrzslzz005519fy2q3pn1am","_id":"cjfrzsm05005h19fya4oy797u"},{"post_id":"cjfrzslzq005019fyg95jvfps","category_id":"cjfrzslzz005519fy2q3pn1am","_id":"cjfrzsm08005m19fyjve4xepr"},{"post_id":"cjfrzslzx005219fyhyajkpy1","category_id":"cjfrzslzz005519fy2q3pn1am","_id":"cjfrzsm09005p19fyr40ypk30"},{"post_id":"cjfrzsm00005719fytq30atoh","category_id":"cjfrzslzz005519fy2q3pn1am","_id":"cjfrzsm0c005w19fy4fz6ibks"},{"post_id":"cjfrzsm0c005z19fyhr0qlven","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsm0f006519fy5c6f7ero"},{"post_id":"cjfrzsm0d006119fyf77oetcf","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsm0g006819fyik4wz8k2"},{"post_id":"cjfrzsm09005s19fyoayh8e0p","category_id":"cjfrzsm0c005v19fygnzi7dci","_id":"cjfrzsm0h006d19fyp5bxu6ck"},{"post_id":"cjfrzsm0e006419fyaahqwk30","category_id":"cjfrzslx4000e19fys76tj8j9","_id":"cjfrzsm0i006g19fyo383o7gc"},{"post_id":"cjfrzsm0f006719fy6uhreofc","category_id":"cjfrzsm0h006c19fys6bx3btg","_id":"cjfrzsm0l006n19fyv7xbvlcr"},{"post_id":"cjfrzsm0h006f19fyfqv27aj6","category_id":"cjfrzsm0h006c19fys6bx3btg","_id":"cjfrzsm0m006r19fyerfm63at"}],"PostTag":[{"post_id":"cjfrzslwi000119fyk6ogdczt","tag_id":"cjfrzslwr000519fyxx4qg5bx","_id":"cjfrzslx3000c19fyjai83zvr"},{"post_id":"cjfrzslwn000319fycsmqu1zc","tag_id":"cjfrzslx1000b19fyxs6vqoek","_id":"cjfrzslx8000j19fy5dff2y3k"},{"post_id":"cjfrzslwu000619fyet5dbx4x","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslxf000p19fy59gpiy6z"},{"post_id":"cjfrzslwz000919fyc17sxdrt","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzslxk000w19fys4za7ldx"},{"post_id":"cjfrzslxh000r19fy6vdfvhl0","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslxl000z19fyfd4fur7y"},{"post_id":"cjfrzslxj000v19fyx9gi6z2q","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslxm001319fy2f37emi5"},{"post_id":"cjfrzslx0000a19fy749me5ts","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslxn001619fy49smg554"},{"post_id":"cjfrzslxk000y19fy7ktk6vus","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslxo001a19fyhl561vhb"},{"post_id":"cjfrzslxl001219fyr8cfd1km","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslxs001d19fyd051or65"},{"post_id":"cjfrzslx3000d19fyl3g8tzeo","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzslxv001h19fy98sjfia6"},{"post_id":"cjfrzslxp001c19fydkbl3yi9","tag_id":"cjfrzslxn001819fyyv6zn0ao","_id":"cjfrzslxy001k19fyqowtl7wj"},{"post_id":"cjfrzslx4000f19fy01ygixdy","tag_id":"cjfrzslxn001819fyyv6zn0ao","_id":"cjfrzslxz001o19fyiv3go185"},{"post_id":"cjfrzslx6000i19fy6y3usx68","tag_id":"cjfrzslxt001g19fyopsb4nrm","_id":"cjfrzsly1001r19fyd1otkvfq"},{"post_id":"cjfrzslxz001q19fya3x5ssh5","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzsly3001v19fye6isp06e"},{"post_id":"cjfrzslxc000l19fykwjch8gf","tag_id":"cjfrzslxz001n19fyv82b5jfj","_id":"cjfrzsly6001y19fyflp213kc"},{"post_id":"cjfrzsly1001t19fy1u7pf8fs","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzsly7002119fyd0jzy0jp"},{"post_id":"cjfrzsly4001x19fyflvc3276","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzsly9002519fy3szxduaf"},{"post_id":"cjfrzslxe000o19fyhxrwc89a","tag_id":"cjfrzsly3001u19fydzkuw2im","_id":"cjfrzsly9002819fyc13apagm"},{"post_id":"cjfrzsly6002019fyfqen4frh","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslyd002c19fyq3bvl7z0"},{"post_id":"cjfrzsly8002419fyjhkzzulj","tag_id":"cjfrzslxz001n19fyv82b5jfj","_id":"cjfrzslyg002f19fyypqwhsna"},{"post_id":"cjfrzslxm001519fypujie73t","tag_id":"cjfrzslxz001n19fyv82b5jfj","_id":"cjfrzslyk002j19fyzvf2v8mq"},{"post_id":"cjfrzsly9002719fy2jgq776k","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzslyl002m19fytt0h0xfv"},{"post_id":"cjfrzslxo001919fyx47eqgif","tag_id":"cjfrzslxn001819fyyv6zn0ao","_id":"cjfrzslyn002q19fy2qivo37a"},{"post_id":"cjfrzslyh002i19fyst01z3iy","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslyo002t19fyc0m4lrkg"},{"post_id":"cjfrzslxs001f19fyd9b7r737","tag_id":"cjfrzslxz001n19fyv82b5jfj","_id":"cjfrzslyp002x19fyb5e3qe7o"},{"post_id":"cjfrzslym002p19fyihgnlu3k","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslyr003019fycb8hso66"},{"post_id":"cjfrzslxw001j19fykuq2t59y","tag_id":"cjfrzslxz001n19fyv82b5jfj","_id":"cjfrzslyt003419fye9yht1ip"},{"post_id":"cjfrzslyn002s19fy5anmbtlj","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzslyu003719fygkv0aosh"},{"post_id":"cjfrzslyo002w19fyutmbr8ch","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzslyw003b19fyxysixs9p"},{"post_id":"cjfrzslyp002z19fy5l9dt38d","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzslyy003e19fy73c76zxs"},{"post_id":"cjfrzslxy001m19fyizwbv5es","tag_id":"cjfrzslyo002v19fyodumk1oa","_id":"cjfrzslyz003i19fy0tlyvlgx"},{"post_id":"cjfrzslya002b19fyvt3mcd6a","tag_id":"cjfrzslyt003319fyhdi6mikr","_id":"cjfrzslz1003l19fyeygx5oao"},{"post_id":"cjfrzslyd002e19fy70r5vv2c","tag_id":"cjfrzslyw003a19fyah8ch6jh","_id":"cjfrzslz3003o19fykmis5w6u"},{"post_id":"cjfrzslyk002l19fyjbg3xd8e","tag_id":"cjfrzslyz003h19fytm55nyi5","_id":"cjfrzslz5003s19fyf7iaepay"},{"post_id":"cjfrzslyr003219fyqw72e2z3","tag_id":"cjfrzslz3003q19fy6m32nrh3","_id":"cjfrzslz8003y19fyee1kjevd"},{"post_id":"cjfrzslyu003619fy80ts6pj8","tag_id":"cjfrzslz3003q19fy6m32nrh3","_id":"cjfrzslzc004319fyrhjqt8qw"},{"post_id":"cjfrzslyv003919fy99k30i5i","tag_id":"cjfrzslz3003q19fy6m32nrh3","_id":"cjfrzslze004919fy0oca78lq"},{"post_id":"cjfrzslze004a19fyz9yun3yz","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzslzh004f19fyi0p812mq"},{"post_id":"cjfrzslyx003d19fy9rukjkjs","tag_id":"cjfrzslz3003q19fy6m32nrh3","_id":"cjfrzslzi004i19fystd6rt2v"},{"post_id":"cjfrzslyy003g19fyg8e3c313","tag_id":"cjfrzslz3003q19fy6m32nrh3","_id":"cjfrzslzk004o19fyg5a2srcf"},{"post_id":"cjfrzslz0003k19fyis7gjzz6","tag_id":"cjfrzslz3003q19fy6m32nrh3","_id":"cjfrzslzn004u19fyttc8yxvh"},{"post_id":"cjfrzslzn004v19fylsdenjic","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzslzp004z19fyszrfkjlt"},{"post_id":"cjfrzslz2003n19fy77l1v9j6","tag_id":"cjfrzslzm004s19fywx6u1tay","_id":"cjfrzslzx005119fy02b9w0hm"},{"post_id":"cjfrzslzo004w19fykfwhlq3a","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzslzz005619fyxrwy29dy"},{"post_id":"cjfrzslzq005019fyg95jvfps","tag_id":"cjfrzslzm004s19fywx6u1tay","_id":"cjfrzsm01005919fysb5z1p00"},{"post_id":"cjfrzslz4003r19fyu1ppvr1s","tag_id":"cjfrzslzp004y19fyun6y4jwg","_id":"cjfrzsm02005b19fynpa7suui"},{"post_id":"cjfrzslzx005219fyhyajkpy1","tag_id":"cjfrzslzm004s19fywx6u1tay","_id":"cjfrzsm04005f19fyyk2okhdk"},{"post_id":"cjfrzsm00005719fytq30atoh","tag_id":"cjfrzslzm004s19fywx6u1tay","_id":"cjfrzsm05005i19fyaltq7qls"},{"post_id":"cjfrzslz5003u19fypit0nxtj","tag_id":"cjfrzslzy005419fyzup0t98a","_id":"cjfrzsm08005n19fypzy553kr"},{"post_id":"cjfrzsm01005a19fyu11jv0q5","tag_id":"cjfrzslzm004s19fywx6u1tay","_id":"cjfrzsm09005q19fyqpuk1wmv"},{"post_id":"cjfrzslz6003w19fylpbrj8zp","tag_id":"cjfrzslzy005419fyzup0t98a","_id":"cjfrzsm0a005t19fyvxmqr1il"},{"post_id":"cjfrzsm04005g19fy7rfxv6k4","tag_id":"cjfrzslxn001819fyyv6zn0ao","_id":"cjfrzsm0c005x19fy3ehup5ck"},{"post_id":"cjfrzslz8003z19fy9ec656gv","tag_id":"cjfrzslzy005419fyzup0t98a","_id":"cjfrzsm0d006019fy8kaw8qau"},{"post_id":"cjfrzsm08005o19fyg9xghw6n","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzsm0e006219fywnaul4ut"},{"post_id":"cjfrzsm09005s19fyoayh8e0p","tag_id":"cjfrzslxd000m19fyi42z7099","_id":"cjfrzsm0f006619fyzs205w53"},{"post_id":"cjfrzslza004019fybbzc3r8c","tag_id":"cjfrzslzy005419fyzup0t98a","_id":"cjfrzsm0g006919fyskyvxznd"},{"post_id":"cjfrzsm0c005z19fyhr0qlven","tag_id":"cjfrzslyw003a19fyah8ch6jh","_id":"cjfrzsm0h006e19fyjhk0r8cb"},{"post_id":"cjfrzslzc004419fysyg8ry1o","tag_id":"cjfrzslzy005419fyzup0t98a","_id":"cjfrzsm0i006h19fy7br1otj7"},{"post_id":"cjfrzsm0e006419fyaahqwk30","tag_id":"cjfrzslx5000g19fyipzoghd3","_id":"cjfrzsm0j006j19fyfscb3zgk"},{"post_id":"cjfrzslzd004619fy74dp4448","tag_id":"cjfrzslzy005419fyzup0t98a","_id":"cjfrzsm0k006l19fyduufzf15"},{"post_id":"cjfrzslzg004c19fyzqef31au","tag_id":"cjfrzsm0g006a19fyu0vwktik","_id":"cjfrzsm0l006o19fywqrryd56"},{"post_id":"cjfrzslzi004h19fy13jyc4v2","tag_id":"cjfrzsm0g006a19fyu0vwktik","_id":"cjfrzsm0l006p19fy504xzb61"},{"post_id":"cjfrzslzi004k19fybzadc66n","tag_id":"cjfrzsm0g006a19fyu0vwktik","_id":"cjfrzsm0m006s19fyo2nd5g6w"},{"post_id":"cjfrzslzk004p19fy9cpk4gfb","tag_id":"cjfrzsm0g006a19fyu0vwktik","_id":"cjfrzsm0m006u19fyckejajd3"},{"post_id":"cjfrzslzl004q19fyf4mgbhlc","tag_id":"cjfrzsm0m006t19fylmz12q7z","_id":"cjfrzsm0n006w19fyfsqc5zf2"},{"post_id":"cjfrzsm03005d19fyl7399iv2","tag_id":"cjfrzsm0m006v19fyexr28vw7","_id":"cjfrzsm0n006y19fyju0zu91w"},{"post_id":"cjfrzsm05005k19fyazoajbxr","tag_id":"cjfrzsm0n006x19fy54ij4lgn","_id":"cjfrzsm0o007019fy72us822a"},{"post_id":"cjfrzsm0a005u19fymf006yuq","tag_id":"cjfrzsm0n006z19fynshjzig8","_id":"cjfrzsm0o007219fy7t6vyyhu"},{"post_id":"cjfrzsm0d006119fyf77oetcf","tag_id":"cjfrzsm0o007119fyfrfkvp6c","_id":"cjfrzsm0o007519fy6c4vbp17"},{"post_id":"cjfrzsm0d006119fyf77oetcf","tag_id":"cjfrzsm0o007319fy0imyg8nw","_id":"cjfrzsm0o007619fy8hvsr8hb"},{"post_id":"cjfrzsm0f006719fy6uhreofc","tag_id":"cjfrzsm0o007419fyxrhmpnjp","_id":"cjfrzsm0p007819fys9lfvh4a"},{"post_id":"cjfrzsm0g006b19fyodpt8uzw","tag_id":"cjfrzsm0o007719fyi5nrjhlj","_id":"cjfrzsm0p007a19fy1kv2lyo5"},{"post_id":"cjfrzsm0h006f19fyfqv27aj6","tag_id":"cjfrzsm0o007419fyxrhmpnjp","_id":"cjfrzsm0p007b19fy99uwzycz"}],"Tag":[{"name":"职业生涯","_id":"cjfrzslwr000519fyxx4qg5bx"},{"name":"计划总结","_id":"cjfrzslx1000b19fyxs6vqoek"},{"name":"framework","_id":"cjfrzslx5000g19fyipzoghd3"},{"name":"Android","_id":"cjfrzslxd000m19fyi42z7099"},{"name":"jni","_id":"cjfrzslxn001819fyyv6zn0ao"},{"name":"安全","_id":"cjfrzslxt001g19fyopsb4nrm"},{"name":"源码","_id":"cjfrzslxz001n19fyv82b5jfj"},{"name":"Andrid","_id":"cjfrzsly3001u19fydzkuw2im"},{"name":"动画","_id":"cjfrzslyo002v19fyodumk1oa"},{"name":"Xposed","_id":"cjfrzslyt003319fyhdi6mikr"},{"name":"插件化","_id":"cjfrzslyw003a19fyah8ch6jh"},{"name":"Android源码","_id":"cjfrzslyz003h19fytm55nyi5"},{"name":"fresco","_id":"cjfrzslz3003q19fy6m32nrh3"},{"name":"gradle","_id":"cjfrzslzm004s19fywx6u1tay"},{"name":"hexo","_id":"cjfrzslzp004y19fyun6y4jwg"},{"name":"jvm","_id":"cjfrzslzy005419fyzup0t98a"},{"name":"tinker","_id":"cjfrzsm0g006a19fyu0vwktik"},{"name":"测试","_id":"cjfrzsm0m006t19fylmz12q7z"},{"name":"程序设计","_id":"cjfrzsm0m006v19fyexr28vw7"},{"name":"杂谈","_id":"cjfrzsm0n006x19fy54ij4lgn"},{"name":"增量升级","_id":"cjfrzsm0n006z19fynshjzig8"},{"name":"android","_id":"cjfrzsm0o007119fyfrfkvp6c"},{"name":"消息机制","_id":"cjfrzsm0o007319fy0imyg8nw"},{"name":"shell","_id":"cjfrzsm0o007419fyxrhmpnjp"},{"name":"杂技","_id":"cjfrzsm0o007719fyi5nrjhlj"}]}}