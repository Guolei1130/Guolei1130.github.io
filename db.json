{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"909a2b39bf012a9bb70865f9ba4569a08b165adb","modified":1483674706000},{"_id":"themes/next/README.en.md","hash":"3b0c7998cf17f9cf9e1a5bfcd65679a43a00c817","modified":1483546612000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1483546612000},{"_id":"themes/next/_config.yml","hash":"68ebf7e4d63ed0fe7361df3a929bd37df28dceca","modified":1483772767000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1483546612000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1483546612000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1483546612000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1483680474000},{"_id":"source/_posts/2017学习计划.md","hash":"d531ba63ebc503d6e41425f72c3033dd7ea773c8","modified":1484143638000},{"_id":"source/_posts/AndroidJNI学习笔记（四）－数据类型映射以及native调用java.md","hash":"aa4a84909948e765fd062b9f2c48f5b230cfdf9e","modified":1483772267000},{"_id":"source/_posts/AMS中的进程管理部分－上.md","hash":"74a2ff3347621aed25d0a3e99d579d4f847ed1f8","modified":1483772221000},{"_id":"source/_posts/Activity启动流程.md","hash":"538e5474e9061e71c08de9ef65c214e12c5ee232","modified":1483772215000},{"_id":"source/_posts/Android消息机制浅析.md","hash":"0dab392311fd6ef7c85c84787a0503e9e8cf11c7","modified":1483772250000},{"_id":"source/_posts/Android应用程序是如何安装的.md","hash":"b82740ab300e2ad83f96a827370d6981872a7c70","modified":1483772257000},{"_id":"source/_posts/JNI学习笔记（二）－动态注册native函数.md","hash":"ec5ad7c6f7ae8289aa70b460779c94a678c1e1c7","modified":1483772323000},{"_id":"source/_posts/Android消息机制－native层.md","hash":"0a87df7414e7c34abf172207114ceb50dca6e5bd","modified":1483772228000},{"_id":"source/_posts/ContentProvider水文(凑四大组件).md","hash":"b841e72ab1cdafb5cb391e141e3ec09bbcf45a8e","modified":1483772276000},{"_id":"source/_posts/LruCache源码浅析.md","hash":"adae7038a82152527d061d20baa32ec107c7bc98","modified":1484236879000},{"_id":"source/_posts/JNI学习笔记（三）－编译文件makefile以及cmake.md","hash":"897cf4fe774f1af4e65e9872bcd4f5fd5646ea49","modified":1483772328000},{"_id":"source/_posts/Service启动流程.md","hash":"24ec92cbfe20f28dc9381807249623a4ce77b8c1","modified":1483772339000},{"_id":"source/_posts/PMS初始化做了什么.md","hash":"5cdef154bb989f98892fa4836948b2827a526fce","modified":1483772334000},{"_id":"source/_posts/SystemServer进程的初始化.md","hash":"0d0fbcb84edb34d653b257186ddef9ba161a58a8","modified":1483800420000},{"_id":"source/_posts/ThreadLocal源码浅析.md","hash":"2be1e17797d7902b1d7ab4b33bd331219f92f97c","modified":1484317527000},{"_id":"source/_posts/Zygote进程的初始化.md","hash":"01dc0d3e14639a65cf6484c81f13e0bb8fc7ad9d","modified":1483771945000},{"_id":"source/_posts/broadcast流程浅析.md","hash":"1cc3801592d5a1d81b7c42bb9911fadc47039bcf","modified":1483772271000},{"_id":"source/_posts/fresco内存管理.md","hash":"9f50bd70b994022c42863485985c7e8266b3f995","modified":1483772293000},{"_id":"source/_posts/fresco初始化过程.md","hash":"d1721f871a36b88898feda816473b3a8450f9e2c","modified":1483772281000},{"_id":"source/_posts/android应用进程是如何启动的.md","hash":"739827217e5a18c5356e5cb36c8f6c16ba3831c7","modified":1483772263000},{"_id":"source/_posts/fresco生产者Producer.md","hash":"4897e9bbaf82ed49ded97e31c72685aa2caeb6a7","modified":1483772299000},{"_id":"source/_posts/fresco加载数据.md","hash":"e9f93efc8c950612208068ccf5a0ac6a2b2da72b","modified":1483772286000},{"_id":"source/_posts/hexo+github pages搭建个人博客.md","hash":"6e2893a01a6fe4e2c083b325ed0d1db7e8c9806e","modified":1483772316000},{"_id":"source/_posts/jvm垃圾回收.md","hash":"b60f937c52f10c0606861ff8012d8b39b266d4b9","modified":1484395299000},{"_id":"source/_posts/fresco图片decode的大体流程.md","hash":"229930cfb3b827a73107cf49c573df7f69dea175","modified":1483772304000},{"_id":"source/_posts/java内存区域.md","hash":"9821bdddcabbdafce7dd5f36792cafec3d033735","modified":1484227987000},{"_id":"source/_posts/jvm类加载机制.md","hash":"f36cd677952e615cefac13756b39fdc6e19d9c9e","modified":1484665248000},{"_id":"source/_posts/了解gradle（二）-扩展gradle.md","hash":"81add33d3dc61d41c959d8ef3a7982b2ba09757e","modified":1483772195000},{"_id":"source/_posts/fresco用法.md","hash":"04fc8087db54722e50ed20fd8cd2822b8a52ca21","modified":1483772310000},{"_id":"source/_posts/了解gradle（一）.md","hash":"d1a5345ed21ab21dc07d8eb2d1c20e5468d7fba6","modified":1483772202000},{"_id":"source/_posts/消息机制在多进程的应用.md","hash":"ac702f9303f54f43be1cda3241fde7ee4a7b6d3f","modified":1483772208000},{"_id":"source/_posts/记不住adb命令？试试shell吧.md","hash":"ed156a2f4191131999238f8e721cb5a75fc62cff","modified":1483772182000},{"_id":"source/_posts/脚本打怪-shell篇.md","hash":"233db99282b48bf0aeaf8a64479acf5d18ef8b21","modified":1483772189000},{"_id":"source/_posts/系统资源的预加载过程.md","hash":"b1d5a2dbab7371bdb8d37f65789dfb2ec49af606","modified":1483946305000},{"_id":"source/tags/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1483674056000},{"_id":"source/me/index.md","hash":"dbcbd176383a48c9e1e191b763b4471069415f95","modified":1483772744000},{"_id":"source/tags/index.md","hash":"32ec9646ff7f68226c93fb8b8d1aca5daab69378","modified":1483674279000},{"_id":"source/categories/index.md","hash":"d24696dbb2f94391363d5cf384c115a00b9a68b0","modified":1483674417000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1483546612000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1483546612000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1483546612000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1483546612000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1483546612000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1483546612000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1483546612000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1483546612000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1483546612000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1483546612000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1483546612000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1483546612000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1483546612000},{"_id":"themes/next/layout/_layout.swig","hash":"2fa3c74066843a859fac77803324a1de51044da9","modified":1483546612000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1483546612000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1483546612000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1483546612000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1483546612000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1483546612000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1483546612000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1483546612000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1483546612000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1483546612000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1483546612000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1483546612000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1483546612000},{"_id":"themes/next/layout/_macro/post.swig","hash":"e6016def9b512188f4c2725399c9adc7bc41cdae","modified":1483546612000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1483546612000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1483546612000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1483546612000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1483546612000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"78ccfc1dc915247c1fec3c86d742e0f4c2f6d99c","modified":1483546612000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1483546612000},{"_id":"themes/next/layout/_partials/header.swig","hash":"adab5c3f7b173f1b45454787f39dde07aea03483","modified":1483546612000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1483546612000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1483546612000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1483546612000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1483546612000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1483546612000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1483546612000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1483546612000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1483546612000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1483546612000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1483546612000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1483546612000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1483546612000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1483546612000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1483546612000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1483546612000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1483546612000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1483546612000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483546612000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483546612000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483546612000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1483546612000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1483546612000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483546612000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1483546612000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1483546612000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1483546612000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483546612000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1483546612000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1483546612000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1483546612000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1483546612000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1483546612000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1483546612000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1483546612000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1483546612000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1483546612000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1483546612000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1483546612000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"4abc01bc870e1d7a783cdbd26166edc782a6a4f4","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1483546612000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1483546612000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1483546612000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fc185c6cec79593775d1c2440dbe2a71cfbe2e99","modified":1483546612000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c459aa6d607d8bcb747544e74f6ad0b8374aa3b1","modified":1483546612000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1483546612000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1483546612000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1483546612000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1483546612000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1483546612000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1483546612000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1483546612000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1483546612000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1483546612000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1483546612000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1483546612000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1483546612000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1483546612000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1483546612000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"ea8078fa9e10be2bb042749d8b6a97adc38f914c","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1483546612000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1408209dfb9a22a0982a30bdbd14842c2b53f264","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1483546612000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1483546612000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1483546612000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1483546612000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1483546612000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1483546612000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1483546612000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1483546612000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"fdfadbb4483043c7e0afd541ee9712389e633517","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"c0c81317c8ef6fa5d2799fefe05d701b6ea0f039","modified":1483680135000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1483546612000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1483546612000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1483546612000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1483546612000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1483546612000},{"_id":"public/404.html","hash":"d386a11d6e5c4496042801901abe0a77a1139de0","modified":1484665258272},{"_id":"public/me/index.html","hash":"0993e57f1578ccdd7aace8329e05fdb57bde7043","modified":1484665258298},{"_id":"public/tags/index.html","hash":"9c18fdf0618abac43ec1726c0534fa167a37681a","modified":1484665258298},{"_id":"public/2017/01/14/jvm垃圾回收/index.html","hash":"17f2a8d021ad7c528c389fa662998c5244f8656d","modified":1484665258298},{"_id":"public/2017/01/13/ThreadLocal源码浅析/index.html","hash":"3b2a29417fb5f1da46c808879b477adf60da2397","modified":1484665258298},{"_id":"public/2017/01/12/java内存区域/index.html","hash":"c99867ba5f83d5b6189819acf9c9b1b45d179fac","modified":1484665258299},{"_id":"public/categories/index.html","hash":"44e36d88fd533698b1818ee1f82691785767b3ec","modified":1484665258380},{"_id":"public/archives/page/4/index.html","hash":"65c1cd3c149c0b19e0a3ab2f8e2613369ed611f8","modified":1484665258381},{"_id":"public/archives/2016/11/index.html","hash":"dff91478d488d8833a30f49ba001a4b9d350d0ce","modified":1484665258381},{"_id":"public/archives/2016/12/page/2/index.html","hash":"465c921db7d53760c4ea0dc73a3692393e05116c","modified":1484665258381},{"_id":"public/archives/2017/page/2/index.html","hash":"153b01fc9b4e7f344d5806db4098b9e9108d19ec","modified":1484665258381},{"_id":"public/categories/随笔/index.html","hash":"5c642ceb9d670eb40be9817b4b5f2a1c6521b053","modified":1484665258381},{"_id":"public/archives/2017/01/page/2/index.html","hash":"0c12aa5fb665cb90a3f187e799510c464a95d5b8","modified":1484665258381},{"_id":"public/categories/Java/index.html","hash":"d2a432c796ae3f465482185ddc78812985bdf1b7","modified":1484665258382},{"_id":"public/categories/hexo/index.html","hash":"6dd0ad534096035411c0ecc3bc188d66cbca0cfd","modified":1484665258382},{"_id":"public/categories/Android/page/3/index.html","hash":"a7d2e1e09b479be9e9c3f314ddc84a2dcc04fbda","modified":1484665258382},{"_id":"public/categories/shell/index.html","hash":"51632893ad07a799f5d827406416ad858fa536b1","modified":1484665258382},{"_id":"public/tags/计划总结/index.html","hash":"a84ab8682b56fd5993ad3604250010145eea4919","modified":1484665258382},{"_id":"public/tags/jni/index.html","hash":"95444f869748ed28df04a9e8bc1e08cf19b05a8e","modified":1484665258382},{"_id":"public/categories/Gradle/index.html","hash":"8c10611502582b467c9e3113cadcf5238fdb2f5a","modified":1484665258382},{"_id":"public/tags/framework/page/2/index.html","hash":"d29b03f498eeac3562c8b79c9ea8dbccf702f58f","modified":1484665258382},{"_id":"public/tags/源码/index.html","hash":"3ad8e284834ae67706c383d308fe39f96beb7600","modified":1484665258382},{"_id":"public/tags/fresco/index.html","hash":"64c14a129d33463ff63d494c00119afa2c5e715c","modified":1484665258382},{"_id":"public/tags/jvm/index.html","hash":"85f56991c5ae8f8947e7f0117d9a4c35a80ff32f","modified":1484665258382},{"_id":"public/tags/hexo/index.html","hash":"4342f6c3442d6d859a7701b4b644e96bb8cb9d81","modified":1484665258382},{"_id":"public/tags/android/index.html","hash":"f0ccdd894f6b5a2f36d89d38d6fb74a9f5b0d65d","modified":1484665258382},{"_id":"public/tags/gradle/index.html","hash":"2217ab947ea8989c41caeebb8392fd9bcfae1788","modified":1484665258382},{"_id":"public/tags/消息机制/index.html","hash":"4ffa10fde992a440a44b89d3bc935a90b13a41dd","modified":1484665258382},{"_id":"public/tags/shell/index.html","hash":"669825e761d852a41e3987fcce797a113bcc5fec","modified":1484665258382},{"_id":"public/2017/01/13/LruCache源码浅析/index.html","hash":"0e73dc172dc3f2ce2b100d946f193eecf92a62cc","modified":1484665258382},{"_id":"public/2017/01/11/2017学习计划/index.html","hash":"3bd42b2148e03872b933c480a4f3025b33e3d208","modified":1484665258382},{"_id":"public/2017/01/05/PMS初始化做了什么/index.html","hash":"490bdf095654a01a846f7656d77ccf38b25382e7","modified":1484665258382},{"_id":"public/2017/01/05/AMS中的进程管理部分－上/index.html","hash":"80a041816abc6d2f948711ee9ef40aad95f6cf00","modified":1484665258382},{"_id":"public/2017/01/07/SystemServer进程的初始化/index.html","hash":"8ea15db5c24aa4d7a480e014dbae6937ae5c52b5","modified":1484665258383},{"_id":"public/2017/01/07/Zygote进程的初始化/index.html","hash":"70dc4f7c7c9a8543ec2747464e0616435b0e3ead","modified":1484665258383},{"_id":"public/2017/01/09/系统资源的预加载过程/index.html","hash":"ab979ac2701fff4acf0ff6fb8e8e829fb9522150","modified":1484665258383},{"_id":"public/2016/12/29/ContentProvider水文(凑四大组件)/index.html","hash":"6b992533160945368956e1b25edd060e890c2d7d","modified":1484665258383},{"_id":"public/2017/01/04/Android应用程序是如何安装的/index.html","hash":"014c0f6552f17ebaae6eea0fd52103cfcc4f648b","modified":1484665258383},{"_id":"public/2017/01/01/消息机制在多进程的应用/index.html","hash":"348bd78745ca8f002e9311af8483c4a9ea8e338d","modified":1484665258383},{"_id":"public/2017/01/02/android应用进程是如何启动的/index.html","hash":"1c9971eac600bf42c270bcffb8f334bd262f6a48","modified":1484665258383},{"_id":"public/2016/12/27/broadcast流程浅析/index.html","hash":"5de0a7f15d84e9d14d3e3fbe6fd4df50fc6c59ce","modified":1484665258383},{"_id":"public/2016/12/21/Android消息机制浅析/index.html","hash":"a7b70d4234f7476cd960d25c8995f5edf2766343","modified":1484665258383},{"_id":"public/2016/12/20/记不住adb命令？试试shell吧/index.html","hash":"a8be367a8ec4463e5a3f1aaf5ae48ea4f788e3b8","modified":1484665258383},{"_id":"public/2016/12/14/fresco内存管理/index.html","hash":"dc8a3460464630d971928ac7a7d099a7def2f043","modified":1484665258383},{"_id":"public/2016/12/24/Android消息机制－native层/index.html","hash":"27d671c71b0fbf2da42fdc8a32623f7b483bc56d","modified":1484665258383},{"_id":"public/2016/12/26/Service启动流程/index.html","hash":"1e006ce2f87d65c20181fb876b753d85b2b00245","modified":1484665258383},{"_id":"public/2016/12/13/fresco生产者Producer/index.html","hash":"b1d05904537039f8007494933da0a195cf466985","modified":1484665258383},{"_id":"public/2016/12/12/fresco初始化过程/index.html","hash":"009c1d28e327c8a1d302b77aa4beddd76da4beac","modified":1484665258383},{"_id":"public/2016/12/13/fresco图片decode的大体流程/index.html","hash":"3d91ac8a8641b7eda94a2335217d47eda22f4737","modified":1484665258383},{"_id":"public/2016/12/12/fresco加载数据/index.html","hash":"a0f109b4264109e538d63d5cbff6dae490b9f1ed","modified":1484665258384},{"_id":"public/2016/12/12/fresco用法/index.html","hash":"016aa91653695849ce2c5a30028866e6f544e6fd","modified":1484665258384},{"_id":"public/2016/12/06/了解gradle（二）-扩展gradle/index.html","hash":"838a80385fe3a25fcda00f8b0a6b860c17372d5c","modified":1484665258384},{"_id":"public/2016/11/30/AndroidJNI学习笔记（四）－数据类型映射以及native调用java/index.html","hash":"9dcff1fcae53d614ce28b48f56827e90f17f8f80","modified":1484665258384},{"_id":"public/2016/12/03/脚本打怪-shell篇/index.html","hash":"9da98d06be7e6c9410f5ed265e4ac2252e0e6ddb","modified":1484665258384},{"_id":"public/2016/12/25/Activity启动流程/index.html","hash":"cceb2aaa0624ff973603aedd65a0eeed0dca924f","modified":1484665258384},{"_id":"public/2016/12/05/了解gradle（一）/index.html","hash":"83d47ed8d958e4ef4f2c1cb57f437311f49d8eef","modified":1484665258384},{"_id":"public/archives/index.html","hash":"8d0aebcf59d06cb163f92c88c85df5b4f6e42869","modified":1484665258384},{"_id":"public/archives/page/2/index.html","hash":"1e005080b2022c08e0efd0dd3e56c315d16f13e8","modified":1484665258384},{"_id":"public/2016/11/29/hexo+github pages搭建个人博客/index.html","hash":"5ed02148dfbe5e50b22f6a926654b81ff2c7266d","modified":1484665258384},{"_id":"public/archives/page/3/index.html","hash":"752ba0a65b93afed9f655650425f9d45e5b0094b","modified":1484665258384},{"_id":"public/2016/11/29/JNI学习笔记（二）－动态注册native函数/index.html","hash":"0b67904072ed507b4fd0b719982668232b699ae7","modified":1484665258384},{"_id":"public/2016/11/29/JNI学习笔记（三）－编译文件makefile以及cmake/index.html","hash":"6618f6e2dfa920f55f30ddeabccee68a694bd165","modified":1484665258384},{"_id":"public/archives/2016/12/index.html","hash":"b4087ed70c2687547696c7b8f34131c55b6604ef","modified":1484665258384},{"_id":"public/archives/2016/page/2/index.html","hash":"47b9778d30f97091d9522e68afa6fc9e2ae34702","modified":1484665258384},{"_id":"public/archives/2016/index.html","hash":"80991e1303b8c98994d1536250652d9eca3a0e96","modified":1484665258384},{"_id":"public/archives/2017/index.html","hash":"f0debad2eea231b83997599b8bb6a5b3b6d19651","modified":1484665258384},{"_id":"public/archives/2017/01/index.html","hash":"a3dff0a8dd0e2b0a212c7b0ce7d9c0af07f72be8","modified":1484665258384},{"_id":"public/categories/Android/index.html","hash":"177d58cc93a3851d3e4cfd03af04422e5e1e60da","modified":1484665258384},{"_id":"public/page/2/index.html","hash":"d07d369e8679401c38dc35551fcb104ebd43bfb3","modified":1484665258384},{"_id":"public/page/3/index.html","hash":"0a49bcef564fad574b4f8b881a56ea45fc0f4b0a","modified":1484665258384},{"_id":"public/categories/Android/page/2/index.html","hash":"725ba0ccd457c577eba6b65623ea80a7717d8252","modified":1484665258385},{"_id":"public/page/4/index.html","hash":"e3f0c454bb2aa1a8dbbcf81af5fc6f5ddd2b6a2b","modified":1484665258385},{"_id":"public/tags/framework/index.html","hash":"6c9e8fc296f0236915bdaa9ca2e1ea37ce910e92","modified":1484665258385},{"_id":"public/2017/01/17/jvm类加载机制/index.html","hash":"21abf8b7845b3e5063afef3a52024d3f116e5bdb","modified":1484665258391},{"_id":"public/index.html","hash":"cd08dcb3026f7e2d04a16ae49cacc5736e1eaea2","modified":1484665258391},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1484665258391},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1484665258391},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1484665258391},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1484665258391},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1484665258391},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1484665258391},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1484665258391},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1484665258391},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1484665258391},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1484665258391},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1484665258391},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1484665258391},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1484665258391},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1484665258392},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1484665258392},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1484665258392},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1484665258392},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1484665258392},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1484665258392},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1484665258392},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1484665258392},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1484665258392},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1484665258393},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1484665258393},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1484665259109},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1484665259112},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1484665259115},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1484665259115},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1484665259118},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1484665259118},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1484665259118},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1484665259118},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1484665259118},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1484665259118},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1484665259118},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1484665259118},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1484665259118},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1484665259118},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1484665259118},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1484665259118},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1484665259118},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1484665259119},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1484665259119},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1484665259119},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1484665259119},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1484665259119},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1484665259119},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1484665259119},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1484665259119},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1484665259119},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1484665259119},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1484665259119},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1484665259119},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1484665259119},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1484665259119},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1484665259119},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1484665259119},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1484665259119},{"_id":"public/css/main.css","hash":"75194683d866e00497c30905ad8a31c5aa4bc021","modified":1484665259120},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1484665259120},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1484665259120},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1484665259120},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1484665259120},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1484665259120},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1484665259120},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1484665259120},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1484665259121},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1484665259121},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1484665259121},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1484665259121},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1484665259128}],"Category":[{"name":"随笔","_id":"ciy1ncy130003hws6hfoeq6f7"},{"name":"Android","_id":"ciy1ncy1j0008hws6s9o6guw4"},{"name":"hexo","_id":"ciy1ncy2s0024hws69b4i8ihg"},{"name":"Java","_id":"ciy1ncy2v002fhws6jijcil10"},{"name":"Gradle","_id":"ciy1ncy340032hws6jqro36uw"},{"name":"shell","_id":"ciy1ncy37003dhws6onzphdwu"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>","date":"2017-01-06T03:51:46.000Z","updated":"2017-01-06T03:51:46.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ciy1ncxzs0000hws6qqkmr525","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\">\n</script>\n\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>"},{"title":"me","date":"2017-01-07T07:02:16.000Z","type":"me","comments":0,"_content":"\n不甘平凡Android新手一枚，长期混迹于各个交流群。\n\n求18-22周岁妹子收留。\n\n技能篇：\n\n* 熟悉面向对象编程，熟悉Java开发语言，了解JVM 、了解Groovy、Shell、Python等脚本（可以编写简单脚本提升工作效率）\n* 了解TCP/IP、HTTP等协议，熟悉Socket、熟悉Android网络编程\n* 熟悉常用设计模式以及应用场景\n* 熟悉常用的开发架构如mvc、mvp、mvvm\n* 熟悉Android开发技巧、了解自定义View，动画等，能够根据需求做出自定义效果\n* 熟悉常用的开源框架并了解其内部实现原理，如Retrofit、Okhttp、EventBus、Fresco等\n* 了解NDK编程，了解JNI开发基本流程\n* 了解Android FrameWork及其部分流程与实现原理\n","source":"me/index.md","raw":"---\ntitle: me\ndate: 2017-01-07 15:02:16\ntype: \"me\"\ncomments: false\n\n---\n\n不甘平凡Android新手一枚，长期混迹于各个交流群。\n\n求18-22周岁妹子收留。\n\n技能篇：\n\n* 熟悉面向对象编程，熟悉Java开发语言，了解JVM 、了解Groovy、Shell、Python等脚本（可以编写简单脚本提升工作效率）\n* 了解TCP/IP、HTTP等协议，熟悉Socket、熟悉Android网络编程\n* 熟悉常用设计模式以及应用场景\n* 熟悉常用的开发架构如mvc、mvp、mvvm\n* 熟悉Android开发技巧、了解自定义View，动画等，能够根据需求做出自定义效果\n* 熟悉常用的开源框架并了解其内部实现原理，如Retrofit、Okhttp、EventBus、Fresco等\n* 了解NDK编程，了解JNI开发基本流程\n* 了解Android FrameWork及其部分流程与实现原理\n","updated":"2017-01-07T07:05:44.000Z","path":"me/index.html","layout":"page","_id":"ciy1ncy50003thws6g5tj7qwq","content":"<p>不甘平凡Android新手一枚，长期混迹于各个交流群。</p>\n<p>求18-22周岁妹子收留。</p>\n<p>技能篇：</p>\n<ul>\n<li>熟悉面向对象编程，熟悉Java开发语言，了解JVM 、了解Groovy、Shell、Python等脚本（可以编写简单脚本提升工作效率）</li>\n<li>了解TCP/IP、HTTP等协议，熟悉Socket、熟悉Android网络编程</li>\n<li>熟悉常用设计模式以及应用场景</li>\n<li>熟悉常用的开发架构如mvc、mvp、mvvm</li>\n<li>熟悉Android开发技巧、了解自定义View，动画等，能够根据需求做出自定义效果</li>\n<li>熟悉常用的开源框架并了解其内部实现原理，如Retrofit、Okhttp、EventBus、Fresco等</li>\n<li>了解NDK编程，了解JNI开发基本流程</li>\n<li>了解Android FrameWork及其部分流程与实现原理</li>\n</ul>\n","excerpt":"","more":"<p>不甘平凡Android新手一枚，长期混迹于各个交流群。</p>\n<p>求18-22周岁妹子收留。</p>\n<p>技能篇：</p>\n<ul>\n<li>熟悉面向对象编程，熟悉Java开发语言，了解JVM 、了解Groovy、Shell、Python等脚本（可以编写简单脚本提升工作效率）</li>\n<li>了解TCP/IP、HTTP等协议，熟悉Socket、熟悉Android网络编程</li>\n<li>熟悉常用设计模式以及应用场景</li>\n<li>熟悉常用的开发架构如mvc、mvp、mvvm</li>\n<li>熟悉Android开发技巧、了解自定义View，动画等，能够根据需求做出自定义效果</li>\n<li>熟悉常用的开源框架并了解其内部实现原理，如Retrofit、Okhttp、EventBus、Fresco等</li>\n<li>了解NDK编程，了解JNI开发基本流程</li>\n<li>了解Android FrameWork及其部分流程与实现原理</li>\n</ul>\n"},{"title":"All tags","type":"tags","comments":0,"date":"2017-01-06T03:43:49.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ntype: \"tags\"\ncomments: false\ndate: 2017-01-06 11:43:49\n\n---\n","updated":"2017-01-06T03:44:39.000Z","path":"tags/index.html","layout":"page","_id":"ciy1ncy51003uhws6x3j8v8ev","content":"","excerpt":"","more":""},{"title":"categories","date":"2017-01-06T03:45:57.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-01-06 11:45:57\ntype: \"categories\"\ncomments: false\n\n---\n","updated":"2017-01-06T03:46:57.000Z","path":"categories/index.html","layout":"page","_id":"ciy1ncy5c003vhws6i2vbhiho","content":"","excerpt":"","more":""}],"Post":[{"title":"2017学习计划","date":"2017-01-11T13:51:29.000Z","_content":"<Excerpt in index | 首页摘要>\n\n回顾2016，预定2017\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 郁闷\n最近想换份工作，尝试投了一些简历，然而，一个面试都没。这让我开始怀疑人生了，虽然说我从去年实习到现在只有一年多的时间，刚刚毕业半年，但是我每天晚上充电，可还是不行，可能是努力的还不够吧。\n\n### 2017计划\n\n* Android方面\n\t* 继续研究framework\n\t* 对插件话、热修复进行系统的分析(droidplugin、zuesplugin看完很长时间了，但是没写笔记)\n\t* 着手性能优化部分，如果可以的话，把公司项目，开一个分支出来，进行代码重构和优化吧，\n\t* 尝试对某一方面进行专题研究，如音视频、opengl等\n\t* 继续工作、工作\n* Java\n\t* 继续学习并发包中的内容\n\t* 继续学习数据结构在java中的实现\n\t* 继续学习jvm \t \n* Python\n\t* 想做一些好玩的东西\n\t* 尝试做下android自动化测试\n* 基础\n\t* 我的数据结构是真的烂\n\t* 我的算法是一窍不不同\n\t* 是时候改变一下了 \n\t\n* 其他\n\t* shell 随性吧\n\t* groovy\n\t* c++|c 为了能够看懂android native层次的代码，不能放弃\n\t* 想起来，再补\n\n### 学无止境\n\n为了更好的明天，加油吧。\n\t\n\t \n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/2017学习计划.md","raw":"---\ntitle: 2017学习计划\ndate: 2017-01-11 21:51:29\ncategories: 随笔\ntags: 计划总结\n\n---\n<Excerpt in index | 首页摘要>\n\n回顾2016，预定2017\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 郁闷\n最近想换份工作，尝试投了一些简历，然而，一个面试都没。这让我开始怀疑人生了，虽然说我从去年实习到现在只有一年多的时间，刚刚毕业半年，但是我每天晚上充电，可还是不行，可能是努力的还不够吧。\n\n### 2017计划\n\n* Android方面\n\t* 继续研究framework\n\t* 对插件话、热修复进行系统的分析(droidplugin、zuesplugin看完很长时间了，但是没写笔记)\n\t* 着手性能优化部分，如果可以的话，把公司项目，开一个分支出来，进行代码重构和优化吧，\n\t* 尝试对某一方面进行专题研究，如音视频、opengl等\n\t* 继续工作、工作\n* Java\n\t* 继续学习并发包中的内容\n\t* 继续学习数据结构在java中的实现\n\t* 继续学习jvm \t \n* Python\n\t* 想做一些好玩的东西\n\t* 尝试做下android自动化测试\n* 基础\n\t* 我的数据结构是真的烂\n\t* 我的算法是一窍不不同\n\t* 是时候改变一下了 \n\t\n* 其他\n\t* shell 随性吧\n\t* groovy\n\t* c++|c 为了能够看懂android native层次的代码，不能放弃\n\t* 想起来，再补\n\n### 学无止境\n\n为了更好的明天，加油吧。\n\t\n\t \n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"2017学习计划","published":1,"updated":"2017-01-11T14:07:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy0x0001hws6fbjewxfb","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<p>回顾2016，预定2017</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"郁闷\"><a href=\"#郁闷\" class=\"headerlink\" title=\"郁闷\"></a>郁闷</h3><p>最近想换份工作，尝试投了一些简历，然而，一个面试都没。这让我开始怀疑人生了，虽然说我从去年实习到现在只有一年多的时间，刚刚毕业半年，但是我每天晚上充电，可还是不行，可能是努力的还不够吧。</p>\n<h3 id=\"2017计划\"><a href=\"#2017计划\" class=\"headerlink\" title=\"2017计划\"></a>2017计划</h3><ul>\n<li>Android方面<ul>\n<li>继续研究framework</li>\n<li>对插件话、热修复进行系统的分析(droidplugin、zuesplugin看完很长时间了，但是没写笔记)</li>\n<li>着手性能优化部分，如果可以的话，把公司项目，开一个分支出来，进行代码重构和优化吧，</li>\n<li>尝试对某一方面进行专题研究，如音视频、opengl等</li>\n<li>继续工作、工作</li>\n</ul>\n</li>\n<li>Java<ul>\n<li>继续学习并发包中的内容</li>\n<li>继续学习数据结构在java中的实现</li>\n<li>继续学习jvm      </li>\n</ul>\n</li>\n<li>Python<ul>\n<li>想做一些好玩的东西</li>\n<li>尝试做下android自动化测试</li>\n</ul>\n</li>\n<li><p>基础</p>\n<ul>\n<li>我的数据结构是真的烂</li>\n<li>我的算法是一窍不不同</li>\n<li>是时候改变一下了 </li>\n</ul>\n</li>\n<li><p>其他</p>\n<ul>\n<li>shell 随性吧</li>\n<li>groovy</li>\n<li>c++|c 为了能够看懂android native层次的代码，不能放弃</li>\n<li>想起来，再补</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"学无止境\"><a href=\"#学无止境\" class=\"headerlink\" title=\"学无止境\"></a>学无止境</h3><p>为了更好的明天，加油吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<p>回顾2016，预定2017</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"郁闷\"><a href=\"#郁闷\" class=\"headerlink\" title=\"郁闷\"></a>郁闷</h3><p>最近想换份工作，尝试投了一些简历，然而，一个面试都没。这让我开始怀疑人生了，虽然说我从去年实习到现在只有一年多的时间，刚刚毕业半年，但是我每天晚上充电，可还是不行，可能是努力的还不够吧。</p>\n<h3 id=\"2017计划\"><a href=\"#2017计划\" class=\"headerlink\" title=\"2017计划\"></a>2017计划</h3><ul>\n<li>Android方面<ul>\n<li>继续研究framework</li>\n<li>对插件话、热修复进行系统的分析(droidplugin、zuesplugin看完很长时间了，但是没写笔记)</li>\n<li>着手性能优化部分，如果可以的话，把公司项目，开一个分支出来，进行代码重构和优化吧，</li>\n<li>尝试对某一方面进行专题研究，如音视频、opengl等</li>\n<li>继续工作、工作</li>\n</ul>\n</li>\n<li>Java<ul>\n<li>继续学习并发包中的内容</li>\n<li>继续学习数据结构在java中的实现</li>\n<li>继续学习jvm      </li>\n</ul>\n</li>\n<li>Python<ul>\n<li>想做一些好玩的东西</li>\n<li>尝试做下android自动化测试</li>\n</ul>\n</li>\n<li><p>基础</p>\n<ul>\n<li>我的数据结构是真的烂</li>\n<li>我的算法是一窍不不同</li>\n<li>是时候改变一下了 </li>\n</ul>\n</li>\n<li><p>其他</p>\n<ul>\n<li>shell 随性吧</li>\n<li>groovy</li>\n<li>c++|c 为了能够看懂android native层次的代码，不能放弃</li>\n<li>想起来，再补</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"学无止境\"><a href=\"#学无止境\" class=\"headerlink\" title=\"学无止境\"></a>学无止境</h3><p>为了更好的明天，加油吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"AMS中的进程管理部分－上","date":"2017-01-05T03:41:01.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1.前言\n\nActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 新建进程\n* 调整进程在mLruProcesses的位置\n* 调整进程OomAdj值\n* 杀进程\n\n而新建进程在前面有说到过，今天就来介绍下剩下的三个。\n\n### 2.调整位置的updateLruProcessLocked方法\n\n代码比较长，分段看。\n\n```\n        final boolean hasActivity = app.activities.size() > 0 || app.hasClientActivities\n                || app.treatLikeActivity;\n        final boolean hasService = false; // not impl yet. app.services.size() > 0;\n        if (!activityChange && hasActivity) {\n            // The process has activities, so we are only allowing activity-based adjustments\n            // to move it.  It should be kept in the front of the list with other\n            // processes that have activities, and we don't want those to change their\n            // order except due to activity operations.\n            return;\n        }\n\n        mLruSeq++;\n        final long now = SystemClock.uptimeMillis();\n        app.lastActivityTime = now;\n\n        // First a quick reject: if the app is already at the position we will\n        // put it, then there is nothing to do.\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (N > 0 && mLruProcesses.get(N-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top activity: \" + app);\n                return;\n            }\n        } else {\n            if (mLruProcessServiceStart > 0\n                    && mLruProcesses.get(mLruProcessServiceStart-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top other: \" + app);\n                return;\n            }\n        }\n\n        int lrui = mLruProcesses.lastIndexOf(app);\n\n        if (app.persistent && lrui >= 0) {\n            // We don't care about the position of persistent processes, as long as\n            // they are in the list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, persistent: \" + app);\n            return;\n        }\n```\n\n* 如果有activity，并且进程中activity没有发生变化，不需要调整\n* 如果有activity，但是当前进程就是在最后，不需要调整\n* 如果没有activity，但是在合适的位置，不需要调整\n* 如果有persistent标志，不需要调整\n* lrui 为当前进程在list中的索引(最后一个的索引)\n\n```\n        if (lrui >= 0) {\n            if (lrui < mLruProcessActivityStart) {\n                mLruProcessActivityStart--;\n            }\n            if (lrui < mLruProcessServiceStart) {\n                mLruProcessServiceStart--;\n            }\n            /*\n            if (addIndex > lrui) {\n                addIndex--;\n            }\n            if (nextIndex > lrui) {\n                nextIndex--;\n            }\n            */\n            mLruProcesses.remove(lrui);\n        }\n\n```\n\n如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。\n\n```\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (app.activities.size() == 0 && mLruProcessActivityStart < (N - 1)) {\n                // Process doesn't have activities, but has clients with\n                // activities...  move it up, but one below the top (the top\n                // should always have a real activity).\n                if (DEBUG_LRU) Slog.d(TAG_LRU,\n                        \"Adding to second-top of LRU activity list: \" + app);\n                mLruProcesses.add(N - 1, app);\n                // To keep it from spamming the LRU list (by making a bunch of clients),\n                // we will push down any other entries owned by the app.\n                final int uid = app.info.uid;\n                for (int i = N - 2; i > mLruProcessActivityStart; i--) {\n                    ProcessRecord subProc = mLruProcesses.get(i);\n                    if (subProc.info.uid == uid) {\n                        // We want to push this one down the list.  If the process after\n                        // it is for the same uid, however, don't do so, because we don't\n                        // want them internally to be re-ordered.\n                        if (mLruProcesses.get(i - 1).info.uid != uid) {\n                            if (DEBUG_LRU) Slog.d(TAG_LRU,\n                                    \"Pushing uid \" + uid + \" swapping at \" + i + \": \"\n                                    + mLruProcesses.get(i) + \" : \" + mLruProcesses.get(i - 1));\n                            ProcessRecord tmp = mLruProcesses.get(i);\n                            mLruProcesses.set(i, mLruProcesses.get(i - 1));\n                            mLruProcesses.set(i - 1, tmp);\n                            i--;\n                        }\n                    } else {\n                        // A gap, we can stop here.\n                        break;\n                    }\n                }\n            } else {\n                // Process has activities, put it at the very tipsy-top.\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU activity list: \" + app);\n                mLruProcesses.add(app);\n            }\n            nextIndex = mLruProcessServiceStart;\n        } else if (hasService) {\n            // Process has services, put it at the top of the service list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU service list: \" + app);\n            mLruProcesses.add(mLruProcessActivityStart, app);\n            nextIndex = mLruProcessServiceStart;\n            mLruProcessActivityStart++;\n        } else  {\n            // Process not otherwise of interest, it goes to the top of the non-service area.\n            int index = mLruProcessServiceStart;\n            if (client != null) {\n                // If there is a client, don't allow the process to be moved up higher\n                // in the list than that client.\n                int clientIndex = mLruProcesses.lastIndexOf(client);\n                if (DEBUG_LRU && clientIndex < 0) Slog.d(TAG_LRU, \"Unknown client \" + client\n                        + \" when updating \" + app);\n                if (clientIndex <= lrui) {\n                    // Don't allow the client index restriction to push it down farther in the\n                    // list than it already is.\n                    clientIndex = lrui;\n                }\n                if (clientIndex >= 0 && index > clientIndex) {\n                    index = clientIndex;\n                }\n            }\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding at \" + index + \" of LRU list: \" + app);\n            mLruProcesses.add(index, app);\n            nextIndex = index-1;\n            mLruProcessActivityStart++;\n            mLruProcessServiceStart++;\n        }\n\n```\n\n* hasActivity为true\n\t* 没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。\n\t* 直接添加到最后一个\n* hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置\n* 因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处\n\n\n```\n        for (int j=app.connections.size()-1; j>=0; j--) {\n            ConnectionRecord cr = app.connections.valueAt(j);\n            if (cr.binding != null && !cr.serviceDead && cr.binding.service != null\n                    && cr.binding.service.app != null\n                    && cr.binding.service.app.lruSeq != mLruSeq\n                    && !cr.binding.service.app.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,\n                        \"service connection\", cr, app);\n            }\n        }\n        for (int j=app.conProviders.size()-1; j>=0; j--) {\n            ContentProviderRecord cpr = app.conProviders.get(j).provider;\n            if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq && !cpr.proc.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,\n                        \"provider reference\", cpr, app);\n            }\n        }\n```\n\n把和这个进程关联的service和contentprovider调整到这个进程之后。\n\n### 3. 调整OomAdj值的updateOomAdjLocked方法\n\n方法较长，分段看。\n\n```\n        final ActivityRecord TOP_ACT = resumedAppLocked();\n        final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;\n        final long now = SystemClock.uptimeMillis();\n        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;\n        final int N = mLruProcesses.size();\n\n        if (false) {\n            RuntimeException e = new RuntimeException();\n            e.fillInStackTrace();\n            Slog.i(TAG, \"updateOomAdj: top=\" + TOP_ACT, e);\n        }\n\n        // Reset state in all uid records.\n        for (int i=mActiveUids.size()-1; i>=0; i--) {\n            final UidRecord uidRec = mActiveUids.valueAt(i);\n            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,\n                    \"Starting update of \" + uidRec);\n            uidRec.reset();\n        }\n\n        mAdjSeq++;\n        mNewNumServiceProcs = 0;\n        mNewNumAServiceProcs = 0;\n\n        final int emptyProcessLimit;\n        final int cachedProcessLimit;\n        if (mProcessLimit <= 0) {\n            emptyProcessLimit = cachedProcessLimit = 0;\n        } else if (mProcessLimit == 1) {\n            emptyProcessLimit = 1;\n            cachedProcessLimit = 0;\n        } else {\n            emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);\n            cachedProcessLimit = mProcessLimit - emptyProcessLimit;\n        }\n\n        // Let's determine how many processes we have running vs.\n        // how many slots we have for background processes; we may want\n        // to put multiple processes in a slot of there are enough of\n        // them.\n        int numSlots = (ProcessList.CACHED_APP_MAX_ADJ\n                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;\n        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;\n        if (numEmptyProcs > cachedProcessLimit) {\n            // If there are more empty processes than our limit on cached\n            // processes, then use the cached process limit for the factor.\n            // This ensures that the really old empty processes get pushed\n            // down to the bottom, so if we are running low on memory we will\n            // have a better chance at keeping around more cached processes\n            // instead of a gazillion empty processes.\n            numEmptyProcs = cachedProcessLimit;\n        }\n        int emptyFactor = numEmptyProcs/numSlots;\n        if (emptyFactor < 1) emptyFactor = 1;\n        int cachedFactor = (mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1)/numSlots;\n        if (cachedFactor < 1) cachedFactor = 1;\n        int stepCached = 0;\n        int stepEmpty = 0;\n        int numCached = 0;\n        int numEmpty = 0;\n        int numTrimming = 0;\n\n        mNumNonCachedProcs = 0;\n        mNumCachedHiddenProcs = 0;\n\n```\n\n这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。\n\n\n```\n int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextCachedAdj = curCachedAdj+1;\n        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextEmptyAdj = curEmptyAdj+2;\n        for (int i=N-1; i>=0; i--) {\n            ProcessRecord app = mLruProcesses.get(i);\n            if (!app.killedByAm && app.thread != null) {\n                app.procStateChanged = false;\n                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);\n\n                // If we haven't yet assigned the final cached adj\n                // to the process, do that now.\n                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {\n                    switch (app.curProcState) {\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                            // This process is a cached process holding activities...\n                            // assign it the next cached value for that type, and then\n                            // step that cached level.\n                            app.curRawAdj = curCachedAdj;\n                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning activity LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curCachedAdj=\" + curCachedAdj\n                                    + \")\");\n                            if (curCachedAdj != nextCachedAdj) {\n                                stepCached++;\n                                if (stepCached >= cachedFactor) {\n                                    stepCached = 0;\n                                    curCachedAdj = nextCachedAdj;\n                                    nextCachedAdj += 2;\n                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                        default:\n                            // For everything else, assign next empty cached process\n                            // level and bump that up.  Note that this means that\n                            // long-running services that have dropped down to the\n                            // cached level will be treated as empty (since their process\n                            // state is still as a service), which is what we want.\n                            app.curRawAdj = curEmptyAdj;\n                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning empty LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curEmptyAdj=\" + curEmptyAdj\n                                    + \")\");\n                            if (curEmptyAdj != nextEmptyAdj) {\n                                stepEmpty++;\n                                if (stepEmpty >= emptyFactor) {\n                                    stepEmpty = 0;\n                                    curEmptyAdj = nextEmptyAdj;\n                                    nextEmptyAdj += 2;\n                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                    }\n                }\n\n                applyOomAdjLocked(app, true, now);\n\n                // Count the number of process types.\n                switch (app.curProcState) {\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                        mNumCachedHiddenProcs++;\n                        numCached++;\n                        if (numCached > cachedProcessLimit) {\n                            app.kill(\"cached #\" + numCached, true);\n                        }\n                        break;\n                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:\n                        if (numEmpty > ProcessList.TRIM_EMPTY_APPS\n                                && app.lastActivityTime < oldTime) {\n                            app.kill(\"empty for \"\n                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)\n                                    / 1000) + \"s\", true);\n                        } else {\n                            numEmpty++;\n                            if (numEmpty > emptyProcessLimit) {\n                                app.kill(\"empty #\" + numEmpty, true);\n                            }\n                        }\n                        break;\n                    default:\n                        mNumNonCachedProcs++;\n                        break;\n                }\n\n                if (app.isolated && app.services.size() <= 0) {\n                    // If this is an isolated process, and there are no\n                    // services running in it, then the process is no longer\n                    // needed.  We agressively kill these because we can by\n                    // definition not re-use the same process again, and it is\n                    // good to avoid having whatever code was running in them\n                    // left sitting around after no longer needed.\n                    app.kill(\"isolated not needed\", true);\n                } else {\n                    // Keeping this process, update its uid.\n                    final UidRecord uidRec = app.uidRecord;\n                    if (uidRec != null && uidRec.curProcState > app.curProcState) {\n                        uidRec.curProcState = app.curProcState;\n                    }\n                }\n\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    numTrimming++;\n                }\n            }\n        }\n```\n\n\n上面代码的逻辑是更新进程oomadj值。\n\n* 首先通过computeOomAdjLocked计算oomadj值\n* 当进程未分配adj值是，更新adj值(if (app.curAdj >= ProcessList.UNKNOWN_ADJ))\n\t* 当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值\n\t* 不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值\n* applyOomAdjLocked,使更新生效\n* 根据进程状态，选择策略\n\t* PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程\n\t* PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程\n* 如果是孤立进程 并且没有service，直接杀掉\n\n\n```\n        final int numCachedAndEmpty = numCached + numEmpty;\n        int memFactor;\n        if (numCached <= ProcessList.TRIM_CACHED_APPS\n                && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {\n            if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n            } else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n            } else {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n            }\n        } else {\n            memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n        }\n        // We always allow the memory level to go up (better).  We only allow it to go\n        // down if we are in a state where that is allowed, *and* the total number of processes\n        // has gone down since last time.\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"oom: memFactor=\" + memFactor\n                + \" last=\" + mLastMemoryLevel + \" allowLow=\" + mAllowLowerMemLevel\n                + \" numProcs=\" + mLruProcesses.size() + \" last=\" + mLastNumProcesses);\n        if (memFactor > mLastMemoryLevel) {\n            if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {\n                memFactor = mLastMemoryLevel;\n                if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"Keeping last mem factor!\");\n            }\n        }\n        mLastMemoryLevel = memFactor;\n        mLastNumProcesses = mLruProcesses.size();\n        boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\n        final int trackerMemFactor = mProcessStats.getMemFactorLocked();\n        if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n            if (mLowRamStartTime == 0) {\n                mLowRamStartTime = now;\n            }\n            int step = 0;\n            int fgTrimLevel;\n            switch (memFactor) {\n                case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n                    break;\n                case ProcessStats.ADJ_MEM_FACTOR_LOW:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n                    break;\n                default:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n                    break;\n            }\n            int factor = numTrimming/3;\n            int minFactor = 2;\n            if (mHomeProcess != null) minFactor++;\n            if (mPreviousProcess != null) minFactor++;\n            if (factor < minFactor) factor = minFactor;\n            int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    if (app.trimMemoryLevel < curLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of \" + app.processName + \" to \" + curLevel);\n                            app.thread.scheduleTrimMemory(curLevel);\n                        } catch (RemoteException e) {\n                        }\n                        if (false) {\n                            // For now we won't do this; our memory trimming seems\n                            // to be good enough at this point that destroying\n                            // activities causes more harm than good.\n                            if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                                    && app != mHomeProcess && app != mPreviousProcess) {\n                                // Need to do this on its own message because the stack may not\n                                // be in a consistent state at this point.\n                                // For these apps we will also finish their activities\n                                // to help them free memory.\n                                mStackSupervisor.scheduleDestroyAllActivities(app, \"trim\");\n                            }\n                        }\n                    }\n                    app.trimMemoryLevel = curLevel;\n                    step++;\n                    if (step >= factor) {\n                        step = 0;\n                        switch (curLevel) {\n                            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                                break;\n                            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                                break;\n                        }\n                    }\n                } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of heavy-weight \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                } else {\n                    if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                            || app.systemNoUi) && app.pendingUiClean) {\n                        // If this application is now in the background and it\n                        // had done UI, then give it the special trim level to\n                        // have it free UI resources.\n                        final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                        if (app.trimMemoryLevel < level && app.thread != null) {\n                            try {\n                                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                        \"Trimming memory of bg-ui \" + app.processName\n                                        + \" to \" + level);\n                                app.thread.scheduleTrimMemory(level);\n                            } catch (RemoteException e) {\n                            }\n                        }\n                        app.pendingUiClean = false;\n                    }\n                    if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of fg \" + app.processName\n                                    + \" to \" + fgTrimLevel);\n                            app.thread.scheduleTrimMemory(fgTrimLevel);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = fgTrimLevel;\n                }\n            }\n        } else {\n            if (mLowRamStartTime != 0) {\n                mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n                mLowRamStartTime = 0;\n            }\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                        || app.systemNoUi) && app.pendingUiClean) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of ui hidden \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.pendingUiClean = false;\n                }\n                app.trimMemoryLevel = 0;\n            }\n        }\n```\t\n\n* 先调整内存因子memFactor\n* 如果内存因子不为0\n\t* 根据内存因子 初始化fgTrimLevel\n\t* 循环处理进程\n\t\t* curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel\n\t\t* curProcState等于9，且满足条件，进行TrimMemory\n\t\t* 其他情况下，根据条件进行TrimMemory操作\n\t \n* 内存因子为0,也是根据跳进进行TrimMemory操作\n\n整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。\n\ncomputeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。\n\n### 4.杀进程\n\n杀进程这里就略过了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\t","source":"_posts/AMS中的进程管理部分－上.md","raw":"---\ntitle: AMS中的进程管理部分－上\ndate: 2017-01-05 11:41:01\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1.前言\n\nActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 新建进程\n* 调整进程在mLruProcesses的位置\n* 调整进程OomAdj值\n* 杀进程\n\n而新建进程在前面有说到过，今天就来介绍下剩下的三个。\n\n### 2.调整位置的updateLruProcessLocked方法\n\n代码比较长，分段看。\n\n```\n        final boolean hasActivity = app.activities.size() > 0 || app.hasClientActivities\n                || app.treatLikeActivity;\n        final boolean hasService = false; // not impl yet. app.services.size() > 0;\n        if (!activityChange && hasActivity) {\n            // The process has activities, so we are only allowing activity-based adjustments\n            // to move it.  It should be kept in the front of the list with other\n            // processes that have activities, and we don't want those to change their\n            // order except due to activity operations.\n            return;\n        }\n\n        mLruSeq++;\n        final long now = SystemClock.uptimeMillis();\n        app.lastActivityTime = now;\n\n        // First a quick reject: if the app is already at the position we will\n        // put it, then there is nothing to do.\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (N > 0 && mLruProcesses.get(N-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top activity: \" + app);\n                return;\n            }\n        } else {\n            if (mLruProcessServiceStart > 0\n                    && mLruProcesses.get(mLruProcessServiceStart-1) == app) {\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, already top other: \" + app);\n                return;\n            }\n        }\n\n        int lrui = mLruProcesses.lastIndexOf(app);\n\n        if (app.persistent && lrui >= 0) {\n            // We don't care about the position of persistent processes, as long as\n            // they are in the list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Not moving, persistent: \" + app);\n            return;\n        }\n```\n\n* 如果有activity，并且进程中activity没有发生变化，不需要调整\n* 如果有activity，但是当前进程就是在最后，不需要调整\n* 如果没有activity，但是在合适的位置，不需要调整\n* 如果有persistent标志，不需要调整\n* lrui 为当前进程在list中的索引(最后一个的索引)\n\n```\n        if (lrui >= 0) {\n            if (lrui < mLruProcessActivityStart) {\n                mLruProcessActivityStart--;\n            }\n            if (lrui < mLruProcessServiceStart) {\n                mLruProcessServiceStart--;\n            }\n            /*\n            if (addIndex > lrui) {\n                addIndex--;\n            }\n            if (nextIndex > lrui) {\n                nextIndex--;\n            }\n            */\n            mLruProcesses.remove(lrui);\n        }\n\n```\n\n如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。\n\n```\n        if (hasActivity) {\n            final int N = mLruProcesses.size();\n            if (app.activities.size() == 0 && mLruProcessActivityStart < (N - 1)) {\n                // Process doesn't have activities, but has clients with\n                // activities...  move it up, but one below the top (the top\n                // should always have a real activity).\n                if (DEBUG_LRU) Slog.d(TAG_LRU,\n                        \"Adding to second-top of LRU activity list: \" + app);\n                mLruProcesses.add(N - 1, app);\n                // To keep it from spamming the LRU list (by making a bunch of clients),\n                // we will push down any other entries owned by the app.\n                final int uid = app.info.uid;\n                for (int i = N - 2; i > mLruProcessActivityStart; i--) {\n                    ProcessRecord subProc = mLruProcesses.get(i);\n                    if (subProc.info.uid == uid) {\n                        // We want to push this one down the list.  If the process after\n                        // it is for the same uid, however, don't do so, because we don't\n                        // want them internally to be re-ordered.\n                        if (mLruProcesses.get(i - 1).info.uid != uid) {\n                            if (DEBUG_LRU) Slog.d(TAG_LRU,\n                                    \"Pushing uid \" + uid + \" swapping at \" + i + \": \"\n                                    + mLruProcesses.get(i) + \" : \" + mLruProcesses.get(i - 1));\n                            ProcessRecord tmp = mLruProcesses.get(i);\n                            mLruProcesses.set(i, mLruProcesses.get(i - 1));\n                            mLruProcesses.set(i - 1, tmp);\n                            i--;\n                        }\n                    } else {\n                        // A gap, we can stop here.\n                        break;\n                    }\n                }\n            } else {\n                // Process has activities, put it at the very tipsy-top.\n                if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU activity list: \" + app);\n                mLruProcesses.add(app);\n            }\n            nextIndex = mLruProcessServiceStart;\n        } else if (hasService) {\n            // Process has services, put it at the top of the service list.\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding to top of LRU service list: \" + app);\n            mLruProcesses.add(mLruProcessActivityStart, app);\n            nextIndex = mLruProcessServiceStart;\n            mLruProcessActivityStart++;\n        } else  {\n            // Process not otherwise of interest, it goes to the top of the non-service area.\n            int index = mLruProcessServiceStart;\n            if (client != null) {\n                // If there is a client, don't allow the process to be moved up higher\n                // in the list than that client.\n                int clientIndex = mLruProcesses.lastIndexOf(client);\n                if (DEBUG_LRU && clientIndex < 0) Slog.d(TAG_LRU, \"Unknown client \" + client\n                        + \" when updating \" + app);\n                if (clientIndex <= lrui) {\n                    // Don't allow the client index restriction to push it down farther in the\n                    // list than it already is.\n                    clientIndex = lrui;\n                }\n                if (clientIndex >= 0 && index > clientIndex) {\n                    index = clientIndex;\n                }\n            }\n            if (DEBUG_LRU) Slog.d(TAG_LRU, \"Adding at \" + index + \" of LRU list: \" + app);\n            mLruProcesses.add(index, app);\n            nextIndex = index-1;\n            mLruProcessActivityStart++;\n            mLruProcessServiceStart++;\n        }\n\n```\n\n* hasActivity为true\n\t* 没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。\n\t* 直接添加到最后一个\n* hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置\n* 因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处\n\n\n```\n        for (int j=app.connections.size()-1; j>=0; j--) {\n            ConnectionRecord cr = app.connections.valueAt(j);\n            if (cr.binding != null && !cr.serviceDead && cr.binding.service != null\n                    && cr.binding.service.app != null\n                    && cr.binding.service.app.lruSeq != mLruSeq\n                    && !cr.binding.service.app.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,\n                        \"service connection\", cr, app);\n            }\n        }\n        for (int j=app.conProviders.size()-1; j>=0; j--) {\n            ContentProviderRecord cpr = app.conProviders.get(j).provider;\n            if (cpr.proc != null && cpr.proc.lruSeq != mLruSeq && !cpr.proc.persistent) {\n                nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,\n                        \"provider reference\", cpr, app);\n            }\n        }\n```\n\n把和这个进程关联的service和contentprovider调整到这个进程之后。\n\n### 3. 调整OomAdj值的updateOomAdjLocked方法\n\n方法较长，分段看。\n\n```\n        final ActivityRecord TOP_ACT = resumedAppLocked();\n        final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;\n        final long now = SystemClock.uptimeMillis();\n        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;\n        final int N = mLruProcesses.size();\n\n        if (false) {\n            RuntimeException e = new RuntimeException();\n            e.fillInStackTrace();\n            Slog.i(TAG, \"updateOomAdj: top=\" + TOP_ACT, e);\n        }\n\n        // Reset state in all uid records.\n        for (int i=mActiveUids.size()-1; i>=0; i--) {\n            final UidRecord uidRec = mActiveUids.valueAt(i);\n            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,\n                    \"Starting update of \" + uidRec);\n            uidRec.reset();\n        }\n\n        mAdjSeq++;\n        mNewNumServiceProcs = 0;\n        mNewNumAServiceProcs = 0;\n\n        final int emptyProcessLimit;\n        final int cachedProcessLimit;\n        if (mProcessLimit <= 0) {\n            emptyProcessLimit = cachedProcessLimit = 0;\n        } else if (mProcessLimit == 1) {\n            emptyProcessLimit = 1;\n            cachedProcessLimit = 0;\n        } else {\n            emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);\n            cachedProcessLimit = mProcessLimit - emptyProcessLimit;\n        }\n\n        // Let's determine how many processes we have running vs.\n        // how many slots we have for background processes; we may want\n        // to put multiple processes in a slot of there are enough of\n        // them.\n        int numSlots = (ProcessList.CACHED_APP_MAX_ADJ\n                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;\n        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;\n        if (numEmptyProcs > cachedProcessLimit) {\n            // If there are more empty processes than our limit on cached\n            // processes, then use the cached process limit for the factor.\n            // This ensures that the really old empty processes get pushed\n            // down to the bottom, so if we are running low on memory we will\n            // have a better chance at keeping around more cached processes\n            // instead of a gazillion empty processes.\n            numEmptyProcs = cachedProcessLimit;\n        }\n        int emptyFactor = numEmptyProcs/numSlots;\n        if (emptyFactor < 1) emptyFactor = 1;\n        int cachedFactor = (mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1)/numSlots;\n        if (cachedFactor < 1) cachedFactor = 1;\n        int stepCached = 0;\n        int stepEmpty = 0;\n        int numCached = 0;\n        int numEmpty = 0;\n        int numTrimming = 0;\n\n        mNumNonCachedProcs = 0;\n        mNumCachedHiddenProcs = 0;\n\n```\n\n这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。\n\n\n```\n int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextCachedAdj = curCachedAdj+1;\n        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;\n        int nextEmptyAdj = curEmptyAdj+2;\n        for (int i=N-1; i>=0; i--) {\n            ProcessRecord app = mLruProcesses.get(i);\n            if (!app.killedByAm && app.thread != null) {\n                app.procStateChanged = false;\n                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);\n\n                // If we haven't yet assigned the final cached adj\n                // to the process, do that now.\n                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {\n                    switch (app.curProcState) {\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                            // This process is a cached process holding activities...\n                            // assign it the next cached value for that type, and then\n                            // step that cached level.\n                            app.curRawAdj = curCachedAdj;\n                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning activity LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curCachedAdj=\" + curCachedAdj\n                                    + \")\");\n                            if (curCachedAdj != nextCachedAdj) {\n                                stepCached++;\n                                if (stepCached >= cachedFactor) {\n                                    stepCached = 0;\n                                    curCachedAdj = nextCachedAdj;\n                                    nextCachedAdj += 2;\n                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                        default:\n                            // For everything else, assign next empty cached process\n                            // level and bump that up.  Note that this means that\n                            // long-running services that have dropped down to the\n                            // cached level will be treated as empty (since their process\n                            // state is still as a service), which is what we want.\n                            app.curRawAdj = curEmptyAdj;\n                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);\n                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, \"Assigning empty LRU #\" + i\n                                    + \" adj: \" + app.curAdj + \" (curEmptyAdj=\" + curEmptyAdj\n                                    + \")\");\n                            if (curEmptyAdj != nextEmptyAdj) {\n                                stepEmpty++;\n                                if (stepEmpty >= emptyFactor) {\n                                    stepEmpty = 0;\n                                    curEmptyAdj = nextEmptyAdj;\n                                    nextEmptyAdj += 2;\n                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {\n                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;\n                                    }\n                                }\n                            }\n                            break;\n                    }\n                }\n\n                applyOomAdjLocked(app, true, now);\n\n                // Count the number of process types.\n                switch (app.curProcState) {\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:\n                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:\n                        mNumCachedHiddenProcs++;\n                        numCached++;\n                        if (numCached > cachedProcessLimit) {\n                            app.kill(\"cached #\" + numCached, true);\n                        }\n                        break;\n                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:\n                        if (numEmpty > ProcessList.TRIM_EMPTY_APPS\n                                && app.lastActivityTime < oldTime) {\n                            app.kill(\"empty for \"\n                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)\n                                    / 1000) + \"s\", true);\n                        } else {\n                            numEmpty++;\n                            if (numEmpty > emptyProcessLimit) {\n                                app.kill(\"empty #\" + numEmpty, true);\n                            }\n                        }\n                        break;\n                    default:\n                        mNumNonCachedProcs++;\n                        break;\n                }\n\n                if (app.isolated && app.services.size() <= 0) {\n                    // If this is an isolated process, and there are no\n                    // services running in it, then the process is no longer\n                    // needed.  We agressively kill these because we can by\n                    // definition not re-use the same process again, and it is\n                    // good to avoid having whatever code was running in them\n                    // left sitting around after no longer needed.\n                    app.kill(\"isolated not needed\", true);\n                } else {\n                    // Keeping this process, update its uid.\n                    final UidRecord uidRec = app.uidRecord;\n                    if (uidRec != null && uidRec.curProcState > app.curProcState) {\n                        uidRec.curProcState = app.curProcState;\n                    }\n                }\n\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    numTrimming++;\n                }\n            }\n        }\n```\n\n\n上面代码的逻辑是更新进程oomadj值。\n\n* 首先通过computeOomAdjLocked计算oomadj值\n* 当进程未分配adj值是，更新adj值(if (app.curAdj >= ProcessList.UNKNOWN_ADJ))\n\t* 当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值\n\t* 不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值\n* applyOomAdjLocked,使更新生效\n* 根据进程状态，选择策略\n\t* PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程\n\t* PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程\n* 如果是孤立进程 并且没有service，直接杀掉\n\n\n```\n        final int numCachedAndEmpty = numCached + numEmpty;\n        int memFactor;\n        if (numCached <= ProcessList.TRIM_CACHED_APPS\n                && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {\n            if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n            } else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n            } else {\n                memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n            }\n        } else {\n            memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n        }\n        // We always allow the memory level to go up (better).  We only allow it to go\n        // down if we are in a state where that is allowed, *and* the total number of processes\n        // has gone down since last time.\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"oom: memFactor=\" + memFactor\n                + \" last=\" + mLastMemoryLevel + \" allowLow=\" + mAllowLowerMemLevel\n                + \" numProcs=\" + mLruProcesses.size() + \" last=\" + mLastNumProcesses);\n        if (memFactor > mLastMemoryLevel) {\n            if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {\n                memFactor = mLastMemoryLevel;\n                if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"Keeping last mem factor!\");\n            }\n        }\n        mLastMemoryLevel = memFactor;\n        mLastNumProcesses = mLruProcesses.size();\n        boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\n        final int trackerMemFactor = mProcessStats.getMemFactorLocked();\n        if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n            if (mLowRamStartTime == 0) {\n                mLowRamStartTime = now;\n            }\n            int step = 0;\n            int fgTrimLevel;\n            switch (memFactor) {\n                case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n                    break;\n                case ProcessStats.ADJ_MEM_FACTOR_LOW:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n                    break;\n                default:\n                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n                    break;\n            }\n            int factor = numTrimming/3;\n            int minFactor = 2;\n            if (mHomeProcess != null) minFactor++;\n            if (mPreviousProcess != null) minFactor++;\n            if (factor < minFactor) factor = minFactor;\n            int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME\n                        && !app.killedByAm) {\n                    if (app.trimMemoryLevel < curLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of \" + app.processName + \" to \" + curLevel);\n                            app.thread.scheduleTrimMemory(curLevel);\n                        } catch (RemoteException e) {\n                        }\n                        if (false) {\n                            // For now we won't do this; our memory trimming seems\n                            // to be good enough at this point that destroying\n                            // activities causes more harm than good.\n                            if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                                    && app != mHomeProcess && app != mPreviousProcess) {\n                                // Need to do this on its own message because the stack may not\n                                // be in a consistent state at this point.\n                                // For these apps we will also finish their activities\n                                // to help them free memory.\n                                mStackSupervisor.scheduleDestroyAllActivities(app, \"trim\");\n                            }\n                        }\n                    }\n                    app.trimMemoryLevel = curLevel;\n                    step++;\n                    if (step >= factor) {\n                        step = 0;\n                        switch (curLevel) {\n                            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                                break;\n                            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                                curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                                break;\n                        }\n                    }\n                } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of heavy-weight \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                } else {\n                    if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                            || app.systemNoUi) && app.pendingUiClean) {\n                        // If this application is now in the background and it\n                        // had done UI, then give it the special trim level to\n                        // have it free UI resources.\n                        final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                        if (app.trimMemoryLevel < level && app.thread != null) {\n                            try {\n                                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                        \"Trimming memory of bg-ui \" + app.processName\n                                        + \" to \" + level);\n                                app.thread.scheduleTrimMemory(level);\n                            } catch (RemoteException e) {\n                            }\n                        }\n                        app.pendingUiClean = false;\n                    }\n                    if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of fg \" + app.processName\n                                    + \" to \" + fgTrimLevel);\n                            app.thread.scheduleTrimMemory(fgTrimLevel);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.trimMemoryLevel = fgTrimLevel;\n                }\n            }\n        } else {\n            if (mLowRamStartTime != 0) {\n                mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n                mLowRamStartTime = 0;\n            }\n            for (int i=N-1; i>=0; i--) {\n                ProcessRecord app = mLruProcesses.get(i);\n                if (allChanged || app.procStateChanged) {\n                    setProcessTrackerStateLocked(app, trackerMemFactor, now);\n                    app.procStateChanged = false;\n                }\n                if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                        || app.systemNoUi) && app.pendingUiClean) {\n                    if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                            && app.thread != null) {\n                        try {\n                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                    \"Trimming memory of ui hidden \" + app.processName\n                                    + \" to \" + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                            app.thread.scheduleTrimMemory(\n                                    ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                        } catch (RemoteException e) {\n                        }\n                    }\n                    app.pendingUiClean = false;\n                }\n                app.trimMemoryLevel = 0;\n            }\n        }\n```\t\n\n* 先调整内存因子memFactor\n* 如果内存因子不为0\n\t* 根据内存因子 初始化fgTrimLevel\n\t* 循环处理进程\n\t\t* curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel\n\t\t* curProcState等于9，且满足条件，进行TrimMemory\n\t\t* 其他情况下，根据条件进行TrimMemory操作\n\t \n* 内存因子为0,也是根据跳进进行TrimMemory操作\n\n整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。\n\ncomputeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。\n\n### 4.杀进程\n\n杀进程这里就略过了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\t","slug":"AMS中的进程管理部分－上","published":1,"updated":"2017-01-07T06:57:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy110002hws6a6zyfwqu","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>ActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<ul>\n<li>新建进程</li>\n<li>调整进程在mLruProcesses的位置</li>\n<li>调整进程OomAdj值</li>\n<li>杀进程</li>\n</ul>\n<p>而新建进程在前面有说到过，今天就来介绍下剩下的三个。</p>\n<h3 id=\"2-调整位置的updateLruProcessLocked方法\"><a href=\"#2-调整位置的updateLruProcessLocked方法\" class=\"headerlink\" title=\"2.调整位置的updateLruProcessLocked方法\"></a>2.调整位置的updateLruProcessLocked方法</h3><p>代码比较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean hasActivity = app.activities.size() &gt; 0 || app.hasClientActivities</div><div class=\"line\">        || app.treatLikeActivity;</div><div class=\"line\">final boolean hasService = false; // not impl yet. app.services.size() &gt; 0;</div><div class=\"line\">if (!activityChange &amp;&amp; hasActivity) &#123;</div><div class=\"line\">    // The process has activities, so we are only allowing activity-based adjustments</div><div class=\"line\">    // to move it.  It should be kept in the front of the list with other</div><div class=\"line\">    // processes that have activities, and we don&apos;t want those to change their</div><div class=\"line\">    // order except due to activity operations.</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mLruSeq++;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">app.lastActivityTime = now;</div><div class=\"line\"></div><div class=\"line\">// First a quick reject: if the app is already at the position we will</div><div class=\"line\">// put it, then there is nothing to do.</div><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (N &gt; 0 &amp;&amp; mLruProcesses.get(N-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top activity: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    if (mLruProcessServiceStart &gt; 0</div><div class=\"line\">            &amp;&amp; mLruProcesses.get(mLruProcessServiceStart-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top other: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int lrui = mLruProcesses.lastIndexOf(app);</div><div class=\"line\"></div><div class=\"line\">if (app.persistent &amp;&amp; lrui &gt;= 0) &#123;</div><div class=\"line\">    // We don&apos;t care about the position of persistent processes, as long as</div><div class=\"line\">    // they are in the list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, persistent: &quot; + app);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果有activity，并且进程中activity没有发生变化，不需要调整</li>\n<li>如果有activity，但是当前进程就是在最后，不需要调整</li>\n<li>如果没有activity，但是在合适的位置，不需要调整</li>\n<li>如果有persistent标志，不需要调整</li>\n<li>lrui 为当前进程在list中的索引(最后一个的索引)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (lrui &gt;= 0) &#123;</div><div class=\"line\">    if (lrui &lt; mLruProcessActivityStart) &#123;</div><div class=\"line\">        mLruProcessActivityStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (lrui &lt; mLruProcessServiceStart) &#123;</div><div class=\"line\">        mLruProcessServiceStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">    if (addIndex &gt; lrui) &#123;</div><div class=\"line\">        addIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (nextIndex &gt; lrui) &#123;</div><div class=\"line\">        nextIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    */</div><div class=\"line\">    mLruProcesses.remove(lrui);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (app.activities.size() == 0 &amp;&amp; mLruProcessActivityStart &lt; (N - 1)) &#123;</div><div class=\"line\">        // Process doesn&apos;t have activities, but has clients with</div><div class=\"line\">        // activities...  move it up, but one below the top (the top</div><div class=\"line\">        // should always have a real activity).</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                &quot;Adding to second-top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(N - 1, app);</div><div class=\"line\">        // To keep it from spamming the LRU list (by making a bunch of clients),</div><div class=\"line\">        // we will push down any other entries owned by the app.</div><div class=\"line\">        final int uid = app.info.uid;</div><div class=\"line\">        for (int i = N - 2; i &gt; mLruProcessActivityStart; i--) &#123;</div><div class=\"line\">            ProcessRecord subProc = mLruProcesses.get(i);</div><div class=\"line\">            if (subProc.info.uid == uid) &#123;</div><div class=\"line\">                // We want to push this one down the list.  If the process after</div><div class=\"line\">                // it is for the same uid, however, don&apos;t do so, because we don&apos;t</div><div class=\"line\">                // want them internally to be re-ordered.</div><div class=\"line\">                if (mLruProcesses.get(i - 1).info.uid != uid) &#123;</div><div class=\"line\">                    if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                            &quot;Pushing uid &quot; + uid + &quot; swapping at &quot; + i + &quot;: &quot;</div><div class=\"line\">                            + mLruProcesses.get(i) + &quot; : &quot; + mLruProcesses.get(i - 1));</div><div class=\"line\">                    ProcessRecord tmp = mLruProcesses.get(i);</div><div class=\"line\">                    mLruProcesses.set(i, mLruProcesses.get(i - 1));</div><div class=\"line\">                    mLruProcesses.set(i - 1, tmp);</div><div class=\"line\">                    i--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // A gap, we can stop here.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Process has activities, put it at the very tipsy-top.</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(app);</div><div class=\"line\">    &#125;</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">&#125; else if (hasService) &#123;</div><div class=\"line\">    // Process has services, put it at the top of the service list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU service list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(mLruProcessActivityStart, app);</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">&#125; else  &#123;</div><div class=\"line\">    // Process not otherwise of interest, it goes to the top of the non-service area.</div><div class=\"line\">    int index = mLruProcessServiceStart;</div><div class=\"line\">    if (client != null) &#123;</div><div class=\"line\">        // If there is a client, don&apos;t allow the process to be moved up higher</div><div class=\"line\">        // in the list than that client.</div><div class=\"line\">        int clientIndex = mLruProcesses.lastIndexOf(client);</div><div class=\"line\">        if (DEBUG_LRU &amp;&amp; clientIndex &lt; 0) Slog.d(TAG_LRU, &quot;Unknown client &quot; + client</div><div class=\"line\">                + &quot; when updating &quot; + app);</div><div class=\"line\">        if (clientIndex &lt;= lrui) &#123;</div><div class=\"line\">            // Don&apos;t allow the client index restriction to push it down farther in the</div><div class=\"line\">            // list than it already is.</div><div class=\"line\">            clientIndex = lrui;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (clientIndex &gt;= 0 &amp;&amp; index &gt; clientIndex) &#123;</div><div class=\"line\">            index = clientIndex;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding at &quot; + index + &quot; of LRU list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(index, app);</div><div class=\"line\">    nextIndex = index-1;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">    mLruProcessServiceStart++;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>hasActivity为true<ul>\n<li>没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。</li>\n<li>直接添加到最后一个</li>\n</ul>\n</li>\n<li>hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置</li>\n<li>因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j=app.connections.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ConnectionRecord cr = app.connections.valueAt(j);</div><div class=\"line\">    if (cr.binding != null &amp;&amp; !cr.serviceDead &amp;&amp; cr.binding.service != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app.lruSeq != mLruSeq</div><div class=\"line\">            &amp;&amp; !cr.binding.service.app.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,</div><div class=\"line\">                &quot;service connection&quot;, cr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">for (int j=app.conProviders.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ContentProviderRecord cpr = app.conProviders.get(j).provider;</div><div class=\"line\">    if (cpr.proc != null &amp;&amp; cpr.proc.lruSeq != mLruSeq &amp;&amp; !cpr.proc.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,</div><div class=\"line\">                &quot;provider reference&quot;, cpr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>把和这个进程关联的service和contentprovider调整到这个进程之后。</p>\n<h3 id=\"3-调整OomAdj值的updateOomAdjLocked方法\"><a href=\"#3-调整OomAdj值的updateOomAdjLocked方法\" class=\"headerlink\" title=\"3. 调整OomAdj值的updateOomAdjLocked方法\"></a>3. 调整OomAdj值的updateOomAdjLocked方法</h3><p>方法较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ActivityRecord TOP_ACT = resumedAppLocked();</div><div class=\"line\">final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">final long oldTime = now - ProcessList.MAX_EMPTY_TIME;</div><div class=\"line\">final int N = mLruProcesses.size();</div><div class=\"line\"></div><div class=\"line\">if (false) &#123;</div><div class=\"line\">    RuntimeException e = new RuntimeException();</div><div class=\"line\">    e.fillInStackTrace();</div><div class=\"line\">    Slog.i(TAG, &quot;updateOomAdj: top=&quot; + TOP_ACT, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Reset state in all uid records.</div><div class=\"line\">for (int i=mActiveUids.size()-1; i&gt;=0; i--) &#123;</div><div class=\"line\">    final UidRecord uidRec = mActiveUids.valueAt(i);</div><div class=\"line\">    if (false &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</div><div class=\"line\">            &quot;Starting update of &quot; + uidRec);</div><div class=\"line\">    uidRec.reset();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mAdjSeq++;</div><div class=\"line\">mNewNumServiceProcs = 0;</div><div class=\"line\">mNewNumAServiceProcs = 0;</div><div class=\"line\"></div><div class=\"line\">final int emptyProcessLimit;</div><div class=\"line\">final int cachedProcessLimit;</div><div class=\"line\">if (mProcessLimit &lt;= 0) &#123;</div><div class=\"line\">    emptyProcessLimit = cachedProcessLimit = 0;</div><div class=\"line\">&#125; else if (mProcessLimit == 1) &#123;</div><div class=\"line\">    emptyProcessLimit = 1;</div><div class=\"line\">    cachedProcessLimit = 0;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);</div><div class=\"line\">    cachedProcessLimit = mProcessLimit - emptyProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Let&apos;s determine how many processes we have running vs.</div><div class=\"line\">// how many slots we have for background processes; we may want</div><div class=\"line\">// to put multiple processes in a slot of there are enough of</div><div class=\"line\">// them.</div><div class=\"line\">int numSlots = (ProcessList.CACHED_APP_MAX_ADJ</div><div class=\"line\">        - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;</div><div class=\"line\">int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</div><div class=\"line\">if (numEmptyProcs &gt; cachedProcessLimit) &#123;</div><div class=\"line\">    // If there are more empty processes than our limit on cached</div><div class=\"line\">    // processes, then use the cached process limit for the factor.</div><div class=\"line\">    // This ensures that the really old empty processes get pushed</div><div class=\"line\">    // down to the bottom, so if we are running low on memory we will</div><div class=\"line\">    // have a better chance at keeping around more cached processes</div><div class=\"line\">    // instead of a gazillion empty processes.</div><div class=\"line\">    numEmptyProcs = cachedProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\">int emptyFactor = numEmptyProcs/numSlots;</div><div class=\"line\">if (emptyFactor &lt; 1) emptyFactor = 1;</div><div class=\"line\">int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1)/numSlots;</div><div class=\"line\">if (cachedFactor &lt; 1) cachedFactor = 1;</div><div class=\"line\">int stepCached = 0;</div><div class=\"line\">int stepEmpty = 0;</div><div class=\"line\">int numCached = 0;</div><div class=\"line\">int numEmpty = 0;</div><div class=\"line\">int numTrimming = 0;</div><div class=\"line\"></div><div class=\"line\">mNumNonCachedProcs = 0;</div><div class=\"line\">mNumCachedHiddenProcs = 0;</div></pre></td></tr></table></figure>\n<p>这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextCachedAdj = curCachedAdj+1;</div><div class=\"line\">       int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextEmptyAdj = curEmptyAdj+2;</div><div class=\"line\">       for (int i=N-1; i&gt;=0; i--) &#123;</div><div class=\"line\">           ProcessRecord app = mLruProcesses.get(i);</div><div class=\"line\">           if (!app.killedByAm &amp;&amp; app.thread != null) &#123;</div><div class=\"line\">               app.procStateChanged = false;</div><div class=\"line\">               computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);</div><div class=\"line\"></div><div class=\"line\">               // If we haven&apos;t yet assigned the final cached adj</div><div class=\"line\">               // to the process, do that now.</div><div class=\"line\">               if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</div><div class=\"line\">                   switch (app.curProcState) &#123;</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                           // This process is a cached process holding activities...</div><div class=\"line\">                           // assign it the next cached value for that type, and then</div><div class=\"line\">                           // step that cached level.</div><div class=\"line\">                           app.curRawAdj = curCachedAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curCachedAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning activity LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curCachedAdj=&quot; + curCachedAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curCachedAdj != nextCachedAdj) &#123;</div><div class=\"line\">                               stepCached++;</div><div class=\"line\">                               if (stepCached &gt;= cachedFactor) &#123;</div><div class=\"line\">                                   stepCached = 0;</div><div class=\"line\">                                   curCachedAdj = nextCachedAdj;</div><div class=\"line\">                                   nextCachedAdj += 2;</div><div class=\"line\">                                   if (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                       default:</div><div class=\"line\">                           // For everything else, assign next empty cached process</div><div class=\"line\">                           // level and bump that up.  Note that this means that</div><div class=\"line\">                           // long-running services that have dropped down to the</div><div class=\"line\">                           // cached level will be treated as empty (since their process</div><div class=\"line\">                           // state is still as a service), which is what we want.</div><div class=\"line\">                           app.curRawAdj = curEmptyAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning empty LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curEmptyAdj=&quot; + curEmptyAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curEmptyAdj != nextEmptyAdj) &#123;</div><div class=\"line\">                               stepEmpty++;</div><div class=\"line\">                               if (stepEmpty &gt;= emptyFactor) &#123;</div><div class=\"line\">                                   stepEmpty = 0;</div><div class=\"line\">                                   curEmptyAdj = nextEmptyAdj;</div><div class=\"line\">                                   nextEmptyAdj += 2;</div><div class=\"line\">                                   if (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               applyOomAdjLocked(app, true, now);</div><div class=\"line\"></div><div class=\"line\">               // Count the number of process types.</div><div class=\"line\">               switch (app.curProcState) &#123;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                       mNumCachedHiddenProcs++;</div><div class=\"line\">                       numCached++;</div><div class=\"line\">                       if (numCached &gt; cachedProcessLimit) &#123;</div><div class=\"line\">                           app.kill(&quot;cached #&quot; + numCached, true);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_EMPTY:</div><div class=\"line\">                       if (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS</div><div class=\"line\">                               &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</div><div class=\"line\">                           app.kill(&quot;empty for &quot;</div><div class=\"line\">                                   + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)</div><div class=\"line\">                                   / 1000) + &quot;s&quot;, true);</div><div class=\"line\">                       &#125; else &#123;</div><div class=\"line\">                           numEmpty++;</div><div class=\"line\">                           if (numEmpty &gt; emptyProcessLimit) &#123;</div><div class=\"line\">                               app.kill(&quot;empty #&quot; + numEmpty, true);</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   default:</div><div class=\"line\">                       mNumNonCachedProcs++;</div><div class=\"line\">                       break;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.isolated &amp;&amp; app.services.size() &lt;= 0) &#123;</div><div class=\"line\">                   // If this is an isolated process, and there are no</div><div class=\"line\">                   // services running in it, then the process is no longer</div><div class=\"line\">                   // needed.  We agressively kill these because we can by</div><div class=\"line\">                   // definition not re-use the same process again, and it is</div><div class=\"line\">                   // good to avoid having whatever code was running in them</div><div class=\"line\">                   // left sitting around after no longer needed.</div><div class=\"line\">                   app.kill(&quot;isolated not needed&quot;, true);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Keeping this process, update its uid.</div><div class=\"line\">                   final UidRecord uidRec = app.uidRecord;</div><div class=\"line\">                   if (uidRec != null &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123;</div><div class=\"line\">                       uidRec.curProcState = app.curProcState;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</div><div class=\"line\">                       &amp;&amp; !app.killedByAm) &#123;</div><div class=\"line\">                   numTrimming++;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>上面代码的逻辑是更新进程oomadj值。</p>\n<ul>\n<li>首先通过computeOomAdjLocked计算oomadj值</li>\n<li>当进程未分配adj值是，更新adj值(if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ))<ul>\n<li>当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值</li>\n<li>不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值</li>\n</ul>\n</li>\n<li>applyOomAdjLocked,使更新生效</li>\n<li>根据进程状态，选择策略<ul>\n<li>PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程</li>\n<li>PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程</li>\n</ul>\n</li>\n<li>如果是孤立进程 并且没有service，直接杀掉</li>\n</ul>\n<pre><code>final int numCachedAndEmpty = numCached + numEmpty;\nint memFactor;\nif (numCached &lt;= ProcessList.TRIM_CACHED_APPS\n        &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) {\n    if (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n    } else if (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n    } else {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n    }\n} else {\n    memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n}\n// We always allow the memory level to go up (better).  We only allow it to go\n// down if we are in a state where that is allowed, *and* the total number of processes\n// has gone down since last time.\nif (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;oom: memFactor=&quot; + memFactor\n        + &quot; last=&quot; + mLastMemoryLevel + &quot; allowLow=&quot; + mAllowLowerMemLevel\n        + &quot; numProcs=&quot; + mLruProcesses.size() + &quot; last=&quot; + mLastNumProcesses);\nif (memFactor &gt; mLastMemoryLevel) {\n    if (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) {\n        memFactor = mLastMemoryLevel;\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;Keeping last mem factor!&quot;);\n    }\n}\nmLastMemoryLevel = memFactor;\nmLastNumProcesses = mLruProcesses.size();\nboolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\nfinal int trackerMemFactor = mProcessStats.getMemFactorLocked();\nif (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n    if (mLowRamStartTime == 0) {\n        mLowRamStartTime = now;\n    }\n    int step = 0;\n    int fgTrimLevel;\n    switch (memFactor) {\n        case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n            break;\n        case ProcessStats.ADJ_MEM_FACTOR_LOW:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n            break;\n        default:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n            break;\n    }\n    int factor = numTrimming/3;\n    int minFactor = 2;\n    if (mHomeProcess != null) minFactor++;\n    if (mPreviousProcess != null) minFactor++;\n    if (factor &lt; minFactor) factor = minFactor;\n    int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME\n                &amp;&amp; !app.killedByAm) {\n            if (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of &quot; + app.processName + &quot; to &quot; + curLevel);\n                    app.thread.scheduleTrimMemory(curLevel);\n                } catch (RemoteException e) {\n                }\n                if (false) {\n                    // For now we won&apos;t do this; our memory trimming seems\n                    // to be good enough at this point that destroying\n                    // activities causes more harm than good.\n                    if (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                            &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) {\n                        // Need to do this on its own message because the stack may not\n                        // be in a consistent state at this point.\n                        // For these apps we will also finish their activities\n                        // to help them free memory.\n                        mStackSupervisor.scheduleDestroyAllActivities(app, &quot;trim&quot;);\n                    }\n                }\n            }\n            app.trimMemoryLevel = curLevel;\n            step++;\n            if (step &gt;= factor) {\n                step = 0;\n                switch (curLevel) {\n                    case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                        break;\n                    case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                        break;\n                }\n            }\n        } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of heavy-weight &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n        } else {\n            if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                    || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n                // If this application is now in the background and it\n                // had done UI, then give it the special trim level to\n                // have it free UI resources.\n                final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                if (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != null) {\n                    try {\n                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                &quot;Trimming memory of bg-ui &quot; + app.processName\n                                + &quot; to &quot; + level);\n                        app.thread.scheduleTrimMemory(level);\n                    } catch (RemoteException e) {\n                    }\n                }\n                app.pendingUiClean = false;\n            }\n            if (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of fg &quot; + app.processName\n                            + &quot; to &quot; + fgTrimLevel);\n                    app.thread.scheduleTrimMemory(fgTrimLevel);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = fgTrimLevel;\n        }\n    }\n} else {\n    if (mLowRamStartTime != 0) {\n        mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n        mLowRamStartTime = 0;\n    }\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of ui hidden &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                } catch (RemoteException e) {\n                }\n            }\n            app.pendingUiClean = false;\n        }\n        app.trimMemoryLevel = 0;\n    }\n}\n</code></pre><ul>\n<li>先调整内存因子memFactor</li>\n<li><p>如果内存因子不为0</p>\n<ul>\n<li>根据内存因子 初始化fgTrimLevel</li>\n<li>循环处理进程<ul>\n<li>curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel</li>\n<li>curProcState等于9，且满足条件，进行TrimMemory</li>\n<li>其他情况下，根据条件进行TrimMemory操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内存因子为0,也是根据跳进进行TrimMemory操作</p>\n</li>\n</ul>\n<p>整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。</p>\n<p>computeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。</p>\n<h3 id=\"4-杀进程\"><a href=\"#4-杀进程\" class=\"headerlink\" title=\"4.杀进程\"></a>4.杀进程</h3><p>杀进程这里就略过了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>ActivityManagerService作为一个核心系统服务，除了负责管理四大组件之外，还负责管理进程，对进程的管理有以下方面:</p>","more":"<The rest of contents | 余下全文>\n\n\n<ul>\n<li>新建进程</li>\n<li>调整进程在mLruProcesses的位置</li>\n<li>调整进程OomAdj值</li>\n<li>杀进程</li>\n</ul>\n<p>而新建进程在前面有说到过，今天就来介绍下剩下的三个。</p>\n<h3 id=\"2-调整位置的updateLruProcessLocked方法\"><a href=\"#2-调整位置的updateLruProcessLocked方法\" class=\"headerlink\" title=\"2.调整位置的updateLruProcessLocked方法\"></a>2.调整位置的updateLruProcessLocked方法</h3><p>代码比较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean hasActivity = app.activities.size() &gt; 0 || app.hasClientActivities</div><div class=\"line\">        || app.treatLikeActivity;</div><div class=\"line\">final boolean hasService = false; // not impl yet. app.services.size() &gt; 0;</div><div class=\"line\">if (!activityChange &amp;&amp; hasActivity) &#123;</div><div class=\"line\">    // The process has activities, so we are only allowing activity-based adjustments</div><div class=\"line\">    // to move it.  It should be kept in the front of the list with other</div><div class=\"line\">    // processes that have activities, and we don&apos;t want those to change their</div><div class=\"line\">    // order except due to activity operations.</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mLruSeq++;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">app.lastActivityTime = now;</div><div class=\"line\"></div><div class=\"line\">// First a quick reject: if the app is already at the position we will</div><div class=\"line\">// put it, then there is nothing to do.</div><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (N &gt; 0 &amp;&amp; mLruProcesses.get(N-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top activity: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    if (mLruProcessServiceStart &gt; 0</div><div class=\"line\">            &amp;&amp; mLruProcesses.get(mLruProcessServiceStart-1) == app) &#123;</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, already top other: &quot; + app);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int lrui = mLruProcesses.lastIndexOf(app);</div><div class=\"line\"></div><div class=\"line\">if (app.persistent &amp;&amp; lrui &gt;= 0) &#123;</div><div class=\"line\">    // We don&apos;t care about the position of persistent processes, as long as</div><div class=\"line\">    // they are in the list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Not moving, persistent: &quot; + app);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果有activity，并且进程中activity没有发生变化，不需要调整</li>\n<li>如果有activity，但是当前进程就是在最后，不需要调整</li>\n<li>如果没有activity，但是在合适的位置，不需要调整</li>\n<li>如果有persistent标志，不需要调整</li>\n<li>lrui 为当前进程在list中的索引(最后一个的索引)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (lrui &gt;= 0) &#123;</div><div class=\"line\">    if (lrui &lt; mLruProcessActivityStart) &#123;</div><div class=\"line\">        mLruProcessActivityStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (lrui &lt; mLruProcessServiceStart) &#123;</div><div class=\"line\">        mLruProcessServiceStart--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">    if (addIndex &gt; lrui) &#123;</div><div class=\"line\">        addIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (nextIndex &gt; lrui) &#123;</div><div class=\"line\">        nextIndex--;</div><div class=\"line\">    &#125;</div><div class=\"line\">    */</div><div class=\"line\">    mLruProcesses.remove(lrui);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果已经存在，调整mLruProcessActivityStart和mLruProcessServiceStart，并且暂时从列表中移除进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasActivity) &#123;</div><div class=\"line\">    final int N = mLruProcesses.size();</div><div class=\"line\">    if (app.activities.size() == 0 &amp;&amp; mLruProcessActivityStart &lt; (N - 1)) &#123;</div><div class=\"line\">        // Process doesn&apos;t have activities, but has clients with</div><div class=\"line\">        // activities...  move it up, but one below the top (the top</div><div class=\"line\">        // should always have a real activity).</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                &quot;Adding to second-top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(N - 1, app);</div><div class=\"line\">        // To keep it from spamming the LRU list (by making a bunch of clients),</div><div class=\"line\">        // we will push down any other entries owned by the app.</div><div class=\"line\">        final int uid = app.info.uid;</div><div class=\"line\">        for (int i = N - 2; i &gt; mLruProcessActivityStart; i--) &#123;</div><div class=\"line\">            ProcessRecord subProc = mLruProcesses.get(i);</div><div class=\"line\">            if (subProc.info.uid == uid) &#123;</div><div class=\"line\">                // We want to push this one down the list.  If the process after</div><div class=\"line\">                // it is for the same uid, however, don&apos;t do so, because we don&apos;t</div><div class=\"line\">                // want them internally to be re-ordered.</div><div class=\"line\">                if (mLruProcesses.get(i - 1).info.uid != uid) &#123;</div><div class=\"line\">                    if (DEBUG_LRU) Slog.d(TAG_LRU,</div><div class=\"line\">                            &quot;Pushing uid &quot; + uid + &quot; swapping at &quot; + i + &quot;: &quot;</div><div class=\"line\">                            + mLruProcesses.get(i) + &quot; : &quot; + mLruProcesses.get(i - 1));</div><div class=\"line\">                    ProcessRecord tmp = mLruProcesses.get(i);</div><div class=\"line\">                    mLruProcesses.set(i, mLruProcesses.get(i - 1));</div><div class=\"line\">                    mLruProcesses.set(i - 1, tmp);</div><div class=\"line\">                    i--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // A gap, we can stop here.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Process has activities, put it at the very tipsy-top.</div><div class=\"line\">        if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU activity list: &quot; + app);</div><div class=\"line\">        mLruProcesses.add(app);</div><div class=\"line\">    &#125;</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">&#125; else if (hasService) &#123;</div><div class=\"line\">    // Process has services, put it at the top of the service list.</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding to top of LRU service list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(mLruProcessActivityStart, app);</div><div class=\"line\">    nextIndex = mLruProcessServiceStart;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">&#125; else  &#123;</div><div class=\"line\">    // Process not otherwise of interest, it goes to the top of the non-service area.</div><div class=\"line\">    int index = mLruProcessServiceStart;</div><div class=\"line\">    if (client != null) &#123;</div><div class=\"line\">        // If there is a client, don&apos;t allow the process to be moved up higher</div><div class=\"line\">        // in the list than that client.</div><div class=\"line\">        int clientIndex = mLruProcesses.lastIndexOf(client);</div><div class=\"line\">        if (DEBUG_LRU &amp;&amp; clientIndex &lt; 0) Slog.d(TAG_LRU, &quot;Unknown client &quot; + client</div><div class=\"line\">                + &quot; when updating &quot; + app);</div><div class=\"line\">        if (clientIndex &lt;= lrui) &#123;</div><div class=\"line\">            // Don&apos;t allow the client index restriction to push it down farther in the</div><div class=\"line\">            // list than it already is.</div><div class=\"line\">            clientIndex = lrui;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (clientIndex &gt;= 0 &amp;&amp; index &gt; clientIndex) &#123;</div><div class=\"line\">            index = clientIndex;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (DEBUG_LRU) Slog.d(TAG_LRU, &quot;Adding at &quot; + index + &quot; of LRU list: &quot; + app);</div><div class=\"line\">    mLruProcesses.add(index, app);</div><div class=\"line\">    nextIndex = index-1;</div><div class=\"line\">    mLruProcessActivityStart++;</div><div class=\"line\">    mLruProcessServiceStart++;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>hasActivity为true<ul>\n<li>没有activities，但是有hasClientActivities，将当前进程插入到列表的最后，从mLruProcessActivityStart到n－2的位置，如果i处的uid和当前进程uid相等，但是上一个却不等的话，交换位置。</li>\n<li>直接添加到最后一个</li>\n</ul>\n</li>\n<li>hasActivity为false，hasService为true，加入到mLruProcessActivityStart位置</li>\n<li>因为client大多为null，所以这里插入到index位置，也就是mLruProcessServiceStart处</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int j=app.connections.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ConnectionRecord cr = app.connections.valueAt(j);</div><div class=\"line\">    if (cr.binding != null &amp;&amp; !cr.serviceDead &amp;&amp; cr.binding.service != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app != null</div><div class=\"line\">            &amp;&amp; cr.binding.service.app.lruSeq != mLruSeq</div><div class=\"line\">            &amp;&amp; !cr.binding.service.app.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex,</div><div class=\"line\">                &quot;service connection&quot;, cr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">for (int j=app.conProviders.size()-1; j&gt;=0; j--) &#123;</div><div class=\"line\">    ContentProviderRecord cpr = app.conProviders.get(j).provider;</div><div class=\"line\">    if (cpr.proc != null &amp;&amp; cpr.proc.lruSeq != mLruSeq &amp;&amp; !cpr.proc.persistent) &#123;</div><div class=\"line\">        nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex,</div><div class=\"line\">                &quot;provider reference&quot;, cpr, app);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>把和这个进程关联的service和contentprovider调整到这个进程之后。</p>\n<h3 id=\"3-调整OomAdj值的updateOomAdjLocked方法\"><a href=\"#3-调整OomAdj值的updateOomAdjLocked方法\" class=\"headerlink\" title=\"3. 调整OomAdj值的updateOomAdjLocked方法\"></a>3. 调整OomAdj值的updateOomAdjLocked方法</h3><p>方法较长，分段看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ActivityRecord TOP_ACT = resumedAppLocked();</div><div class=\"line\">final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;</div><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">final long oldTime = now - ProcessList.MAX_EMPTY_TIME;</div><div class=\"line\">final int N = mLruProcesses.size();</div><div class=\"line\"></div><div class=\"line\">if (false) &#123;</div><div class=\"line\">    RuntimeException e = new RuntimeException();</div><div class=\"line\">    e.fillInStackTrace();</div><div class=\"line\">    Slog.i(TAG, &quot;updateOomAdj: top=&quot; + TOP_ACT, e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Reset state in all uid records.</div><div class=\"line\">for (int i=mActiveUids.size()-1; i&gt;=0; i--) &#123;</div><div class=\"line\">    final UidRecord uidRec = mActiveUids.valueAt(i);</div><div class=\"line\">    if (false &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</div><div class=\"line\">            &quot;Starting update of &quot; + uidRec);</div><div class=\"line\">    uidRec.reset();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mAdjSeq++;</div><div class=\"line\">mNewNumServiceProcs = 0;</div><div class=\"line\">mNewNumAServiceProcs = 0;</div><div class=\"line\"></div><div class=\"line\">final int emptyProcessLimit;</div><div class=\"line\">final int cachedProcessLimit;</div><div class=\"line\">if (mProcessLimit &lt;= 0) &#123;</div><div class=\"line\">    emptyProcessLimit = cachedProcessLimit = 0;</div><div class=\"line\">&#125; else if (mProcessLimit == 1) &#123;</div><div class=\"line\">    emptyProcessLimit = 1;</div><div class=\"line\">    cachedProcessLimit = 0;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);</div><div class=\"line\">    cachedProcessLimit = mProcessLimit - emptyProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Let&apos;s determine how many processes we have running vs.</div><div class=\"line\">// how many slots we have for background processes; we may want</div><div class=\"line\">// to put multiple processes in a slot of there are enough of</div><div class=\"line\">// them.</div><div class=\"line\">int numSlots = (ProcessList.CACHED_APP_MAX_ADJ</div><div class=\"line\">        - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;</div><div class=\"line\">int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</div><div class=\"line\">if (numEmptyProcs &gt; cachedProcessLimit) &#123;</div><div class=\"line\">    // If there are more empty processes than our limit on cached</div><div class=\"line\">    // processes, then use the cached process limit for the factor.</div><div class=\"line\">    // This ensures that the really old empty processes get pushed</div><div class=\"line\">    // down to the bottom, so if we are running low on memory we will</div><div class=\"line\">    // have a better chance at keeping around more cached processes</div><div class=\"line\">    // instead of a gazillion empty processes.</div><div class=\"line\">    numEmptyProcs = cachedProcessLimit;</div><div class=\"line\">&#125;</div><div class=\"line\">int emptyFactor = numEmptyProcs/numSlots;</div><div class=\"line\">if (emptyFactor &lt; 1) emptyFactor = 1;</div><div class=\"line\">int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1)/numSlots;</div><div class=\"line\">if (cachedFactor &lt; 1) cachedFactor = 1;</div><div class=\"line\">int stepCached = 0;</div><div class=\"line\">int stepEmpty = 0;</div><div class=\"line\">int numCached = 0;</div><div class=\"line\">int numEmpty = 0;</div><div class=\"line\">int numTrimming = 0;</div><div class=\"line\"></div><div class=\"line\">mNumNonCachedProcs = 0;</div><div class=\"line\">mNumCachedHiddenProcs = 0;</div></pre></td></tr></table></figure>\n<p>这一部分代码是对一些值进行初始化操作，如空进程、缓存进程的数目，numSlots。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextCachedAdj = curCachedAdj+1;</div><div class=\"line\">       int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;</div><div class=\"line\">       int nextEmptyAdj = curEmptyAdj+2;</div><div class=\"line\">       for (int i=N-1; i&gt;=0; i--) &#123;</div><div class=\"line\">           ProcessRecord app = mLruProcesses.get(i);</div><div class=\"line\">           if (!app.killedByAm &amp;&amp; app.thread != null) &#123;</div><div class=\"line\">               app.procStateChanged = false;</div><div class=\"line\">               computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);</div><div class=\"line\"></div><div class=\"line\">               // If we haven&apos;t yet assigned the final cached adj</div><div class=\"line\">               // to the process, do that now.</div><div class=\"line\">               if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</div><div class=\"line\">                   switch (app.curProcState) &#123;</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                       case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                           // This process is a cached process holding activities...</div><div class=\"line\">                           // assign it the next cached value for that type, and then</div><div class=\"line\">                           // step that cached level.</div><div class=\"line\">                           app.curRawAdj = curCachedAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curCachedAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning activity LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curCachedAdj=&quot; + curCachedAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curCachedAdj != nextCachedAdj) &#123;</div><div class=\"line\">                               stepCached++;</div><div class=\"line\">                               if (stepCached &gt;= cachedFactor) &#123;</div><div class=\"line\">                                   stepCached = 0;</div><div class=\"line\">                                   curCachedAdj = nextCachedAdj;</div><div class=\"line\">                                   nextCachedAdj += 2;</div><div class=\"line\">                                   if (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                       default:</div><div class=\"line\">                           // For everything else, assign next empty cached process</div><div class=\"line\">                           // level and bump that up.  Note that this means that</div><div class=\"line\">                           // long-running services that have dropped down to the</div><div class=\"line\">                           // cached level will be treated as empty (since their process</div><div class=\"line\">                           // state is still as a service), which is what we want.</div><div class=\"line\">                           app.curRawAdj = curEmptyAdj;</div><div class=\"line\">                           app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</div><div class=\"line\">                           if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning empty LRU #&quot; + i</div><div class=\"line\">                                   + &quot; adj: &quot; + app.curAdj + &quot; (curEmptyAdj=&quot; + curEmptyAdj</div><div class=\"line\">                                   + &quot;)&quot;);</div><div class=\"line\">                           if (curEmptyAdj != nextEmptyAdj) &#123;</div><div class=\"line\">                               stepEmpty++;</div><div class=\"line\">                               if (stepEmpty &gt;= emptyFactor) &#123;</div><div class=\"line\">                                   stepEmpty = 0;</div><div class=\"line\">                                   curEmptyAdj = nextEmptyAdj;</div><div class=\"line\">                                   nextEmptyAdj += 2;</div><div class=\"line\">                                   if (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</div><div class=\"line\">                                       nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;</div><div class=\"line\">                                   &#125;</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               applyOomAdjLocked(app, true, now);</div><div class=\"line\"></div><div class=\"line\">               // Count the number of process types.</div><div class=\"line\">               switch (app.curProcState) &#123;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</div><div class=\"line\">                       mNumCachedHiddenProcs++;</div><div class=\"line\">                       numCached++;</div><div class=\"line\">                       if (numCached &gt; cachedProcessLimit) &#123;</div><div class=\"line\">                           app.kill(&quot;cached #&quot; + numCached, true);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   case ActivityManager.PROCESS_STATE_CACHED_EMPTY:</div><div class=\"line\">                       if (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS</div><div class=\"line\">                               &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</div><div class=\"line\">                           app.kill(&quot;empty for &quot;</div><div class=\"line\">                                   + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)</div><div class=\"line\">                                   / 1000) + &quot;s&quot;, true);</div><div class=\"line\">                       &#125; else &#123;</div><div class=\"line\">                           numEmpty++;</div><div class=\"line\">                           if (numEmpty &gt; emptyProcessLimit) &#123;</div><div class=\"line\">                               app.kill(&quot;empty #&quot; + numEmpty, true);</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       break;</div><div class=\"line\">                   default:</div><div class=\"line\">                       mNumNonCachedProcs++;</div><div class=\"line\">                       break;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.isolated &amp;&amp; app.services.size() &lt;= 0) &#123;</div><div class=\"line\">                   // If this is an isolated process, and there are no</div><div class=\"line\">                   // services running in it, then the process is no longer</div><div class=\"line\">                   // needed.  We agressively kill these because we can by</div><div class=\"line\">                   // definition not re-use the same process again, and it is</div><div class=\"line\">                   // good to avoid having whatever code was running in them</div><div class=\"line\">                   // left sitting around after no longer needed.</div><div class=\"line\">                   app.kill(&quot;isolated not needed&quot;, true);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Keeping this process, update its uid.</div><div class=\"line\">                   final UidRecord uidRec = app.uidRecord;</div><div class=\"line\">                   if (uidRec != null &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123;</div><div class=\"line\">                       uidRec.curProcState = app.curProcState;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</div><div class=\"line\">                       &amp;&amp; !app.killedByAm) &#123;</div><div class=\"line\">                   numTrimming++;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>上面代码的逻辑是更新进程oomadj值。</p>\n<ul>\n<li>首先通过computeOomAdjLocked计算oomadj值</li>\n<li>当进程未分配adj值是，更新adj值(if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ))<ul>\n<li>当前进程状态为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj为9(CACHED_APP_MIN_ADJ),若当前cache adj不等于下一个cache adj的时候， 调整nextCachedAdj和curCachedAdj值</li>\n<li>不是PROCESS_STATE_CACHED_ACTIVITY和PROCESS_STATE_CACHED_ACTIVITY_CLIENT，修改adj值为curEmptyAdj，当curEmptyAdj不等于nextEmptyAdj的时候，调整这两个值</li>\n</ul>\n</li>\n<li>applyOomAdjLocked,使更新生效</li>\n<li>根据进程状态，选择策略<ul>\n<li>PROCESS_STATE_CACHED_ACTIVITY_CLIENT，如果，缓存进程数大于最大限制的话，杀掉进程</li>\n<li>PROCESS_STATE_CACHED_EMPTY ,空进程超过数目上线，并且空闲时间大于30分钟，这杀掉进程</li>\n</ul>\n</li>\n<li>如果是孤立进程 并且没有service，直接杀掉</li>\n</ul>\n<pre><code>final int numCachedAndEmpty = numCached + numEmpty;\nint memFactor;\nif (numCached &lt;= ProcessList.TRIM_CACHED_APPS\n        &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) {\n    if (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;\n    } else if (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;\n    } else {\n        memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;\n    }\n} else {\n    memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;\n}\n// We always allow the memory level to go up (better).  We only allow it to go\n// down if we are in a state where that is allowed, *and* the total number of processes\n// has gone down since last time.\nif (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;oom: memFactor=&quot; + memFactor\n        + &quot; last=&quot; + mLastMemoryLevel + &quot; allowLow=&quot; + mAllowLowerMemLevel\n        + &quot; numProcs=&quot; + mLruProcesses.size() + &quot; last=&quot; + mLastNumProcesses);\nif (memFactor &gt; mLastMemoryLevel) {\n    if (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) {\n        memFactor = mLastMemoryLevel;\n        if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;Keeping last mem factor!&quot;);\n    }\n}\nmLastMemoryLevel = memFactor;\nmLastNumProcesses = mLruProcesses.size();\nboolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);\nfinal int trackerMemFactor = mProcessStats.getMemFactorLocked();\nif (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {\n    if (mLowRamStartTime == 0) {\n        mLowRamStartTime = now;\n    }\n    int step = 0;\n    int fgTrimLevel;\n    switch (memFactor) {\n        case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;\n            break;\n        case ProcessStats.ADJ_MEM_FACTOR_LOW:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;\n            break;\n        default:\n            fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;\n            break;\n    }\n    int factor = numTrimming/3;\n    int minFactor = 2;\n    if (mHomeProcess != null) minFactor++;\n    if (mPreviousProcess != null) minFactor++;\n    if (factor &lt; minFactor) factor = minFactor;\n    int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME\n                &amp;&amp; !app.killedByAm) {\n            if (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of &quot; + app.processName + &quot; to &quot; + curLevel);\n                    app.thread.scheduleTrimMemory(curLevel);\n                } catch (RemoteException e) {\n                }\n                if (false) {\n                    // For now we won&apos;t do this; our memory trimming seems\n                    // to be good enough at this point that destroying\n                    // activities causes more harm than good.\n                    if (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE\n                            &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) {\n                        // Need to do this on its own message because the stack may not\n                        // be in a consistent state at this point.\n                        // For these apps we will also finish their activities\n                        // to help them free memory.\n                        mStackSupervisor.scheduleDestroyAllActivities(app, &quot;trim&quot;);\n                    }\n                }\n            }\n            app.trimMemoryLevel = curLevel;\n            step++;\n            if (step &gt;= factor) {\n                step = 0;\n                switch (curLevel) {\n                    case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;\n                        break;\n                    case ComponentCallbacks2.TRIM_MEMORY_MODERATE:\n                        curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n                        break;\n                }\n            }\n        } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of heavy-weight &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;\n        } else {\n            if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                    || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n                // If this application is now in the background and it\n                // had done UI, then give it the special trim level to\n                // have it free UI resources.\n                final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;\n                if (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != null) {\n                    try {\n                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                                &quot;Trimming memory of bg-ui &quot; + app.processName\n                                + &quot; to &quot; + level);\n                        app.thread.scheduleTrimMemory(level);\n                    } catch (RemoteException e) {\n                    }\n                }\n                app.pendingUiClean = false;\n            }\n            if (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of fg &quot; + app.processName\n                            + &quot; to &quot; + fgTrimLevel);\n                    app.thread.scheduleTrimMemory(fgTrimLevel);\n                } catch (RemoteException e) {\n                }\n            }\n            app.trimMemoryLevel = fgTrimLevel;\n        }\n    }\n} else {\n    if (mLowRamStartTime != 0) {\n        mLowRamTimeSinceLastIdle += now - mLowRamStartTime;\n        mLowRamStartTime = 0;\n    }\n    for (int i=N-1; i&gt;=0; i--) {\n        ProcessRecord app = mLruProcesses.get(i);\n        if (allChanged || app.procStateChanged) {\n            setProcessTrackerStateLocked(app, trackerMemFactor, now);\n            app.procStateChanged = false;\n        }\n        if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND\n                || app.systemNoUi) &amp;&amp; app.pendingUiClean) {\n            if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n                    &amp;&amp; app.thread != null) {\n                try {\n                    if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,\n                            &quot;Trimming memory of ui hidden &quot; + app.processName\n                            + &quot; to &quot; + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                    app.thread.scheduleTrimMemory(\n                            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);\n                } catch (RemoteException e) {\n                }\n            }\n            app.pendingUiClean = false;\n        }\n        app.trimMemoryLevel = 0;\n    }\n}\n</code></pre><ul>\n<li>先调整内存因子memFactor</li>\n<li><p>如果内存因子不为0</p>\n<ul>\n<li>根据内存因子 初始化fgTrimLevel</li>\n<li>循环处理进程<ul>\n<li>curProcState大于12 且没有被am杀掉，若trimMemoryLevel小于curLevel，进行TrimMemory。调整trimMemoryLevel和curLevel</li>\n<li>curProcState等于9，且满足条件，进行TrimMemory</li>\n<li>其他情况下，根据条件进行TrimMemory操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内存因子为0,也是根据跳进进行TrimMemory操作</p>\n</li>\n</ul>\n<p>整个过程很复杂，大概就是三个流程，调整oomadj值，清理进程，TrimMemory回收内存。</p>\n<p>computeOomAdjLocked和applyOomAdjLocked这里就不介绍了，总之，这部分内容比较复杂。</p>\n<h3 id=\"4-杀进程\"><a href=\"#4-杀进程\" class=\"headerlink\" title=\"4.杀进程\"></a>4.杀进程</h3><p>杀进程这里就略过了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"AndroidJNI学习笔记（四）－数据类型映射以及native调用java","date":"2016-11-29T16:05:36.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 2. 数据类型映射 \n\n首先是我们的基本数据类型，其关系如下表描述这样。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225511135)\n\n上面关系的相关代码在jni.h的44－51行，如下\n\n```\ntypedef unsigned char   jboolean;       /* unsigned 8 bits */\ntypedef signed char     jbyte;          /* signed 8 bits */\ntypedef unsigned short  jchar;          /* unsigned 16 bits */\ntypedef short           jshort;         /* signed 16 bits */\ntypedef int             jint;           /* signed 32 bits */\ntypedef long long       jlong;          /* signed 64 bits */\ntypedef float           jfloat;         /* 32-bit IEEE 754 */\ntypedef double          jdouble;        /* 64-bit IEEE 754 */\n```\n\n\n而jni层的引用类型则是下面这个样子。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225901230)\n\n对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。\n\n```\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n```\n\n### 3. native 如何调用c\n\n我们这里的调用包括许多方面，如：\n\n* 调用静态方法\n* 调用实例方法\n* 获取字段值\n* 修改字段值\n* 构造对象\n* 等等\n\n而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：\n\n*  根据全限定名在jvm中找到想要的类\n* 从jclass中获取到method、或者field\n* 执行获取值、修改值、调用方法或者其他的操作\n* 释放局部引用\n\n举个调用静态方法的例子看看。\n\n```\nvoid callJavaStatic(JNIEnv *env,jobject jobj){\n  char* str = \"call from c++\";\n\n  jclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n  if (clazz == NULL) {\n    LOGE(\"class is null\");\n    return;\n  }\n\n  jmethodID method = env->GetStaticMethodID(clazz,\"javaStaticMethod\",\"(Ljava/lang/String;)V\");\n  if (method == NULL) {\n    LOGE(\"not find method\");\n  }\n\n  jstring  jstr = env->NewStringUTF(str);\n  env->CallStaticVoidMethod(clazz,method,jstr);\n  env->DeleteLocalRef(clazz);\n  env->DeleteLocalRef(jstr);\n}\n```\n\n\n#### 3.1 如何找到类\n\n很简单，我们可以通过FindClass方法去查找类。\n\n```\njclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n```\n\n#### 3.2  如何获取方法、或者字段\n大致为以下四种方法\n\n```\n env->GetxxxField()\n env->GetStaticxxxField()\n env->GetMethodID()\n env->GetxxxMethodID()\n```\n\n上面没有列出参数，但是仍然很明白，这里就不多说了。\n\n\n#### 3.3 如何调用方法\n\n这里呢。大致分为以下四种：\n\n```\n  env->CallXXXMethod();\n  env->CallxxxMethodA();\n  env->CallxxxMethodV();\n  env->CallNonvirtualBooleanMethod()\n```\n\n同样，我这里没给出方法的参数，同学们自己看jni.h吧\n\n* 调用方法（这里的方法可能使静态的、也可能是非静态的）\n* 和上面的区别就在于对应的java层参数，在这里以数组的形式传进入\n* 和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。\n* 调用构造函数初始化一个对象，这个，马上说道。\n\n#### 3.4 如何修改字段的值\n\n相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。\n\n\n#### 3.5 如何构造一个对象出来\n\n有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。\n\n*  NewObject方法 \n*  CallNonvirtualxxMethod\n\n先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是< init >（md语法的原因，注意尖括号之间没有空格），别问为什么。\n\n在来说说第二种，第二中使用时这样的\n\n```\n  jobject  jo = env->AllocObject(clazz);\n  env->CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )\n```\n\n* 第一行代码 创建未初始化的对象，并分配内存\n* 第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。\n\n\n### 4. 总结\n\n现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/AndroidJNI学习笔记（四）－数据类型映射以及native调用java.md","raw":"---\ntitle: AndroidJNI学习笔记（四）－数据类型映射以及native调用java\ndate: 2016-11-30 00:05:36\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 2. 数据类型映射 \n\n首先是我们的基本数据类型，其关系如下表描述这样。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225511135)\n\n上面关系的相关代码在jni.h的44－51行，如下\n\n```\ntypedef unsigned char   jboolean;       /* unsigned 8 bits */\ntypedef signed char     jbyte;          /* signed 8 bits */\ntypedef unsigned short  jchar;          /* unsigned 16 bits */\ntypedef short           jshort;         /* signed 16 bits */\ntypedef int             jint;           /* signed 32 bits */\ntypedef long long       jlong;          /* signed 64 bits */\ntypedef float           jfloat;         /* 32-bit IEEE 754 */\ntypedef double          jdouble;        /* 64-bit IEEE 754 */\n```\n\n\n而jni层的引用类型则是下面这个样子。\n\n![这里写图片描述](http://img.blog.csdn.net/20161129225901230)\n\n对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。\n\n```\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n```\n\n### 3. native 如何调用c\n\n我们这里的调用包括许多方面，如：\n\n* 调用静态方法\n* 调用实例方法\n* 获取字段值\n* 修改字段值\n* 构造对象\n* 等等\n\n而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：\n\n*  根据全限定名在jvm中找到想要的类\n* 从jclass中获取到method、或者field\n* 执行获取值、修改值、调用方法或者其他的操作\n* 释放局部引用\n\n举个调用静态方法的例子看看。\n\n```\nvoid callJavaStatic(JNIEnv *env,jobject jobj){\n  char* str = \"call from c++\";\n\n  jclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n  if (clazz == NULL) {\n    LOGE(\"class is null\");\n    return;\n  }\n\n  jmethodID method = env->GetStaticMethodID(clazz,\"javaStaticMethod\",\"(Ljava/lang/String;)V\");\n  if (method == NULL) {\n    LOGE(\"not find method\");\n  }\n\n  jstring  jstr = env->NewStringUTF(str);\n  env->CallStaticVoidMethod(clazz,method,jstr);\n  env->DeleteLocalRef(clazz);\n  env->DeleteLocalRef(jstr);\n}\n```\n\n\n#### 3.1 如何找到类\n\n很简单，我们可以通过FindClass方法去查找类。\n\n```\njclass clazz = env->FindClass(\"com/example/cmake_demo/MainActivity\");\n```\n\n#### 3.2  如何获取方法、或者字段\n大致为以下四种方法\n\n```\n env->GetxxxField()\n env->GetStaticxxxField()\n env->GetMethodID()\n env->GetxxxMethodID()\n```\n\n上面没有列出参数，但是仍然很明白，这里就不多说了。\n\n\n#### 3.3 如何调用方法\n\n这里呢。大致分为以下四种：\n\n```\n  env->CallXXXMethod();\n  env->CallxxxMethodA();\n  env->CallxxxMethodV();\n  env->CallNonvirtualBooleanMethod()\n```\n\n同样，我这里没给出方法的参数，同学们自己看jni.h吧\n\n* 调用方法（这里的方法可能使静态的、也可能是非静态的）\n* 和上面的区别就在于对应的java层参数，在这里以数组的形式传进入\n* 和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。\n* 调用构造函数初始化一个对象，这个，马上说道。\n\n#### 3.4 如何修改字段的值\n\n相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。\n\n\n#### 3.5 如何构造一个对象出来\n\n有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。\n\n*  NewObject方法 \n*  CallNonvirtualxxMethod\n\n先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是< init >（md语法的原因，注意尖括号之间没有空格），别问为什么。\n\n在来说说第二种，第二中使用时这样的\n\n```\n  jobject  jo = env->AllocObject(clazz);\n  env->CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )\n```\n\n* 第一行代码 创建未初始化的对象，并分配内存\n* 第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。\n\n\n### 4. 总结\n\n现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"AndroidJNI学习笔记（四）－数据类型映射以及native调用java","published":1,"updated":"2017-01-07T06:57:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy170005hws6j3hsp7em","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"2-数据类型映射\"><a href=\"#2-数据类型映射\" class=\"headerlink\" title=\"2. 数据类型映射\"></a>2. 数据类型映射</h3><p>首先是我们的基本数据类型，其关系如下表描述这样。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225511135\" alt=\"这里写图片描述\"></p>\n<p>上面关系的相关代码在jni.h的44－51行，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char   jboolean;       /* unsigned 8 bits */</div><div class=\"line\">typedef signed char     jbyte;          /* signed 8 bits */</div><div class=\"line\">typedef unsigned short  jchar;          /* unsigned 16 bits */</div><div class=\"line\">typedef short           jshort;         /* signed 16 bits */</div><div class=\"line\">typedef int             jint;           /* signed 32 bits */</div><div class=\"line\">typedef long long       jlong;          /* signed 64 bits */</div><div class=\"line\">typedef float           jfloat;         /* 32-bit IEEE 754 */</div><div class=\"line\">typedef double          jdouble;        /* 64-bit IEEE 754 */</div></pre></td></tr></table></figure>\n<p>而jni层的引用类型则是下面这个样子。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225901230\" alt=\"这里写图片描述\"></p>\n<p>对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class _jobject &#123;&#125;;</div><div class=\"line\">class _jclass : public _jobject &#123;&#125;;</div><div class=\"line\">class _jstring : public _jobject &#123;&#125;;</div><div class=\"line\">class _jarray : public _jobject &#123;&#125;;</div><div class=\"line\">class _jobjectArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbooleanArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbyteArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jcharArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jshortArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jintArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jlongArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jfloatArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jdoubleArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jthrowable : public _jobject &#123;&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-native-如何调用c\"><a href=\"#3-native-如何调用c\" class=\"headerlink\" title=\"3. native 如何调用c\"></a>3. native 如何调用c</h3><p>我们这里的调用包括许多方面，如：</p>\n<ul>\n<li>调用静态方法</li>\n<li>调用实例方法</li>\n<li>获取字段值</li>\n<li>修改字段值</li>\n<li>构造对象</li>\n<li>等等</li>\n</ul>\n<p>而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：</p>\n<ul>\n<li>根据全限定名在jvm中找到想要的类</li>\n<li>从jclass中获取到method、或者field</li>\n<li>执行获取值、修改值、调用方法或者其他的操作</li>\n<li>释放局部引用</li>\n</ul>\n<p>举个调用静态方法的例子看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void callJavaStatic(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;call from c++&quot;;</div><div class=\"line\"></div><div class=\"line\">  jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div><div class=\"line\">  if (clazz == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;class is null&quot;);</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jmethodID method = env-&gt;GetStaticMethodID(clazz,&quot;javaStaticMethod&quot;,&quot;(Ljava/lang/String;)V&quot;);</div><div class=\"line\">  if (method == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;not find method&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jstring  jstr = env-&gt;NewStringUTF(str);</div><div class=\"line\">  env-&gt;CallStaticVoidMethod(clazz,method,jstr);</div><div class=\"line\">  env-&gt;DeleteLocalRef(clazz);</div><div class=\"line\">  env-&gt;DeleteLocalRef(jstr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-如何找到类\"><a href=\"#3-1-如何找到类\" class=\"headerlink\" title=\"3.1 如何找到类\"></a>3.1 如何找到类</h4><p>很简单，我们可以通过FindClass方法去查找类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div></pre></td></tr></table></figure>\n<h4 id=\"3-2-如何获取方法、或者字段\"><a href=\"#3-2-如何获取方法、或者字段\" class=\"headerlink\" title=\"3.2  如何获取方法、或者字段\"></a>3.2  如何获取方法、或者字段</h4><p>大致为以下四种方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;GetxxxField()</div><div class=\"line\">env-&gt;GetStaticxxxField()</div><div class=\"line\">env-&gt;GetMethodID()</div><div class=\"line\">env-&gt;GetxxxMethodID()</div></pre></td></tr></table></figure>\n<p>上面没有列出参数，但是仍然很明白，这里就不多说了。</p>\n<h4 id=\"3-3-如何调用方法\"><a href=\"#3-3-如何调用方法\" class=\"headerlink\" title=\"3.3 如何调用方法\"></a>3.3 如何调用方法</h4><p>这里呢。大致分为以下四种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;CallXXXMethod();</div><div class=\"line\">env-&gt;CallxxxMethodA();</div><div class=\"line\">env-&gt;CallxxxMethodV();</div><div class=\"line\">env-&gt;CallNonvirtualBooleanMethod()</div></pre></td></tr></table></figure>\n<p>同样，我这里没给出方法的参数，同学们自己看jni.h吧</p>\n<ul>\n<li>调用方法（这里的方法可能使静态的、也可能是非静态的）</li>\n<li>和上面的区别就在于对应的java层参数，在这里以数组的形式传进入</li>\n<li>和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。</li>\n<li>调用构造函数初始化一个对象，这个，马上说道。</li>\n</ul>\n<h4 id=\"3-4-如何修改字段的值\"><a href=\"#3-4-如何修改字段的值\" class=\"headerlink\" title=\"3.4 如何修改字段的值\"></a>3.4 如何修改字段的值</h4><p>相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。</p>\n<h4 id=\"3-5-如何构造一个对象出来\"><a href=\"#3-5-如何构造一个对象出来\" class=\"headerlink\" title=\"3.5 如何构造一个对象出来\"></a>3.5 如何构造一个对象出来</h4><p>有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。</p>\n<ul>\n<li>NewObject方法 </li>\n<li>CallNonvirtualxxMethod</li>\n</ul>\n<p>先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是&lt; init &gt;（md语法的原因，注意尖括号之间没有空格），别问为什么。</p>\n<p>在来说说第二种，第二中使用时这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jobject  jo = env-&gt;AllocObject(clazz);</div><div class=\"line\">env-&gt;CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )</div></pre></td></tr></table></figure>\n<ul>\n<li>第一行代码 创建未初始化的对象，并分配内存</li>\n<li>第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前几篇学习了jni开发的基本流程、动态注册native函数以及相关编译文件的编写，咱们也算是知道了jni开发，但是还不够，今天咱们来学习下，java和jni的数据类型映射（说白了就是对应关系），以及如何在jni层调用java层的一些东西。偷偷告诉你们，这些全在jni.h文件里。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"2-数据类型映射\"><a href=\"#2-数据类型映射\" class=\"headerlink\" title=\"2. 数据类型映射\"></a>2. 数据类型映射</h3><p>首先是我们的基本数据类型，其关系如下表描述这样。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225511135\" alt=\"这里写图片描述\"></p>\n<p>上面关系的相关代码在jni.h的44－51行，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef unsigned char   jboolean;       /* unsigned 8 bits */</div><div class=\"line\">typedef signed char     jbyte;          /* signed 8 bits */</div><div class=\"line\">typedef unsigned short  jchar;          /* unsigned 16 bits */</div><div class=\"line\">typedef short           jshort;         /* signed 16 bits */</div><div class=\"line\">typedef int             jint;           /* signed 32 bits */</div><div class=\"line\">typedef long long       jlong;          /* signed 64 bits */</div><div class=\"line\">typedef float           jfloat;         /* 32-bit IEEE 754 */</div><div class=\"line\">typedef double          jdouble;        /* 64-bit IEEE 754 */</div></pre></td></tr></table></figure>\n<p>而jni层的引用类型则是下面这个样子。</p>\n<p><img src=\"http://img.blog.csdn.net/20161129225901230\" alt=\"这里写图片描述\"></p>\n<p>对于这些引用类型，c++和c的实现是不一样的。如果是c++的话，所有引用类型派生自 jobject，如果使用 C 语言编写的话，所有引用类型使用 jobject，其它引用类型使用 typedef 重新定义。同样代码也在jni.h中。这里只给出c++继承结构的部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class _jobject &#123;&#125;;</div><div class=\"line\">class _jclass : public _jobject &#123;&#125;;</div><div class=\"line\">class _jstring : public _jobject &#123;&#125;;</div><div class=\"line\">class _jarray : public _jobject &#123;&#125;;</div><div class=\"line\">class _jobjectArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbooleanArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jbyteArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jcharArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jshortArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jintArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jlongArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jfloatArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jdoubleArray : public _jarray &#123;&#125;;</div><div class=\"line\">class _jthrowable : public _jobject &#123;&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-native-如何调用c\"><a href=\"#3-native-如何调用c\" class=\"headerlink\" title=\"3. native 如何调用c\"></a>3. native 如何调用c</h3><p>我们这里的调用包括许多方面，如：</p>\n<ul>\n<li>调用静态方法</li>\n<li>调用实例方法</li>\n<li>获取字段值</li>\n<li>修改字段值</li>\n<li>构造对象</li>\n<li>等等</li>\n</ul>\n<p>而要实现上面的一些功能，同样要依靠jni.h的JNINativeInterface这个结构体，这里有很多很多的方法，供我们使用来实现native 调用java层的功能。而调用的流程是这样的：</p>\n<ul>\n<li>根据全限定名在jvm中找到想要的类</li>\n<li>从jclass中获取到method、或者field</li>\n<li>执行获取值、修改值、调用方法或者其他的操作</li>\n<li>释放局部引用</li>\n</ul>\n<p>举个调用静态方法的例子看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void callJavaStatic(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;call from c++&quot;;</div><div class=\"line\"></div><div class=\"line\">  jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div><div class=\"line\">  if (clazz == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;class is null&quot;);</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jmethodID method = env-&gt;GetStaticMethodID(clazz,&quot;javaStaticMethod&quot;,&quot;(Ljava/lang/String;)V&quot;);</div><div class=\"line\">  if (method == NULL) &#123;</div><div class=\"line\">    LOGE(&quot;not find method&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jstring  jstr = env-&gt;NewStringUTF(str);</div><div class=\"line\">  env-&gt;CallStaticVoidMethod(clazz,method,jstr);</div><div class=\"line\">  env-&gt;DeleteLocalRef(clazz);</div><div class=\"line\">  env-&gt;DeleteLocalRef(jstr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-如何找到类\"><a href=\"#3-1-如何找到类\" class=\"headerlink\" title=\"3.1 如何找到类\"></a>3.1 如何找到类</h4><p>很简单，我们可以通过FindClass方法去查找类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">jclass clazz = env-&gt;FindClass(&quot;com/example/cmake_demo/MainActivity&quot;);</div></pre></td></tr></table></figure>\n<h4 id=\"3-2-如何获取方法、或者字段\"><a href=\"#3-2-如何获取方法、或者字段\" class=\"headerlink\" title=\"3.2  如何获取方法、或者字段\"></a>3.2  如何获取方法、或者字段</h4><p>大致为以下四种方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;GetxxxField()</div><div class=\"line\">env-&gt;GetStaticxxxField()</div><div class=\"line\">env-&gt;GetMethodID()</div><div class=\"line\">env-&gt;GetxxxMethodID()</div></pre></td></tr></table></figure>\n<p>上面没有列出参数，但是仍然很明白，这里就不多说了。</p>\n<h4 id=\"3-3-如何调用方法\"><a href=\"#3-3-如何调用方法\" class=\"headerlink\" title=\"3.3 如何调用方法\"></a>3.3 如何调用方法</h4><p>这里呢。大致分为以下四种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">env-&gt;CallXXXMethod();</div><div class=\"line\">env-&gt;CallxxxMethodA();</div><div class=\"line\">env-&gt;CallxxxMethodV();</div><div class=\"line\">env-&gt;CallNonvirtualBooleanMethod()</div></pre></td></tr></table></figure>\n<p>同样，我这里没给出方法的参数，同学们自己看jni.h吧</p>\n<ul>\n<li>调用方法（这里的方法可能使静态的、也可能是非静态的）</li>\n<li>和上面的区别就在于对应的java层参数，在这里以数组的形式传进入</li>\n<li>和1的区别就是，以v(矢量？)的形式传进去，这里我也不是很理解，希望知道的同学指点下。</li>\n<li>调用构造函数初始化一个对象，这个，马上说道。</li>\n</ul>\n<h4 id=\"3-4-如何修改字段的值\"><a href=\"#3-4-如何修改字段的值\" class=\"headerlink\" title=\"3.4 如何修改字段的值\"></a>3.4 如何修改字段的值</h4><p>相信到这里，大家猜都能猜出来，set 么，这里我就不叨叨了。</p>\n<h4 id=\"3-5-如何构造一个对象出来\"><a href=\"#3-5-如何构造一个对象出来\" class=\"headerlink\" title=\"3.5 如何构造一个对象出来\"></a>3.5 如何构造一个对象出来</h4><p>有些情况下我们是需要构造出java层的对象的，那么如何构造呢，我们有两种办法。</p>\n<ul>\n<li>NewObject方法 </li>\n<li>CallNonvirtualxxMethod</li>\n</ul>\n<p>先说第一种，NewObject方法，除了要求jclass参数之外，还要求jmethodid，以及java称构造方法对应的参数。其他两个还好，关键是这个jmethodID，这个在获取的时候，方法名固定是&lt; init &gt;（md语法的原因，注意尖括号之间没有空格），别问为什么。</p>\n<p>在来说说第二种，第二中使用时这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jobject  jo = env-&gt;AllocObject(clazz);</div><div class=\"line\">env-&gt;CallNonvirtualVoidMethod(jo,clazz,jmethodId,arg )</div></pre></td></tr></table></figure>\n<ul>\n<li>第一行代码 创建未初始化的对象，并分配内存</li>\n<li>第二行代码，调用init那个方法（构造方法）进行初始化,注意，只能初始化一次。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>现在我们明白了jni 和 java的数据类型映射关系，以及在jni层调用java层的方法。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Activity启动流程","date":"2016-12-25T07:20:05.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2.从startActivity说起\n\n不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：\n\n```java\nInstrumentation.ActivityResult ar =\n    mInstrumentation.execStartActivity(\n        this, mMainThread.getApplicationThread(), mToken, this,\n        intent, requestCode, options);\nif (ar != null) {\n    mMainThread.sendActivityResult(\n        mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n        r.getResultData());\n}\n```\n\n* 通过Instrumentation去启动activiy，\n\n### 3.Instrumentation#execStartActivity\n\nInstrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。\n\n```java\n            int result = ActivityManagerNative.getDefault()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n                        token, target != null ? target.mEmbeddedID : null,\n                        requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n```\n\n* 通过AMS启动activity\n* 检查结果\n\nActivityManagerNative.getDefault()如下：\n\n```java\n    static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n```\n\n其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。\n\n### 4.ActivityManagerService#startActivity\n\n而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。\n\n```java\n    @Override\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n        enforceNotIsolatedCaller(\"startActivity\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                false, ALLOW_FULL_ONLY, \"startActivity\", null);\n        // TODO: Switch to user app stacks here.\n        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n                profilerInfo, null, null, options, false, userId, null, null);\n    }\n```\n\n这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。\n\n### 5.ActivityStackSupervisor#startActivityMayWait\n\n这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：\n\n```java\n            int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n                    voiceSession, voiceInteractor, resultTo, resultWho,\n                    requestCode, callingPid, callingUid, callingPackage,\n                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,\n                    componentSpecified, null, container, inTask);\n```\n\n而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：\n\n```java\n        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n                startFlags, true, options, inTask);\n```\n\nstartActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:\n\n```java\n        targetStack.mLastPausedActivity = null;\n        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n```\n\n* 其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as\n\n### 6.ActivityStack#startActivityLocked\n\n而这个方法的最下面有如下代码。\n\n```java\n        if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n```\n\n这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as\n\n```java\n result = targetStack.resumeTopActivityLocked(target, targetOptions);\n```\n\n绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked->resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用\n\n```java\nmStackSupervisor.startSpecificActivityLocked(next, true, false); \n```\n回到as，好吧，好绕。\n\n而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。\n\n```java\nrealStartActivityLocked(r, app, andResume, checkConfig);\n```\n\n在这个方法中做了什么呢？\n\n```java\n            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                    new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n```\n\n通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。\n\n\n### 7.ApplicationThread#scheduleLaunchActivity\n\n在这个方法中，发送一个消息，然后ActivityThread的H类去处理。\n\n```java\nsendMessage(H.LAUNCH_ACTIVITY, r);\n```\n\n接收到这个消息之后，调用handleLaunchActivity方法去处理。\n\n```java\nActivity a = performLaunchActivity(r, customIntent);\n```\n\n\n在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。\n\n```java\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n                    ...\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n```\n\n### 8.Instrumentation\n\n在这里，先是通过类加载器去构造类对象，\n\n```java\n(Activity)cl.loadClass(className).newInstance()\n```\n\n然后通过callActivityOnCreate方法，\n\n```java\n    public void callActivityOnCreate(Activity activity, Bundle icicle) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle);\n        postPerformCreate(activity);\n    }\n```\n调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。\n\n### 9.给张图吧。\n\n流程图不一定画的对。😢\n\n![](/images/framework/activity/Activity启动流程图.png)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/Activity启动流程.md","raw":"---\ntitle: Activity启动流程\ndate: 2016-12-25 15:20:05\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2.从startActivity说起\n\n不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：\n\n```java\nInstrumentation.ActivityResult ar =\n    mInstrumentation.execStartActivity(\n        this, mMainThread.getApplicationThread(), mToken, this,\n        intent, requestCode, options);\nif (ar != null) {\n    mMainThread.sendActivityResult(\n        mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n        r.getResultData());\n}\n```\n\n* 通过Instrumentation去启动activiy，\n\n### 3.Instrumentation#execStartActivity\n\nInstrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。\n\n```java\n            int result = ActivityManagerNative.getDefault()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolveTypeIfNeeded(who.getContentResolver()),\n                        token, target != null ? target.mEmbeddedID : null,\n                        requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n```\n\n* 通过AMS启动activity\n* 检查结果\n\nActivityManagerNative.getDefault()如下：\n\n```java\n    static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n```\n\n其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。\n\n### 4.ActivityManagerService#startActivity\n\n而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。\n\n```java\n    @Override\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n        enforceNotIsolatedCaller(\"startActivity\");\n        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,\n                false, ALLOW_FULL_ONLY, \"startActivity\", null);\n        // TODO: Switch to user app stacks here.\n        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n                profilerInfo, null, null, options, false, userId, null, null);\n    }\n```\n\n这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。\n\n### 5.ActivityStackSupervisor#startActivityMayWait\n\n这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：\n\n```java\n            int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n                    voiceSession, voiceInteractor, resultTo, resultWho,\n                    requestCode, callingPid, callingUid, callingPackage,\n                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,\n                    componentSpecified, null, container, inTask);\n```\n\n而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：\n\n```java\n        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n                startFlags, true, options, inTask);\n```\n\nstartActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:\n\n```java\n        targetStack.mLastPausedActivity = null;\n        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n```\n\n* 其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as\n\n### 6.ActivityStack#startActivityLocked\n\n而这个方法的最下面有如下代码。\n\n```java\n        if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n```\n\n这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as\n\n```java\n result = targetStack.resumeTopActivityLocked(target, targetOptions);\n```\n\n绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked->resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用\n\n```java\nmStackSupervisor.startSpecificActivityLocked(next, true, false); \n```\n回到as，好吧，好绕。\n\n而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。\n\n```java\nrealStartActivityLocked(r, app, andResume, checkConfig);\n```\n\n在这个方法中做了什么呢？\n\n```java\n            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                    new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n```\n\n通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。\n\n\n### 7.ApplicationThread#scheduleLaunchActivity\n\n在这个方法中，发送一个消息，然后ActivityThread的H类去处理。\n\n```java\nsendMessage(H.LAUNCH_ACTIVITY, r);\n```\n\n接收到这个消息之后，调用handleLaunchActivity方法去处理。\n\n```java\nActivity a = performLaunchActivity(r, customIntent);\n```\n\n\n在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。\n\n```java\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n                    ...\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n```\n\n### 8.Instrumentation\n\n在这里，先是通过类加载器去构造类对象，\n\n```java\n(Activity)cl.loadClass(className).newInstance()\n```\n\n然后通过callActivityOnCreate方法，\n\n```java\n    public void callActivityOnCreate(Activity activity, Bundle icicle) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle);\n        postPerformCreate(activity);\n    }\n```\n调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。\n\n### 9.给张图吧。\n\n流程图不一定画的对。😢\n\n![](/images/framework/activity/Activity启动流程图.png)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"Activity启动流程","published":1,"updated":"2017-01-07T06:56:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy1h0006hws6f7dvf3jq","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"2-从startActivity说起\"><a href=\"#2-从startActivity说起\" class=\"headerlink\" title=\"2.从startActivity说起\"></a>2.从startActivity说起</h3><p>不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Instrumentation.ActivityResult ar =</div><div class=\"line\">    mInstrumentation.execStartActivity(</div><div class=\"line\">        <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</div><div class=\"line\">        intent, requestCode, options);</div><div class=\"line\"><span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    mMainThread.sendActivityResult(</div><div class=\"line\">        mToken, mEmbeddedID, requestCode, ar.getResultCode(),</div><div class=\"line\">        r.getResultData());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Instrumentation去启动activiy，</li>\n</ul>\n<h3 id=\"3-Instrumentation-execStartActivity\"><a href=\"#3-Instrumentation-execStartActivity\" class=\"headerlink\" title=\"3.Instrumentation#execStartActivity\"></a>3.Instrumentation#execStartActivity</h3><p>Instrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</div><div class=\"line\">    .startActivity(whoThread, who.getBasePackageName(), intent,</div><div class=\"line\">            intent.resolveTypeIfNeeded(who.getContentResolver()),</div><div class=\"line\">            token, target != <span class=\"keyword\">null</span> ? target.mEmbeddedID : <span class=\"keyword\">null</span>,</div><div class=\"line\">            requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</div><div class=\"line\">checkStartActivityResult(result, intent);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过AMS启动activity</li>\n<li>检查结果</li>\n</ul>\n<p>ActivityManagerNative.getDefault()如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。</p>\n<h3 id=\"4-ActivityManagerService-startActivity\"><a href=\"#4-ActivityManagerService-startActivity\" class=\"headerlink\" title=\"4.ActivityManagerService#startActivity\"></a>4.ActivityManagerService#startActivity</h3><p>而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></div><div class=\"line\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</div><div class=\"line\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class=\"keyword\">int</span> userId) &#123;</div><div class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</div><div class=\"line\">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</div><div class=\"line\">            <span class=\"keyword\">false</span>, ALLOW_FULL_ONLY, <span class=\"string\">\"startActivity\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class=\"number\">1</span>, callingPackage, intent,</div><div class=\"line\">            resolvedType, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, resultTo, resultWho, requestCode, startFlags,</div><div class=\"line\">            profilerInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, options, <span class=\"keyword\">false</span>, userId, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。</p>\n<h3 id=\"5-ActivityStackSupervisor-startActivityMayWait\"><a href=\"#5-ActivityStackSupervisor-startActivityMayWait\" class=\"headerlink\" title=\"5.ActivityStackSupervisor#startActivityMayWait\"></a>5.ActivityStackSupervisor#startActivityMayWait</h3><p>这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> res = startActivityLocked(caller, intent, resolvedType, aInfo,</div><div class=\"line\">        voiceSession, voiceInteractor, resultTo, resultWho,</div><div class=\"line\">        requestCode, callingPid, callingUid, callingPackage,</div><div class=\"line\">        realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</div><div class=\"line\">        componentSpecified, <span class=\"keyword\">null</span>, container, inTask);</div></pre></td></tr></table></figure>\n<p>而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</div><div class=\"line\">        startFlags, <span class=\"keyword\">true</span>, options, inTask);</div></pre></td></tr></table></figure>\n<p>startActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">targetStack.mLastPausedActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as</li>\n</ul>\n<h3 id=\"6-ActivityStack-startActivityLocked\"><a href=\"#6-ActivityStack-startActivityLocked\" class=\"headerlink\" title=\"6.ActivityStack#startActivityLocked\"></a>6.ActivityStack#startActivityLocked</h3><p>而这个方法的最下面有如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (doResume) &#123;</div><div class=\"line\">    mStackSupervisor.resumeTopActivitiesLocked(<span class=\"keyword\">this</span>, r, options);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">result = targetStack.resumeTopActivityLocked(target, targetOptions);</div></pre></td></tr></table></figure>\n<p>绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked-&gt;resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>回到as，好吧，好绕。</p>\n<p>而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">realStartActivityLocked(r, app, andResume, checkConfig);</div></pre></td></tr></table></figure>\n<p>在这个方法中做了什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleLaunchActivity(<span class=\"keyword\">new</span> Intent(r.intent), r.appToken,</div><div class=\"line\">        System.identityHashCode(r), r.info, <span class=\"keyword\">new</span> Configuration(mService.mConfiguration),</div><div class=\"line\">        <span class=\"keyword\">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</div><div class=\"line\">        task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</div><div class=\"line\">        newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</div></pre></td></tr></table></figure>\n<p>通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。</p>\n<h3 id=\"7-ApplicationThread-scheduleLaunchActivity\"><a href=\"#7-ApplicationThread-scheduleLaunchActivity\" class=\"headerlink\" title=\"7.ApplicationThread#scheduleLaunchActivity\"></a>7.ApplicationThread#scheduleLaunchActivity</h3><p>在这个方法中，发送一个消息，然后ActivityThread的H类去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendMessage(H.LAUNCH_ACTIVITY, r);</div></pre></td></tr></table></figure>\n<p>接收到这个消息之后，调用handleLaunchActivity方法去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Activity a = performLaunchActivity(r, customIntent);</div></pre></td></tr></table></figure>\n<p>在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">activity = mInstrumentation.newActivity(</div><div class=\"line\">        cl, component.getClassName(), r.intent);</div><div class=\"line\">        ...</div><div class=\"line\">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div></pre></td></tr></table></figure>\n<h3 id=\"8-Instrumentation\"><a href=\"#8-Instrumentation\" class=\"headerlink\" title=\"8.Instrumentation\"></a>8.Instrumentation</h3><p>在这里，先是通过类加载器去构造类对象，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Activity)cl.loadClass(className).newInstance()</div></pre></td></tr></table></figure>\n<p>然后通过callActivityOnCreate方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle)</span> </span>&#123;</div><div class=\"line\">    prePerformCreate(activity);</div><div class=\"line\">    activity.performCreate(icicle);</div><div class=\"line\">    postPerformCreate(activity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。</p>\n<h3 id=\"9-给张图吧。\"><a href=\"#9-给张图吧。\" class=\"headerlink\" title=\"9.给张图吧。\"></a>9.给张图吧。</h3><p>流程图不一定画的对。😢</p>\n<p><img src=\"/images/framework/activity/Activity启动流程图.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们每天都在使用startActivity去启动一个新的activty，可有想过这中间的流程是什么？可有想过这涉及到哪些东西？今天，就走一下流程，了解下，activity是如何启动的。</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"2-从startActivity说起\"><a href=\"#2-从startActivity说起\" class=\"headerlink\" title=\"2.从startActivity说起\"></a>2.从startActivity说起</h3><p>不管我们是通过startActivity,还是通过startActivityForResult去启动一个activity，最终都会调用，startActivityForResult这个方法，这个方法的核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Instrumentation.ActivityResult ar =</div><div class=\"line\">    mInstrumentation.execStartActivity(</div><div class=\"line\">        <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</div><div class=\"line\">        intent, requestCode, options);</div><div class=\"line\"><span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    mMainThread.sendActivityResult(</div><div class=\"line\">        mToken, mEmbeddedID, requestCode, ar.getResultCode(),</div><div class=\"line\">        r.getResultData());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Instrumentation去启动activiy，</li>\n</ul>\n<h3 id=\"3-Instrumentation-execStartActivity\"><a href=\"#3-Instrumentation-execStartActivity\" class=\"headerlink\" title=\"3.Instrumentation#execStartActivity\"></a>3.Instrumentation#execStartActivity</h3><p>Instrumentation是一个很关键的类，我们知道Activity也是一个java类，但是他确有声明周期，而声明周期的方法，就是由这个类来控制的。而我们能看到一些插件话框架如DroidPlugin也是通过hook这个类，来做到替换的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</div><div class=\"line\">    .startActivity(whoThread, who.getBasePackageName(), intent,</div><div class=\"line\">            intent.resolveTypeIfNeeded(who.getContentResolver()),</div><div class=\"line\">            token, target != <span class=\"keyword\">null</span> ? target.mEmbeddedID : <span class=\"keyword\">null</span>,</div><div class=\"line\">            requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</div><div class=\"line\">checkStartActivityResult(result, intent);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过AMS启动activity</li>\n<li>检查结果</li>\n</ul>\n<p>ActivityManagerNative.getDefault()如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，gDefault是一个Singleton类，他返回的是IActivityManager类型，我们这里要注意，asInterface方法中，返回了AMS的bp客户端，也就是ActivityManagerProxy。而其对应的bn端就是ActivityManagerNative，他的具体实现是ActivityManagerService,也就是我们常说的ams。</p>\n<h3 id=\"4-ActivityManagerService-startActivity\"><a href=\"#4-ActivityManagerService-startActivity\" class=\"headerlink\" title=\"4.ActivityManagerService#startActivity\"></a>4.ActivityManagerService#startActivity</h3><p>而在这里通过startActivityAsUser, 将调用传递给ActivityStackSupervisor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</div><div class=\"line\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</div><div class=\"line\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class=\"keyword\">int</span> userId)</span> </span>&#123;</div><div class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</div><div class=\"line\">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</div><div class=\"line\">            <span class=\"keyword\">false</span>, ALLOW_FULL_ONLY, <span class=\"string\">\"startActivity\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class=\"number\">1</span>, callingPackage, intent,</div><div class=\"line\">            resolvedType, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, resultTo, resultWho, requestCode, startFlags,</div><div class=\"line\">            profilerInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, options, <span class=\"keyword\">false</span>, userId, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的mStackSupervisor就是ActivityStackSupervisor对象，从名字上来看，似乎是activiy栈的管理，事实上确实如此。</p>\n<h3 id=\"5-ActivityStackSupervisor-startActivityMayWait\"><a href=\"#5-ActivityStackSupervisor-startActivityMayWait\" class=\"headerlink\" title=\"5.ActivityStackSupervisor#startActivityMayWait\"></a>5.ActivityStackSupervisor#startActivityMayWait</h3><p>这个方法的代码比较长，但是大部分代码都是校验安全性方面的，我们不需要太多的关心，其核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> res = startActivityLocked(caller, intent, resolvedType, aInfo,</div><div class=\"line\">        voiceSession, voiceInteractor, resultTo, resultWho,</div><div class=\"line\">        requestCode, callingPid, callingUid, callingPackage,</div><div class=\"line\">        realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</div><div class=\"line\">        componentSpecified, <span class=\"keyword\">null</span>, container, inTask);</div></pre></td></tr></table></figure>\n<p>而startActivityLocked也很长，我们不去关心其具体逻辑，其大部分代码都是错误检查、权限检查等操作，启动actviy的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</div><div class=\"line\">        startFlags, <span class=\"keyword\">true</span>, options, inTask);</div></pre></td></tr></table></figure>\n<p>startActivityUncheckedLocked中涉及到启动模式和activiy栈，代码很复杂，不过我们今天的目的是了解启动流程，因此，直接看重点。在这个方法的最下面，我们能看到如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">targetStack.mLastPausedActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中，targetStack是ActivityStack,这样，启动流程就从ass转移到了as</li>\n</ul>\n<h3 id=\"6-ActivityStack-startActivityLocked\"><a href=\"#6-ActivityStack-startActivityLocked\" class=\"headerlink\" title=\"6.ActivityStack#startActivityLocked\"></a>6.ActivityStack#startActivityLocked</h3><p>而这个方法的最下面有如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (doResume) &#123;</div><div class=\"line\">    mStackSupervisor.resumeTopActivitiesLocked(<span class=\"keyword\">this</span>, r, options);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，就又从as转移到了ass，但是，这里没有过多的代码，而是又将操作给了as</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">result = targetStack.resumeTopActivityLocked(target, targetOptions);</div></pre></td></tr></table></figure>\n<p>绕半圈，回来了。我们接着跟，在as中，通过resumeTopActivityLocked-&gt;resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，又调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>回到as，好吧，好绕。</p>\n<p>而在ass的startSpecificActivityLocked方法中，通过如下代码去启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">realStartActivityLocked(r, app, andResume, checkConfig);</div></pre></td></tr></table></figure>\n<p>在这个方法中做了什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleLaunchActivity(<span class=\"keyword\">new</span> Intent(r.intent), r.appToken,</div><div class=\"line\">        System.identityHashCode(r), r.info, <span class=\"keyword\">new</span> Configuration(mService.mConfiguration),</div><div class=\"line\">        <span class=\"keyword\">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</div><div class=\"line\">        task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</div><div class=\"line\">        newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</div></pre></td></tr></table></figure>\n<p>通过ApplicationThread的scheduleLaunchActivity，去启动一个actvity。</p>\n<h3 id=\"7-ApplicationThread-scheduleLaunchActivity\"><a href=\"#7-ApplicationThread-scheduleLaunchActivity\" class=\"headerlink\" title=\"7.ApplicationThread#scheduleLaunchActivity\"></a>7.ApplicationThread#scheduleLaunchActivity</h3><p>在这个方法中，发送一个消息，然后ActivityThread的H类去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendMessage(H.LAUNCH_ACTIVITY, r);</div></pre></td></tr></table></figure>\n<p>接收到这个消息之后，调用handleLaunchActivity方法去处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Activity a = performLaunchActivity(r, customIntent);</div></pre></td></tr></table></figure>\n<p>在performLaunchActivity方法中，先是通过Instrumentation.newActivity去生成actvity，然后调用callActivityOnCreate。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">activity = mInstrumentation.newActivity(</div><div class=\"line\">        cl, component.getClassName(), r.intent);</div><div class=\"line\">        ...</div><div class=\"line\">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div></pre></td></tr></table></figure>\n<h3 id=\"8-Instrumentation\"><a href=\"#8-Instrumentation\" class=\"headerlink\" title=\"8.Instrumentation\"></a>8.Instrumentation</h3><p>在这里，先是通过类加载器去构造类对象，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Activity)cl.loadClass(className).newInstance()</div></pre></td></tr></table></figure>\n<p>然后通过callActivityOnCreate方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle)</span> </span>&#123;</div><div class=\"line\">    prePerformCreate(activity);</div><div class=\"line\">    activity.performCreate(icicle);</div><div class=\"line\">    postPerformCreate(activity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用activity.performCreate，在这个方法中，便会调用onCreate方法，这样，activity就启动起来了。</p>\n<h3 id=\"9-给张图吧。\"><a href=\"#9-给张图吧。\" class=\"headerlink\" title=\"9.给张图吧。\"></a>9.给张图吧。</h3><p>流程图不一定画的对。😢</p>\n<p><img src=\"/images/framework/activity/Activity启动流程图.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android消息机制浅析","date":"2016-12-21T15:32:56.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.Looper、Handler、MessageQueue的关系\n* Looper 用于线程的消息循环,一个线程只能有一个Looper对象\n* Handler\n * 执行任务调度和发生一些操作（在未来某时刻）\n * 执行其他线程中的队列消息\n* MessageQueue 消息队列\n\n>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.Looper\n以主线程为例。Looper的初始化过程是这样的。\n代码地址： \n/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)\n```\nLooper.prepareMainLooper();\nxxxx\nLooper.loop();\n```\n而非UI线程的初始化过程\n```\nLooper.prepare()\nxxx\nLooper.loop();\n```\n不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。\n```\n\tprivate static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n接下来看Looper的构造方法\n```\n\tprivate Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。\n那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法\n```\nfinal Looper me = myLooper();\n```\n```\n\tpublic static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n```\n取出和当前线程对应的Looper对象\n```\n\tfor (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            msg.recycleUnchecked();\n        }\n    }\n```\n上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。\n\n### 3.Handler\n既然知道了Looper，那么我们需要知道消息是怎么来的。\n```\nMessage msg = new Message();\nmsg.what = xxx;\nmsg.obj = xxx;\nhandler.sendMessage(msg);\n```\n我们通常都是通过上面的步骤去发送的，所以，追踪下代码。\n\nsendMessage->sendMessageDelayed->sendMessageAtTime->enqueueMessage\n到这里就来到了一个关键点了，我们看下代码。\n```\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n   msg.target = this;\n   if (mAsynchronous) {\n        msg.setAsynchronous(true);\n   }\n   return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。\n```\nHandler target\n```\n好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。\n```\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n调用关系和初始化的关系有关。\n\n  *  Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法\n  * 初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法\n  * 否则，调用handlerMessage(msg)方法。\n\n回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。\n### 4.MessageQueue\n消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：\n```\n    boolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n上面的步骤是这样子的。\n\n* 判断是否关联了handler\n* 判断是否用过(已经插入到链表中的)\n* 当前队列是否处在退出状态\n * 退出状态  回收资源，插入链表失败\n * 不是退出状态\n \t * 改变Message的状态为已经use，并获取message的when时间\n \t * 在链表中找到合适的位置插入\n \t \t* 和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点\n \t \t* 死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾\n\n在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。\n```\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\n```\n * 假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message\n * 如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis\n * 不小于的话\n \t* 假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息\n \t* 否则，将mMessages(表头)指向msg.next(也是移除了该消息) \n\n * 下面的代码忽略(ps:我看不懂...)\n\n### 5.总结\n当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。\nAndroid中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n","source":"_posts/Android消息机制浅析.md","raw":"---\ntitle: Android消息机制浅析\ndate: 2016-12-21 23:32:56\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.Looper、Handler、MessageQueue的关系\n* Looper 用于线程的消息循环,一个线程只能有一个Looper对象\n* Handler\n * 执行任务调度和发生一些操作（在未来某时刻）\n * 执行其他线程中的队列消息\n* MessageQueue 消息队列\n\n>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.Looper\n以主线程为例。Looper的初始化过程是这样的。\n代码地址： \n/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)\n```\nLooper.prepareMainLooper();\nxxxx\nLooper.loop();\n```\n而非UI线程的初始化过程\n```\nLooper.prepare()\nxxx\nLooper.loop();\n```\n不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。\n```\n\tprivate static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n接下来看Looper的构造方法\n```\n\tprivate Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。\n那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法\n```\nfinal Looper me = myLooper();\n```\n```\n\tpublic static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n```\n取出和当前线程对应的Looper对象\n```\n\tfor (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            msg.recycleUnchecked();\n        }\n    }\n```\n上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。\n\n### 3.Handler\n既然知道了Looper，那么我们需要知道消息是怎么来的。\n```\nMessage msg = new Message();\nmsg.what = xxx;\nmsg.obj = xxx;\nhandler.sendMessage(msg);\n```\n我们通常都是通过上面的步骤去发送的，所以，追踪下代码。\n\nsendMessage->sendMessageDelayed->sendMessageAtTime->enqueueMessage\n到这里就来到了一个关键点了，我们看下代码。\n```\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n   msg.target = this;\n   if (mAsynchronous) {\n        msg.setAsynchronous(true);\n   }\n   return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。\n```\nHandler target\n```\n好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。\n```\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n调用关系和初始化的关系有关。\n\n  *  Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法\n  * 初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法\n  * 否则，调用handlerMessage(msg)方法。\n\n回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。\n### 4.MessageQueue\n消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：\n```\n    boolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n上面的步骤是这样子的。\n\n* 判断是否关联了handler\n* 判断是否用过(已经插入到链表中的)\n* 当前队列是否处在退出状态\n * 退出状态  回收资源，插入链表失败\n * 不是退出状态\n \t * 改变Message的状态为已经use，并获取message的when时间\n \t * 在链表中找到合适的位置插入\n \t \t* 和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点\n \t \t* 死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾\n\n在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。\n```\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\n```\n * 假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message\n * 如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis\n * 不小于的话\n \t* 假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息\n \t* 否则，将mMessages(表头)指向msg.next(也是移除了该消息) \n\n * 下面的代码忽略(ps:我看不懂...)\n\n### 5.总结\n当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。\nAndroid中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n","slug":"Android消息机制浅析","published":1,"updated":"2017-01-07T06:57:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy1i0007hws6xvjw9d5b","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-Looper、Handler、MessageQueue的关系\"><a href=\"#1-Looper、Handler、MessageQueue的关系\" class=\"headerlink\" title=\"1.Looper、Handler、MessageQueue的关系\"></a>1.Looper、Handler、MessageQueue的关系</h3><ul>\n<li>Looper 用于线程的消息循环,一个线程只能有一个Looper对象</li>\n<li>Handler<ul>\n<li>执行任务调度和发生一些操作（在未来某时刻）</li>\n<li>执行其他线程中的队列消息</li>\n</ul>\n</li>\n<li>MessageQueue 消息队列</li>\n</ul>\n<blockquote>\n<p>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。</p>\n</blockquote>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"2-Looper\"><a href=\"#2-Looper\" class=\"headerlink\" title=\"2.Looper\"></a>2.Looper</h3><p>以主线程为例。Looper的初始化过程是这样的。<br>代码地址：<br>/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepareMainLooper();</div><div class=\"line\">xxxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>而非UI线程的初始化过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepare()</div><div class=\"line\">xxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void prepare(boolean quitAllowed) &#123;</div><div class=\"line\">       if (sThreadLocal.get() != null) &#123;</div><div class=\"line\">           throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       sThreadLocal.set(new Looper(quitAllowed));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>接下来看Looper的构造方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Looper(boolean quitAllowed) &#123;</div><div class=\"line\">       mQueue = new MessageQueue(quitAllowed);</div><div class=\"line\">       mThread = Thread.currentThread();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。<br>那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Looper me = myLooper();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static @Nullable Looper myLooper() &#123;</div><div class=\"line\">       return sThreadLocal.get();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>取出和当前线程对应的Looper对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">           Message msg = queue.next(); // might block</div><div class=\"line\">           if (msg == null) &#123;</div><div class=\"line\">               // No message indicates that the message queue is quitting.</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">           if (logging != null) &#123;</div><div class=\"line\">               logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Make sure that during the course of dispatching the</div><div class=\"line\">           // identity of the thread wasn&apos;t corrupted.</div><div class=\"line\">           final long newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">           msg.recycleUnchecked();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。</p>\n<h3 id=\"3-Handler\"><a href=\"#3-Handler\" class=\"headerlink\" title=\"3.Handler\"></a>3.Handler</h3><p>既然知道了Looper，那么我们需要知道消息是怎么来的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Message msg = new Message();</div><div class=\"line\">msg.what = xxx;</div><div class=\"line\">msg.obj = xxx;</div><div class=\"line\">handler.sendMessage(msg);</div></pre></td></tr></table></figure></p>\n<p>我们通常都是通过上面的步骤去发送的，所以，追踪下代码。</p>\n<p>sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage<br>到这里就来到了一个关键点了，我们看下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class=\"line\">   msg.target = this;</div><div class=\"line\">   if (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(true);</div><div class=\"line\">   &#125;</div><div class=\"line\">   return queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Handler target</div></pre></td></tr></table></figure></p>\n<p>好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void dispatchMessage(Message msg) &#123;</div><div class=\"line\">    if (msg.callback != null) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (mCallback != null) &#123;</div><div class=\"line\">            if (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用关系和初始化的关系有关。</p>\n<ul>\n<li>Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法</li>\n<li>初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法</li>\n<li>否则，调用handlerMessage(msg)方法。</li>\n</ul>\n<p>回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。</p>\n<h3 id=\"4-MessageQueue\"><a href=\"#4-MessageQueue\" class=\"headerlink\" title=\"4.MessageQueue\"></a>4.MessageQueue</h3><p>消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean enqueueMessage(Message msg, long when) &#123;</div><div class=\"line\">    if (msg.target == null) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg.isInUse()) &#123;</div><div class=\"line\">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        if (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = new IllegalStateException(</div><div class=\"line\">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class=\"line\">            Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        boolean needWake;</div><div class=\"line\">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class=\"line\">            // New head, wake up the event queue if blocked.</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class=\"line\">            // up the event queue unless there is a barrier at the head of the queue</div><div class=\"line\">            // and the message is the earliest asynchronous message in the queue.</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">            for (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">                if (p == null || when &lt; p.when) &#123;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = p; // invariant: p == prev.next</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We can assume mPtr != 0 because mQuitting is false.</div><div class=\"line\">        if (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的步骤是这样子的。</p>\n<ul>\n<li>判断是否关联了handler</li>\n<li>判断是否用过(已经插入到链表中的)</li>\n<li>当前队列是否处在退出状态<ul>\n<li>退出状态  回收资源，插入链表失败</li>\n<li>不是退出状态<ul>\n<li>改变Message的状态为已经use，并获取message的when时间</li>\n<li>在链表中找到合适的位置插入<ul>\n<li>和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点</li>\n<li>死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">Message prevMsg = null;</div><div class=\"line\">Message msg = mMessages;</div><div class=\"line\">if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class=\"line\">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class=\"line\">    do &#123;</div><div class=\"line\">        prevMsg = msg;</div><div class=\"line\">        msg = msg.next;</div><div class=\"line\">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg != null) &#123;</div><div class=\"line\">    if (now &lt; msg.when) &#123;</div><div class=\"line\">        // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class=\"line\">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Got a message.</div><div class=\"line\">        mBlocked = false;</div><div class=\"line\">        if (prevMsg != null) &#123;</div><div class=\"line\">            prevMsg.next = msg.next;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mMessages = msg.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg.next = null;</div><div class=\"line\">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        return msg;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // No more messages.</div><div class=\"line\">    nextPollTimeoutMillis = -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message</li>\n<li>如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis</li>\n<li><p>不小于的话</p>\n<ul>\n<li>假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息</li>\n<li>否则，将mMessages(表头)指向msg.next(也是移除了该消息) </li>\n</ul>\n</li>\n<li><p>下面的代码忽略(ps:我看不懂…)</p>\n</li>\n</ul>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><p>当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。<br>Android中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-Looper、Handler、MessageQueue的关系\"><a href=\"#1-Looper、Handler、MessageQueue的关系\" class=\"headerlink\" title=\"1.Looper、Handler、MessageQueue的关系\"></a>1.Looper、Handler、MessageQueue的关系</h3><ul>\n<li>Looper 用于线程的消息循环,一个线程只能有一个Looper对象</li>\n<li>Handler<ul>\n<li>执行任务调度和发生一些操作（在未来某时刻）</li>\n<li>执行其他线程中的队列消息</li>\n</ul>\n</li>\n<li>MessageQueue 消息队列</li>\n</ul>\n<blockquote>\n<p>一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，提交给Handel处理。</p>\n</blockquote>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"2-Looper\"><a href=\"#2-Looper\" class=\"headerlink\" title=\"2.Looper\"></a>2.Looper</h3><p>以主线程为例。Looper的初始化过程是这样的。<br>代码地址：<br>/frameworks/base/core/java/android/app/ActivityThread.java#main(String[] args)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepareMainLooper();</div><div class=\"line\">xxxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>而非UI线程的初始化过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.prepare()</div><div class=\"line\">xxx</div><div class=\"line\">Looper.loop();</div></pre></td></tr></table></figure></p>\n<p>不管是主线程还是其他线程，都会调用prepare(boolean quitAllowed)方法，参数为是否允许退出循环，主线程是不允许的，而其他线程是允许的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void prepare(boolean quitAllowed) &#123;</div><div class=\"line\">       if (sThreadLocal.get() != null) &#123;</div><div class=\"line\">           throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       sThreadLocal.set(new Looper(quitAllowed));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>接下来看Looper的构造方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Looper(boolean quitAllowed) &#123;</div><div class=\"line\">       mQueue = new MessageQueue(quitAllowed);</div><div class=\"line\">       mThread = Thread.currentThread();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从构造方法中可以看出，将Looper、MessageQueue、currentThread之间建立的关联。<br>那么，Looper对象是如何从消息队列中不断地取出消息呢？代码比较长，我们拆开来看。Looper#loop()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Looper me = myLooper();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static @Nullable Looper myLooper() &#123;</div><div class=\"line\">       return sThreadLocal.get();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>取出和当前线程对应的Looper对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">           Message msg = queue.next(); // might block</div><div class=\"line\">           if (msg == null) &#123;</div><div class=\"line\">               // No message indicates that the message queue is quitting.</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">           if (logging != null) &#123;</div><div class=\"line\">               logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Make sure that during the course of dispatching the</div><div class=\"line\">           // identity of the thread wasn&apos;t corrupted.</div><div class=\"line\">           final long newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">           msg.recycleUnchecked();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码中去掉了一些日志代码。可以看到,死循环从MessageQueue中取出消息，并调用msg.target.dispatchMessage(msg)方法去分发消息，最后回收。</p>\n<h3 id=\"3-Handler\"><a href=\"#3-Handler\" class=\"headerlink\" title=\"3.Handler\"></a>3.Handler</h3><p>既然知道了Looper，那么我们需要知道消息是怎么来的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Message msg = new Message();</div><div class=\"line\">msg.what = xxx;</div><div class=\"line\">msg.obj = xxx;</div><div class=\"line\">handler.sendMessage(msg);</div></pre></td></tr></table></figure></p>\n<p>我们通常都是通过上面的步骤去发送的，所以，追踪下代码。</p>\n<p>sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage<br>到这里就来到了一个关键点了，我们看下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class=\"line\">   msg.target = this;</div><div class=\"line\">   if (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(true);</div><div class=\"line\">   &#125;</div><div class=\"line\">   return queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还记得我们上面分发消息的地方么？同样有target，这个是什么呢？我们进Message的源码里一探究竟。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Handler target</div></pre></td></tr></table></figure></p>\n<p>好，是一个handler对象，也就是我们当前线程的一个handler对象，也就是发送消息的那个handler对象。所以，我们现在来看看handler的dispatchMessage方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void dispatchMessage(Message msg) &#123;</div><div class=\"line\">    if (msg.callback != null) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (mCallback != null) &#123;</div><div class=\"line\">            if (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用关系和初始化的关系有关。</p>\n<ul>\n<li>Message.obtain(Handler h, Runnable callback) 构造消息时，会调用handlerCallback(msg)方法</li>\n<li>初始化Handler的构造函数带CallBack参数是，调用mCallBack的 handleMessage(msg)方法</li>\n<li>否则，调用handlerMessage(msg)方法。</li>\n</ul>\n<p>回到enqueueMessage方法，发现是通过调用MessageQueue的enqueueMessage方法来插入消息的。</p>\n<h3 id=\"4-MessageQueue\"><a href=\"#4-MessageQueue\" class=\"headerlink\" title=\"4.MessageQueue\"></a>4.MessageQueue</h3><p>消息队列，字面意思是消息队列，然而我们知道，队列的方式是先进先出，而我们的消息时候时间调度的，因此，并不符合先进先出的思想，所以，消息队列实际上是个链表，这样我们才能往任意位置插入消息。enqueueMessage的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean enqueueMessage(Message msg, long when) &#123;</div><div class=\"line\">    if (msg.target == null) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg.isInUse()) &#123;</div><div class=\"line\">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        if (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = new IllegalStateException(</div><div class=\"line\">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class=\"line\">            Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        boolean needWake;</div><div class=\"line\">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class=\"line\">            // New head, wake up the event queue if blocked.</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class=\"line\">            // up the event queue unless there is a barrier at the head of the queue</div><div class=\"line\">            // and the message is the earliest asynchronous message in the queue.</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">            for (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">                if (p == null || when &lt; p.when) &#123;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = p; // invariant: p == prev.next</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We can assume mPtr != 0 because mQuitting is false.</div><div class=\"line\">        if (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的步骤是这样子的。</p>\n<ul>\n<li>判断是否关联了handler</li>\n<li>判断是否用过(已经插入到链表中的)</li>\n<li>当前队列是否处在退出状态<ul>\n<li>退出状态  回收资源，插入链表失败</li>\n<li>不是退出状态<ul>\n<li>改变Message的状态为已经use，并获取message的when时间</li>\n<li>在链表中找到合适的位置插入<ul>\n<li>和链表头结点比较时间，如发生时间在头结点消息之前，插入到头结点</li>\n<li>死循环，找到该消息比链表中的消息早发生的消息，插入到那条消息前面，否则就插入到链表表尾</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在最前面Looper里，一直通过queue.next()去读取链表里的消息，所以，我们来看下next方法。由于next的方法比较长，我们一段一段来看。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">final long now = SystemClock.uptimeMillis();</div><div class=\"line\">Message prevMsg = null;</div><div class=\"line\">Message msg = mMessages;</div><div class=\"line\">if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class=\"line\">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class=\"line\">    do &#123;</div><div class=\"line\">        prevMsg = msg;</div><div class=\"line\">        msg = msg.next;</div><div class=\"line\">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg != null) &#123;</div><div class=\"line\">    if (now &lt; msg.when) &#123;</div><div class=\"line\">        // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class=\"line\">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Got a message.</div><div class=\"line\">        mBlocked = false;</div><div class=\"line\">        if (prevMsg != null) &#123;</div><div class=\"line\">            prevMsg.next = msg.next;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mMessages = msg.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg.next = null;</div><div class=\"line\">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        return msg;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // No more messages.</div><div class=\"line\">    nextPollTimeoutMillis = -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>假如当前Message不为null 但是没和handler关联的话，就找下一个消息，直到找到不是null也关联到handler的Message</li>\n<li>如果当前时间小于Message的when的话，就计算时间差，并赋值给nextPollTimeoutMillis</li>\n<li><p>不小于的话</p>\n<ul>\n<li>假如步骤1中链表头的消息没关联handler，就将步骤1中找出的不是null也关联了handler的Message的上一条Message.next指向该Message.next(这里有点绕，其实就相当于在链表中移除了改消息)，并返回该消息</li>\n<li>否则，将mMessages(表头)指向msg.next(也是移除了该消息) </li>\n</ul>\n</li>\n<li><p>下面的代码忽略(ps:我看不懂…)</p>\n</li>\n</ul>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><p>当然，这些东西里面我没有介绍ThreadLocal这个，想了解的朋友们去Google吧(百度不是出事了么，嘿嘿)。<br>Android中的消息传递机制是一个非常重要的东西，我们需要简单的了解下他的简单原理，所以，大家也去看看源代码吧。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android应用程序是如何安装的","date":"2017-01-04T12:24:27.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，\n\n### 2.安装器\n\n显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。\n\n```\n        if (v == mOk) {\n            if (mOkCanInstall || mScrollView == null) {\n                mInstallFlowAnalytics.setInstallButtonClicked();\n                if (mSessionId != -1) {\n                    mInstaller.setPermissionsResult(mSessionId, true);\n\n                    // We're only confirming permissions, so we don't really know how the\n                    // story ends; assume success.\n                    mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(\n                            PackageManager.INSTALL_SUCCEEDED);\n                    finish();\n                } else {\n                    startInstall();\n                }\n            } else {\n                mScrollView.pageScroll(View.FOCUS_DOWN);\n            }\n        }\n```\n\n虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。\n\n```\n        if (\"package\".equals(mPackageURI.getScheme())) {\n            try {\n                pm.installExistingPackage(mAppInfo.packageName);\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_SUCCEEDED);\n            } catch (PackageManager.NameNotFoundException e) {\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_FAILED_INVALID_APK);\n            }\n        } else {\n            pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,\n                    installerPackageName, verificationParams, null);\n        }\n```\n\n* mPackageURI，安装应用的话，应该是file\n* pm 为ApplicationPackageManager\n\n因此，我们看installPackageWithVerificationAndEncryption方法。\n\n### 3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\n\n\n在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。\n\n```\n    public static IPackageManager getPackageManager() {\n        if (sPackageManager != null) {\n            //Slog.v(\"PackageManager\", \"returning cur default = \" + sPackageManager);\n            return sPackageManager;\n        }\n        IBinder b = ServiceManager.getService(\"package\");\n        //Slog.v(\"PackageManager\", \"default service binder = \" + b);\n        sPackageManager = IPackageManager.Stub.asInterface(b);\n        //Slog.v(\"PackageManager\", \"default service = \" + sPackageManager);\n        return sPackageManager;\n    }\n```\n\n从中可以看出，其binder服务端为PackageManagerService.\n\n### 4.PackageManagerService#installPackage\n\n在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy\n\n```\n        final Message msg = mHandler.obtainMessage(INIT_COPY);\n        msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,\n                null, verificationParams, user, packageAbiOverride, null);\n        mHandler.sendMessage(msg);\n```\n\n这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？\n\n```\n                case INIT_COPY: {\n                    HandlerParams params = (HandlerParams) msg.obj;\n                    int idx = mPendingInstalls.size();\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy idx=\" + idx + \": \" + params);\n                    // If a bind was already initiated we dont really\n                    // need to do anything. The pending install\n                    // will be processed later on.\n                    if (!mBound) {\n                        // If this is the only one pending we might\n                        // have to bind to the service again.\n                        if (!connectToService()) {\n                            Slog.e(TAG, \"Failed to bind to media container service\");\n                            params.serviceError();\n                            return;\n                        } else {\n                            // Once we bind to the service, the first\n                            // pending request will be processed.\n                            mPendingInstalls.add(idx, params);\n                        }\n                    } else {\n                        mPendingInstalls.add(idx, params);\n                        // Already bound to the service. Just make\n                        // sure we trigger off processing the first request.\n                        if (idx == 0) {\n                            mHandler.sendEmptyMessage(MCS_BOUND);\n                        }\n                    }\n                    break;\n                }\n```\n\n如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。\n在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，\n\n```\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_bound\");\n                    if (msg.obj != null) {\n                        mContainerService = (IMediaContainerService) msg.obj;\n                    }\n                    if (mContainerService == null) {\n                        if (!mBound) {\n                            // Something seriously wrong since we are not bound and we are not\n                            // waiting for connection. Bail out.\n                            Slog.e(TAG, \"Cannot bind to media container service\");\n                            for (HandlerParams params : mPendingInstalls) {\n                                // Indicate service bind error\n                                params.serviceError();\n                            }\n                            mPendingInstalls.clear();\n                        } else {\n                            Slog.w(TAG, \"Waiting to connect to media container service\");\n                        }\n                    } else if (mPendingInstalls.size() > 0) {\n                        HandlerParams params = mPendingInstalls.get(0);\n                        if (params != null) {\n                            if (params.startCopy()) {\n                                // We are done...  look for more work or to\n                                // go idle.\n                                if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                        \"Checking for more work or unbind...\");\n                                // Delete pending install\n                                if (mPendingInstalls.size() > 0) {\n                                    mPendingInstalls.remove(0);\n                                }\n                                if (mPendingInstalls.size() == 0) {\n                                    if (mBound) {\n                                        if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                                \"Posting delayed MCS_UNBIND\");\n                                        removeMessages(MCS_UNBIND);\n                                        Message ubmsg = obtainMessage(MCS_UNBIND);\n                                        // Unbind after a little delay, to avoid\n                                        // continual thrashing.\n                                        sendMessageDelayed(ubmsg, 10000);\n                                    }\n                                } else {\n                                    // There are more pending requests in queue.\n                                    // Just post MCS_BOUND message to trigger processing\n                                    // of next pending install.\n                                    if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                            \"Posting MCS_BOUND for next work\");\n                                    mHandler.sendEmptyMessage(MCS_BOUND);\n                                }\n                            }\n                        }\n                    } else {\n                        // Should never happen ideally.\n                        Slog.w(TAG, \"Empty queue\");\n                    }\n                    break;\n```\n\n从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。\n\n### 5.HandlerParams#startCopy\n\n```\n        final boolean startCopy() {\n            boolean res;\n            try {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"startCopy \" + mUser + \": \" + this);\n\n                if (++mRetries > MAX_RETRIES) {\n                    Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\");\n                    mHandler.sendEmptyMessage(MCS_GIVE_UP);\n                    handleServiceError();\n                    return false;\n                } else {\n                    handleStartCopy();\n                    res = true;\n                }\n            } catch (RemoteException e) {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\");\n                mHandler.sendEmptyMessage(MCS_RECONNECT);\n                res = false;\n            }\n            handleReturnCode();\n            return res;\n        }\n```\n\n这里有重试机制。而handleStartCopy的实现在InstallParams中。\n\n### 6.InstallParams#handleStartCopy\n\n这个方法比较长，分段来看。\n\n```\n                    final StorageManager storage = StorageManager.from(mContext);\n                    final long lowThreshold = storage.getStorageLowBytes(\n                            Environment.getDataDirectory());\n\n                    final long sizeBytes = mContainerService.calculateInstalledSize(\n                            origin.resolvedPath, isForwardLocked(), packageAbiOverride);\n\n                    if (mInstaller.freeCache(null, sizeBytes + lowThreshold) >= 0) {\n                        pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,\n                                installFlags, packageAbiOverride);\n                    }\n```\n\n首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。\n\n这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。\n\n中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。\n\n```\nif (ret == PackageManager.INSTALL_SUCCEEDED) {\n                 /*\n                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by\n                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.\n                 */\n                int userIdentifier = getUser().getIdentifier();\n                if (userIdentifier == UserHandle.USER_ALL\n                        && ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0)) {\n                    userIdentifier = UserHandle.USER_OWNER;\n                }\n\n                /*\n                 * Determine if we have any installed package verifiers. If we\n                 * do, then we'll defer to them to verify the packages.\n                 */\n                final int requiredUid = mRequiredVerifierPackage == null ? -1\n                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);\n                if (!origin.existing && requiredUid != -1\n                        && isVerificationEnabled(userIdentifier, installFlags)) {\n                    final Intent verification = new Intent(\n                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);\n                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),\n                            PACKAGE_MIME_TYPE);\n                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n                    final List<ResolveInfo> receivers = queryIntentReceivers(verification,\n                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,\n                            0 /* TODO: Which userId? */);\n\n                    if (DEBUG_VERIFY) {\n                        Slog.d(TAG, \"Found \" + receivers.size() + \" verifiers for intent \"\n                                + verification.toString() + \" with \" + pkgLite.verifiers.length\n                                + \" optional verifiers\");\n                    }\n\n                    final int verificationId = mPendingVerificationToken++;\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,\n                            installerPackageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,\n                            installFlags);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,\n                            pkgLite.packageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,\n                            pkgLite.versionCode);\n\n                    if (verificationParams != null) {\n                        if (verificationParams.getVerificationURI() != null) {\n                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,\n                                 verificationParams.getVerificationURI());\n                        }\n                        if (verificationParams.getOriginatingURI() != null) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,\n                                  verificationParams.getOriginatingURI());\n                        }\n                        if (verificationParams.getReferrer() != null) {\n                            verification.putExtra(Intent.EXTRA_REFERRER,\n                                  verificationParams.getReferrer());\n                        }\n                        if (verificationParams.getOriginatingUid() >= 0) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,\n                                  verificationParams.getOriginatingUid());\n                        }\n                        if (verificationParams.getInstallerUid() >= 0) {\n                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,\n                                  verificationParams.getInstallerUid());\n                        }\n                    }\n\n                    final PackageVerificationState verificationState = new PackageVerificationState(\n                            requiredUid, args);\n\n                    mPendingVerification.append(verificationId, verificationState);\n\n                    final List<ComponentName> sufficientVerifiers = matchVerifiers(pkgLite,\n                            receivers, verificationState);\n\n                    // Apps installed for \"all\" users use the device owner to verify the app\n                    UserHandle verifierUser = getUser();\n                    if (verifierUser == UserHandle.ALL) {\n                        verifierUser = UserHandle.OWNER;\n                    }\n\n                    /*\n                     * If any sufficient verifiers were listed in the package\n                     * manifest, attempt to ask them.\n                     */\n                    if (sufficientVerifiers != null) {\n                        final int N = sufficientVerifiers.size();\n                        if (N == 0) {\n                            Slog.i(TAG, \"Additional verifiers required, but none installed.\");\n                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;\n                        } else {\n                            for (int i = 0; i < N; i++) {\n                                final ComponentName verifierComponent = sufficientVerifiers.get(i);\n\n                                final Intent sufficientIntent = new Intent(verification);\n                                sufficientIntent.setComponent(verifierComponent);\n                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);\n                            }\n                        }\n                    }\n\n                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(\n                            mRequiredVerifierPackage, receivers);\n                    if (ret == PackageManager.INSTALL_SUCCEEDED\n                            && mRequiredVerifierPackage != null) {\n                        /*\n                         * Send the intent to the required verification agent,\n                         * but only start the verification timeout after the\n                         * target BroadcastReceivers have run.\n                         */\n                        verification.setComponent(requiredVerifierComponent);\n                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,\n                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,\n                                new BroadcastReceiver() {\n                                    @Override\n                                    public void onReceive(Context context, Intent intent) {\n                                        final Message msg = mHandler\n                                                .obtainMessage(CHECK_PENDING_VERIFICATION);\n                                        msg.arg1 = verificationId;\n                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());\n                                    }\n                                }, null, 0, null, null);\n\n                        /*\n                         * We don't want the copy to proceed until verification\n                         * succeeds, so null out this field.\n                         */\n                        mArgs = null;\n                    }\n                } else {\n                    /*\n                     * No package verification is enabled, so immediately start\n                     * the remote call to initiate copy using temporary file.\n                     */\n                    ret = args.copyApk(mContainerService, true);\n                }\n            }\n\n```\n\n* 如果启动了包验证的话，就会进入验证阶段。 \n\t* 发送有序广播， \n* 否则，直接进行复制操作\n\n验证部分的逻辑很长，大部分代码都是对intent进行设置。\n\n### 7.InstallArgs#copyApk\n\n在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。\n\n```\n    private InstallArgs createInstallArgs(InstallParams params) {\n        if (params.move != null) {\n            return new MoveInstallArgs(params);\n        } else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {\n            return new AsecInstallArgs(params);\n        } else {\n            return new FileInstallArgs(params);\n        }\n    }\n```\n\n以FileInstallArgs为例，我们来看看。\n\n```\n\n       int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {\n            if (origin.staged) {\n                if (DEBUG_INSTALL) Slog.d(TAG, origin.file + \" already staged; skipping copy\");\n                codeFile = origin.file;\n                resourceFile = origin.file;\n                return PackageManager.INSTALL_SUCCEEDED;\n            }\n\n            try {\n                final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);\n                codeFile = tempDir;\n                resourceFile = tempDir;\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to create copy file: \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n\n            final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {\n                @Override\n                public ParcelFileDescriptor open(String name, int mode) throws RemoteException {\n                    if (!FileUtils.isValidExtFilename(name)) {\n                        throw new IllegalArgumentException(\"Invalid filename: \" + name);\n                    }\n                    try {\n                        final File file = new File(codeFile, name);\n                        final FileDescriptor fd = Os.open(file.getAbsolutePath(),\n                                O_RDWR | O_CREAT, 0644);\n                        Os.chmod(file.getAbsolutePath(), 0644);\n                        return new ParcelFileDescriptor(fd);\n                    } catch (ErrnoException e) {\n                        throw new RemoteException(\"Failed to open: \" + e.getMessage());\n                    }\n                }\n            };\n\n            int ret = PackageManager.INSTALL_SUCCEEDED;\n            ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);\n            if (ret != PackageManager.INSTALL_SUCCEEDED) {\n                Slog.e(TAG, \"Failed to copy package\");\n                return ret;\n            }\n\n            final File libraryRoot = new File(codeFile, LIB_DIR_NAME);\n            NativeLibraryHelper.Handle handle = null;\n            try {\n                handle = NativeLibraryHelper.Handle.create(codeFile);\n                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,\n                        abiOverride);\n            } catch (IOException e) {\n                Slog.e(TAG, \"Copying native libraries failed\", e);\n                ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;\n            } finally {\n                IoUtils.closeQuietly(handle);\n            }\n\n            return ret;\n        }\n\n```\n\n* 首先mInstallerService.allocateStageDirLegacy申请足够的存储空间\n* 得到申请的那部分空间的文件描述符，并且修改权限\n* IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，\n* NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)\n\n### 8.DefaultContainerService#copyPackage\n\n```\n        public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) {\n            if (packagePath == null || target == null) {\n                return PackageManager.INSTALL_FAILED_INVALID_URI;\n            }\n\n            PackageLite pkg = null;\n            try {\n                final File packageFile = new File(packagePath);\n                pkg = PackageParser.parsePackageLite(packageFile, 0);\n                return copyPackageInner(pkg, target);\n            } catch (PackageParserException | IOException | RemoteException e) {\n                Slog.w(TAG, \"Failed to copy package at \" + packagePath + \": \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n        }\n```\n\n* 解析apk文件\n* 将文件拷贝到指定目录\n\n### 9.NativeLibraryHelper#copyNativeBinariesWithOverride\n\n在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。\n\n到现在，copy的流程就完了。\n\n在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。\n\n### 10.InstallParams#handleReturnCode\n\n在这个方法中，会调用processPendingInstall去处理。\n\n```\n    private void processPendingInstall(final InstallArgs args, final int currentStatus) {\n        // Queue up an async operation since the package installation may take a little while.\n        mHandler.post(new Runnable() {\n            public void run() {\n                mHandler.removeCallbacks(this);\n                 // Result object to be returned\n                PackageInstalledInfo res = new PackageInstalledInfo();\n                res.returnCode = currentStatus;\n                res.uid = -1;\n                res.pkg = null;\n                res.removedInfo = new PackageRemovedInfo();\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {\n                    args.doPreInstall(res.returnCode);\n                    synchronized (mInstallLock) {\n                        installPackageLI(args, res);\n                    }\n                    args.doPostInstall(res.returnCode, res.uid);\n                }\n\n                // A restore should be performed at this point if (a) the install\n                // succeeded, (b) the operation is not an update, and (c) the new\n                // package has not opted out of backup participation.\n                final boolean update = res.removedInfo.removedPackage != null;\n                final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;\n                boolean doRestore = !update\n                        && ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);\n\n                // Set up the post-install work request bookkeeping.  This will be used\n                // and cleaned up by the post-install event handling regardless of whether\n                // there's a restore pass performed.  Token values are >= 1.\n                int token;\n                if (mNextInstallToken < 0) mNextInstallToken = 1;\n                token = mNextInstallToken++;\n\n                PostInstallData data = new PostInstallData(args, res);\n                mRunningInstalls.put(token, data);\n                if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token);\n\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {\n                    // Pass responsibility to the Backup Manager.  It will perform a\n                    // restore if appropriate, then pass responsibility back to the\n                    // Package Manager to run the post-install observer callbacks\n                    // and broadcasts.\n                    IBackupManager bm = IBackupManager.Stub.asInterface(\n                            ServiceManager.getService(Context.BACKUP_SERVICE));\n                    if (bm != null) {\n                        if (DEBUG_INSTALL) Log.v(TAG, \"token \" + token\n                                + \" to BM for possible restore\");\n                        try {\n                            if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) {\n                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);\n                            } else {\n                                doRestore = false;\n                            }\n                        } catch (RemoteException e) {\n                            // can't happen; the backup manager is local\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"Exception trying to enqueue restore\", e);\n                            doRestore = false;\n                        }\n                    } else {\n                        Slog.e(TAG, \"Backup Manager not found!\");\n                        doRestore = false;\n                    }\n                }\n\n                if (!doRestore) {\n                    // No restore possible, or the Backup Manager was mysteriously not\n                    // available -- just fire the post-install work request directly.\n                    if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token);\n                    Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);\n                    mHandler.sendMessage(msg);\n                }\n            }\n        });\n    }\n```\n\n安装过程\n\n* installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。\n* 恢复部分代码 没看明白。😭\n* 发送POST_INSTALL消息\n\n### 11.installPackageLI\n\n改方法氛围几部分。\n\n首先是解析包过程。\n\n```\n        PackageParser pp = new PackageParser();\n        pp.setSeparateProcesses(mSeparateProcesses);\n        pp.setDisplayMetrics(mMetrics);\n\n        final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(tmpPackageFile, parseFlags);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed parse during installPackageLI\", e);\n            return;\n        }\n```\n\n其次是校验签名的md5的过程\n\n```\n        try {\n            pp.collectCertificates(pkg, parseFlags);\n            pp.collectManifestDigest(pkg);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed collect during installPackageLI\", e);\n            return;\n        }\n\n        /* If the installer passed in a manifest digest, compare it now. */\n        if (args.manifestDigest != null) {\n            if (DEBUG_INSTALL) {\n                final String parsedManifest = pkg.manifestDigest == null ? \"null\"\n                        : pkg.manifestDigest.toString();\n                Slog.d(TAG, \"Comparing manifests: \" + args.manifestDigest.toString() + \" vs. \"\n                        + parsedManifest);\n            }\n\n            if (!args.manifestDigest.equals(pkg.manifestDigest)) {\n                res.setError(INSTALL_FAILED_PACKAGE_CHANGED, \"Manifest digest changed\");\n                return;\n            }\n        } else if (DEBUG_INSTALL) {\n            final String parsedManifest = pkg.manifestDigest == null\n                    ? \"null\" : pkg.manifestDigest.toString();\n            Slog.d(TAG, \"manifestDigest was not present, but parser got: \" + parsedManifest);\n        }\n```\n\n\n调用installNewPackageLI安装。\n\n### 12.installNewPackageLI\n\n在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。\n\n\n### 13.处理POST_INSTALL消息\n\n略。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n","source":"_posts/Android应用程序是如何安装的.md","raw":"---\ntitle: Android应用程序是如何安装的\ndate: 2017-01-04 20:24:27\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，\n\n### 2.安装器\n\n显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。\n\n```\n        if (v == mOk) {\n            if (mOkCanInstall || mScrollView == null) {\n                mInstallFlowAnalytics.setInstallButtonClicked();\n                if (mSessionId != -1) {\n                    mInstaller.setPermissionsResult(mSessionId, true);\n\n                    // We're only confirming permissions, so we don't really know how the\n                    // story ends; assume success.\n                    mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(\n                            PackageManager.INSTALL_SUCCEEDED);\n                    finish();\n                } else {\n                    startInstall();\n                }\n            } else {\n                mScrollView.pageScroll(View.FOCUS_DOWN);\n            }\n        }\n```\n\n虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。\n\n```\n        if (\"package\".equals(mPackageURI.getScheme())) {\n            try {\n                pm.installExistingPackage(mAppInfo.packageName);\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_SUCCEEDED);\n            } catch (PackageManager.NameNotFoundException e) {\n                observer.packageInstalled(mAppInfo.packageName,\n                        PackageManager.INSTALL_FAILED_INVALID_APK);\n            }\n        } else {\n            pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,\n                    installerPackageName, verificationParams, null);\n        }\n```\n\n* mPackageURI，安装应用的话，应该是file\n* pm 为ApplicationPackageManager\n\n因此，我们看installPackageWithVerificationAndEncryption方法。\n\n### 3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\n\n\n在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。\n\n```\n    public static IPackageManager getPackageManager() {\n        if (sPackageManager != null) {\n            //Slog.v(\"PackageManager\", \"returning cur default = \" + sPackageManager);\n            return sPackageManager;\n        }\n        IBinder b = ServiceManager.getService(\"package\");\n        //Slog.v(\"PackageManager\", \"default service binder = \" + b);\n        sPackageManager = IPackageManager.Stub.asInterface(b);\n        //Slog.v(\"PackageManager\", \"default service = \" + sPackageManager);\n        return sPackageManager;\n    }\n```\n\n从中可以看出，其binder服务端为PackageManagerService.\n\n### 4.PackageManagerService#installPackage\n\n在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy\n\n```\n        final Message msg = mHandler.obtainMessage(INIT_COPY);\n        msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,\n                null, verificationParams, user, packageAbiOverride, null);\n        mHandler.sendMessage(msg);\n```\n\n这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？\n\n```\n                case INIT_COPY: {\n                    HandlerParams params = (HandlerParams) msg.obj;\n                    int idx = mPendingInstalls.size();\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy idx=\" + idx + \": \" + params);\n                    // If a bind was already initiated we dont really\n                    // need to do anything. The pending install\n                    // will be processed later on.\n                    if (!mBound) {\n                        // If this is the only one pending we might\n                        // have to bind to the service again.\n                        if (!connectToService()) {\n                            Slog.e(TAG, \"Failed to bind to media container service\");\n                            params.serviceError();\n                            return;\n                        } else {\n                            // Once we bind to the service, the first\n                            // pending request will be processed.\n                            mPendingInstalls.add(idx, params);\n                        }\n                    } else {\n                        mPendingInstalls.add(idx, params);\n                        // Already bound to the service. Just make\n                        // sure we trigger off processing the first request.\n                        if (idx == 0) {\n                            mHandler.sendEmptyMessage(MCS_BOUND);\n                        }\n                    }\n                    break;\n                }\n```\n\n如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。\n在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，\n\n```\n                    if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_bound\");\n                    if (msg.obj != null) {\n                        mContainerService = (IMediaContainerService) msg.obj;\n                    }\n                    if (mContainerService == null) {\n                        if (!mBound) {\n                            // Something seriously wrong since we are not bound and we are not\n                            // waiting for connection. Bail out.\n                            Slog.e(TAG, \"Cannot bind to media container service\");\n                            for (HandlerParams params : mPendingInstalls) {\n                                // Indicate service bind error\n                                params.serviceError();\n                            }\n                            mPendingInstalls.clear();\n                        } else {\n                            Slog.w(TAG, \"Waiting to connect to media container service\");\n                        }\n                    } else if (mPendingInstalls.size() > 0) {\n                        HandlerParams params = mPendingInstalls.get(0);\n                        if (params != null) {\n                            if (params.startCopy()) {\n                                // We are done...  look for more work or to\n                                // go idle.\n                                if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                        \"Checking for more work or unbind...\");\n                                // Delete pending install\n                                if (mPendingInstalls.size() > 0) {\n                                    mPendingInstalls.remove(0);\n                                }\n                                if (mPendingInstalls.size() == 0) {\n                                    if (mBound) {\n                                        if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                                \"Posting delayed MCS_UNBIND\");\n                                        removeMessages(MCS_UNBIND);\n                                        Message ubmsg = obtainMessage(MCS_UNBIND);\n                                        // Unbind after a little delay, to avoid\n                                        // continual thrashing.\n                                        sendMessageDelayed(ubmsg, 10000);\n                                    }\n                                } else {\n                                    // There are more pending requests in queue.\n                                    // Just post MCS_BOUND message to trigger processing\n                                    // of next pending install.\n                                    if (DEBUG_SD_INSTALL) Log.i(TAG,\n                                            \"Posting MCS_BOUND for next work\");\n                                    mHandler.sendEmptyMessage(MCS_BOUND);\n                                }\n                            }\n                        }\n                    } else {\n                        // Should never happen ideally.\n                        Slog.w(TAG, \"Empty queue\");\n                    }\n                    break;\n```\n\n从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。\n\n### 5.HandlerParams#startCopy\n\n```\n        final boolean startCopy() {\n            boolean res;\n            try {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"startCopy \" + mUser + \": \" + this);\n\n                if (++mRetries > MAX_RETRIES) {\n                    Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\");\n                    mHandler.sendEmptyMessage(MCS_GIVE_UP);\n                    handleServiceError();\n                    return false;\n                } else {\n                    handleStartCopy();\n                    res = true;\n                }\n            } catch (RemoteException e) {\n                if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\");\n                mHandler.sendEmptyMessage(MCS_RECONNECT);\n                res = false;\n            }\n            handleReturnCode();\n            return res;\n        }\n```\n\n这里有重试机制。而handleStartCopy的实现在InstallParams中。\n\n### 6.InstallParams#handleStartCopy\n\n这个方法比较长，分段来看。\n\n```\n                    final StorageManager storage = StorageManager.from(mContext);\n                    final long lowThreshold = storage.getStorageLowBytes(\n                            Environment.getDataDirectory());\n\n                    final long sizeBytes = mContainerService.calculateInstalledSize(\n                            origin.resolvedPath, isForwardLocked(), packageAbiOverride);\n\n                    if (mInstaller.freeCache(null, sizeBytes + lowThreshold) >= 0) {\n                        pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,\n                                installFlags, packageAbiOverride);\n                    }\n```\n\n首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。\n\n这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。\n\n中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。\n\n```\nif (ret == PackageManager.INSTALL_SUCCEEDED) {\n                 /*\n                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by\n                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.\n                 */\n                int userIdentifier = getUser().getIdentifier();\n                if (userIdentifier == UserHandle.USER_ALL\n                        && ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0)) {\n                    userIdentifier = UserHandle.USER_OWNER;\n                }\n\n                /*\n                 * Determine if we have any installed package verifiers. If we\n                 * do, then we'll defer to them to verify the packages.\n                 */\n                final int requiredUid = mRequiredVerifierPackage == null ? -1\n                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);\n                if (!origin.existing && requiredUid != -1\n                        && isVerificationEnabled(userIdentifier, installFlags)) {\n                    final Intent verification = new Intent(\n                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);\n                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),\n                            PACKAGE_MIME_TYPE);\n                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n                    final List<ResolveInfo> receivers = queryIntentReceivers(verification,\n                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,\n                            0 /* TODO: Which userId? */);\n\n                    if (DEBUG_VERIFY) {\n                        Slog.d(TAG, \"Found \" + receivers.size() + \" verifiers for intent \"\n                                + verification.toString() + \" with \" + pkgLite.verifiers.length\n                                + \" optional verifiers\");\n                    }\n\n                    final int verificationId = mPendingVerificationToken++;\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,\n                            installerPackageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,\n                            installFlags);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,\n                            pkgLite.packageName);\n\n                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,\n                            pkgLite.versionCode);\n\n                    if (verificationParams != null) {\n                        if (verificationParams.getVerificationURI() != null) {\n                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,\n                                 verificationParams.getVerificationURI());\n                        }\n                        if (verificationParams.getOriginatingURI() != null) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,\n                                  verificationParams.getOriginatingURI());\n                        }\n                        if (verificationParams.getReferrer() != null) {\n                            verification.putExtra(Intent.EXTRA_REFERRER,\n                                  verificationParams.getReferrer());\n                        }\n                        if (verificationParams.getOriginatingUid() >= 0) {\n                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,\n                                  verificationParams.getOriginatingUid());\n                        }\n                        if (verificationParams.getInstallerUid() >= 0) {\n                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,\n                                  verificationParams.getInstallerUid());\n                        }\n                    }\n\n                    final PackageVerificationState verificationState = new PackageVerificationState(\n                            requiredUid, args);\n\n                    mPendingVerification.append(verificationId, verificationState);\n\n                    final List<ComponentName> sufficientVerifiers = matchVerifiers(pkgLite,\n                            receivers, verificationState);\n\n                    // Apps installed for \"all\" users use the device owner to verify the app\n                    UserHandle verifierUser = getUser();\n                    if (verifierUser == UserHandle.ALL) {\n                        verifierUser = UserHandle.OWNER;\n                    }\n\n                    /*\n                     * If any sufficient verifiers were listed in the package\n                     * manifest, attempt to ask them.\n                     */\n                    if (sufficientVerifiers != null) {\n                        final int N = sufficientVerifiers.size();\n                        if (N == 0) {\n                            Slog.i(TAG, \"Additional verifiers required, but none installed.\");\n                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;\n                        } else {\n                            for (int i = 0; i < N; i++) {\n                                final ComponentName verifierComponent = sufficientVerifiers.get(i);\n\n                                final Intent sufficientIntent = new Intent(verification);\n                                sufficientIntent.setComponent(verifierComponent);\n                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);\n                            }\n                        }\n                    }\n\n                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(\n                            mRequiredVerifierPackage, receivers);\n                    if (ret == PackageManager.INSTALL_SUCCEEDED\n                            && mRequiredVerifierPackage != null) {\n                        /*\n                         * Send the intent to the required verification agent,\n                         * but only start the verification timeout after the\n                         * target BroadcastReceivers have run.\n                         */\n                        verification.setComponent(requiredVerifierComponent);\n                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,\n                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,\n                                new BroadcastReceiver() {\n                                    @Override\n                                    public void onReceive(Context context, Intent intent) {\n                                        final Message msg = mHandler\n                                                .obtainMessage(CHECK_PENDING_VERIFICATION);\n                                        msg.arg1 = verificationId;\n                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());\n                                    }\n                                }, null, 0, null, null);\n\n                        /*\n                         * We don't want the copy to proceed until verification\n                         * succeeds, so null out this field.\n                         */\n                        mArgs = null;\n                    }\n                } else {\n                    /*\n                     * No package verification is enabled, so immediately start\n                     * the remote call to initiate copy using temporary file.\n                     */\n                    ret = args.copyApk(mContainerService, true);\n                }\n            }\n\n```\n\n* 如果启动了包验证的话，就会进入验证阶段。 \n\t* 发送有序广播， \n* 否则，直接进行复制操作\n\n验证部分的逻辑很长，大部分代码都是对intent进行设置。\n\n### 7.InstallArgs#copyApk\n\n在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。\n\n```\n    private InstallArgs createInstallArgs(InstallParams params) {\n        if (params.move != null) {\n            return new MoveInstallArgs(params);\n        } else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {\n            return new AsecInstallArgs(params);\n        } else {\n            return new FileInstallArgs(params);\n        }\n    }\n```\n\n以FileInstallArgs为例，我们来看看。\n\n```\n\n       int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {\n            if (origin.staged) {\n                if (DEBUG_INSTALL) Slog.d(TAG, origin.file + \" already staged; skipping copy\");\n                codeFile = origin.file;\n                resourceFile = origin.file;\n                return PackageManager.INSTALL_SUCCEEDED;\n            }\n\n            try {\n                final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);\n                codeFile = tempDir;\n                resourceFile = tempDir;\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to create copy file: \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n\n            final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {\n                @Override\n                public ParcelFileDescriptor open(String name, int mode) throws RemoteException {\n                    if (!FileUtils.isValidExtFilename(name)) {\n                        throw new IllegalArgumentException(\"Invalid filename: \" + name);\n                    }\n                    try {\n                        final File file = new File(codeFile, name);\n                        final FileDescriptor fd = Os.open(file.getAbsolutePath(),\n                                O_RDWR | O_CREAT, 0644);\n                        Os.chmod(file.getAbsolutePath(), 0644);\n                        return new ParcelFileDescriptor(fd);\n                    } catch (ErrnoException e) {\n                        throw new RemoteException(\"Failed to open: \" + e.getMessage());\n                    }\n                }\n            };\n\n            int ret = PackageManager.INSTALL_SUCCEEDED;\n            ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);\n            if (ret != PackageManager.INSTALL_SUCCEEDED) {\n                Slog.e(TAG, \"Failed to copy package\");\n                return ret;\n            }\n\n            final File libraryRoot = new File(codeFile, LIB_DIR_NAME);\n            NativeLibraryHelper.Handle handle = null;\n            try {\n                handle = NativeLibraryHelper.Handle.create(codeFile);\n                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,\n                        abiOverride);\n            } catch (IOException e) {\n                Slog.e(TAG, \"Copying native libraries failed\", e);\n                ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;\n            } finally {\n                IoUtils.closeQuietly(handle);\n            }\n\n            return ret;\n        }\n\n```\n\n* 首先mInstallerService.allocateStageDirLegacy申请足够的存储空间\n* 得到申请的那部分空间的文件描述符，并且修改权限\n* IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，\n* NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)\n\n### 8.DefaultContainerService#copyPackage\n\n```\n        public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) {\n            if (packagePath == null || target == null) {\n                return PackageManager.INSTALL_FAILED_INVALID_URI;\n            }\n\n            PackageLite pkg = null;\n            try {\n                final File packageFile = new File(packagePath);\n                pkg = PackageParser.parsePackageLite(packageFile, 0);\n                return copyPackageInner(pkg, target);\n            } catch (PackageParserException | IOException | RemoteException e) {\n                Slog.w(TAG, \"Failed to copy package at \" + packagePath + \": \" + e);\n                return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;\n            }\n        }\n```\n\n* 解析apk文件\n* 将文件拷贝到指定目录\n\n### 9.NativeLibraryHelper#copyNativeBinariesWithOverride\n\n在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。\n\n到现在，copy的流程就完了。\n\n在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。\n\n### 10.InstallParams#handleReturnCode\n\n在这个方法中，会调用processPendingInstall去处理。\n\n```\n    private void processPendingInstall(final InstallArgs args, final int currentStatus) {\n        // Queue up an async operation since the package installation may take a little while.\n        mHandler.post(new Runnable() {\n            public void run() {\n                mHandler.removeCallbacks(this);\n                 // Result object to be returned\n                PackageInstalledInfo res = new PackageInstalledInfo();\n                res.returnCode = currentStatus;\n                res.uid = -1;\n                res.pkg = null;\n                res.removedInfo = new PackageRemovedInfo();\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {\n                    args.doPreInstall(res.returnCode);\n                    synchronized (mInstallLock) {\n                        installPackageLI(args, res);\n                    }\n                    args.doPostInstall(res.returnCode, res.uid);\n                }\n\n                // A restore should be performed at this point if (a) the install\n                // succeeded, (b) the operation is not an update, and (c) the new\n                // package has not opted out of backup participation.\n                final boolean update = res.removedInfo.removedPackage != null;\n                final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;\n                boolean doRestore = !update\n                        && ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);\n\n                // Set up the post-install work request bookkeeping.  This will be used\n                // and cleaned up by the post-install event handling regardless of whether\n                // there's a restore pass performed.  Token values are >= 1.\n                int token;\n                if (mNextInstallToken < 0) mNextInstallToken = 1;\n                token = mNextInstallToken++;\n\n                PostInstallData data = new PostInstallData(args, res);\n                mRunningInstalls.put(token, data);\n                if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token);\n\n                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {\n                    // Pass responsibility to the Backup Manager.  It will perform a\n                    // restore if appropriate, then pass responsibility back to the\n                    // Package Manager to run the post-install observer callbacks\n                    // and broadcasts.\n                    IBackupManager bm = IBackupManager.Stub.asInterface(\n                            ServiceManager.getService(Context.BACKUP_SERVICE));\n                    if (bm != null) {\n                        if (DEBUG_INSTALL) Log.v(TAG, \"token \" + token\n                                + \" to BM for possible restore\");\n                        try {\n                            if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) {\n                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);\n                            } else {\n                                doRestore = false;\n                            }\n                        } catch (RemoteException e) {\n                            // can't happen; the backup manager is local\n                        } catch (Exception e) {\n                            Slog.e(TAG, \"Exception trying to enqueue restore\", e);\n                            doRestore = false;\n                        }\n                    } else {\n                        Slog.e(TAG, \"Backup Manager not found!\");\n                        doRestore = false;\n                    }\n                }\n\n                if (!doRestore) {\n                    // No restore possible, or the Backup Manager was mysteriously not\n                    // available -- just fire the post-install work request directly.\n                    if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token);\n                    Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);\n                    mHandler.sendMessage(msg);\n                }\n            }\n        });\n    }\n```\n\n安装过程\n\n* installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。\n* 恢复部分代码 没看明白。😭\n* 发送POST_INSTALL消息\n\n### 11.installPackageLI\n\n改方法氛围几部分。\n\n首先是解析包过程。\n\n```\n        PackageParser pp = new PackageParser();\n        pp.setSeparateProcesses(mSeparateProcesses);\n        pp.setDisplayMetrics(mMetrics);\n\n        final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(tmpPackageFile, parseFlags);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed parse during installPackageLI\", e);\n            return;\n        }\n```\n\n其次是校验签名的md5的过程\n\n```\n        try {\n            pp.collectCertificates(pkg, parseFlags);\n            pp.collectManifestDigest(pkg);\n        } catch (PackageParserException e) {\n            res.setError(\"Failed collect during installPackageLI\", e);\n            return;\n        }\n\n        /* If the installer passed in a manifest digest, compare it now. */\n        if (args.manifestDigest != null) {\n            if (DEBUG_INSTALL) {\n                final String parsedManifest = pkg.manifestDigest == null ? \"null\"\n                        : pkg.manifestDigest.toString();\n                Slog.d(TAG, \"Comparing manifests: \" + args.manifestDigest.toString() + \" vs. \"\n                        + parsedManifest);\n            }\n\n            if (!args.manifestDigest.equals(pkg.manifestDigest)) {\n                res.setError(INSTALL_FAILED_PACKAGE_CHANGED, \"Manifest digest changed\");\n                return;\n            }\n        } else if (DEBUG_INSTALL) {\n            final String parsedManifest = pkg.manifestDigest == null\n                    ? \"null\" : pkg.manifestDigest.toString();\n            Slog.d(TAG, \"manifestDigest was not present, but parser got: \" + parsedManifest);\n        }\n```\n\n\n调用installNewPackageLI安装。\n\n### 12.installNewPackageLI\n\n在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。\n\n\n### 13.处理POST_INSTALL消息\n\n略。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n","slug":"Android应用程序是如何安装的","published":1,"updated":"2017-01-07T06:57:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy1l000bhws6elqdnk59","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<p>以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，</p>\n<h3 id=\"2-安装器\"><a href=\"#2-安装器\" class=\"headerlink\" title=\"2.安装器\"></a>2.安装器</h3><p>显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (v == mOk) &#123;</div><div class=\"line\">    if (mOkCanInstall || mScrollView == null) &#123;</div><div class=\"line\">        mInstallFlowAnalytics.setInstallButtonClicked();</div><div class=\"line\">        if (mSessionId != -1) &#123;</div><div class=\"line\">            mInstaller.setPermissionsResult(mSessionId, true);</div><div class=\"line\"></div><div class=\"line\">            // We&apos;re only confirming permissions, so we don&apos;t really know how the</div><div class=\"line\">            // story ends; assume success.</div><div class=\"line\">            mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(</div><div class=\"line\">                    PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">            finish();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            startInstall();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mScrollView.pageScroll(View.FOCUS_DOWN);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        pm.installExistingPackage(mAppInfo.packageName);</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_FAILED_INVALID_APK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,</div><div class=\"line\">            installerPackageName, verificationParams, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>mPackageURI，安装应用的话，应该是file</li>\n<li>pm 为ApplicationPackageManager</li>\n</ul>\n<p>因此，我们看installPackageWithVerificationAndEncryption方法。</p>\n<h3 id=\"3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\"><a href=\"#3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\" class=\"headerlink\" title=\"3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\"></a>3.ApplicationPackageManager#installPackageWithVerificationAndEncryption</h3><p>在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static IPackageManager getPackageManager() &#123;</div><div class=\"line\">    if (sPackageManager != null) &#123;</div><div class=\"line\">        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</div><div class=\"line\">        return sPackageManager;</div><div class=\"line\">    &#125;</div><div class=\"line\">    IBinder b = ServiceManager.getService(&quot;package&quot;);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</div><div class=\"line\">    sPackageManager = IPackageManager.Stub.asInterface(b);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</div><div class=\"line\">    return sPackageManager;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从中可以看出，其binder服务端为PackageManagerService.</p>\n<h3 id=\"4-PackageManagerService-installPackage\"><a href=\"#4-PackageManagerService-installPackage\" class=\"headerlink\" title=\"4.PackageManagerService#installPackage\"></a>4.PackageManagerService#installPackage</h3><p>在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Message msg = mHandler.obtainMessage(INIT_COPY);</div><div class=\"line\">msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,</div><div class=\"line\">        null, verificationParams, user, packageAbiOverride, null);</div><div class=\"line\">mHandler.sendMessage(msg);</div></pre></td></tr></table></figure>\n<p>这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">case INIT_COPY: &#123;</div><div class=\"line\">    HandlerParams params = (HandlerParams) msg.obj;</div><div class=\"line\">    int idx = mPendingInstalls.size();</div><div class=\"line\">    if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params);</div><div class=\"line\">    // If a bind was already initiated we dont really</div><div class=\"line\">    // need to do anything. The pending install</div><div class=\"line\">    // will be processed later on.</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // If this is the only one pending we might</div><div class=\"line\">        // have to bind to the service again.</div><div class=\"line\">        if (!connectToService()) &#123;</div><div class=\"line\">            Slog.e(TAG, &quot;Failed to bind to media container service&quot;);</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Once we bind to the service, the first</div><div class=\"line\">            // pending request will be processed.</div><div class=\"line\">            mPendingInstalls.add(idx, params);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mPendingInstalls.add(idx, params);</div><div class=\"line\">        // Already bound to the service. Just make</div><div class=\"line\">        // sure we trigger off processing the first request.</div><div class=\"line\">        if (idx == 0) &#123;</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。<br>在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;);</div><div class=\"line\">if (msg.obj != null) &#123;</div><div class=\"line\">    mContainerService = (IMediaContainerService) msg.obj;</div><div class=\"line\">&#125;</div><div class=\"line\">if (mContainerService == null) &#123;</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // Something seriously wrong since we are not bound and we are not</div><div class=\"line\">        // waiting for connection. Bail out.</div><div class=\"line\">        Slog.e(TAG, &quot;Cannot bind to media container service&quot;);</div><div class=\"line\">        for (HandlerParams params : mPendingInstalls) &#123;</div><div class=\"line\">            // Indicate service bind error</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mPendingInstalls.clear();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Waiting to connect to media container service&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">    HandlerParams params = mPendingInstalls.get(0);</div><div class=\"line\">    if (params != null) &#123;</div><div class=\"line\">        if (params.startCopy()) &#123;</div><div class=\"line\">            // We are done...  look for more work or to</div><div class=\"line\">            // go idle.</div><div class=\"line\">            if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                    &quot;Checking for more work or unbind...&quot;);</div><div class=\"line\">            // Delete pending install</div><div class=\"line\">            if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">                mPendingInstalls.remove(0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (mPendingInstalls.size() == 0) &#123;</div><div class=\"line\">                if (mBound) &#123;</div><div class=\"line\">                    if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                            &quot;Posting delayed MCS_UNBIND&quot;);</div><div class=\"line\">                    removeMessages(MCS_UNBIND);</div><div class=\"line\">                    Message ubmsg = obtainMessage(MCS_UNBIND);</div><div class=\"line\">                    // Unbind after a little delay, to avoid</div><div class=\"line\">                    // continual thrashing.</div><div class=\"line\">                    sendMessageDelayed(ubmsg, 10000);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are more pending requests in queue.</div><div class=\"line\">                // Just post MCS_BOUND message to trigger processing</div><div class=\"line\">                // of next pending install.</div><div class=\"line\">                if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                        &quot;Posting MCS_BOUND for next work&quot;);</div><div class=\"line\">                mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // Should never happen ideally.</div><div class=\"line\">    Slog.w(TAG, &quot;Empty queue&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div></pre></td></tr></table></figure>\n<p>从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。</p>\n<h3 id=\"5-HandlerParams-startCopy\"><a href=\"#5-HandlerParams-startCopy\" class=\"headerlink\" title=\"5.HandlerParams#startCopy\"></a>5.HandlerParams#startCopy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean startCopy() &#123;</div><div class=\"line\">    boolean res;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);</div><div class=\"line\"></div><div class=\"line\">        if (++mRetries &gt; MAX_RETRIES) &#123;</div><div class=\"line\">            Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_GIVE_UP);</div><div class=\"line\">            handleServiceError();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            handleStartCopy();</div><div class=\"line\">            res = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);</div><div class=\"line\">        mHandler.sendEmptyMessage(MCS_RECONNECT);</div><div class=\"line\">        res = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    handleReturnCode();</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有重试机制。而handleStartCopy的实现在InstallParams中。</p>\n<h3 id=\"6-InstallParams-handleStartCopy\"><a href=\"#6-InstallParams-handleStartCopy\" class=\"headerlink\" title=\"6.InstallParams#handleStartCopy\"></a>6.InstallParams#handleStartCopy</h3><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">final StorageManager storage = StorageManager.from(mContext);</div><div class=\"line\">final long lowThreshold = storage.getStorageLowBytes(</div><div class=\"line\">        Environment.getDataDirectory());</div><div class=\"line\"></div><div class=\"line\">final long sizeBytes = mContainerService.calculateInstalledSize(</div><div class=\"line\">        origin.resolvedPath, isForwardLocked(), packageAbiOverride);</div><div class=\"line\"></div><div class=\"line\">if (mInstaller.freeCache(null, sizeBytes + lowThreshold) &gt;= 0) &#123;</div><div class=\"line\">    pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,</div><div class=\"line\">            installFlags, packageAbiOverride);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。</p>\n<p>这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。</p>\n<p>中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                 /*</div><div class=\"line\">                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by</div><div class=\"line\">                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.</div><div class=\"line\">                 */</div><div class=\"line\">                int userIdentifier = getUser().getIdentifier();</div><div class=\"line\">                if (userIdentifier == UserHandle.USER_ALL</div><div class=\"line\">                        &amp;&amp; ((installFlags &amp; PackageManager.INSTALL_FROM_ADB) != 0)) &#123;</div><div class=\"line\">                    userIdentifier = UserHandle.USER_OWNER;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /*</div><div class=\"line\">                 * Determine if we have any installed package verifiers. If we</div><div class=\"line\">                 * do, then we&apos;ll defer to them to verify the packages.</div><div class=\"line\">                 */</div><div class=\"line\">                final int requiredUid = mRequiredVerifierPackage == null ? -1</div><div class=\"line\">                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);</div><div class=\"line\">                if (!origin.existing &amp;&amp; requiredUid != -1</div><div class=\"line\">                        &amp;&amp; isVerificationEnabled(userIdentifier, installFlags)) &#123;</div><div class=\"line\">                    final Intent verification = new Intent(</div><div class=\"line\">                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</div><div class=\"line\">                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),</div><div class=\"line\">                            PACKAGE_MIME_TYPE);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ResolveInfo&gt; receivers = queryIntentReceivers(verification,</div><div class=\"line\">                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,</div><div class=\"line\">                            0 /* TODO: Which userId? */);</div><div class=\"line\"></div><div class=\"line\">                    if (DEBUG_VERIFY) &#123;</div><div class=\"line\">                        Slog.d(TAG, &quot;Found &quot; + receivers.size() + &quot; verifiers for intent &quot;</div><div class=\"line\">                                + verification.toString() + &quot; with &quot; + pkgLite.verifiers.length</div><div class=\"line\">                                + &quot; optional verifiers&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final int verificationId = mPendingVerificationToken++;</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</div><div class=\"line\">                            installerPackageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,</div><div class=\"line\">                            installFlags);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,</div><div class=\"line\">                            pkgLite.packageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,</div><div class=\"line\">                            pkgLite.versionCode);</div><div class=\"line\"></div><div class=\"line\">                    if (verificationParams != null) &#123;</div><div class=\"line\">                        if (verificationParams.getVerificationURI() != null) &#123;</div><div class=\"line\">                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</div><div class=\"line\">                                 verificationParams.getVerificationURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingURI() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,</div><div class=\"line\">                                  verificationParams.getOriginatingURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getReferrer() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_REFERRER,</div><div class=\"line\">                                  verificationParams.getReferrer());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,</div><div class=\"line\">                                  verificationParams.getOriginatingUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getInstallerUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,</div><div class=\"line\">                                  verificationParams.getInstallerUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final PackageVerificationState verificationState = new PackageVerificationState(</div><div class=\"line\">                            requiredUid, args);</div><div class=\"line\"></div><div class=\"line\">                    mPendingVerification.append(verificationId, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite,</div><div class=\"line\">                            receivers, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    // Apps installed for &quot;all&quot; users use the device owner to verify the app</div><div class=\"line\">                    UserHandle verifierUser = getUser();</div><div class=\"line\">                    if (verifierUser == UserHandle.ALL) &#123;</div><div class=\"line\">                        verifierUser = UserHandle.OWNER;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    /*</div><div class=\"line\">                     * If any sufficient verifiers were listed in the package</div><div class=\"line\">                     * manifest, attempt to ask them.</div><div class=\"line\">                     */</div><div class=\"line\">                    if (sufficientVerifiers != null) &#123;</div><div class=\"line\">                        final int N = sufficientVerifiers.size();</div><div class=\"line\">                        if (N == 0) &#123;</div><div class=\"line\">                            Slog.i(TAG, &quot;Additional verifiers required, but none installed.&quot;);</div><div class=\"line\">                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            for (int i = 0; i &lt; N; i++) &#123;</div><div class=\"line\">                                final ComponentName verifierComponent = sufficientVerifiers.get(i);</div><div class=\"line\"></div><div class=\"line\">                                final Intent sufficientIntent = new Intent(verification);</div><div class=\"line\">                                sufficientIntent.setComponent(verifierComponent);</div><div class=\"line\">                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(</div><div class=\"line\">                            mRequiredVerifierPackage, receivers);</div><div class=\"line\">                    if (ret == PackageManager.INSTALL_SUCCEEDED</div><div class=\"line\">                            &amp;&amp; mRequiredVerifierPackage != null) &#123;</div><div class=\"line\">                        /*</div><div class=\"line\">                         * Send the intent to the required verification agent,</div><div class=\"line\">                         * but only start the verification timeout after the</div><div class=\"line\">                         * target BroadcastReceivers have run.</div><div class=\"line\">                         */</div><div class=\"line\">                        verification.setComponent(requiredVerifierComponent);</div><div class=\"line\">                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,</div><div class=\"line\">                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</div><div class=\"line\">                                new BroadcastReceiver() &#123;</div><div class=\"line\">                                    @Override</div><div class=\"line\">                                    public void onReceive(Context context, Intent intent) &#123;</div><div class=\"line\">                                        final Message msg = mHandler</div><div class=\"line\">                                                .obtainMessage(CHECK_PENDING_VERIFICATION);</div><div class=\"line\">                                        msg.arg1 = verificationId;</div><div class=\"line\">                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125;, null, 0, null, null);</div><div class=\"line\"></div><div class=\"line\">                        /*</div><div class=\"line\">                         * We don&apos;t want the copy to proceed until verification</div><div class=\"line\">                         * succeeds, so null out this field.</div><div class=\"line\">                         */</div><div class=\"line\">                        mArgs = null;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    /*</div><div class=\"line\">                     * No package verification is enabled, so immediately start</div><div class=\"line\">                     * the remote call to initiate copy using temporary file.</div><div class=\"line\">                     */</div><div class=\"line\">                    ret = args.copyApk(mContainerService, true);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果启动了包验证的话，就会进入验证阶段。 <ul>\n<li>发送有序广播， </li>\n</ul>\n</li>\n<li>否则，直接进行复制操作</li>\n</ul>\n<p>验证部分的逻辑很长，大部分代码都是对intent进行设置。</p>\n<h3 id=\"7-InstallArgs-copyApk\"><a href=\"#7-InstallArgs-copyApk\" class=\"headerlink\" title=\"7.InstallArgs#copyApk\"></a>7.InstallArgs#copyApk</h3><p>在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private InstallArgs createInstallArgs(InstallParams params) &#123;</div><div class=\"line\">    if (params.move != null) &#123;</div><div class=\"line\">        return new MoveInstallArgs(params);</div><div class=\"line\">    &#125; else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) &#123;</div><div class=\"line\">        return new AsecInstallArgs(params);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return new FileInstallArgs(params);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以FileInstallArgs为例，我们来看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException &#123;</div><div class=\"line\">     if (origin.staged) &#123;</div><div class=\"line\">         if (DEBUG_INSTALL) Slog.d(TAG, origin.file + &quot; already staged; skipping copy&quot;);</div><div class=\"line\">         codeFile = origin.file;</div><div class=\"line\">         resourceFile = origin.file;</div><div class=\"line\">         return PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);</div><div class=\"line\">         codeFile = tempDir;</div><div class=\"line\">         resourceFile = tempDir;</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.w(TAG, &quot;Failed to create copy file: &quot; + e);</div><div class=\"line\">         return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() &#123;</div><div class=\"line\">         @Override</div><div class=\"line\">         public ParcelFileDescriptor open(String name, int mode) throws RemoteException &#123;</div><div class=\"line\">             if (!FileUtils.isValidExtFilename(name)) &#123;</div><div class=\"line\">                 throw new IllegalArgumentException(&quot;Invalid filename: &quot; + name);</div><div class=\"line\">             &#125;</div><div class=\"line\">             try &#123;</div><div class=\"line\">                 final File file = new File(codeFile, name);</div><div class=\"line\">                 final FileDescriptor fd = Os.open(file.getAbsolutePath(),</div><div class=\"line\">                         O_RDWR | O_CREAT, 0644);</div><div class=\"line\">                 Os.chmod(file.getAbsolutePath(), 0644);</div><div class=\"line\">                 return new ParcelFileDescriptor(fd);</div><div class=\"line\">             &#125; catch (ErrnoException e) &#123;</div><div class=\"line\">                 throw new RemoteException(&quot;Failed to open: &quot; + e.getMessage());</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\"></div><div class=\"line\">     int ret = PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);</div><div class=\"line\">     if (ret != PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Failed to copy package&quot;);</div><div class=\"line\">         return ret;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final File libraryRoot = new File(codeFile, LIB_DIR_NAME);</div><div class=\"line\">     NativeLibraryHelper.Handle handle = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         handle = NativeLibraryHelper.Handle.create(codeFile);</div><div class=\"line\">         ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,</div><div class=\"line\">                 abiOverride);</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Copying native libraries failed&quot;, e);</div><div class=\"line\">         ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(handle);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     return ret;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先mInstallerService.allocateStageDirLegacy申请足够的存储空间</li>\n<li>得到申请的那部分空间的文件描述符，并且修改权限</li>\n<li>IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，</li>\n<li>NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)</li>\n</ul>\n<h3 id=\"8-DefaultContainerService-copyPackage\"><a href=\"#8-DefaultContainerService-copyPackage\" class=\"headerlink\" title=\"8.DefaultContainerService#copyPackage\"></a>8.DefaultContainerService#copyPackage</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) &#123;</div><div class=\"line\">    if (packagePath == null || target == null) &#123;</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INVALID_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    PackageLite pkg = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        final File packageFile = new File(packagePath);</div><div class=\"line\">        pkg = PackageParser.parsePackageLite(packageFile, 0);</div><div class=\"line\">        return copyPackageInner(pkg, target);</div><div class=\"line\">    &#125; catch (PackageParserException | IOException | RemoteException e) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Failed to copy package at &quot; + packagePath + &quot;: &quot; + e);</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>解析apk文件</li>\n<li>将文件拷贝到指定目录</li>\n</ul>\n<h3 id=\"9-NativeLibraryHelper-copyNativeBinariesWithOverride\"><a href=\"#9-NativeLibraryHelper-copyNativeBinariesWithOverride\" class=\"headerlink\" title=\"9.NativeLibraryHelper#copyNativeBinariesWithOverride\"></a>9.NativeLibraryHelper#copyNativeBinariesWithOverride</h3><p>在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。</p>\n<p>到现在，copy的流程就完了。</p>\n<p>在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。</p>\n<h3 id=\"10-InstallParams-handleReturnCode\"><a href=\"#10-InstallParams-handleReturnCode\" class=\"headerlink\" title=\"10.InstallParams#handleReturnCode\"></a>10.InstallParams#handleReturnCode</h3><p>在这个方法中，会调用processPendingInstall去处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123;</div><div class=\"line\">    // Queue up an async operation since the package installation may take a little while.</div><div class=\"line\">    mHandler.post(new Runnable() &#123;</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            mHandler.removeCallbacks(this);</div><div class=\"line\">             // Result object to be returned</div><div class=\"line\">            PackageInstalledInfo res = new PackageInstalledInfo();</div><div class=\"line\">            res.returnCode = currentStatus;</div><div class=\"line\">            res.uid = -1;</div><div class=\"line\">            res.pkg = null;</div><div class=\"line\">            res.removedInfo = new PackageRemovedInfo();</div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                args.doPreInstall(res.returnCode);</div><div class=\"line\">                synchronized (mInstallLock) &#123;</div><div class=\"line\">                    installPackageLI(args, res);</div><div class=\"line\">                &#125;</div><div class=\"line\">                args.doPostInstall(res.returnCode, res.uid);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // A restore should be performed at this point if (a) the install</div><div class=\"line\">            // succeeded, (b) the operation is not an update, and (c) the new</div><div class=\"line\">            // package has not opted out of backup participation.</div><div class=\"line\">            final boolean update = res.removedInfo.removedPackage != null;</div><div class=\"line\">            final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;</div><div class=\"line\">            boolean doRestore = !update</div><div class=\"line\">                    &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);</div><div class=\"line\"></div><div class=\"line\">            // Set up the post-install work request bookkeeping.  This will be used</div><div class=\"line\">            // and cleaned up by the post-install event handling regardless of whether</div><div class=\"line\">            // there&apos;s a restore pass performed.  Token values are &gt;= 1.</div><div class=\"line\">            int token;</div><div class=\"line\">            if (mNextInstallToken &lt; 0) mNextInstallToken = 1;</div><div class=\"line\">            token = mNextInstallToken++;</div><div class=\"line\"></div><div class=\"line\">            PostInstallData data = new PostInstallData(args, res);</div><div class=\"line\">            mRunningInstalls.put(token, data);</div><div class=\"line\">            if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token);</div><div class=\"line\"></div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123;</div><div class=\"line\">                // Pass responsibility to the Backup Manager.  It will perform a</div><div class=\"line\">                // restore if appropriate, then pass responsibility back to the</div><div class=\"line\">                // Package Manager to run the post-install observer callbacks</div><div class=\"line\">                // and broadcasts.</div><div class=\"line\">                IBackupManager bm = IBackupManager.Stub.asInterface(</div><div class=\"line\">                        ServiceManager.getService(Context.BACKUP_SERVICE));</div><div class=\"line\">                if (bm != null) &#123;</div><div class=\"line\">                    if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token</div><div class=\"line\">                            + &quot; to BM for possible restore&quot;);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) &#123;</div><div class=\"line\">                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            doRestore = false;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">                        // can&apos;t happen; the backup manager is local</div><div class=\"line\">                    &#125; catch (Exception e) &#123;</div><div class=\"line\">                        Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e);</div><div class=\"line\">                        doRestore = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    Slog.e(TAG, &quot;Backup Manager not found!&quot;);</div><div class=\"line\">                    doRestore = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!doRestore) &#123;</div><div class=\"line\">                // No restore possible, or the Backup Manager was mysteriously not</div><div class=\"line\">                // available -- just fire the post-install work request directly.</div><div class=\"line\">                if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);</div><div class=\"line\">                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</div><div class=\"line\">                mHandler.sendMessage(msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装过程</p>\n<ul>\n<li>installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。</li>\n<li>恢复部分代码 没看明白。😭</li>\n<li>发送POST_INSTALL消息</li>\n</ul>\n<h3 id=\"11-installPackageLI\"><a href=\"#11-installPackageLI\" class=\"headerlink\" title=\"11.installPackageLI\"></a>11.installPackageLI</h3><p>改方法氛围几部分。</p>\n<p>首先是解析包过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">PackageParser pp = new PackageParser();</div><div class=\"line\">pp.setSeparateProcesses(mSeparateProcesses);</div><div class=\"line\">pp.setDisplayMetrics(mMetrics);</div><div class=\"line\"></div><div class=\"line\">final PackageParser.Package pkg;</div><div class=\"line\">try &#123;</div><div class=\"line\">    pkg = pp.parsePackage(tmpPackageFile, parseFlags);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed parse during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其次是校验签名的md5的过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    pp.collectCertificates(pkg, parseFlags);</div><div class=\"line\">    pp.collectManifestDigest(pkg);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed collect during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* If the installer passed in a manifest digest, compare it now. */</div><div class=\"line\">if (args.manifestDigest != null) &#123;</div><div class=\"line\">    if (DEBUG_INSTALL) &#123;</div><div class=\"line\">        final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot;</div><div class=\"line\">                : pkg.manifestDigest.toString();</div><div class=\"line\">        Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot;</div><div class=\"line\">                + parsedManifest);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!args.manifestDigest.equals(pkg.manifestDigest)) &#123;</div><div class=\"line\">        res.setError(INSTALL_FAILED_PACKAGE_CHANGED, &quot;Manifest digest changed&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (DEBUG_INSTALL) &#123;</div><div class=\"line\">    final String parsedManifest = pkg.manifestDigest == null</div><div class=\"line\">            ? &quot;null&quot; : pkg.manifestDigest.toString();</div><div class=\"line\">    Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用installNewPackageLI安装。</p>\n<h3 id=\"12-installNewPackageLI\"><a href=\"#12-installNewPackageLI\" class=\"headerlink\" title=\"12.installNewPackageLI\"></a>12.installNewPackageLI</h3><p>在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。</p>\n<h3 id=\"13-处理POST-INSTALL消息\"><a href=\"#13-处理POST-INSTALL消息\" class=\"headerlink\" title=\"13.处理POST_INSTALL消息\"></a>13.处理POST_INSTALL消息</h3><p>略。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>当我们安装应用程序的时候，会弹出安装界面，那么，在我们点击安装之后，发生了什么呢？今天就来了解下，应用程序是如何安装的。首先，我们今天介绍的是通过安装器安装应用，当然，在pms的构造函数中，也会将我们原先安装好的应用装载到内存中。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<p>以6.0源码为例。安装器在源码目录packages/apps/PackageInstaller中，</p>\n<h3 id=\"2-安装器\"><a href=\"#2-安装器\" class=\"headerlink\" title=\"2.安装器\"></a>2.安装器</h3><p>显示安装 取消按钮的那个界面对应着PackageInstallerActivity，而安装按钮对应的是mOk，对应部分代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (v == mOk) &#123;</div><div class=\"line\">    if (mOkCanInstall || mScrollView == null) &#123;</div><div class=\"line\">        mInstallFlowAnalytics.setInstallButtonClicked();</div><div class=\"line\">        if (mSessionId != -1) &#123;</div><div class=\"line\">            mInstaller.setPermissionsResult(mSessionId, true);</div><div class=\"line\"></div><div class=\"line\">            // We&apos;re only confirming permissions, so we don&apos;t really know how the</div><div class=\"line\">            // story ends; assume success.</div><div class=\"line\">            mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(</div><div class=\"line\">                    PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">            finish();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            startInstall();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mScrollView.pageScroll(View.FOCUS_DOWN);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然，我不知懂这里的mSessionId是什么含义，但是 根据代码能看出，安装一个应用应该是startInstall方法。在这个方法中，最终会去玩InstallAppProgress这个界面，对应我们安装中进度条显示的界面。有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        pm.installExistingPackage(mAppInfo.packageName);</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_SUCCEEDED);</div><div class=\"line\">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class=\"line\">        observer.packageInstalled(mAppInfo.packageName,</div><div class=\"line\">                PackageManager.INSTALL_FAILED_INVALID_APK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,</div><div class=\"line\">            installerPackageName, verificationParams, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>mPackageURI，安装应用的话，应该是file</li>\n<li>pm 为ApplicationPackageManager</li>\n</ul>\n<p>因此，我们看installPackageWithVerificationAndEncryption方法。</p>\n<h3 id=\"3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\"><a href=\"#3-ApplicationPackageManager-installPackageWithVerificationAndEncryption\" class=\"headerlink\" title=\"3.ApplicationPackageManager#installPackageWithVerificationAndEncryption\"></a>3.ApplicationPackageManager#installPackageWithVerificationAndEncryption</h3><p>在这个方法中，会调用installCommon方法，而installCommon方法中，会进行简单的参数校验，然后调用mPM的installPackage方法去安装。这个mPM参数实在构造的时候传入的。是通过ActivityThread.getPackageManager()获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static IPackageManager getPackageManager() &#123;</div><div class=\"line\">    if (sPackageManager != null) &#123;</div><div class=\"line\">        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</div><div class=\"line\">        return sPackageManager;</div><div class=\"line\">    &#125;</div><div class=\"line\">    IBinder b = ServiceManager.getService(&quot;package&quot;);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</div><div class=\"line\">    sPackageManager = IPackageManager.Stub.asInterface(b);</div><div class=\"line\">    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</div><div class=\"line\">    return sPackageManager;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从中可以看出，其binder服务端为PackageManagerService.</p>\n<h3 id=\"4-PackageManagerService-installPackage\"><a href=\"#4-PackageManagerService-installPackage\" class=\"headerlink\" title=\"4.PackageManagerService#installPackage\"></a>4.PackageManagerService#installPackage</h3><p>在这个方法中，回调用installPackageAsUser方法。在这个方法中，会发送一个消息，执行安装过程的第一个阶段，copy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Message msg = mHandler.obtainMessage(INIT_COPY);</div><div class=\"line\">msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,</div><div class=\"line\">        null, verificationParams, user, packageAbiOverride, null);</div><div class=\"line\">mHandler.sendMessage(msg);</div></pre></td></tr></table></figure>\n<p>这里的mHandler为PackageHandler实例对象，其消息处理部分代码在doHandleMessage中，我们看INIT_COPY，做了什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">case INIT_COPY: &#123;</div><div class=\"line\">    HandlerParams params = (HandlerParams) msg.obj;</div><div class=\"line\">    int idx = mPendingInstalls.size();</div><div class=\"line\">    if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params);</div><div class=\"line\">    // If a bind was already initiated we dont really</div><div class=\"line\">    // need to do anything. The pending install</div><div class=\"line\">    // will be processed later on.</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // If this is the only one pending we might</div><div class=\"line\">        // have to bind to the service again.</div><div class=\"line\">        if (!connectToService()) &#123;</div><div class=\"line\">            Slog.e(TAG, &quot;Failed to bind to media container service&quot;);</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Once we bind to the service, the first</div><div class=\"line\">            // pending request will be processed.</div><div class=\"line\">            mPendingInstalls.add(idx, params);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mPendingInstalls.add(idx, params);</div><div class=\"line\">        // Already bound to the service. Just make</div><div class=\"line\">        // sure we trigger off processing the first request.</div><div class=\"line\">        if (idx == 0) &#123;</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有绑定，就绑定，如果绑定了，将HandlerParams加入到mPendingInstalls中，并且如果以前为空，则发送MCS_BOUND这个空消息。<br>在接受到MCS_BOUND这个消息之后，会循环处理并且再次发送MCS_BOUND消息，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;);</div><div class=\"line\">if (msg.obj != null) &#123;</div><div class=\"line\">    mContainerService = (IMediaContainerService) msg.obj;</div><div class=\"line\">&#125;</div><div class=\"line\">if (mContainerService == null) &#123;</div><div class=\"line\">    if (!mBound) &#123;</div><div class=\"line\">        // Something seriously wrong since we are not bound and we are not</div><div class=\"line\">        // waiting for connection. Bail out.</div><div class=\"line\">        Slog.e(TAG, &quot;Cannot bind to media container service&quot;);</div><div class=\"line\">        for (HandlerParams params : mPendingInstalls) &#123;</div><div class=\"line\">            // Indicate service bind error</div><div class=\"line\">            params.serviceError();</div><div class=\"line\">        &#125;</div><div class=\"line\">        mPendingInstalls.clear();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Waiting to connect to media container service&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">    HandlerParams params = mPendingInstalls.get(0);</div><div class=\"line\">    if (params != null) &#123;</div><div class=\"line\">        if (params.startCopy()) &#123;</div><div class=\"line\">            // We are done...  look for more work or to</div><div class=\"line\">            // go idle.</div><div class=\"line\">            if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                    &quot;Checking for more work or unbind...&quot;);</div><div class=\"line\">            // Delete pending install</div><div class=\"line\">            if (mPendingInstalls.size() &gt; 0) &#123;</div><div class=\"line\">                mPendingInstalls.remove(0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (mPendingInstalls.size() == 0) &#123;</div><div class=\"line\">                if (mBound) &#123;</div><div class=\"line\">                    if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                            &quot;Posting delayed MCS_UNBIND&quot;);</div><div class=\"line\">                    removeMessages(MCS_UNBIND);</div><div class=\"line\">                    Message ubmsg = obtainMessage(MCS_UNBIND);</div><div class=\"line\">                    // Unbind after a little delay, to avoid</div><div class=\"line\">                    // continual thrashing.</div><div class=\"line\">                    sendMessageDelayed(ubmsg, 10000);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are more pending requests in queue.</div><div class=\"line\">                // Just post MCS_BOUND message to trigger processing</div><div class=\"line\">                // of next pending install.</div><div class=\"line\">                if (DEBUG_SD_INSTALL) Log.i(TAG,</div><div class=\"line\">                        &quot;Posting MCS_BOUND for next work&quot;);</div><div class=\"line\">                mHandler.sendEmptyMessage(MCS_BOUND);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // Should never happen ideally.</div><div class=\"line\">    Slog.w(TAG, &quot;Empty queue&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div></pre></td></tr></table></figure>\n<p>从上诉代码中，我们就能知道，通过params.startCopy()去执行copy操作，并且如果还有未安装的，会重复发这个消息，知道所有都安装成功。</p>\n<h3 id=\"5-HandlerParams-startCopy\"><a href=\"#5-HandlerParams-startCopy\" class=\"headerlink\" title=\"5.HandlerParams#startCopy\"></a>5.HandlerParams#startCopy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean startCopy() &#123;</div><div class=\"line\">    boolean res;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);</div><div class=\"line\"></div><div class=\"line\">        if (++mRetries &gt; MAX_RETRIES) &#123;</div><div class=\"line\">            Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);</div><div class=\"line\">            mHandler.sendEmptyMessage(MCS_GIVE_UP);</div><div class=\"line\">            handleServiceError();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            handleStartCopy();</div><div class=\"line\">            res = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);</div><div class=\"line\">        mHandler.sendEmptyMessage(MCS_RECONNECT);</div><div class=\"line\">        res = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    handleReturnCode();</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有重试机制。而handleStartCopy的实现在InstallParams中。</p>\n<h3 id=\"6-InstallParams-handleStartCopy\"><a href=\"#6-InstallParams-handleStartCopy\" class=\"headerlink\" title=\"6.InstallParams#handleStartCopy\"></a>6.InstallParams#handleStartCopy</h3><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">final StorageManager storage = StorageManager.from(mContext);</div><div class=\"line\">final long lowThreshold = storage.getStorageLowBytes(</div><div class=\"line\">        Environment.getDataDirectory());</div><div class=\"line\"></div><div class=\"line\">final long sizeBytes = mContainerService.calculateInstalledSize(</div><div class=\"line\">        origin.resolvedPath, isForwardLocked(), packageAbiOverride);</div><div class=\"line\"></div><div class=\"line\">if (mInstaller.freeCache(null, sizeBytes + lowThreshold) &gt;= 0) &#123;</div><div class=\"line\">    pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,</div><div class=\"line\">            installFlags, packageAbiOverride);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，如果需要的空间不够大，就调用Install的freeCache去释放一部分缓存。</p>\n<p>这里的mContainerService对应的binder服务端实现，在DefaultContainerService中。</p>\n<p>中间经过复杂的判断处理之后，创建一个InstallArgs对象，如果前面的判断结果是能安装成功的话，进入分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                 /*</div><div class=\"line\">                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by</div><div class=\"line\">                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.</div><div class=\"line\">                 */</div><div class=\"line\">                int userIdentifier = getUser().getIdentifier();</div><div class=\"line\">                if (userIdentifier == UserHandle.USER_ALL</div><div class=\"line\">                        &amp;&amp; ((installFlags &amp; PackageManager.INSTALL_FROM_ADB) != 0)) &#123;</div><div class=\"line\">                    userIdentifier = UserHandle.USER_OWNER;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /*</div><div class=\"line\">                 * Determine if we have any installed package verifiers. If we</div><div class=\"line\">                 * do, then we&apos;ll defer to them to verify the packages.</div><div class=\"line\">                 */</div><div class=\"line\">                final int requiredUid = mRequiredVerifierPackage == null ? -1</div><div class=\"line\">                        : getPackageUid(mRequiredVerifierPackage, userIdentifier);</div><div class=\"line\">                if (!origin.existing &amp;&amp; requiredUid != -1</div><div class=\"line\">                        &amp;&amp; isVerificationEnabled(userIdentifier, installFlags)) &#123;</div><div class=\"line\">                    final Intent verification = new Intent(</div><div class=\"line\">                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</div><div class=\"line\">                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),</div><div class=\"line\">                            PACKAGE_MIME_TYPE);</div><div class=\"line\">                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ResolveInfo&gt; receivers = queryIntentReceivers(verification,</div><div class=\"line\">                            PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS,</div><div class=\"line\">                            0 /* TODO: Which userId? */);</div><div class=\"line\"></div><div class=\"line\">                    if (DEBUG_VERIFY) &#123;</div><div class=\"line\">                        Slog.d(TAG, &quot;Found &quot; + receivers.size() + &quot; verifiers for intent &quot;</div><div class=\"line\">                                + verification.toString() + &quot; with &quot; + pkgLite.verifiers.length</div><div class=\"line\">                                + &quot; optional verifiers&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final int verificationId = mPendingVerificationToken++;</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</div><div class=\"line\">                            installerPackageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,</div><div class=\"line\">                            installFlags);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,</div><div class=\"line\">                            pkgLite.packageName);</div><div class=\"line\"></div><div class=\"line\">                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,</div><div class=\"line\">                            pkgLite.versionCode);</div><div class=\"line\"></div><div class=\"line\">                    if (verificationParams != null) &#123;</div><div class=\"line\">                        if (verificationParams.getVerificationURI() != null) &#123;</div><div class=\"line\">                           verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</div><div class=\"line\">                                 verificationParams.getVerificationURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingURI() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,</div><div class=\"line\">                                  verificationParams.getOriginatingURI());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getReferrer() != null) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_REFERRER,</div><div class=\"line\">                                  verificationParams.getReferrer());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getOriginatingUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,</div><div class=\"line\">                                  verificationParams.getOriginatingUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (verificationParams.getInstallerUid() &gt;= 0) &#123;</div><div class=\"line\">                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,</div><div class=\"line\">                                  verificationParams.getInstallerUid());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final PackageVerificationState verificationState = new PackageVerificationState(</div><div class=\"line\">                            requiredUid, args);</div><div class=\"line\"></div><div class=\"line\">                    mPendingVerification.append(verificationId, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite,</div><div class=\"line\">                            receivers, verificationState);</div><div class=\"line\"></div><div class=\"line\">                    // Apps installed for &quot;all&quot; users use the device owner to verify the app</div><div class=\"line\">                    UserHandle verifierUser = getUser();</div><div class=\"line\">                    if (verifierUser == UserHandle.ALL) &#123;</div><div class=\"line\">                        verifierUser = UserHandle.OWNER;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    /*</div><div class=\"line\">                     * If any sufficient verifiers were listed in the package</div><div class=\"line\">                     * manifest, attempt to ask them.</div><div class=\"line\">                     */</div><div class=\"line\">                    if (sufficientVerifiers != null) &#123;</div><div class=\"line\">                        final int N = sufficientVerifiers.size();</div><div class=\"line\">                        if (N == 0) &#123;</div><div class=\"line\">                            Slog.i(TAG, &quot;Additional verifiers required, but none installed.&quot;);</div><div class=\"line\">                            ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            for (int i = 0; i &lt; N; i++) &#123;</div><div class=\"line\">                                final ComponentName verifierComponent = sufficientVerifiers.get(i);</div><div class=\"line\"></div><div class=\"line\">                                final Intent sufficientIntent = new Intent(verification);</div><div class=\"line\">                                sufficientIntent.setComponent(verifierComponent);</div><div class=\"line\">                                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    final ComponentName requiredVerifierComponent = matchComponentForVerifier(</div><div class=\"line\">                            mRequiredVerifierPackage, receivers);</div><div class=\"line\">                    if (ret == PackageManager.INSTALL_SUCCEEDED</div><div class=\"line\">                            &amp;&amp; mRequiredVerifierPackage != null) &#123;</div><div class=\"line\">                        /*</div><div class=\"line\">                         * Send the intent to the required verification agent,</div><div class=\"line\">                         * but only start the verification timeout after the</div><div class=\"line\">                         * target BroadcastReceivers have run.</div><div class=\"line\">                         */</div><div class=\"line\">                        verification.setComponent(requiredVerifierComponent);</div><div class=\"line\">                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,</div><div class=\"line\">                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</div><div class=\"line\">                                new BroadcastReceiver() &#123;</div><div class=\"line\">                                    @Override</div><div class=\"line\">                                    public void onReceive(Context context, Intent intent) &#123;</div><div class=\"line\">                                        final Message msg = mHandler</div><div class=\"line\">                                                .obtainMessage(CHECK_PENDING_VERIFICATION);</div><div class=\"line\">                                        msg.arg1 = verificationId;</div><div class=\"line\">                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125;, null, 0, null, null);</div><div class=\"line\"></div><div class=\"line\">                        /*</div><div class=\"line\">                         * We don&apos;t want the copy to proceed until verification</div><div class=\"line\">                         * succeeds, so null out this field.</div><div class=\"line\">                         */</div><div class=\"line\">                        mArgs = null;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    /*</div><div class=\"line\">                     * No package verification is enabled, so immediately start</div><div class=\"line\">                     * the remote call to initiate copy using temporary file.</div><div class=\"line\">                     */</div><div class=\"line\">                    ret = args.copyApk(mContainerService, true);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果启动了包验证的话，就会进入验证阶段。 <ul>\n<li>发送有序广播， </li>\n</ul>\n</li>\n<li>否则，直接进行复制操作</li>\n</ul>\n<p>验证部分的逻辑很长，大部分代码都是对intent进行设置。</p>\n<h3 id=\"7-InstallArgs-copyApk\"><a href=\"#7-InstallArgs-copyApk\" class=\"headerlink\" title=\"7.InstallArgs#copyApk\"></a>7.InstallArgs#copyApk</h3><p>在createInstallArgs中，会根据InstallParams创建不同的InstallArgs对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private InstallArgs createInstallArgs(InstallParams params) &#123;</div><div class=\"line\">    if (params.move != null) &#123;</div><div class=\"line\">        return new MoveInstallArgs(params);</div><div class=\"line\">    &#125; else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) &#123;</div><div class=\"line\">        return new AsecInstallArgs(params);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return new FileInstallArgs(params);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以FileInstallArgs为例，我们来看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException &#123;</div><div class=\"line\">     if (origin.staged) &#123;</div><div class=\"line\">         if (DEBUG_INSTALL) Slog.d(TAG, origin.file + &quot; already staged; skipping copy&quot;);</div><div class=\"line\">         codeFile = origin.file;</div><div class=\"line\">         resourceFile = origin.file;</div><div class=\"line\">         return PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);</div><div class=\"line\">         codeFile = tempDir;</div><div class=\"line\">         resourceFile = tempDir;</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.w(TAG, &quot;Failed to create copy file: &quot; + e);</div><div class=\"line\">         return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() &#123;</div><div class=\"line\">         @Override</div><div class=\"line\">         public ParcelFileDescriptor open(String name, int mode) throws RemoteException &#123;</div><div class=\"line\">             if (!FileUtils.isValidExtFilename(name)) &#123;</div><div class=\"line\">                 throw new IllegalArgumentException(&quot;Invalid filename: &quot; + name);</div><div class=\"line\">             &#125;</div><div class=\"line\">             try &#123;</div><div class=\"line\">                 final File file = new File(codeFile, name);</div><div class=\"line\">                 final FileDescriptor fd = Os.open(file.getAbsolutePath(),</div><div class=\"line\">                         O_RDWR | O_CREAT, 0644);</div><div class=\"line\">                 Os.chmod(file.getAbsolutePath(), 0644);</div><div class=\"line\">                 return new ParcelFileDescriptor(fd);</div><div class=\"line\">             &#125; catch (ErrnoException e) &#123;</div><div class=\"line\">                 throw new RemoteException(&quot;Failed to open: &quot; + e.getMessage());</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\"></div><div class=\"line\">     int ret = PackageManager.INSTALL_SUCCEEDED;</div><div class=\"line\">     ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);</div><div class=\"line\">     if (ret != PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Failed to copy package&quot;);</div><div class=\"line\">         return ret;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     final File libraryRoot = new File(codeFile, LIB_DIR_NAME);</div><div class=\"line\">     NativeLibraryHelper.Handle handle = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         handle = NativeLibraryHelper.Handle.create(codeFile);</div><div class=\"line\">         ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,</div><div class=\"line\">                 abiOverride);</div><div class=\"line\">     &#125; catch (IOException e) &#123;</div><div class=\"line\">         Slog.e(TAG, &quot;Copying native libraries failed&quot;, e);</div><div class=\"line\">         ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(handle);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     return ret;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先mInstallerService.allocateStageDirLegacy申请足够的存储空间</li>\n<li>得到申请的那部分空间的文件描述符，并且修改权限</li>\n<li>IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中，</li>\n<li>NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)</li>\n</ul>\n<h3 id=\"8-DefaultContainerService-copyPackage\"><a href=\"#8-DefaultContainerService-copyPackage\" class=\"headerlink\" title=\"8.DefaultContainerService#copyPackage\"></a>8.DefaultContainerService#copyPackage</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int copyPackage(String packagePath, IParcelFileDescriptorFactory target) &#123;</div><div class=\"line\">    if (packagePath == null || target == null) &#123;</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INVALID_URI;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    PackageLite pkg = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        final File packageFile = new File(packagePath);</div><div class=\"line\">        pkg = PackageParser.parsePackageLite(packageFile, 0);</div><div class=\"line\">        return copyPackageInner(pkg, target);</div><div class=\"line\">    &#125; catch (PackageParserException | IOException | RemoteException e) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Failed to copy package at &quot; + packagePath + &quot;: &quot; + e);</div><div class=\"line\">        return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>解析apk文件</li>\n<li>将文件拷贝到指定目录</li>\n</ul>\n<h3 id=\"9-NativeLibraryHelper-copyNativeBinariesWithOverride\"><a href=\"#9-NativeLibraryHelper-copyNativeBinariesWithOverride\" class=\"headerlink\" title=\"9.NativeLibraryHelper#copyNativeBinariesWithOverride\"></a>9.NativeLibraryHelper#copyNativeBinariesWithOverride</h3><p>在这个方法中，将不同的so库通过copyNativeBinariesForSupportedAbi方法copy到不同的目录。copy的具体流程就不说了。</p>\n<p>到现在，copy的流程就完了。</p>\n<p>在上面startCopy中，下面有handleReturnCode，是对copy后进行后续处理的，我们依然看，InstallParams的这个方法。</p>\n<h3 id=\"10-InstallParams-handleReturnCode\"><a href=\"#10-InstallParams-handleReturnCode\" class=\"headerlink\" title=\"10.InstallParams#handleReturnCode\"></a>10.InstallParams#handleReturnCode</h3><p>在这个方法中，会调用processPendingInstall去处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123;</div><div class=\"line\">    // Queue up an async operation since the package installation may take a little while.</div><div class=\"line\">    mHandler.post(new Runnable() &#123;</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            mHandler.removeCallbacks(this);</div><div class=\"line\">             // Result object to be returned</div><div class=\"line\">            PackageInstalledInfo res = new PackageInstalledInfo();</div><div class=\"line\">            res.returnCode = currentStatus;</div><div class=\"line\">            res.uid = -1;</div><div class=\"line\">            res.pkg = null;</div><div class=\"line\">            res.removedInfo = new PackageRemovedInfo();</div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</div><div class=\"line\">                args.doPreInstall(res.returnCode);</div><div class=\"line\">                synchronized (mInstallLock) &#123;</div><div class=\"line\">                    installPackageLI(args, res);</div><div class=\"line\">                &#125;</div><div class=\"line\">                args.doPostInstall(res.returnCode, res.uid);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // A restore should be performed at this point if (a) the install</div><div class=\"line\">            // succeeded, (b) the operation is not an update, and (c) the new</div><div class=\"line\">            // package has not opted out of backup participation.</div><div class=\"line\">            final boolean update = res.removedInfo.removedPackage != null;</div><div class=\"line\">            final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;</div><div class=\"line\">            boolean doRestore = !update</div><div class=\"line\">                    &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);</div><div class=\"line\"></div><div class=\"line\">            // Set up the post-install work request bookkeeping.  This will be used</div><div class=\"line\">            // and cleaned up by the post-install event handling regardless of whether</div><div class=\"line\">            // there&apos;s a restore pass performed.  Token values are &gt;= 1.</div><div class=\"line\">            int token;</div><div class=\"line\">            if (mNextInstallToken &lt; 0) mNextInstallToken = 1;</div><div class=\"line\">            token = mNextInstallToken++;</div><div class=\"line\"></div><div class=\"line\">            PostInstallData data = new PostInstallData(args, res);</div><div class=\"line\">            mRunningInstalls.put(token, data);</div><div class=\"line\">            if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token);</div><div class=\"line\"></div><div class=\"line\">            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123;</div><div class=\"line\">                // Pass responsibility to the Backup Manager.  It will perform a</div><div class=\"line\">                // restore if appropriate, then pass responsibility back to the</div><div class=\"line\">                // Package Manager to run the post-install observer callbacks</div><div class=\"line\">                // and broadcasts.</div><div class=\"line\">                IBackupManager bm = IBackupManager.Stub.asInterface(</div><div class=\"line\">                        ServiceManager.getService(Context.BACKUP_SERVICE));</div><div class=\"line\">                if (bm != null) &#123;</div><div class=\"line\">                    if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token</div><div class=\"line\">                            + &quot; to BM for possible restore&quot;);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) &#123;</div><div class=\"line\">                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            doRestore = false;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">                        // can&apos;t happen; the backup manager is local</div><div class=\"line\">                    &#125; catch (Exception e) &#123;</div><div class=\"line\">                        Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e);</div><div class=\"line\">                        doRestore = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    Slog.e(TAG, &quot;Backup Manager not found!&quot;);</div><div class=\"line\">                    doRestore = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!doRestore) &#123;</div><div class=\"line\">                // No restore possible, or the Backup Manager was mysteriously not</div><div class=\"line\">                // available -- just fire the post-install work request directly.</div><div class=\"line\">                if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);</div><div class=\"line\">                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</div><div class=\"line\">                mHandler.sendMessage(msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装过程</p>\n<ul>\n<li>installPackageLI，在这个之前，会用doPreInstall进行cleanup操作，在这之后会用doPostInstall进行clean操作。</li>\n<li>恢复部分代码 没看明白。😭</li>\n<li>发送POST_INSTALL消息</li>\n</ul>\n<h3 id=\"11-installPackageLI\"><a href=\"#11-installPackageLI\" class=\"headerlink\" title=\"11.installPackageLI\"></a>11.installPackageLI</h3><p>改方法氛围几部分。</p>\n<p>首先是解析包过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">PackageParser pp = new PackageParser();</div><div class=\"line\">pp.setSeparateProcesses(mSeparateProcesses);</div><div class=\"line\">pp.setDisplayMetrics(mMetrics);</div><div class=\"line\"></div><div class=\"line\">final PackageParser.Package pkg;</div><div class=\"line\">try &#123;</div><div class=\"line\">    pkg = pp.parsePackage(tmpPackageFile, parseFlags);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed parse during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其次是校验签名的md5的过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    pp.collectCertificates(pkg, parseFlags);</div><div class=\"line\">    pp.collectManifestDigest(pkg);</div><div class=\"line\">&#125; catch (PackageParserException e) &#123;</div><div class=\"line\">    res.setError(&quot;Failed collect during installPackageLI&quot;, e);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* If the installer passed in a manifest digest, compare it now. */</div><div class=\"line\">if (args.manifestDigest != null) &#123;</div><div class=\"line\">    if (DEBUG_INSTALL) &#123;</div><div class=\"line\">        final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot;</div><div class=\"line\">                : pkg.manifestDigest.toString();</div><div class=\"line\">        Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot;</div><div class=\"line\">                + parsedManifest);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!args.manifestDigest.equals(pkg.manifestDigest)) &#123;</div><div class=\"line\">        res.setError(INSTALL_FAILED_PACKAGE_CHANGED, &quot;Manifest digest changed&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (DEBUG_INSTALL) &#123;</div><div class=\"line\">    final String parsedManifest = pkg.manifestDigest == null</div><div class=\"line\">            ? &quot;null&quot; : pkg.manifestDigest.toString();</div><div class=\"line\">    Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用installNewPackageLI安装。</p>\n<h3 id=\"12-installNewPackageLI\"><a href=\"#12-installNewPackageLI\" class=\"headerlink\" title=\"12.installNewPackageLI\"></a>12.installNewPackageLI</h3><p>在这个方法中，调用scanPackageDirtyLI进行扫描，而在scanPackageDirtyLI中，经过复杂的操作之后就算完成了安装，诸如，创建用户数据目录，进行dex优化等等。</p>\n<h3 id=\"13-处理POST-INSTALL消息\"><a href=\"#13-处理POST-INSTALL消息\" class=\"headerlink\" title=\"13.处理POST_INSTALL消息\"></a>13.处理POST_INSTALL消息</h3><p>略。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"layout":"android","title":"JNI学习笔记（二）－动态注册native函数","date":"2016-11-29T08:33:30.000Z","_content":"<Excerpt in index | 首页摘要> \n\n### 1.前言\n\n在很久之前的一篇[Android 开发艺术探索的笔记](http://blog.csdn.net/qq_21430549/article/details/49535483)当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. 首先声明native函数\n\n现在，我在activity里声明了一个native函数。\n\n```\npublic native String getStringFromC();\n```\n\n然后我们build一下，为啥要build呢，这个马上就说的。\n\n### 3. 创建并编写 .h头文件\n\n创建jni目录，并且右键->new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。\n\n```\n#ifndef NDK_CORE_H\n#define NDK_CORE_H\n\n#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))\n\n#include <jni.h>\n#include <stdlib.h>\n\n__BEGIN_DECLS\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);\nJNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);\n\n\n__END_DECLS\n\n#endif //TEXT_HELLO_H\n\n```\n\n代码说明如下：\n\n*  我们定义了一个宏NELEM，后面会用到\n*  我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，\n\n### 4. 编写cpp文件\n\n代码如下：\n\n```\njstring returnString(JNIEnv *env,jobject jobj){\n  char* str = \"I come from C＋＋\";\n  return env->NewStringUTF(str);\n}\n\nstatic JNINativeMethod gMethods[] = {\n    {\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n};\n\nJNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) {\n  JNIEnv *env;\n  if (vm->GetEnv((void **) &env,JNI_VERSION_1_6) != JNI_OK){\n    return JNI_ERR;\n  }\n\n  jclass javaClass = env->FindClass(\"com/example/hello_jni/MainActivity\");\n  if (javaClass == NULL){\n    return JNI_ERR;\n  }\n  if (env->RegisterNatives(javaClass,gMethods,NELEM(gMethods)) < 0) {\n    return JNI_ERR;\n  }\n\n  return JNI_VERSION_1_6;\n}\n```\n先看JNI_OnLoad方法，这是注册native函数的地方。\n\n*  首先判断jni版本是不是JNI_VERSION_1_6\n*  FindClass方法找到我们对应生命native函数的类，返回一个jclass\n*  RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，\n\n就这样，我们就注册了native函数了。接下来我们看下gMethods。\n\n### 5. JNINativeMethod数组\n\n这个数组里存放着这样的元素。\n\n```\n{\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n```\n\n* 第一个参数对应的native方法名\n* 第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。\n![这里写图片描述](http://img.blog.csdn.net/20161126110049266)\n* 第三个参数对应的是我嗯c++代码里对应的实现\n\n最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。\n\nandroid.mk\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := hello-jni\n\nLOCAL_C_INCLUDES += $(LOCAL_PATH)\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\napplication.mk\n\n```\nAPP_ABI := armeabi x86\nAPP_PLATFORM := android-14\nAPP_STL := stlport_static\nAPP_OPTIM := debug\n```\n\ngradle 配置\n\n![这里写图片描述](http://img.blog.csdn.net/20161126110601745)\n\n最后就会生出so文件了。(会自动打包进apk里)\n![这里写图片描述](http://img.blog.csdn.net/20161126110719106)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/JNI学习笔记（二）－动态注册native函数.md","raw":"layout: android\ntitle: JNI学习笔记（二）－动态注册native函数\ndate: 2016-11-29 16:33:30\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要> \n\n### 1.前言\n\n在很久之前的一篇[Android 开发艺术探索的笔记](http://blog.csdn.net/qq_21430549/article/details/49535483)当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. 首先声明native函数\n\n现在，我在activity里声明了一个native函数。\n\n```\npublic native String getStringFromC();\n```\n\n然后我们build一下，为啥要build呢，这个马上就说的。\n\n### 3. 创建并编写 .h头文件\n\n创建jni目录，并且右键->new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。\n\n```\n#ifndef NDK_CORE_H\n#define NDK_CORE_H\n\n#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))\n\n#include <jni.h>\n#include <stdlib.h>\n\n__BEGIN_DECLS\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);\nJNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);\n\n\n__END_DECLS\n\n#endif //TEXT_HELLO_H\n\n```\n\n代码说明如下：\n\n*  我们定义了一个宏NELEM，后面会用到\n*  我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，\n\n### 4. 编写cpp文件\n\n代码如下：\n\n```\njstring returnString(JNIEnv *env,jobject jobj){\n  char* str = \"I come from C＋＋\";\n  return env->NewStringUTF(str);\n}\n\nstatic JNINativeMethod gMethods[] = {\n    {\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n};\n\nJNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) {\n  JNIEnv *env;\n  if (vm->GetEnv((void **) &env,JNI_VERSION_1_6) != JNI_OK){\n    return JNI_ERR;\n  }\n\n  jclass javaClass = env->FindClass(\"com/example/hello_jni/MainActivity\");\n  if (javaClass == NULL){\n    return JNI_ERR;\n  }\n  if (env->RegisterNatives(javaClass,gMethods,NELEM(gMethods)) < 0) {\n    return JNI_ERR;\n  }\n\n  return JNI_VERSION_1_6;\n}\n```\n先看JNI_OnLoad方法，这是注册native函数的地方。\n\n*  首先判断jni版本是不是JNI_VERSION_1_6\n*  FindClass方法找到我们对应生命native函数的类，返回一个jclass\n*  RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，\n\n就这样，我们就注册了native函数了。接下来我们看下gMethods。\n\n### 5. JNINativeMethod数组\n\n这个数组里存放着这样的元素。\n\n```\n{\"getStringFromC\",\"()Ljava/lang/String;\",(void *)returnString }\n```\n\n* 第一个参数对应的native方法名\n* 第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。\n![这里写图片描述](http://img.blog.csdn.net/20161126110049266)\n* 第三个参数对应的是我嗯c++代码里对应的实现\n\n最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。\n\nandroid.mk\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := hello-jni\n\nLOCAL_C_INCLUDES += $(LOCAL_PATH)\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\napplication.mk\n\n```\nAPP_ABI := armeabi x86\nAPP_PLATFORM := android-14\nAPP_STL := stlport_static\nAPP_OPTIM := debug\n```\n\ngradle 配置\n\n![这里写图片描述](http://img.blog.csdn.net/20161126110601745)\n\n最后就会生出so文件了。(会自动打包进apk里)\n![这里写图片描述](http://img.blog.csdn.net/20161126110719106)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"JNI学习笔记（二）－动态注册native函数","published":1,"updated":"2017-01-07T06:58:43.000Z","comments":1,"photos":[],"link":"","_id":"ciy1ncy1o000dhws6l7m1v33u","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"> \n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在很久之前的一篇<a href=\"http://blog.csdn.net/qq_21430549/article/details/49535483\" target=\"_blank\" rel=\"external\">Android 开发艺术探索的笔记</a>当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。<br><a id=\"more\"></a></p>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"2-首先声明native函数\"><a href=\"#2-首先声明native函数\" class=\"headerlink\" title=\"2. 首先声明native函数\"></a>2. 首先声明native函数</h3><p>现在，我在activity里声明了一个native函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public native String getStringFromC();</div></pre></td></tr></table></figure>\n<p>然后我们build一下，为啥要build呢，这个马上就说的。</p>\n<h3 id=\"3-创建并编写-h头文件\"><a href=\"#3-创建并编写-h头文件\" class=\"headerlink\" title=\"3. 创建并编写 .h头文件\"></a>3. 创建并编写 .h头文件</h3><p>创建jni目录，并且右键-&gt;new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef NDK_CORE_H</div><div class=\"line\">#define NDK_CORE_H</div><div class=\"line\"></div><div class=\"line\">#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))</div><div class=\"line\"></div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\"></div><div class=\"line\">__BEGIN_DECLS</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);</div><div class=\"line\">JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">__END_DECLS</div><div class=\"line\"></div><div class=\"line\">#endif //TEXT_HELLO_H</div></pre></td></tr></table></figure>\n<p>代码说明如下：</p>\n<ul>\n<li>我们定义了一个宏NELEM，后面会用到</li>\n<li>我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，</li>\n</ul>\n<h3 id=\"4-编写cpp文件\"><a href=\"#4-编写cpp文件\" class=\"headerlink\" title=\"4. 编写cpp文件\"></a>4. 编写cpp文件</h3><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">jstring returnString(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;I come from C＋＋&quot;;</div><div class=\"line\">  return env-&gt;NewStringUTF(str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">    &#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) &#123;</div><div class=\"line\">  JNIEnv *env;</div><div class=\"line\">  if (vm-&gt;GetEnv((void **) &amp;env,JNI_VERSION_1_6) != JNI_OK)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jclass javaClass = env-&gt;FindClass(&quot;com/example/hello_jni/MainActivity&quot;);</div><div class=\"line\">  if (javaClass == NULL)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (env-&gt;RegisterNatives(javaClass,gMethods,NELEM(gMethods)) &lt; 0) &#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return JNI_VERSION_1_6;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先看JNI_OnLoad方法，这是注册native函数的地方。</p>\n<ul>\n<li>首先判断jni版本是不是JNI_VERSION_1_6</li>\n<li>FindClass方法找到我们对应生命native函数的类，返回一个jclass</li>\n<li>RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，</li>\n</ul>\n<p>就这样，我们就注册了native函数了。接下来我们看下gMethods。</p>\n<h3 id=\"5-JNINativeMethod数组\"><a href=\"#5-JNINativeMethod数组\" class=\"headerlink\" title=\"5. JNINativeMethod数组\"></a>5. JNINativeMethod数组</h3><p>这个数组里存放着这样的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数对应的native方法名</li>\n<li>第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。<br><img src=\"http://img.blog.csdn.net/20161126110049266\" alt=\"这里写图片描述\"></li>\n<li>第三个参数对应的是我嗯c++代码里对应的实现</li>\n</ul>\n<p>最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。</p>\n<p>android.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_C_INCLUDES += $(LOCAL_PATH)</div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>application.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP_ABI := armeabi x86</div><div class=\"line\">APP_PLATFORM := android-14</div><div class=\"line\">APP_STL := stlport_static</div><div class=\"line\">APP_OPTIM := debug</div></pre></td></tr></table></figure>\n<p>gradle 配置</p>\n<p><img src=\"http://img.blog.csdn.net/20161126110601745\" alt=\"这里写图片描述\"></p>\n<p>最后就会生出so文件了。(会自动打包进apk里)<br><img src=\"http://img.blog.csdn.net/20161126110719106\" alt=\"这里写图片描述\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要> \n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在很久之前的一篇<a href=\"http://blog.csdn.net/qq_21430549/article/details/49535483\">Android 开发艺术探索的笔记</a>当中,学习了简单的jni开发流程，但是那会的步骤极其繁琐复杂，而且生成的头文件函数太长，那么，有没有方法能解决呢，让开发过程变得简单易懂。当然是有的，那就是今天的主角。JNI_OnLoad函数。顺便说一下，现在as对 jni开发的支持是越来越好了。<br>","more":"</p>\n<The rest of contents | 余下全文>\n\n<h3 id=\"2-首先声明native函数\"><a href=\"#2-首先声明native函数\" class=\"headerlink\" title=\"2. 首先声明native函数\"></a>2. 首先声明native函数</h3><p>现在，我在activity里声明了一个native函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public native String getStringFromC();</div></pre></td></tr></table></figure>\n<p>然后我们build一下，为啥要build呢，这个马上就说的。</p>\n<h3 id=\"3-创建并编写-h头文件\"><a href=\"#3-创建并编写-h头文件\" class=\"headerlink\" title=\"3. 创建并编写 .h头文件\"></a>3. 创建并编写 .h头文件</h3><p>创建jni目录，并且右键-&gt;new c++class，会生出相应的.h 和.cpp 文件，我们需要稍微修改下.h 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef NDK_CORE_H</div><div class=\"line\">#define NDK_CORE_H</div><div class=\"line\"></div><div class=\"line\">#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))</div><div class=\"line\"></div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\"></div><div class=\"line\">__BEGIN_DECLS</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);</div><div class=\"line\">JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">__END_DECLS</div><div class=\"line\"></div><div class=\"line\">#endif //TEXT_HELLO_H</div></pre></td></tr></table></figure>\n<p>代码说明如下：</p>\n<ul>\n<li>我们定义了一个宏NELEM，后面会用到</li>\n<li>我们用JNIEXPORT和JNICALL关键字，告诉虚拟机，这是jni函数，</li>\n</ul>\n<h3 id=\"4-编写cpp文件\"><a href=\"#4-编写cpp文件\" class=\"headerlink\" title=\"4. 编写cpp文件\"></a>4. 编写cpp文件</h3><p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">jstring returnString(JNIEnv *env,jobject jobj)&#123;</div><div class=\"line\">  char* str = &quot;I come from C＋＋&quot;;</div><div class=\"line\">  return env-&gt;NewStringUTF(str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">    &#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">JNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) &#123;</div><div class=\"line\">  JNIEnv *env;</div><div class=\"line\">  if (vm-&gt;GetEnv((void **) &amp;env,JNI_VERSION_1_6) != JNI_OK)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  jclass javaClass = env-&gt;FindClass(&quot;com/example/hello_jni/MainActivity&quot;);</div><div class=\"line\">  if (javaClass == NULL)&#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (env-&gt;RegisterNatives(javaClass,gMethods,NELEM(gMethods)) &lt; 0) &#123;</div><div class=\"line\">    return JNI_ERR;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return JNI_VERSION_1_6;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先看JNI_OnLoad方法，这是注册native函数的地方。</p>\n<ul>\n<li>首先判断jni版本是不是JNI_VERSION_1_6</li>\n<li>FindClass方法找到我们对应生命native函数的类，返回一个jclass</li>\n<li>RegisterNatives 注册native函数，我这里用这个三个参数的方法，第一个表示对应jclass，第二个表示JNINativeMethod的数组，第三个，这个就是我们先前命名的宏，</li>\n</ul>\n<p>就这样，我们就注册了native函数了。接下来我们看下gMethods。</p>\n<h3 id=\"5-JNINativeMethod数组\"><a href=\"#5-JNINativeMethod数组\" class=\"headerlink\" title=\"5. JNINativeMethod数组\"></a>5. JNINativeMethod数组</h3><p>这个数组里存放着这样的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&quot;getStringFromC&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数对应的native方法名</li>\n<li>第二个参数对应 native方法的描述，我们通过javap -s class文件路径来获取。<br><img src=\"http://img.blog.csdn.net/20161126110049266\" alt=\"这里写图片描述\"></li>\n<li>第三个参数对应的是我嗯c++代码里对应的实现</li>\n</ul>\n<p>最后就是android.mk 和 application.mk的编写以及gradle的配置，最后编译，这里就不多说了，相关的内容下篇说明。现在给出文件内容。</p>\n<p>android.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_C_INCLUDES += $(LOCAL_PATH)</div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>application.mk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP_ABI := armeabi x86</div><div class=\"line\">APP_PLATFORM := android-14</div><div class=\"line\">APP_STL := stlport_static</div><div class=\"line\">APP_OPTIM := debug</div></pre></td></tr></table></figure>\n<p>gradle 配置</p>\n<p><img src=\"http://img.blog.csdn.net/20161126110601745\" alt=\"这里写图片描述\"></p>\n<p>最后就会生出so文件了。(会自动打包进apk里)<br><img src=\"http://img.blog.csdn.net/20161126110719106\" alt=\"这里写图片描述\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Android消息机制－native层","date":"2016-12-24T08:25:04.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2.初始化\n\n在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。\n\n首先，我们先看下方法表：\n\n```\nstatic JNINativeMethod gMessageQueueMethods[] = {\n    /* name, signature, funcPtr */\n    { \"nativeInit\", \"()J\", (void*)android_os_MessageQueue_nativeInit },\n    { \"nativeDestroy\", \"(J)V\", (void*)android_os_MessageQueue_nativeDestroy },\n    { \"nativePollOnce\", \"(JI)V\", (void*)android_os_MessageQueue_nativePollOnce },\n    { \"nativeWake\", \"(J)V\", (void*)android_os_MessageQueue_nativeWake },\n    { \"nativeIsPolling\", \"(J)Z\", (void*)android_os_MessageQueue_nativeIsPolling },\n    { \"nativeSetFileDescriptorEvents\", \"(JII)V\",\n            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },\n};\n```\n\n\n因为前面有介绍jni的相关知识，这里就不多说了。\n\n从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.\n\n```\nstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n    if (!nativeMessageQueue) {\n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");\n        return 0;\n    }\n\n    nativeMessageQueue->incStrong(env);\n    return reinterpret_cast<jlong>(nativeMessageQueue);\n}\n```\n\n\n* 初始化NativeMessageQueue\n* 并且返回给java层，也就是java层的mPtr\n\n那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。\n\n```\nNativeMessageQueue::NativeMessageQueue() :\n        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n        mLooper = new Looper(false);\n        Looper::setForThread(mLooper);\n    }\n}\n```\n\n* 构造native层的looper，注意，这个和java层的没有任何关系\n* 保存在类似ThreadLocal一样的结构里。\n\nLooper的构造函数在Looper.cpp中。\n\n```\nLooper::Looper(bool allowNonCallbacks) :\n        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),\n        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),\n        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {\n    mWakeEventFd = eventfd(0, EFD_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(mWakeEventFd < 0, \"Could not make wake event fd.  errno=%d\", errno);\n\n    AutoMutex _l(mLock);\n    rebuildEpollLocked();\n}\n```\n\n* eventfd构造欢迎时间的fd\n* rebuildEpollLocked 重建epoll\n\nepoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：\n\n* 监视的描述符数量不受限制\n* IO效率不会随着监视fd的数量增长而下降\n\n关于epoll的更多内容，这里就不介绍了。\n\n那么，在我们native的looper里面，是如何重建的呢？\n\n```\nvoid Looper::rebuildEpollLocked() {\n    // Close old epoll instance if we have one.\n    if (mEpollFd >= 0) {\n#if DEBUG_CALLBACKS\n        ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);\n#endif\n        close(mEpollFd);\n    }\n\n    // Allocate the new epoll instance and register the wake pipe.\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance.  errno=%d\", errno);\n\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;\n    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance.  errno=%d\",\n            errno);\n\n    for (size_t i = 0; i < mRequests.size(); i++) {\n        const Request& request = mRequests.valueAt(i);\n        struct epoll_event eventItem;\n        request.initEventItem(&eventItem);\n\n        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, & eventItem);\n        if (epollResult < 0) {\n            ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d\",\n                    request.fd, errno);\n        }\n    }\n}\n```\n\n* epoll_create，创建epoll句柄\n* memset 将数据区域至0\n* eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。\n* epoll_ctl添加唤醒事件\n* 循环将mRequests中的事件都添加进去。\n\n### 3. nativePollOnce\n\n在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。\n\nandroid_os_MessageQueue_nativePollOnce->pollOnce->Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)\n\n\n\n```\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != NULL) *outFd = fd;\n                if (outEvents != NULL) *outEvents = events;\n                if (outData != NULL) *outData = data;\n                return ident;\n            }\n        }\n\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != NULL) *outFd = 0;\n            if (outEvents != NULL) *outEvents = 0;\n            if (outData != NULL) *outData = NULL;\n            return result;\n        }\n\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n这个方法的参数含义：\n\n* timeoutMillis 超时等待时间，-1无限等待，0立即返回\n* outFd 发生事件的文件描述符\n* outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,\n* outData 存储上下文数据\n\n返回值的含义如下：\n\n* ALOOPER_POLL_WAKE 表示由wake触发\n* ALOOPER_POLL_TIMEOUT 等待超时\n* ALOOPER_POLL_ERROR 等待过程中发生错误\n* ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发\n\n这个方法的处理逻辑如下：\n\n* 先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)\n* pollInner 处理内部轮询\n\n\npollInner方法很长，\n\n* toMillisecondTimeoutDelay 重新计算超时时间\n* epoll_wait 等待\n* 如果需要，重建epoll\n* epoll_wait函数返回，三种情况\n\t* eventCount<0 发生错误，goto Done\n\t* eventCount=0 连接超时 goto Done\n\t* 监听到有事件发生，\n* 如果有事件发生，则循环处理\n\t* 如果是mWakeEventFd，则进行awoken唤醒\n\t* pushResponse，根据request构建response，并添加到response数组中\n* Done 标志，事件处理\n\t* handleMessage 先处理native的message\n\t* handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。 \t\n\t\n\n### 4.nativeWake\n\n同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。\n\n在native层通过层层调用，会调用到looper的wake方法中。\n\n```\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(\"Could not write wake signal, errno=%d\", errno);\n        }\n    }\n}\n``` \n\n* 向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。\n\n### 补充\n\n\n当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/Android消息机制－native层.md","raw":"---\ntitle: Android消息机制－native层\ndate: 2016-12-24 16:25:04\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2.初始化\n\n在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。\n\n首先，我们先看下方法表：\n\n```\nstatic JNINativeMethod gMessageQueueMethods[] = {\n    /* name, signature, funcPtr */\n    { \"nativeInit\", \"()J\", (void*)android_os_MessageQueue_nativeInit },\n    { \"nativeDestroy\", \"(J)V\", (void*)android_os_MessageQueue_nativeDestroy },\n    { \"nativePollOnce\", \"(JI)V\", (void*)android_os_MessageQueue_nativePollOnce },\n    { \"nativeWake\", \"(J)V\", (void*)android_os_MessageQueue_nativeWake },\n    { \"nativeIsPolling\", \"(J)Z\", (void*)android_os_MessageQueue_nativeIsPolling },\n    { \"nativeSetFileDescriptorEvents\", \"(JII)V\",\n            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },\n};\n```\n\n\n因为前面有介绍jni的相关知识，这里就不多说了。\n\n从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.\n\n```\nstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n    if (!nativeMessageQueue) {\n        jniThrowRuntimeException(env, \"Unable to allocate native queue\");\n        return 0;\n    }\n\n    nativeMessageQueue->incStrong(env);\n    return reinterpret_cast<jlong>(nativeMessageQueue);\n}\n```\n\n\n* 初始化NativeMessageQueue\n* 并且返回给java层，也就是java层的mPtr\n\n那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。\n\n```\nNativeMessageQueue::NativeMessageQueue() :\n        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n        mLooper = new Looper(false);\n        Looper::setForThread(mLooper);\n    }\n}\n```\n\n* 构造native层的looper，注意，这个和java层的没有任何关系\n* 保存在类似ThreadLocal一样的结构里。\n\nLooper的构造函数在Looper.cpp中。\n\n```\nLooper::Looper(bool allowNonCallbacks) :\n        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),\n        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),\n        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {\n    mWakeEventFd = eventfd(0, EFD_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(mWakeEventFd < 0, \"Could not make wake event fd.  errno=%d\", errno);\n\n    AutoMutex _l(mLock);\n    rebuildEpollLocked();\n}\n```\n\n* eventfd构造欢迎时间的fd\n* rebuildEpollLocked 重建epoll\n\nepoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：\n\n* 监视的描述符数量不受限制\n* IO效率不会随着监视fd的数量增长而下降\n\n关于epoll的更多内容，这里就不介绍了。\n\n那么，在我们native的looper里面，是如何重建的呢？\n\n```\nvoid Looper::rebuildEpollLocked() {\n    // Close old epoll instance if we have one.\n    if (mEpollFd >= 0) {\n#if DEBUG_CALLBACKS\n        ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);\n#endif\n        close(mEpollFd);\n    }\n\n    // Allocate the new epoll instance and register the wake pipe.\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT);\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance.  errno=%d\", errno);\n\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;\n    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance.  errno=%d\",\n            errno);\n\n    for (size_t i = 0; i < mRequests.size(); i++) {\n        const Request& request = mRequests.valueAt(i);\n        struct epoll_event eventItem;\n        request.initEventItem(&eventItem);\n\n        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, & eventItem);\n        if (epollResult < 0) {\n            ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d\",\n                    request.fd, errno);\n        }\n    }\n}\n```\n\n* epoll_create，创建epoll句柄\n* memset 将数据区域至0\n* eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。\n* epoll_ctl添加唤醒事件\n* 循环将mRequests中的事件都添加进去。\n\n### 3. nativePollOnce\n\n在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。\n\nandroid_os_MessageQueue_nativePollOnce->pollOnce->Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)\n\n\n\n```\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != NULL) *outFd = fd;\n                if (outEvents != NULL) *outEvents = events;\n                if (outData != NULL) *outData = data;\n                return ident;\n            }\n        }\n\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != NULL) *outFd = 0;\n            if (outEvents != NULL) *outEvents = 0;\n            if (outData != NULL) *outData = NULL;\n            return result;\n        }\n\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n这个方法的参数含义：\n\n* timeoutMillis 超时等待时间，-1无限等待，0立即返回\n* outFd 发生事件的文件描述符\n* outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,\n* outData 存储上下文数据\n\n返回值的含义如下：\n\n* ALOOPER_POLL_WAKE 表示由wake触发\n* ALOOPER_POLL_TIMEOUT 等待超时\n* ALOOPER_POLL_ERROR 等待过程中发生错误\n* ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发\n\n这个方法的处理逻辑如下：\n\n* 先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)\n* pollInner 处理内部轮询\n\n\npollInner方法很长，\n\n* toMillisecondTimeoutDelay 重新计算超时时间\n* epoll_wait 等待\n* 如果需要，重建epoll\n* epoll_wait函数返回，三种情况\n\t* eventCount<0 发生错误，goto Done\n\t* eventCount=0 连接超时 goto Done\n\t* 监听到有事件发生，\n* 如果有事件发生，则循环处理\n\t* 如果是mWakeEventFd，则进行awoken唤醒\n\t* pushResponse，根据request构建response，并添加到response数组中\n* Done 标志，事件处理\n\t* handleMessage 先处理native的message\n\t* handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。 \t\n\t\n\n### 4.nativeWake\n\n同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。\n\n在native层通过层层调用，会调用到looper的wake方法中。\n\n```\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(\"Could not write wake signal, errno=%d\", errno);\n        }\n    }\n}\n``` \n\n* 向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。\n\n### 补充\n\n\n当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"Android消息机制－native层","published":1,"updated":"2017-01-07T06:57:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy1q000hhws6ke0hw1wi","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><p>在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。</p>\n<p>首先，我们先看下方法表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class=\"line\">    /* name, signature, funcPtr */</div><div class=\"line\">    &#123; &quot;nativeInit&quot;, &quot;()J&quot;, (void*)android_os_MessageQueue_nativeInit &#125;,</div><div class=\"line\">    &#123; &quot;nativeDestroy&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class=\"line\">    &#123; &quot;nativePollOnce&quot;, &quot;(JI)V&quot;, (void*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class=\"line\">    &#123; &quot;nativeWake&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeWake &#125;,</div><div class=\"line\">    &#123; &quot;nativeIsPolling&quot;, &quot;(J)Z&quot;, (void*)android_os_MessageQueue_nativeIsPolling &#125;,</div><div class=\"line\">    &#123; &quot;nativeSetFileDescriptorEvents&quot;, &quot;(JII)V&quot;,</div><div class=\"line\">            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>因为前面有介绍jni的相关知识，这里就不多说了。</p>\n<p>从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</div><div class=\"line\">    if (!nativeMessageQueue) &#123;</div><div class=\"line\">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    nativeMessageQueue-&gt;incStrong(env);</div><div class=\"line\">    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化NativeMessageQueue</li>\n<li>并且返回给java层，也就是java层的mPtr</li>\n</ul>\n<p>那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMessageQueue::NativeMessageQueue() :</div><div class=\"line\">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</div><div class=\"line\">    mLooper = Looper::getForThread();</div><div class=\"line\">    if (mLooper == NULL) &#123;</div><div class=\"line\">        mLooper = new Looper(false);</div><div class=\"line\">        Looper::setForThread(mLooper);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造native层的looper，注意，这个和java层的没有任何关系</li>\n<li>保存在类似ThreadLocal一样的结构里。</li>\n</ul>\n<p>Looper的构造函数在Looper.cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper::Looper(bool allowNonCallbacks) :</div><div class=\"line\">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</div><div class=\"line\">        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),</div><div class=\"line\">        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</div><div class=\"line\">    mWakeEventFd = eventfd(0, EFD_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, &quot;Could not make wake event fd.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\">    rebuildEpollLocked();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>eventfd构造欢迎时间的fd</li>\n<li>rebuildEpollLocked 重建epoll</li>\n</ul>\n<p>epoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：</p>\n<ul>\n<li>监视的描述符数量不受限制</li>\n<li>IO效率不会随着监视fd的数量增长而下降</li>\n</ul>\n<p>关于epoll的更多内容，这里就不介绍了。</p>\n<p>那么，在我们native的looper里面，是如何重建的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Looper::rebuildEpollLocked() &#123;</div><div class=\"line\">    // Close old epoll instance if we have one.</div><div class=\"line\">    if (mEpollFd &gt;= 0) &#123;</div><div class=\"line\">#if DEBUG_CALLBACKS</div><div class=\"line\">        ALOGD(&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;, this);</div><div class=\"line\">#endif</div><div class=\"line\">        close(mEpollFd);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Allocate the new epoll instance and register the wake pipe.</div><div class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    struct epoll_event eventItem;</div><div class=\"line\">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</div><div class=\"line\">    eventItem.events = EPOLLIN;</div><div class=\"line\">    eventItem.data.fd = mWakeEventFd;</div><div class=\"line\">    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; mRequests.size(); i++) &#123;</div><div class=\"line\">        const Request&amp; request = mRequests.valueAt(i);</div><div class=\"line\">        struct epoll_event eventItem;</div><div class=\"line\">        request.initEventItem(&amp;eventItem);</div><div class=\"line\"></div><div class=\"line\">        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</div><div class=\"line\">        if (epollResult &lt; 0) &#123;</div><div class=\"line\">            ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set, errno=%d&quot;,</div><div class=\"line\">                    request.fd, errno);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>epoll_create，创建epoll句柄</li>\n<li>memset 将数据区域至0</li>\n<li>eventItem.events = EPOLLIN;<br>  eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。</li>\n<li>epoll_ctl添加唤醒事件</li>\n<li>循环将mRequests中的事件都添加进去。</li>\n</ul>\n<h3 id=\"3-nativePollOnce\"><a href=\"#3-nativePollOnce\" class=\"headerlink\" title=\"3. nativePollOnce\"></a>3. nativePollOnce</h3><p>在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。</p>\n<p>android_os_MessageQueue_nativePollOnce-&gt;pollOnce-&gt;Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class=\"line\">    int result = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class=\"line\">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class=\"line\">            int ident = response.request.ident;</div><div class=\"line\">            if (ident &gt;= 0) &#123;</div><div class=\"line\">                int fd = response.request.fd;</div><div class=\"line\">                int events = response.events;</div><div class=\"line\">                void* data = response.request.data;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class=\"line\">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class=\"line\">                        this, ident, fd, events, data);</div><div class=\"line\">#endif</div><div class=\"line\">                if (outFd != NULL) *outFd = fd;</div><div class=\"line\">                if (outEvents != NULL) *outEvents = events;</div><div class=\"line\">                if (outData != NULL) *outData = data;</div><div class=\"line\">                return ident;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (result != 0) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class=\"line\">#endif</div><div class=\"line\">            if (outFd != NULL) *outFd = 0;</div><div class=\"line\">            if (outEvents != NULL) *outEvents = 0;</div><div class=\"line\">            if (outData != NULL) *outData = NULL;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        result = pollInner(timeoutMillis);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的参数含义：</p>\n<ul>\n<li>timeoutMillis 超时等待时间，-1无限等待，0立即返回</li>\n<li>outFd 发生事件的文件描述符</li>\n<li>outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,</li>\n<li>outData 存储上下文数据</li>\n</ul>\n<p>返回值的含义如下：</p>\n<ul>\n<li>ALOOPER_POLL_WAKE 表示由wake触发</li>\n<li>ALOOPER_POLL_TIMEOUT 等待超时</li>\n<li>ALOOPER_POLL_ERROR 等待过程中发生错误</li>\n<li>ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发</li>\n</ul>\n<p>这个方法的处理逻辑如下：</p>\n<ul>\n<li>先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)</li>\n<li>pollInner 处理内部轮询</li>\n</ul>\n<p>pollInner方法很长，</p>\n<ul>\n<li>toMillisecondTimeoutDelay 重新计算超时时间</li>\n<li>epoll_wait 等待</li>\n<li>如果需要，重建epoll</li>\n<li>epoll_wait函数返回，三种情况<ul>\n<li>eventCount&lt;0 发生错误，goto Done</li>\n<li>eventCount=0 连接超时 goto Done</li>\n<li>监听到有事件发生，</li>\n</ul>\n</li>\n<li>如果有事件发生，则循环处理<ul>\n<li>如果是mWakeEventFd，则进行awoken唤醒</li>\n<li>pushResponse，根据request构建response，并添加到response数组中</li>\n</ul>\n</li>\n<li>Done 标志，事件处理<ul>\n<li>handleMessage 先处理native的message</li>\n<li>handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-nativeWake\"><a href=\"#4-nativeWake\" class=\"headerlink\" title=\"4.nativeWake\"></a>4.nativeWake</h3><p>同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。</p>\n<p>在native层通过层层调用，会调用到looper的wake方法中。</p>\n<pre><code>void Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(&quot;%p ~ wake&quot;, this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);\n        }\n    }\n}\n</code></pre><ul>\n<li>向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。</li>\n</ul>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前面的文章介绍了java层的消息机制，这篇来简要学习下native层的消息机制。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><p>在MessageQueue的构造函数中，调用nativeInit方法来初始化native层的messagequeue。而java层 MessageQueue中的几个native函数，如nativePollOnce，nativeWake等，其实现都在android_os_MessageQueue.cpp中。</p>\n<p>首先，我们先看下方法表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class=\"line\">    /* name, signature, funcPtr */</div><div class=\"line\">    &#123; &quot;nativeInit&quot;, &quot;()J&quot;, (void*)android_os_MessageQueue_nativeInit &#125;,</div><div class=\"line\">    &#123; &quot;nativeDestroy&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class=\"line\">    &#123; &quot;nativePollOnce&quot;, &quot;(JI)V&quot;, (void*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class=\"line\">    &#123; &quot;nativeWake&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeWake &#125;,</div><div class=\"line\">    &#123; &quot;nativeIsPolling&quot;, &quot;(J)Z&quot;, (void*)android_os_MessageQueue_nativeIsPolling &#125;,</div><div class=\"line\">    &#123; &quot;nativeSetFileDescriptorEvents&quot;, &quot;(JII)V&quot;,</div><div class=\"line\">            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>因为前面有介绍jni的相关知识，这里就不多说了。</p>\n<p>从中找到，我们java层的nativeInit方法，对应的是android_os_MessageQueue_nativeInit.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</div><div class=\"line\">    if (!nativeMessageQueue) &#123;</div><div class=\"line\">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    nativeMessageQueue-&gt;incStrong(env);</div><div class=\"line\">    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化NativeMessageQueue</li>\n<li>并且返回给java层，也就是java层的mPtr</li>\n</ul>\n<p>那么，我们就来看NativeMessageQueue的构造函数，其实还在这个cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMessageQueue::NativeMessageQueue() :</div><div class=\"line\">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</div><div class=\"line\">    mLooper = Looper::getForThread();</div><div class=\"line\">    if (mLooper == NULL) &#123;</div><div class=\"line\">        mLooper = new Looper(false);</div><div class=\"line\">        Looper::setForThread(mLooper);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造native层的looper，注意，这个和java层的没有任何关系</li>\n<li>保存在类似ThreadLocal一样的结构里。</li>\n</ul>\n<p>Looper的构造函数在Looper.cpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper::Looper(bool allowNonCallbacks) :</div><div class=\"line\">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</div><div class=\"line\">        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),</div><div class=\"line\">        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</div><div class=\"line\">    mWakeEventFd = eventfd(0, EFD_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, &quot;Could not make wake event fd.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\">    rebuildEpollLocked();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>eventfd构造欢迎时间的fd</li>\n<li>rebuildEpollLocked 重建epoll</li>\n</ul>\n<p>epoll模型和select／poll模型一样，都是linux下的多路复用I/O模型,epoll模型的优点如下：</p>\n<ul>\n<li>监视的描述符数量不受限制</li>\n<li>IO效率不会随着监视fd的数量增长而下降</li>\n</ul>\n<p>关于epoll的更多内容，这里就不介绍了。</p>\n<p>那么，在我们native的looper里面，是如何重建的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Looper::rebuildEpollLocked() &#123;</div><div class=\"line\">    // Close old epoll instance if we have one.</div><div class=\"line\">    if (mEpollFd &gt;= 0) &#123;</div><div class=\"line\">#if DEBUG_CALLBACKS</div><div class=\"line\">        ALOGD(&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;, this);</div><div class=\"line\">#endif</div><div class=\"line\">        close(mEpollFd);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Allocate the new epoll instance and register the wake pipe.</div><div class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);</div><div class=\"line\"></div><div class=\"line\">    struct epoll_event eventItem;</div><div class=\"line\">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</div><div class=\"line\">    eventItem.events = EPOLLIN;</div><div class=\"line\">    eventItem.data.fd = mWakeEventFd;</div><div class=\"line\">    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; mRequests.size(); i++) &#123;</div><div class=\"line\">        const Request&amp; request = mRequests.valueAt(i);</div><div class=\"line\">        struct epoll_event eventItem;</div><div class=\"line\">        request.initEventItem(&amp;eventItem);</div><div class=\"line\"></div><div class=\"line\">        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</div><div class=\"line\">        if (epollResult &lt; 0) &#123;</div><div class=\"line\">            ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set, errno=%d&quot;,</div><div class=\"line\">                    request.fd, errno);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>epoll_create，创建epoll句柄</li>\n<li>memset 将数据区域至0</li>\n<li>eventItem.events = EPOLLIN;<br>  eventItem.data.fd = mWakeEventFd;，指定事件类型和唤醒的fd。</li>\n<li>epoll_ctl添加唤醒事件</li>\n<li>循环将mRequests中的事件都添加进去。</li>\n</ul>\n<h3 id=\"3-nativePollOnce\"><a href=\"#3-nativePollOnce\" class=\"headerlink\" title=\"3. nativePollOnce\"></a>3. nativePollOnce</h3><p>在java层MessageQueue#next方法中，首先会通过nativePollOnce去提取native层消息队列的消息。</p>\n<p>android_os_MessageQueue_nativePollOnce-&gt;pollOnce-&gt;Looper的pollOnce(这个pollOnce是个内连函数，会调用到4个参数的pollOnce方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class=\"line\">    int result = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class=\"line\">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class=\"line\">            int ident = response.request.ident;</div><div class=\"line\">            if (ident &gt;= 0) &#123;</div><div class=\"line\">                int fd = response.request.fd;</div><div class=\"line\">                int events = response.events;</div><div class=\"line\">                void* data = response.request.data;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class=\"line\">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class=\"line\">                        this, ident, fd, events, data);</div><div class=\"line\">#endif</div><div class=\"line\">                if (outFd != NULL) *outFd = fd;</div><div class=\"line\">                if (outEvents != NULL) *outEvents = events;</div><div class=\"line\">                if (outData != NULL) *outData = data;</div><div class=\"line\">                return ident;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (result != 0) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class=\"line\">#endif</div><div class=\"line\">            if (outFd != NULL) *outFd = 0;</div><div class=\"line\">            if (outEvents != NULL) *outEvents = 0;</div><div class=\"line\">            if (outData != NULL) *outData = NULL;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        result = pollInner(timeoutMillis);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的参数含义：</p>\n<ul>\n<li>timeoutMillis 超时等待时间，-1无限等待，0立即返回</li>\n<li>outFd 发生事件的文件描述符</li>\n<li>outEvents 发生了哪些事件，目前支持可读、可写、错误、中断,</li>\n<li>outData 存储上下文数据</li>\n</ul>\n<p>返回值的含义如下：</p>\n<ul>\n<li>ALOOPER_POLL_WAKE 表示由wake触发</li>\n<li>ALOOPER_POLL_TIMEOUT 等待超时</li>\n<li>ALOOPER_POLL_ERROR 等待过程中发生错误</li>\n<li>ALOOPER_POLL_CALLBACK 被监听的句柄因某种原因被触发</li>\n</ul>\n<p>这个方法的处理逻辑如下：</p>\n<ul>\n<li>先处理没有Callback方法的 Response事件,(Response/Request的结构体在Looper.h中)</li>\n<li>pollInner 处理内部轮询</li>\n</ul>\n<p>pollInner方法很长，</p>\n<ul>\n<li>toMillisecondTimeoutDelay 重新计算超时时间</li>\n<li>epoll_wait 等待</li>\n<li>如果需要，重建epoll</li>\n<li>epoll_wait函数返回，三种情况<ul>\n<li>eventCount&lt;0 发生错误，goto Done</li>\n<li>eventCount=0 连接超时 goto Done</li>\n<li>监听到有事件发生，</li>\n</ul>\n</li>\n<li>如果有事件发生，则循环处理<ul>\n<li>如果是mWakeEventFd，则进行awoken唤醒</li>\n<li>pushResponse，根据request构建response，并添加到response数组中</li>\n</ul>\n</li>\n<li>Done 标志，事件处理<ul>\n<li>handleMessage 先处理native的message</li>\n<li>handleEvent 处理有回调的message，并且response.request.callback.clear();清除引用。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-nativeWake\"><a href=\"#4-nativeWake\" class=\"headerlink\" title=\"4.nativeWake\"></a>4.nativeWake</h3><p>同学上周去美团面试的时候，被问到，当消息队列阻塞的时候，我们插入message，会发生什么呢？根据enqueueMessage方法，可以知道，当消息队列没有消息，也就是p=null的时候，会调用nativeWake进行唤醒操作。</p>\n<p>在native层通过层层调用，会调用到looper的wake方法中。</p>\n<pre><code>void Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(&quot;%p ~ wake&quot;, this);\n#endif\n\n    uint64_t inc = 1;\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));\n    if (nWrite != sizeof(uint64_t)) {\n        if (errno != EAGAIN) {\n            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);\n        }\n    }\n}\n</code></pre><ul>\n<li>向管道mWakeEventFd写入字符,因为有输入，所以读的一端就会被唤醒,r然后nativepollonce函数就会返回。这些继续处理消息了。</li>\n</ul>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>当消息队列里没有消息的时候，会调用nativePollOnce方法 进入阻塞状态，当消息来的时候，会用nativeWake进行唤醒操作。并且，在主线程空闲状态时，会处理注册的mPendingIdleHandlers的任务。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"ContentProvider凑数文","date":"2016-12-29T10:33:56.000Z","_content":"<Excerpt in index | 首页摘要>\n这一篇，没营养，凑数用的。\n\n### 1. ActivityThread的main方法\n\n* 我们知道android应用程序的入口是ActivityThread的main方法。\n* ContentProvid是何时、何流程，调用的onCreate方法呢？\n\nActivityThread的main方法说起。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n```\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n```\n\n在main方法中，我们能发现如上代码，attach什么？我们跟进去看。\n\n```\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n            final IActivityManager mgr = ActivityManagerNative.getDefault();\n            try {\n                mgr.attachApplication(mAppThread);\n            } catch (RemoteException ex) {\n                // Ignore\n            }\n```\n\n我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现\n\n```\nList<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;\n```\n\n* app ProcessRecord, 进程相关信息\n* ProviderInfo contentprovider信息\n\n再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：\n\n```\n            if (!data.restrictedBackupMode) {\n                List<ProviderInfo> providers = data.providers;\n                if (providers != null) {\n                    installContentProviders(app, providers);\n                    // For process that contains content providers, we want to\n                    // ensure that the JIT is enabled \"at some point\".\n                    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);\n                }\n            }\n```\n\n找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。\n\n```\n    private void installContentProviders(\n            Context context, List<ProviderInfo> providers) {\n        final ArrayList<IActivityManager.ContentProviderHolder> results =\n            new ArrayList<IActivityManager.ContentProviderHolder>();\n\n        for (ProviderInfo cpi : providers) {\n            if (DEBUG_PROVIDER) {\n                StringBuilder buf = new StringBuilder(128);\n                buf.append(\"Pub \");\n                buf.append(cpi.authority);\n                buf.append(\": \");\n                buf.append(cpi.name);\n                Log.i(TAG, buf.toString());\n            }\n            IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,\n                    false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);\n            if (cph != null) {\n                cph.noReleaseNeeded = true;\n                results.add(cph);\n            }\n        }\n\n        try {\n            ActivityManagerNative.getDefault().publishContentProviders(\n                getApplicationThread(), results);\n        } catch (RemoteException ex) {\n        }\n    }\n```\n\n总体分为两步，\n\n* installProvider 生成ContentProviderHolder对象\n* publishContentProviders 发布出去\n\n### 2.installProvider\n\n\n```\n                final java.lang.ClassLoader cl = c.getClassLoader();\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n                if (provider == null) {\n                    Slog.e(TAG, \"Failed to instantiate class \" +\n                          info.name + \" from sourceDir \" +\n                          info.applicationInfo.sourceDir);\n                    return null;\n                }\n                if (DEBUG_PROVIDER) Slog.v(\n                    TAG, \"Instantiating local provider \" + info.name);\n                // XXX Need to create the correct context for this provider.\n                localProvider.attachInfo(c, info);\n```\n\n在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现\n\n```\nContentProvider.this.onCreate();\n```\n\n### 3.query操作\n\nContext的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。\n\nquery方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个[理解ContentProvider原理](http://gityuan.com/2016/07/30/content-provider/) \n\n* 获取IContentProvider对象\n* IContentProvider的query方法\n\n\nIContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。\n\n```\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n```\ncp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/ContentProvider水文(凑四大组件).md","raw":"---\ntitle: ContentProvider凑数文\ndate: 2016-12-29 18:33:56\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n这一篇，没营养，凑数用的。\n\n### 1. ActivityThread的main方法\n\n* 我们知道android应用程序的入口是ActivityThread的main方法。\n* ContentProvid是何时、何流程，调用的onCreate方法呢？\n\nActivityThread的main方法说起。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n```\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n```\n\n在main方法中，我们能发现如上代码，attach什么？我们跟进去看。\n\n```\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n            final IActivityManager mgr = ActivityManagerNative.getDefault();\n            try {\n                mgr.attachApplication(mAppThread);\n            } catch (RemoteException ex) {\n                // Ignore\n            }\n```\n\n我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现\n\n```\nList<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;\n```\n\n* app ProcessRecord, 进程相关信息\n* ProviderInfo contentprovider信息\n\n再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：\n\n```\n            if (!data.restrictedBackupMode) {\n                List<ProviderInfo> providers = data.providers;\n                if (providers != null) {\n                    installContentProviders(app, providers);\n                    // For process that contains content providers, we want to\n                    // ensure that the JIT is enabled \"at some point\".\n                    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);\n                }\n            }\n```\n\n找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。\n\n```\n    private void installContentProviders(\n            Context context, List<ProviderInfo> providers) {\n        final ArrayList<IActivityManager.ContentProviderHolder> results =\n            new ArrayList<IActivityManager.ContentProviderHolder>();\n\n        for (ProviderInfo cpi : providers) {\n            if (DEBUG_PROVIDER) {\n                StringBuilder buf = new StringBuilder(128);\n                buf.append(\"Pub \");\n                buf.append(cpi.authority);\n                buf.append(\": \");\n                buf.append(cpi.name);\n                Log.i(TAG, buf.toString());\n            }\n            IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,\n                    false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);\n            if (cph != null) {\n                cph.noReleaseNeeded = true;\n                results.add(cph);\n            }\n        }\n\n        try {\n            ActivityManagerNative.getDefault().publishContentProviders(\n                getApplicationThread(), results);\n        } catch (RemoteException ex) {\n        }\n    }\n```\n\n总体分为两步，\n\n* installProvider 生成ContentProviderHolder对象\n* publishContentProviders 发布出去\n\n### 2.installProvider\n\n\n```\n                final java.lang.ClassLoader cl = c.getClassLoader();\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n                if (provider == null) {\n                    Slog.e(TAG, \"Failed to instantiate class \" +\n                          info.name + \" from sourceDir \" +\n                          info.applicationInfo.sourceDir);\n                    return null;\n                }\n                if (DEBUG_PROVIDER) Slog.v(\n                    TAG, \"Instantiating local provider \" + info.name);\n                // XXX Need to create the correct context for this provider.\n                localProvider.attachInfo(c, info);\n```\n\n在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现\n\n```\nContentProvider.this.onCreate();\n```\n\n### 3.query操作\n\nContext的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。\n\nquery方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个[理解ContentProvider原理](http://gityuan.com/2016/07/30/content-provider/) \n\n* 获取IContentProvider对象\n* IContentProvider的query方法\n\n\nIContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。\n\n```\n                localProvider = (ContentProvider)cl.\n                    loadClass(info.name).newInstance();\n                provider = localProvider.getIContentProvider();\n```\ncp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"ContentProvider水文(凑四大组件)","published":1,"updated":"2017-01-07T06:57:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy1s000khws6wsklhiqu","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br>这一篇，没营养，凑数用的。</excerpt></p>\n<h3 id=\"1-ActivityThread的main方法\"><a href=\"#1-ActivityThread的main方法\" class=\"headerlink\" title=\"1. ActivityThread的main方法\"></a>1. ActivityThread的main方法</h3><ul>\n<li>我们知道android应用程序的入口是ActivityThread的main方法。</li>\n<li>ContentProvid是何时、何流程，调用的onCreate方法呢？</li>\n</ul>\n<p>ActivityThread的main方法说起。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityThread thread = new ActivityThread();</div><div class=\"line\">thread.attach(false);</div></pre></td></tr></table></figure>\n<p>在main方法中，我们能发现如上代码，attach什么？我们跟进去看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class=\"line\">final IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class=\"line\">try &#123;</div><div class=\"line\">    mgr.attachApplication(mAppThread);</div><div class=\"line\">&#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    // Ignore</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null;</div></pre></td></tr></table></figure>\n<ul>\n<li>app ProcessRecord, 进程相关信息</li>\n<li>ProviderInfo contentprovider信息</li>\n</ul>\n<p>再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!data.restrictedBackupMode) &#123;</div><div class=\"line\">    List&lt;ProviderInfo&gt; providers = data.providers;</div><div class=\"line\">    if (providers != null) &#123;</div><div class=\"line\">        installContentProviders(app, providers);</div><div class=\"line\">        // For process that contains content providers, we want to</div><div class=\"line\">        // ensure that the JIT is enabled &quot;at some point&quot;.</div><div class=\"line\">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void installContentProviders(</div><div class=\"line\">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class=\"line\">    final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</div><div class=\"line\">        new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</div><div class=\"line\"></div><div class=\"line\">    for (ProviderInfo cpi : providers) &#123;</div><div class=\"line\">        if (DEBUG_PROVIDER) &#123;</div><div class=\"line\">            StringBuilder buf = new StringBuilder(128);</div><div class=\"line\">            buf.append(&quot;Pub &quot;);</div><div class=\"line\">            buf.append(cpi.authority);</div><div class=\"line\">            buf.append(&quot;: &quot;);</div><div class=\"line\">            buf.append(cpi.name);</div><div class=\"line\">            Log.i(TAG, buf.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">        IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class=\"line\">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class=\"line\">        if (cph != null) &#123;</div><div class=\"line\">            cph.noReleaseNeeded = true;</div><div class=\"line\">            results.add(cph);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        ActivityManagerNative.getDefault().publishContentProviders(</div><div class=\"line\">            getApplicationThread(), results);</div><div class=\"line\">    &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总体分为两步，</p>\n<ul>\n<li>installProvider 生成ContentProviderHolder对象</li>\n<li>publishContentProviders 发布出去</li>\n</ul>\n<h3 id=\"2-installProvider\"><a href=\"#2-installProvider\" class=\"headerlink\" title=\"2.installProvider\"></a>2.installProvider</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">final java.lang.ClassLoader cl = c.getClassLoader();</div><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div><div class=\"line\">if (provider == null) &#123;</div><div class=\"line\">    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</div><div class=\"line\">          info.name + &quot; from sourceDir &quot; +</div><div class=\"line\">          info.applicationInfo.sourceDir);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div><div class=\"line\">if (DEBUG_PROVIDER) Slog.v(</div><div class=\"line\">    TAG, &quot;Instantiating local provider &quot; + info.name);</div><div class=\"line\">// XXX Need to create the correct context for this provider.</div><div class=\"line\">localProvider.attachInfo(c, info);</div></pre></td></tr></table></figure>\n<p>在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentProvider.this.onCreate();</div></pre></td></tr></table></figure>\n<h3 id=\"3-query操作\"><a href=\"#3-query操作\" class=\"headerlink\" title=\"3.query操作\"></a>3.query操作</h3><p>Context的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。</p>\n<p>query方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个<a href=\"http://gityuan.com/2016/07/30/content-provider/\" target=\"_blank\" rel=\"external\">理解ContentProvider原理</a> </p>\n<ul>\n<li>获取IContentProvider对象</li>\n<li>IContentProvider的query方法</li>\n</ul>\n<p>IContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div></pre></td></tr></table></figure>\n<p>cp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要><br>这一篇，没营养，凑数用的。</p>\n<h3 id=\"1-ActivityThread的main方法\"><a href=\"#1-ActivityThread的main方法\" class=\"headerlink\" title=\"1. ActivityThread的main方法\"></a>1. ActivityThread的main方法</h3><ul>\n<li>我们知道android应用程序的入口是ActivityThread的main方法。</li>\n<li>ContentProvid是何时、何流程，调用的onCreate方法呢？</li>\n</ul>\n<p>ActivityThread的main方法说起。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityThread thread = new ActivityThread();</div><div class=\"line\">thread.attach(false);</div></pre></td></tr></table></figure>\n<p>在main方法中，我们能发现如上代码，attach什么？我们跟进去看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class=\"line\">final IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class=\"line\">try &#123;</div><div class=\"line\">    mgr.attachApplication(mAppThread);</div><div class=\"line\">&#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    // Ignore</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的应用程序，会走这个if分支，从方法名我们能看出来，原来是将ApplicationThread和Applicatin关联起来，我们继续看，在ams的attachApplication方法中，会调用attachApplicationLocked，去做关联。继续看这个方法，会发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null;</div></pre></td></tr></table></figure>\n<ul>\n<li>app ProcessRecord, 进程相关信息</li>\n<li>ProviderInfo contentprovider信息</li>\n</ul>\n<p>再然后，我们会发现，调用ApplicationThread#bindApplication方法，在这个方法中发送消息，我们的H类，调用handleBindApplication去处理。在这个方法中有如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!data.restrictedBackupMode) &#123;</div><div class=\"line\">    List&lt;ProviderInfo&gt; providers = data.providers;</div><div class=\"line\">    if (providers != null) &#123;</div><div class=\"line\">        installContentProviders(app, providers);</div><div class=\"line\">        // For process that contains content providers, we want to</div><div class=\"line\">        // ensure that the JIT is enabled &quot;at some point&quot;.</div><div class=\"line\">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>找了半天，总算看到了相关的内容。这个installContentProviders就是用来装载ContentProvider的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void installContentProviders(</div><div class=\"line\">        Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class=\"line\">    final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</div><div class=\"line\">        new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</div><div class=\"line\"></div><div class=\"line\">    for (ProviderInfo cpi : providers) &#123;</div><div class=\"line\">        if (DEBUG_PROVIDER) &#123;</div><div class=\"line\">            StringBuilder buf = new StringBuilder(128);</div><div class=\"line\">            buf.append(&quot;Pub &quot;);</div><div class=\"line\">            buf.append(cpi.authority);</div><div class=\"line\">            buf.append(&quot;: &quot;);</div><div class=\"line\">            buf.append(cpi.name);</div><div class=\"line\">            Log.i(TAG, buf.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">        IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class=\"line\">                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class=\"line\">        if (cph != null) &#123;</div><div class=\"line\">            cph.noReleaseNeeded = true;</div><div class=\"line\">            results.add(cph);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        ActivityManagerNative.getDefault().publishContentProviders(</div><div class=\"line\">            getApplicationThread(), results);</div><div class=\"line\">    &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总体分为两步，</p>\n<ul>\n<li>installProvider 生成ContentProviderHolder对象</li>\n<li>publishContentProviders 发布出去</li>\n</ul>\n<h3 id=\"2-installProvider\"><a href=\"#2-installProvider\" class=\"headerlink\" title=\"2.installProvider\"></a>2.installProvider</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">final java.lang.ClassLoader cl = c.getClassLoader();</div><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div><div class=\"line\">if (provider == null) &#123;</div><div class=\"line\">    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</div><div class=\"line\">          info.name + &quot; from sourceDir &quot; +</div><div class=\"line\">          info.applicationInfo.sourceDir);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div><div class=\"line\">if (DEBUG_PROVIDER) Slog.v(</div><div class=\"line\">    TAG, &quot;Instantiating local provider &quot; + info.name);</div><div class=\"line\">// XXX Need to create the correct context for this provider.</div><div class=\"line\">localProvider.attachInfo(c, info);</div></pre></td></tr></table></figure>\n<p>在这块的代码中，会生成ContentProvider对象，并且调用attachInfo方法。在attachInfo方法中，我们就能发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentProvider.this.onCreate();</div></pre></td></tr></table></figure>\n<h3 id=\"3-query操作\"><a href=\"#3-query操作\" class=\"headerlink\" title=\"3.query操作\"></a>3.query操作</h3><p>Context的实现类是ContextImpl,通过观察代码，我们能够发现，mContentResolver的类型是ApplicationContentResolver，这个类实现类ContentResolver的一些抽象方法。</p>\n<p>query方法也比较复杂，涉及到应用计数的问题，我看不太懂。建议看这个<a href=\"http://gityuan.com/2016/07/30/content-provider/\">理解ContentProvider原理</a> </p>\n<ul>\n<li>获取IContentProvider对象</li>\n<li>IContentProvider的query方法</li>\n</ul>\n<p>IContentProvider在这里的实现是什么呢？这个在ActivityThread的installProvider方法里能找到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">localProvider = (ContentProvider)cl.</div><div class=\"line\">    loadClass(info.name).newInstance();</div><div class=\"line\">provider = localProvider.getIContentProvider();</div></pre></td></tr></table></figure>\n<p>cp的getIContentProvider返回mTransport，是一个Transport的实例，在它的query方法中，调用了cp的query。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"LruCache源码浅析","date":"2017-01-12T16:00:14.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n(LRU)Least Recently Used,最近最少使用算法，其中LruCache便是其在的实现，也是今天的主角，它被用在各种各样的图片库中，我们当然有必要去了解他是如何实现的。源码非常简单，但是能看到许多非常有意思的地方。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 如何使用\n\n```\n   int cacheSize = 4 * 1024 * 1024; // 4MiB\n   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {\n        protected int sizeOf(String key, Bitmap value) {\n            return value.getByteCount();\n        }\n    }}\n```\n\n初始化之后，便可放心的put、get了。很简单，不多说。\n\n### 初始化过程\n\n```\n    public LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n\n短短的几行代码，却有一个地方需要注意，LinkedHashMap传入的第三个参数，true。这是由含义的，这个参数表示，我们在访问的时候，会根据时间进行排序，厉害吧。\n\n### get过程\n\n```\n    public final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                hitCount++;\n                return mapValue;\n            }\n            missCount++;\n        }\n\n        /*\n         * Attempt to create a value. This may take a long time, and the map\n         * may be different when create() returns. If a conflicting value was\n         * added to the map while create() was working, we leave that value in\n         * the map and release the created value.\n         */\n\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            if (mapValue != null) {\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n\n* 首先，根据key获取value，根据结果修改对应的命中还是未命中\n* 如果没有找到，就会调用create方法去创建一个value，当然，如果我们没有实现这个方法的话，默认返回null\n* 如果实现了的话，会用put方法，把这个值丢进去，这个方法的返回结果，如果存在hash冲突(也就是已经有了同一hash值对应的value)，返回原有的value，并且撤销操作(通过将原值重新put进去)，不存在hash冲突，则调整我们当前已用size\n* 存在hash冲突的情况下，entryRemoved去做一些操作，需要我们实现，不存在hash冲突，就调整size\n\n### put过程\n\n```\n    public final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key == null || value == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            putCount++;\n            size += safeSizeOf(key, value);\n            previous = map.put(key, value);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n```\n\n这个过程就简单点了\n\n* 调整size\n* put值进去，如果存在hash冲突，返回原有的值\n* 如果previous，即原来有值，调整size\n* 如果原来有值，则调用entryRemoved去做一些释放操作，需要我们实现\n* 最后，调整size大小\n\n### 调整size过程\n\n```\n    public void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.eldest();\n                if (toEvict == null) {\n                    break;\n                }\n\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n\n调整size的过程呢，就是不断重map中取出头，进行销毁释放(entryRemoved),直到容量小于我们的初始化时给定的值。\n\n### remove操作\n\n```\n    public final V remove(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            previous = map.remove(key);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, null);\n        }\n\n        return previous;\n    }\n```\n\n* map中移除\n* 销毁\n\n### 总结\n\n代码补偿，实现也简单清晰，但是却非常巧妙，有许多值得我们学习的地方。而那么多count，就是用来统计命中率啥的。\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/LruCache源码浅析.md","raw":"---\ntitle: LruCache源码浅析\ndate: 2017-01-13 00:00:14\ncategories: Android\ntags: 源码\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n(LRU)Least Recently Used,最近最少使用算法，其中LruCache便是其在的实现，也是今天的主角，它被用在各种各样的图片库中，我们当然有必要去了解他是如何实现的。源码非常简单，但是能看到许多非常有意思的地方。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 如何使用\n\n```\n   int cacheSize = 4 * 1024 * 1024; // 4MiB\n   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {\n        protected int sizeOf(String key, Bitmap value) {\n            return value.getByteCount();\n        }\n    }}\n```\n\n初始化之后，便可放心的put、get了。很简单，不多说。\n\n### 初始化过程\n\n```\n    public LruCache(int maxSize) {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize <= 0\");\n        }\n        this.maxSize = maxSize;\n        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n    }\n```\n\n短短的几行代码，却有一个地方需要注意，LinkedHashMap传入的第三个参数，true。这是由含义的，这个参数表示，我们在访问的时候，会根据时间进行排序，厉害吧。\n\n### get过程\n\n```\n    public final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V mapValue;\n        synchronized (this) {\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                hitCount++;\n                return mapValue;\n            }\n            missCount++;\n        }\n\n        /*\n         * Attempt to create a value. This may take a long time, and the map\n         * may be different when create() returns. If a conflicting value was\n         * added to the map while create() was working, we leave that value in\n         * the map and release the created value.\n         */\n\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            if (mapValue != null) {\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n```\n\n* 首先，根据key获取value，根据结果修改对应的命中还是未命中\n* 如果没有找到，就会调用create方法去创建一个value，当然，如果我们没有实现这个方法的话，默认返回null\n* 如果实现了的话，会用put方法，把这个值丢进去，这个方法的返回结果，如果存在hash冲突(也就是已经有了同一hash值对应的value)，返回原有的value，并且撤销操作(通过将原值重新put进去)，不存在hash冲突，则调整我们当前已用size\n* 存在hash冲突的情况下，entryRemoved去做一些操作，需要我们实现，不存在hash冲突，就调整size\n\n### put过程\n\n```\n    public final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key == null || value == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            putCount++;\n            size += safeSizeOf(key, value);\n            previous = map.put(key, value);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n```\n\n这个过程就简单点了\n\n* 调整size\n* put值进去，如果存在hash冲突，返回原有的值\n* 如果previous，即原来有值，调整size\n* 如果原来有值，则调用entryRemoved去做一些释放操作，需要我们实现\n* 最后，调整size大小\n\n### 调整size过程\n\n```\n    public void trimToSize(int maxSize) {\n        while (true) {\n            K key;\n            V value;\n            synchronized (this) {\n                if (size < 0 || (map.isEmpty() && size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + \".sizeOf() is reporting inconsistent results!\");\n                }\n\n                if (size <= maxSize) {\n                    break;\n                }\n\n                Map.Entry<K, V> toEvict = map.eldest();\n                if (toEvict == null) {\n                    break;\n                }\n\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                map.remove(key);\n                size -= safeSizeOf(key, value);\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n```\n\n调整size的过程呢，就是不断重map中取出头，进行销毁释放(entryRemoved),直到容量小于我们的初始化时给定的值。\n\n### remove操作\n\n```\n    public final V remove(K key) {\n        if (key == null) {\n            throw new NullPointerException(\"key == null\");\n        }\n\n        V previous;\n        synchronized (this) {\n            previous = map.remove(key);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, null);\n        }\n\n        return previous;\n    }\n```\n\n* map中移除\n* 销毁\n\n### 总结\n\n代码补偿，实现也简单清晰，但是却非常巧妙，有许多值得我们学习的地方。而那么多count，就是用来统计命中率啥的。\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"LruCache源码浅析","published":1,"updated":"2017-01-12T16:01:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy1v000phws63rf9lk5b","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>(LRU)Least Recently Used,最近最少使用算法，其中LruCache便是其在的实现，也是今天的主角，它被用在各种各样的图片库中，我们当然有必要去了解他是如何实现的。源码非常简单，但是能看到许多非常有意思的地方。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">int cacheSize = 4 * 1024 * 1024; // 4MiB</div><div class=\"line\">LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class=\"line\">     protected int sizeOf(String key, Bitmap value) &#123;</div><div class=\"line\">         return value.getByteCount();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;&#125;</div></pre></td></tr></table></figure>\n<p>初始化之后，便可放心的put、get了。很简单，不多说。</p>\n<h3 id=\"初始化过程\"><a href=\"#初始化过程\" class=\"headerlink\" title=\"初始化过程\"></a>初始化过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public LruCache(int maxSize) &#123;</div><div class=\"line\">    if (maxSize &lt;= 0) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.maxSize = maxSize;</div><div class=\"line\">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>短短的几行代码，却有一个地方需要注意，LinkedHashMap传入的第三个参数，true。这是由含义的，这个参数表示，我们在访问的时候，会根据时间进行排序，厉害吧。</p>\n<h3 id=\"get过程\"><a href=\"#get过程\" class=\"headerlink\" title=\"get过程\"></a>get过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V get(K key) &#123;</div><div class=\"line\">    if (key == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V mapValue;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        if (mapValue != null) &#123;</div><div class=\"line\">            hitCount++;</div><div class=\"line\">            return mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Attempt to create a value. This may take a long time, and the map</div><div class=\"line\">     * may be different when create() returns. If a conflicting value was</div><div class=\"line\">     * added to the map while create() was working, we leave that value in</div><div class=\"line\">     * the map and release the created value.</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    if (createdValue == null) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        createCount++;</div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\"></div><div class=\"line\">        if (mapValue != null) &#123;</div><div class=\"line\">            // There was a conflict so undo that last put</div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mapValue != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, createdValue, mapValue);</div><div class=\"line\">        return mapValue;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        return createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，根据key获取value，根据结果修改对应的命中还是未命中</li>\n<li>如果没有找到，就会调用create方法去创建一个value，当然，如果我们没有实现这个方法的话，默认返回null</li>\n<li>如果实现了的话，会用put方法，把这个值丢进去，这个方法的返回结果，如果存在hash冲突(也就是已经有了同一hash值对应的value)，返回原有的value，并且撤销操作(通过将原值重新put进去)，不存在hash冲突，则调整我们当前已用size</li>\n<li>存在hash冲突的情况下，entryRemoved去做一些操作，需要我们实现，不存在hash冲突，就调整size</li>\n</ul>\n<h3 id=\"put过程\"><a href=\"#put过程\" class=\"headerlink\" title=\"put过程\"></a>put过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V put(K key, V value) &#123;</div><div class=\"line\">    if (key == null || value == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null || value == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        putCount++;</div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        if (previous != null) &#123;</div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (previous != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">    return previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个过程就简单点了</p>\n<ul>\n<li>调整size</li>\n<li>put值进去，如果存在hash冲突，返回原有的值</li>\n<li>如果previous，即原来有值，调整size</li>\n<li>如果原来有值，则调用entryRemoved去做一些释放操作，需要我们实现</li>\n<li>最后，调整size大小</li>\n</ul>\n<h3 id=\"调整size过程\"><a href=\"#调整size过程\" class=\"headerlink\" title=\"调整size过程\"></a>调整size过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void trimToSize(int maxSize) &#123;</div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</div><div class=\"line\">                throw new IllegalStateException(getClass().getName()</div><div class=\"line\">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (size &lt;= maxSize) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</div><div class=\"line\">            if (toEvict == null) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        entryRemoved(true, key, value, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调整size的过程呢，就是不断重map中取出头，进行销毁释放(entryRemoved),直到容量小于我们的初始化时给定的值。</p>\n<h3 id=\"remove操作\"><a href=\"#remove操作\" class=\"headerlink\" title=\"remove操作\"></a>remove操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V remove(K key) &#123;</div><div class=\"line\">    if (key == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        previous = map.remove(key);</div><div class=\"line\">        if (previous != null) &#123;</div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (previous != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, previous, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>map中移除</li>\n<li>销毁</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>代码补偿，实现也简单清晰，但是却非常巧妙，有许多值得我们学习的地方。而那么多count，就是用来统计命中率啥的。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>(LRU)Least Recently Used,最近最少使用算法，其中LruCache便是其在的实现，也是今天的主角，它被用在各种各样的图片库中，我们当然有必要去了解他是如何实现的。源码非常简单，但是能看到许多非常有意思的地方。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">int cacheSize = 4 * 1024 * 1024; // 4MiB</div><div class=\"line\">LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class=\"line\">     protected int sizeOf(String key, Bitmap value) &#123;</div><div class=\"line\">         return value.getByteCount();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;&#125;</div></pre></td></tr></table></figure>\n<p>初始化之后，便可放心的put、get了。很简单，不多说。</p>\n<h3 id=\"初始化过程\"><a href=\"#初始化过程\" class=\"headerlink\" title=\"初始化过程\"></a>初始化过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public LruCache(int maxSize) &#123;</div><div class=\"line\">    if (maxSize &lt;= 0) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.maxSize = maxSize;</div><div class=\"line\">    this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>短短的几行代码，却有一个地方需要注意，LinkedHashMap传入的第三个参数，true。这是由含义的，这个参数表示，我们在访问的时候，会根据时间进行排序，厉害吧。</p>\n<h3 id=\"get过程\"><a href=\"#get过程\" class=\"headerlink\" title=\"get过程\"></a>get过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V get(K key) &#123;</div><div class=\"line\">    if (key == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V mapValue;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        if (mapValue != null) &#123;</div><div class=\"line\">            hitCount++;</div><div class=\"line\">            return mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Attempt to create a value. This may take a long time, and the map</div><div class=\"line\">     * may be different when create() returns. If a conflicting value was</div><div class=\"line\">     * added to the map while create() was working, we leave that value in</div><div class=\"line\">     * the map and release the created value.</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    if (createdValue == null) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        createCount++;</div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\"></div><div class=\"line\">        if (mapValue != null) &#123;</div><div class=\"line\">            // There was a conflict so undo that last put</div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mapValue != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, createdValue, mapValue);</div><div class=\"line\">        return mapValue;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        return createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，根据key获取value，根据结果修改对应的命中还是未命中</li>\n<li>如果没有找到，就会调用create方法去创建一个value，当然，如果我们没有实现这个方法的话，默认返回null</li>\n<li>如果实现了的话，会用put方法，把这个值丢进去，这个方法的返回结果，如果存在hash冲突(也就是已经有了同一hash值对应的value)，返回原有的value，并且撤销操作(通过将原值重新put进去)，不存在hash冲突，则调整我们当前已用size</li>\n<li>存在hash冲突的情况下，entryRemoved去做一些操作，需要我们实现，不存在hash冲突，就调整size</li>\n</ul>\n<h3 id=\"put过程\"><a href=\"#put过程\" class=\"headerlink\" title=\"put过程\"></a>put过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V put(K key, V value) &#123;</div><div class=\"line\">    if (key == null || value == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null || value == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        putCount++;</div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        if (previous != null) &#123;</div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (previous != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">    return previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个过程就简单点了</p>\n<ul>\n<li>调整size</li>\n<li>put值进去，如果存在hash冲突，返回原有的值</li>\n<li>如果previous，即原来有值，调整size</li>\n<li>如果原来有值，则调用entryRemoved去做一些释放操作，需要我们实现</li>\n<li>最后，调整size大小</li>\n</ul>\n<h3 id=\"调整size过程\"><a href=\"#调整size过程\" class=\"headerlink\" title=\"调整size过程\"></a>调整size过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void trimToSize(int maxSize) &#123;</div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</div><div class=\"line\">                throw new IllegalStateException(getClass().getName()</div><div class=\"line\">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (size &lt;= maxSize) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</div><div class=\"line\">            if (toEvict == null) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        entryRemoved(true, key, value, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调整size的过程呢，就是不断重map中取出头，进行销毁释放(entryRemoved),直到容量小于我们的初始化时给定的值。</p>\n<h3 id=\"remove操作\"><a href=\"#remove操作\" class=\"headerlink\" title=\"remove操作\"></a>remove操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V remove(K key) &#123;</div><div class=\"line\">    if (key == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;key == null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        previous = map.remove(key);</div><div class=\"line\">        if (previous != null) &#123;</div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (previous != null) &#123;</div><div class=\"line\">        entryRemoved(false, key, previous, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>map中移除</li>\n<li>销毁</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>代码补偿，实现也简单清晰，但是却非常巧妙，有许多值得我们学习的地方。而那么多count，就是用来统计命中率啥的。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"JNI学习笔记（三）－编译文件makefile以及cmake","date":"2016-11-29T10:38:27.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. Android.mk\n\nAndroid.mk在jni目录下，用于描述构建系统的源文件以及\nshared libraries 。文件格式如下：\n\n* 以LOCAL_PATH变量开始 \n\n\n\n\t```\nLOCAL_PATH := $(call my-dir)\n```\n* 紧接着是CLEAR_VARS变量 \n\n\t```\n\tinclude $(CLEAR_VARS) \n\t```\n* 接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。\n* 接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如\n\n\t```\n\tLOCAL_SRC_FILES := hello-jni.c \n\t```\n* 最后一行是帮助构建系统联系在一起的。\n\n\t```\ninclude $(BUILD_SHARED_LIBRARY) \n```\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := hello-jni\n\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。\n\n构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：\n\n* 以LOCAL_开始，如LOCAL_MODULE\n* 以PRIVATE_, NDK_, or APP \n* 小写字母，如 my-di\n\n如果要自定义的话，建议MY_开头。\n\n#### 2.1 NDK 默认的变量\n\n* CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 \n\n\t```\ninclude $(CLEAR_VARS) \n```\n* BUILD_SHARED_LIBRARY,告诉构建系统去收集声明的LOCAL_变量的值，然后输出成so \n\n\t```\ninclude $(BUILD_SHARED_LIBRARY)\n```\n* BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a \n\n\t```\ninclude $(BUILD_STATIC_LIBRARY) \n```\n* PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 \n\n\t```\n\tinclude $(PREBUILT_SHARED_LIBRARY) \n\t```\n* PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似\n* TARGET_ARCH 略，重点看TARGET_ARCH_ABI\n* TARGET_PLATFORM 指定当前编译的android api版本 \n\n\t```\nTARGET_PLATFORM := android-22\n```\n* TARGET_ARCH_ABI 指定cpu架构，\n\n\t```\nTARGET_ARCH_ABI := arm64-v8a\n```\n* TARGET_ABI，指定android api版本鱼abi架构\n* \n\t```\n\tTARGET_ABI := android-22-arm64-v8a\n\t```\n\n#### 2.2 Module-Description Variables 描述model的变量\n\n*  LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 \n\n\n\t\n\t```\n\tLOCAL_PATH := $(call my-dir)\n\t\n\t```\n\t注意CLEAR_VARS，并不会清除这个的值\n* LOCAL_MODULE \n* LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字\n* LOCAL_SRC_FILES 指定这个model对应的原文件\n* LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他\n* LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),\n\n\t```\n\tLOCAL_CPP_FEATURES := rtti\n\t```\n* LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径\n* LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项\n* LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries\n* LOCAL_WHOLE_STATIC_LIBRARIES  整个。\n* LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so \n\n\t```\n\tLOCAL_LDLIBS := -lz \n\t```\n* LOCAL_LDFLAGS 略，没看明白\n* LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。\n* 剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。\n\n### 3. Application.mk\n\n用于描述app需要的native model。\n\n#### 3.1 变量\n\n* APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。\n* APP_OPTIM 配置release和debug\n* APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件\n* APP_CPPFLAGS 和 APP_CFLAGS类似\n* APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效\n* APP_BUILD_SCRIPT 指定Android.mk文件\n* APP_ABI 指定abi\n* APP_PLATFORM 指定android api版本\n* APP_STL 链接其他的c＋＋支持\n* NDK_TOOLCHAIN_VERSION  gcc编译版本\n* APP_PIE \n* APP_THIN_ARCHIVE\n\n\n### 4.在Android Studio中使用 \n\n要求 Android Studio 2.2 以上。\n\n在gradle中，\n\n```\nandroid {\n  defaultConfig {  \n    externalNativeBuild {\n      cmake {\n        // 设置cmake参数 \"-DVAR_NAME=VALUE\"\n        arguments \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_TOOLCHAIN=clang\"\n      }\n    }\n    // 设置 abi\n    ndk {\n            abiFilters \"armeabi\",\"x86\",\"armeabi-v7a\"\n        }\n  }\n  buildTypes {...}\n  \n  externalNativeBuild {\n    cmake {\n    \t// CMakeLists.txt 文件路径\n    \tpath 'src/main/jni/CMakeLists.txt' \n    }\n  }\n}\n```\n\n我们需要编写的就是上面三处有注释的地方。\n\n* cmake参数 格式为 -D + Variable name ＝ Arguments 的形势\n\t* ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种\n\t* ANDROID_PLATFORM target Android platform\n\t* ANDROID_STL  cmake编译时用哪个stl，有以下种类[Helper Runtimes](https://developer.android.com/ndk/guides/cpp-support.html#hr)\n\t* ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。\n\t* ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions\n\t* ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。\n\t* ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb\n\t* NDROID_ARM_NEON build native lib 是否NONE支持\n\t* ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过\n\t* ANDROID_DISABLE_RELRO 是否只读\n\t* ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。\n* ndk abifilters\n* cmake path\n\n关于cmake 参数，[官方文档](https://developer.android.com/ndk/guides/cmake.html)\n\n### 5. CMakeLists.txt 编写\n\n\n* cmake 最小版本 ```\n\tcmake_minimum_required(VERSION 3.4.1)\t\n\t``` \n\t\t\n* \n\t```\nadd_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)\n```\n* 指定头文件路径 \n\n\t```\ninclude_directories(src/main/cpp/include/)\n``` \n\n#### 5.1 添加native api\n\n```\nfind_library( # Defines the name of the path variable that stores the\n              # location of the NDK library.\n              log-lib\n\n              # Specifies the name of the NDK library that\n              # CMake needs to locate.\n              log )\n```\n\n按照我个人的理解，\n\n* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。\n* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name\n\n然后使用target_link_libraries(native-lib,${log-lib}) 去链接咱们的本地库和ndk中带的本地库，\n\n_ _ _\n\n也可以将源代码添加进来，\n\n```\nadd_library( app-glue\n             STATIC\n             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )\n```\n* lib name\n* 类型\n* 文件路径\n\n\n#### 5.2 添加其他预先构建的libraries\n\n因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project\n\n```\nadd_library( imported-lib\n             SHARED\n             IMPORTED )\n```\n\n然后需要用set_target_properties去指定路径。\n\n```\nset_target_properties( # Specifies the target library.\n                       imported-lib\n\n                       # Specifies the parameter you want to define.\n                       PROPERTIES IMPORTED_LOCATION\n\n                       # Provides the path to the library you want to import.\n                       imported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n```\n\n* lib name\n* 指定参数\n* 指定so的路径\n\n这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。\n\n\n### 6. 总结\n有理解的不对的，大家指出，共同学习共同进步。\n\n\n\n\n\n\n\n\n\n\n\n\n_ _ _\n\n参考资料：\n\n* [Android.mk、文档](https://developer.android.com/ndk/guides/android_mk.html)\n* [Application.mk 文档](https://developer.android.com/ndk/guides/application_mk.html)\n* [Android 文档cmake 文档](https://developer.android.com/ndk/guides/cmake.html)\n* [Android studio 中介绍](https://developer.android.com/studio/projects/add-native-code.html#existing-project)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/JNI学习笔记（三）－编译文件makefile以及cmake.md","raw":"---\ntitle: JNI学习笔记（三）－编译文件makefile以及cmake\ndate: 2016-11-29 18:38:27\ncategories: Android\ntags: jni\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. Android.mk\n\nAndroid.mk在jni目录下，用于描述构建系统的源文件以及\nshared libraries 。文件格式如下：\n\n* 以LOCAL_PATH变量开始 \n\n\n\n\t```\nLOCAL_PATH := $(call my-dir)\n```\n* 紧接着是CLEAR_VARS变量 \n\n\t```\n\tinclude $(CLEAR_VARS) \n\t```\n* 接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。\n* 接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如\n\n\t```\n\tLOCAL_SRC_FILES := hello-jni.c \n\t```\n* 最后一行是帮助构建系统联系在一起的。\n\n\t```\ninclude $(BUILD_SHARED_LIBRARY) \n```\n\n```\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := hello-jni\n\nLOCAL_SRC_FILES := hello.cpp\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。\n\n构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：\n\n* 以LOCAL_开始，如LOCAL_MODULE\n* 以PRIVATE_, NDK_, or APP \n* 小写字母，如 my-di\n\n如果要自定义的话，建议MY_开头。\n\n#### 2.1 NDK 默认的变量\n\n* CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 \n\n\t```\ninclude $(CLEAR_VARS) \n```\n* BUILD_SHARED_LIBRARY,告诉构建系统去收集声明的LOCAL_变量的值，然后输出成so \n\n\t```\ninclude $(BUILD_SHARED_LIBRARY)\n```\n* BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a \n\n\t```\ninclude $(BUILD_STATIC_LIBRARY) \n```\n* PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 \n\n\t```\n\tinclude $(PREBUILT_SHARED_LIBRARY) \n\t```\n* PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似\n* TARGET_ARCH 略，重点看TARGET_ARCH_ABI\n* TARGET_PLATFORM 指定当前编译的android api版本 \n\n\t```\nTARGET_PLATFORM := android-22\n```\n* TARGET_ARCH_ABI 指定cpu架构，\n\n\t```\nTARGET_ARCH_ABI := arm64-v8a\n```\n* TARGET_ABI，指定android api版本鱼abi架构\n* \n\t```\n\tTARGET_ABI := android-22-arm64-v8a\n\t```\n\n#### 2.2 Module-Description Variables 描述model的变量\n\n*  LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 \n\n\n\t\n\t```\n\tLOCAL_PATH := $(call my-dir)\n\t\n\t```\n\t注意CLEAR_VARS，并不会清除这个的值\n* LOCAL_MODULE \n* LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字\n* LOCAL_SRC_FILES 指定这个model对应的原文件\n* LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他\n* LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),\n\n\t```\n\tLOCAL_CPP_FEATURES := rtti\n\t```\n* LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径\n* LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项\n* LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries\n* LOCAL_WHOLE_STATIC_LIBRARIES  整个。\n* LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so \n\n\t```\n\tLOCAL_LDLIBS := -lz \n\t```\n* LOCAL_LDFLAGS 略，没看明白\n* LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。\n* 剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。\n\n### 3. Application.mk\n\n用于描述app需要的native model。\n\n#### 3.1 变量\n\n* APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。\n* APP_OPTIM 配置release和debug\n* APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件\n* APP_CPPFLAGS 和 APP_CFLAGS类似\n* APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效\n* APP_BUILD_SCRIPT 指定Android.mk文件\n* APP_ABI 指定abi\n* APP_PLATFORM 指定android api版本\n* APP_STL 链接其他的c＋＋支持\n* NDK_TOOLCHAIN_VERSION  gcc编译版本\n* APP_PIE \n* APP_THIN_ARCHIVE\n\n\n### 4.在Android Studio中使用 \n\n要求 Android Studio 2.2 以上。\n\n在gradle中，\n\n```\nandroid {\n  defaultConfig {  \n    externalNativeBuild {\n      cmake {\n        // 设置cmake参数 \"-DVAR_NAME=VALUE\"\n        arguments \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_TOOLCHAIN=clang\"\n      }\n    }\n    // 设置 abi\n    ndk {\n            abiFilters \"armeabi\",\"x86\",\"armeabi-v7a\"\n        }\n  }\n  buildTypes {...}\n  \n  externalNativeBuild {\n    cmake {\n    \t// CMakeLists.txt 文件路径\n    \tpath 'src/main/jni/CMakeLists.txt' \n    }\n  }\n}\n```\n\n我们需要编写的就是上面三处有注释的地方。\n\n* cmake参数 格式为 -D + Variable name ＝ Arguments 的形势\n\t* ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种\n\t* ANDROID_PLATFORM target Android platform\n\t* ANDROID_STL  cmake编译时用哪个stl，有以下种类[Helper Runtimes](https://developer.android.com/ndk/guides/cpp-support.html#hr)\n\t* ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。\n\t* ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions\n\t* ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。\n\t* ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb\n\t* NDROID_ARM_NEON build native lib 是否NONE支持\n\t* ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过\n\t* ANDROID_DISABLE_RELRO 是否只读\n\t* ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。\n* ndk abifilters\n* cmake path\n\n关于cmake 参数，[官方文档](https://developer.android.com/ndk/guides/cmake.html)\n\n### 5. CMakeLists.txt 编写\n\n\n* cmake 最小版本 ```\n\tcmake_minimum_required(VERSION 3.4.1)\t\n\t``` \n\t\t\n* \n\t```\nadd_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)\n```\n* 指定头文件路径 \n\n\t```\ninclude_directories(src/main/cpp/include/)\n``` \n\n#### 5.1 添加native api\n\n```\nfind_library( # Defines the name of the path variable that stores the\n              # location of the NDK library.\n              log-lib\n\n              # Specifies the name of the NDK library that\n              # CMake needs to locate.\n              log )\n```\n\n按照我个人的理解，\n\n* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。\n* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name\n\n然后使用target_link_libraries(native-lib,${log-lib}) 去链接咱们的本地库和ndk中带的本地库，\n\n_ _ _\n\n也可以将源代码添加进来，\n\n```\nadd_library( app-glue\n             STATIC\n             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )\n```\n* lib name\n* 类型\n* 文件路径\n\n\n#### 5.2 添加其他预先构建的libraries\n\n因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project\n\n```\nadd_library( imported-lib\n             SHARED\n             IMPORTED )\n```\n\n然后需要用set_target_properties去指定路径。\n\n```\nset_target_properties( # Specifies the target library.\n                       imported-lib\n\n                       # Specifies the parameter you want to define.\n                       PROPERTIES IMPORTED_LOCATION\n\n                       # Provides the path to the library you want to import.\n                       imported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n```\n\n* lib name\n* 指定参数\n* 指定so的路径\n\n这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。\n\n\n### 6. 总结\n有理解的不对的，大家指出，共同学习共同进步。\n\n\n\n\n\n\n\n\n\n\n\n\n_ _ _\n\n参考资料：\n\n* [Android.mk、文档](https://developer.android.com/ndk/guides/android_mk.html)\n* [Application.mk 文档](https://developer.android.com/ndk/guides/application_mk.html)\n* [Android 文档cmake 文档](https://developer.android.com/ndk/guides/cmake.html)\n* [Android studio 中介绍](https://developer.android.com/studio/projects/add-native-code.html#existing-project)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"JNI学习笔记（三）－编译文件makefile以及cmake","published":1,"updated":"2017-01-07T06:58:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy1y000shws600aawelc","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。<br><a id=\"more\"></a></p>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"2-Android-mk\"><a href=\"#2-Android-mk\" class=\"headerlink\" title=\"2. Android.mk\"></a>2. Android.mk</h3><p>Android.mk在jni目录下，用于描述构建系统的源文件以及<br>shared libraries 。文件格式如下：</p>\n<ul>\n<li>以LOCAL_PATH变量开始 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><p>紧接着是CLEAR_VARS变量 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。</p>\n</li>\n<li><p>接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div></pre></td></tr></table></figure>\n</li>\n<li><p>最后一行是帮助构建系统联系在一起的。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。</p>\n<p>构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：</p>\n<ul>\n<li>以LOCAL_开始，如LOCAL_MODULE</li>\n<li>以PRIVATE<em>, NDK</em>, or APP </li>\n<li>小写字母，如 my-di</li>\n</ul>\n<p>如果要自定义的话，建议MY_开头。</p>\n<h4 id=\"2-1-NDK-默认的变量\"><a href=\"#2-1-NDK-默认的变量\" class=\"headerlink\" title=\"2.1 NDK 默认的变量\"></a>2.1 NDK 默认的变量</h4><ul>\n<li><p>CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_SHARED<em>LIBRARY,告诉构建系统去收集声明的LOCAL</em>变量的值，然后输出成so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_STATIC_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(PREBUILT_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似</p>\n</li>\n<li>TARGET_ARCH 略，重点看TARGET_ARCH_ABI</li>\n<li><p>TARGET_PLATFORM 指定当前编译的android api版本 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_PLATFORM := android-22</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ARCH_ABI 指定cpu架构，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ARCH_ABI := arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ABI，指定android api版本鱼abi架构</p>\n</li>\n<li>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ABI := android-22-arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-2-Module-Description-Variables-描述model的变量\"><a href=\"#2-2-Module-Description-Variables-描述model的变量\" class=\"headerlink\" title=\"2.2 Module-Description Variables 描述model的变量\"></a>2.2 Module-Description Variables 描述model的变量</h4><ul>\n<li>LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n\n注意CLEAR_VARS，并不会清除这个的值\n</code></pre><ul>\n<li>LOCAL_MODULE </li>\n<li>LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字</li>\n<li>LOCAL_SRC_FILES 指定这个model对应的原文件</li>\n<li>LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他</li>\n<li><p>LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_CPP_FEATURES := rtti</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径</p>\n</li>\n<li>LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项</li>\n<li>LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries</li>\n<li>LOCAL_WHOLE_STATIC_LIBRARIES  整个。</li>\n<li><p>LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_LDLIBS := -lz</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_LDFLAGS 略，没看明白</p>\n</li>\n<li>LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。</li>\n<li>剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。</li>\n</ul>\n<h3 id=\"3-Application-mk\"><a href=\"#3-Application-mk\" class=\"headerlink\" title=\"3. Application.mk\"></a>3. Application.mk</h3><p>用于描述app需要的native model。</p>\n<h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><ul>\n<li>APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。</li>\n<li>APP_OPTIM 配置release和debug</li>\n<li>APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件</li>\n<li>APP_CPPFLAGS 和 APP_CFLAGS类似</li>\n<li>APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效</li>\n<li>APP_BUILD_SCRIPT 指定Android.mk文件</li>\n<li>APP_ABI 指定abi</li>\n<li>APP_PLATFORM 指定android api版本</li>\n<li>APP_STL 链接其他的c＋＋支持</li>\n<li>NDK_TOOLCHAIN_VERSION  gcc编译版本</li>\n<li>APP_PIE </li>\n<li>APP_THIN_ARCHIVE</li>\n</ul>\n<h3 id=\"4-在Android-Studio中使用\"><a href=\"#4-在Android-Studio中使用\" class=\"headerlink\" title=\"4.在Android Studio中使用\"></a>4.在Android Studio中使用</h3><p>要求 Android Studio 2.2 以上。</p>\n<p>在gradle中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">  defaultConfig &#123;  </div><div class=\"line\">    externalNativeBuild &#123;</div><div class=\"line\">      cmake &#123;</div><div class=\"line\">        // 设置cmake参数 &quot;-DVAR_NAME=VALUE&quot;</div><div class=\"line\">        arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DANDROID_TOOLCHAIN=clang&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 设置 abi</div><div class=\"line\">    ndk &#123;</div><div class=\"line\">            abiFilters &quot;armeabi&quot;,&quot;x86&quot;,&quot;armeabi-v7a&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  buildTypes &#123;...&#125;</div><div class=\"line\">  </div><div class=\"line\">  externalNativeBuild &#123;</div><div class=\"line\">    cmake &#123;</div><div class=\"line\">    \t// CMakeLists.txt 文件路径</div><div class=\"line\">    \tpath &apos;src/main/jni/CMakeLists.txt&apos; </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要编写的就是上面三处有注释的地方。</p>\n<ul>\n<li>cmake参数 格式为 -D + Variable name ＝ Arguments 的形势<ul>\n<li>ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种</li>\n<li>ANDROID_PLATFORM target Android platform</li>\n<li>ANDROID_STL  cmake编译时用哪个stl，有以下种类<a href=\"https://developer.android.com/ndk/guides/cpp-support.html#hr\" target=\"_blank\" rel=\"external\">Helper Runtimes</a></li>\n<li>ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。</li>\n<li>ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions</li>\n<li>ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。</li>\n<li>ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb</li>\n<li>NDROID_ARM_NEON build native lib 是否NONE支持</li>\n<li>ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过</li>\n<li>ANDROID_DISABLE_RELRO 是否只读</li>\n<li>ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。</li>\n</ul>\n</li>\n<li>ndk abifilters</li>\n<li>cmake path</li>\n</ul>\n<p>关于cmake 参数，<a href=\"https://developer.android.com/ndk/guides/cmake.html\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<h3 id=\"5-CMakeLists-txt-编写\"><a href=\"#5-CMakeLists-txt-编写\" class=\"headerlink\" title=\"5. CMakeLists.txt 编写\"></a>5. CMakeLists.txt 编写</h3><ul>\n<li>cmake 最小版本 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tcmake_minimum_required(VERSION 3.4.1)\t</div><div class=\"line\">\t``` </div><div class=\"line\">\t\t</div><div class=\"line\">*</div></pre></td></tr></table></figure></li>\n</ul>\n<p>add_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* 指定头文件路径</div></pre></td></tr></table></figure></p>\n<p>include_directories(src/main/cpp/include/)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 5.1 添加native api</div></pre></td></tr></table></figure></p>\n<p>find_library( # Defines the name of the path variable that stores the</p>\n<pre><code># location of the NDK library.\nlog-lib\n\n# Specifies the name of the NDK library that\n# CMake needs to locate.\nlog )\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">按照我个人的理解，</div><div class=\"line\"></div><div class=\"line\">* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。</div><div class=\"line\">* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name</div><div class=\"line\"></div><div class=\"line\">然后使用target_link_libraries(native-lib,$&#123;log-lib&#125;) 去链接咱们的本地库和ndk中带的本地库，</div><div class=\"line\"></div><div class=\"line\">_ _ _</div><div class=\"line\"></div><div class=\"line\">也可以将源代码添加进来，</div></pre></td></tr></table></figure>\n<p>add_library( app-glue<br>             STATIC<br>             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">* lib name</div><div class=\"line\">* 类型</div><div class=\"line\">* 文件路径</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 5.2 添加其他预先构建的libraries</div><div class=\"line\"></div><div class=\"line\">因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project</div></pre></td></tr></table></figure></p>\n<p>add_library( imported-lib<br>             SHARED<br>             IMPORTED )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后需要用set_target_properties去指定路径。</div></pre></td></tr></table></figure></p>\n<p>set_target_properties( # Specifies the target library.<br>                       imported-lib</p>\n<pre><code># Specifies the parameter you want to define.\nPROPERTIES IMPORTED_LOCATION\n\n# Provides the path to the library you want to import.\nimported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n</code></pre><p>```</p>\n<ul>\n<li>lib name</li>\n<li>指定参数</li>\n<li>指定so的路径</li>\n</ul>\n<p>这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>有理解的不对的，大家指出，共同学习共同进步。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/ndk/guides/android_mk.html\" target=\"_blank\" rel=\"external\">Android.mk、文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/application_mk.html\" target=\"_blank\" rel=\"external\">Application.mk 文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/cmake.html\" target=\"_blank\" rel=\"external\">Android 文档cmake 文档</a></li>\n<li><a href=\"https://developer.android.com/studio/projects/add-native-code.html#existing-project\" target=\"_blank\" rel=\"external\">Android studio 中介绍</a></li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>在android2.2中，加入了cmake编译，而以前都是用Android.mk、Application.mk的，今天就来记录下，他们的配置选项。<br>","more":"</p>\n<The rest of contents | 余下全文>\n\n<h3 id=\"2-Android-mk\"><a href=\"#2-Android-mk\" class=\"headerlink\" title=\"2. Android.mk\"></a>2. Android.mk</h3><p>Android.mk在jni目录下，用于描述构建系统的源文件以及<br>shared libraries 。文件格式如下：</p>\n<ul>\n<li>以LOCAL_PATH变量开始 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><p>紧接着是CLEAR_VARS变量 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来LOCAL_MODULE变量，定义来将要输出的so文件的名，默认情况下，输出的so为 lib+LOCAL_MODULE变量值+.so，如果变量值前面有了lib，就不会加了，或者变量值后面有.xxx，也会去掉。</p>\n</li>\n<li><p>接下来是LOCAL_SRC_FILES变量，声明我们的原文件路径，如</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div></pre></td></tr></table></figure>\n</li>\n<li><p>最后一行是帮助构建系统联系在一起的。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE := hello-jni</div><div class=\"line\"></div><div class=\"line\">LOCAL_SRC_FILES := hello.cpp</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>当然，上面只是一个最简单的，下面我们来介绍其他的一些变量和宏。</p>\n<p>构建系统提供了许多变量和宏，当然 也允许我们自定义，内置的有以下三种：</p>\n<ul>\n<li>以LOCAL_开始，如LOCAL_MODULE</li>\n<li>以PRIVATE<em>, NDK</em>, or APP </li>\n<li>小写字母，如 my-di</li>\n</ul>\n<p>如果要自定义的话，建议MY_开头。</p>\n<h4 id=\"2-1-NDK-默认的变量\"><a href=\"#2-1-NDK-默认的变量\" class=\"headerlink\" title=\"2.1 NDK 默认的变量\"></a>2.1 NDK 默认的变量</h4><ul>\n<li><p>CLEAR_VARS  用来在描述新model之前引入这个脚本，会清除之前的值 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(CLEAR_VARS)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_SHARED<em>LIBRARY,告诉构建系统去收集声明的LOCAL</em>变量的值，然后输出成so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>BUILD_STATIC_LIBRARY,和BUILD_SHARED_LIBRARY类似，不过不会复制到project/packages，但是可以提供给shared libraries用，会输出成.a </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(BUILD_STATIC_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_SHARED_LIBRARY 用于指定预先编译好的共享库，但是LOCAL_SRC_FILES是so文件 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">include $(PREBUILT_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n</li>\n<li><p>PREBUILT_STATIC_LIBRARY 和PREBUILT_SHARED_LIBRARY 类似</p>\n</li>\n<li>TARGET_ARCH 略，重点看TARGET_ARCH_ABI</li>\n<li><p>TARGET_PLATFORM 指定当前编译的android api版本 </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_PLATFORM := android-22</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ARCH_ABI 指定cpu架构，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ARCH_ABI := arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n<li><p>TARGET_ABI，指定android api版本鱼abi架构</p>\n</li>\n<li>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TARGET_ABI := android-22-arm64-v8a</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-2-Module-Description-Variables-描述model的变量\"><a href=\"#2-2-Module-Description-Variables-描述model的变量\" class=\"headerlink\" title=\"2.2 Module-Description Variables 描述model的变量\"></a>2.2 Module-Description Variables 描述model的变量</h4><ul>\n<li>LOCAL_PATH 指定当前文件的路径，必须在文件开始的时候指定 </li>\n</ul>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)</div></pre></td></tr></table></figure>\n\n注意CLEAR_VARS，并不会清除这个的值\n</code></pre><ul>\n<li>LOCAL_MODULE </li>\n<li>LOCAL_MODULE_FILENAME 可以指定生成的so文件的名字</li>\n<li>LOCAL_SRC_FILES 指定这个model对应的原文件</li>\n<li>LOCAL_CPP_EXTENSION 配置c++ 文件后缀(扩展名)，是c++、cc还是其他</li>\n<li><p>LOCAL_CPP_FEATURES 指定特定的c++特性 如支持RTTI (RunTime Type Information),</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_CPP_FEATURES := rtti</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_C_INCLUDES 指定路径列表，相对于ndk的跟路径</p>\n</li>\n<li>LOCAL_CFLAGS、LOCAL_CPPFLAGS 可以指定额外的宏定义和编译选项</li>\n<li>LOCAL_STATIC_LIBRARIES、LOCAL_SHARED_LIBRARIES 指定其他的static libraries、shared libraries</li>\n<li>LOCAL_WHOLE_STATIC_LIBRARIES  整个。</li>\n<li><p>LOCAL_LDLIBS 指定系统-l指定系统库，如/system/lib/libz.so </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_LDLIBS := -lz</div></pre></td></tr></table></figure>\n</li>\n<li><p>LOCAL_LDFLAGS 略，没看明白</p>\n</li>\n<li>LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下,当构建系统遇到遇到未定义的引用在试图建立一个共享的,它会抛出未定义符号错误。这个错误可以帮助debug。</li>\n<li>剩下的许多 并不常用，暂时到这里，以后有机会用的话，查文档吧。</li>\n</ul>\n<h3 id=\"3-Application-mk\"><a href=\"#3-Application-mk\" class=\"headerlink\" title=\"3. Application.mk\"></a>3. Application.mk</h3><p>用于描述app需要的native model。</p>\n<h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><ul>\n<li>APP_PROJECT_PATH 这个变量存储应用程序的项目根目录的绝对路径。</li>\n<li>APP_OPTIM 配置release和debug</li>\n<li>APP_CFLAGS 这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件</li>\n<li>APP_CPPFLAGS 和 APP_CFLAGS类似</li>\n<li>APP_LDFLAGS A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效</li>\n<li>APP_BUILD_SCRIPT 指定Android.mk文件</li>\n<li>APP_ABI 指定abi</li>\n<li>APP_PLATFORM 指定android api版本</li>\n<li>APP_STL 链接其他的c＋＋支持</li>\n<li>NDK_TOOLCHAIN_VERSION  gcc编译版本</li>\n<li>APP_PIE </li>\n<li>APP_THIN_ARCHIVE</li>\n</ul>\n<h3 id=\"4-在Android-Studio中使用\"><a href=\"#4-在Android-Studio中使用\" class=\"headerlink\" title=\"4.在Android Studio中使用\"></a>4.在Android Studio中使用</h3><p>要求 Android Studio 2.2 以上。</p>\n<p>在gradle中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">  defaultConfig &#123;  </div><div class=\"line\">    externalNativeBuild &#123;</div><div class=\"line\">      cmake &#123;</div><div class=\"line\">        // 设置cmake参数 &quot;-DVAR_NAME=VALUE&quot;</div><div class=\"line\">        arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DANDROID_TOOLCHAIN=clang&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 设置 abi</div><div class=\"line\">    ndk &#123;</div><div class=\"line\">            abiFilters &quot;armeabi&quot;,&quot;x86&quot;,&quot;armeabi-v7a&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  buildTypes &#123;...&#125;</div><div class=\"line\">  </div><div class=\"line\">  externalNativeBuild &#123;</div><div class=\"line\">    cmake &#123;</div><div class=\"line\">    \t// CMakeLists.txt 文件路径</div><div class=\"line\">    \tpath &apos;src/main/jni/CMakeLists.txt&apos; </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要编写的就是上面三处有注释的地方。</p>\n<ul>\n<li>cmake参数 格式为 -D + Variable name ＝ Arguments 的形势<ul>\n<li>ANDROID_TOOLCHAIN cmake编译链，gcc 和clang（默认）两种</li>\n<li>ANDROID_PLATFORM target Android platform</li>\n<li>ANDROID_STL  cmake编译时用哪个stl，有以下种类<a href=\"https://developer.android.com/ndk/guides/cpp-support.html#hr\">Helper Runtimes</a></li>\n<li>ANDROID_PIE 指定是否使用位置独立的可执行(饼)。Android的动态链接器支持派在Android 4.1(API级16)和更高。</li>\n<li>ANDROID_CPP_FEATURES 指定特定的c++特性CMake编译时需要使用本地库,比如c++ RTTI(运行时类型信息)和异常,rtti,exceptions</li>\n<li>ANDROID_ALLOW_UNDEFINED_SYMBOLS 指定是否抛出未定义符号错误如果CMake遇到一个未定义的引用而建立你的本地库。禁用这些类型的错误,将这个变量设置为TRUE。</li>\n<li>ANDROID_ARM_MODE 设置生成的二进制文件arm 还是 thumb模式，thumb模式下，每个指令都是16bits，arm模式下为32位，默认是 thumb</li>\n<li>NDROID_ARM_NEON build native lib 是否NONE支持</li>\n<li>ANDROID_DISABLE_NO_EXECUTE 是否允许ne bit，或者执行、或者安全特训过</li>\n<li>ANDROID_DISABLE_RELRO 是否只读</li>\n<li>ANDROID_DISABLE_FORMAT_STRING_CHECKS 指定与格式字符串是否编译源代码的保护。当启用时,编译器将抛出一个错误如果不恒定格式字符串中使用printf-style函数。</li>\n</ul>\n</li>\n<li>ndk abifilters</li>\n<li>cmake path</li>\n</ul>\n<p>关于cmake 参数，<a href=\"https://developer.android.com/ndk/guides/cmake.html\">官方文档</a></p>\n<h3 id=\"5-CMakeLists-txt-编写\"><a href=\"#5-CMakeLists-txt-编写\" class=\"headerlink\" title=\"5. CMakeLists.txt 编写\"></a>5. CMakeLists.txt 编写</h3><ul>\n<li>cmake 最小版本 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tcmake_minimum_required(VERSION 3.4.1)\t</div><div class=\"line\">\t``` </div><div class=\"line\">\t\t</div><div class=\"line\">*</div></pre></td></tr></table></figure></li>\n</ul>\n<p>add_library(native lib name,SHARED(SHARED还是STATIC),c++或c文件路径)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* 指定头文件路径</div></pre></td></tr></table></figure></p>\n<p>include_directories(src/main/cpp/include/)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 5.1 添加native api</div></pre></td></tr></table></figure></p>\n<p>find_library( # Defines the name of the path variable that stores the</p>\n<pre><code># location of the NDK library.\nlog-lib\n\n# Specifies the name of the NDK library that\n# CMake needs to locate.\nlog )\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">按照我个人的理解，</div><div class=\"line\"></div><div class=\"line\">* 第一个就是lib库的别名，就是我们在这个文件中其他地方要使用的。</div><div class=\"line\">* 第二个参数是对应的native lib库的名字，第二个参数在ndk-bundle/platforms/android版本／下面能找到。根据我们上面说到的生成so文件规则，能够很清楚的提出lib name</div><div class=\"line\"></div><div class=\"line\">然后使用target_link_libraries(native-lib,$&#123;log-lib&#125;) 去链接咱们的本地库和ndk中带的本地库，</div><div class=\"line\"></div><div class=\"line\">_ _ _</div><div class=\"line\"></div><div class=\"line\">也可以将源代码添加进来，</div></pre></td></tr></table></figure>\n<p>add_library( app-glue<br>             STATIC<br>             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">* lib name</div><div class=\"line\">* 类型</div><div class=\"line\">* 文件路径</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 5.2 添加其他预先构建的libraries</div><div class=\"line\"></div><div class=\"line\">因为这些已经有的，需要用 IMPORTED 去告诉cmkae，只需要将这个lib导入到咱们的project</div></pre></td></tr></table></figure></p>\n<p>add_library( imported-lib<br>             SHARED<br>             IMPORTED )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后需要用set_target_properties去指定路径。</div></pre></td></tr></table></figure></p>\n<p>set_target_properties( # Specifies the target library.<br>                       imported-lib</p>\n<pre><code># Specifies the parameter you want to define.\nPROPERTIES IMPORTED_LOCATION\n\n# Provides the path to the library you want to import.\nimported-lib/src/${ANDROID_ABI}/libimported-lib.so )\n</code></pre><p>```</p>\n<ul>\n<li>lib name</li>\n<li>指定参数</li>\n<li>指定so的路径</li>\n</ul>\n<p>这时候需要include_directories来指定so对应的头文件路径，上面也说到过了。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>有理解的不对的，大家指出，共同学习共同进步。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/ndk/guides/android_mk.html\">Android.mk、文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/application_mk.html\">Application.mk 文档</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/cmake.html\">Android 文档cmake 文档</a></li>\n<li><a href=\"https://developer.android.com/studio/projects/add-native-code.html#existing-project\">Android studio 中介绍</a></li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Service启动流程","date":"2016-12-26T07:19:04.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n我们启动service分为两种情况\n\n* startService\n* bindService\n\n我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。\n\n### 2.startService的方式\n\n#### 2.1 ContextImpl#startServiceCommon\n\n在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：\n\n```\n            ComponentName cn = ActivityManagerNative.getDefault().startService(\n                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(\n                            getContentResolver()), getOpPackageName(), user.getIdentifier());\n```\nActivityManagerNative.getDefault()，为binder客户端，上篇说到过。\n\n在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。\n\n因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。\n\n#### 2.2 ActivityManagerService#startService\n\n在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，\n\n```\n            final int callingPid = Binder.getCallingPid();\n            final int callingUid = Binder.getCallingUid();\n            final long origId = Binder.clearCallingIdentity();\n            ComponentName res = mServices.startServiceLocked(caller, service,\n                    resolvedType, callingPid, callingUid, callingPackage, userId);\n            Binder.restoreCallingIdentity(origId);\n            return res;\n```\n\n#### 2.3 ActivityService#startServiceLocked\n\n在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法\n\n#### 2.4 ActivityService#startServiceInnerLocked\n\n\n\n```\nString error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);\n```\n在这个方法中,后续操作交由bringUpServiceLocked处理。\n\n\n#### 2.5 ActivityService#bringUpServiceLocked\n\n在这个方法中，有两种情况：\n\n* 需要的进程存在\n* 需要的进程不存在\n\n当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。\n\n如果需要的进程不存在，则需要fork进程，这个后面的文章在说。\n\n解析来我们直接看realStartServiceLocked操作吧。\n\n#### 2.6 ActivityService#realStartServiceLocked\n\n改方法核心代码；\n\n```\n            app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),\n                    app.repProcState);\n```\n\n这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。\n\n#### 2.7 ActivityThread#handleCreateService\n\n```\n   private void handleCreateService(CreateServiceData data) {\n        // If we are getting ready to gc after going to the background, well\n        // we are back active so skip it.\n        unscheduleGcIdler();\n\n        LoadedApk packageInfo = getPackageInfoNoCheck(\n                data.info.applicationInfo, data.compatInfo);\n        Service service = null;\n        try {\n            java.lang.ClassLoader cl = packageInfo.getClassLoader();\n            service = (Service) cl.loadClass(data.info.name).newInstance();\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to instantiate service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n\n        try {\n            if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name);\n\n            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n            context.setOuterContext(service);\n\n            Application app = packageInfo.makeApplication(false, mInstrumentation);\n            service.attach(context, this, data.info.name, data.token, app,\n                    ActivityManagerNative.getDefault());\n            service.onCreate();\n            mServices.put(data.token, service);\n            try {\n                ActivityManagerNative.getDefault().serviceDoneExecuting(\n                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);\n            } catch (RemoteException e) {\n                // nothing to do.\n            }\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to create service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n    }\n```\n\n* 构造service\n* 关联application\n* 调用onCreate 执行\n\n就这样，一个全新的service就启动了。\n\n\n\n\n\n\n### 3.bindService的方式\n\n这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；\n\n```\n                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,\n                        r.app.repProcState);\n\n```\n\n随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。\n\n### 4.上图\n这里只是简单的介绍了流程，很多细节的东西并没有看。\n\n![](/images/framework/service/startservice.png)\n\n\n![](/images/framework/service/bindservice.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Service启动流程.md","raw":"---\ntitle: Service启动流程\ndate: 2016-12-26 15:19:04\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n我们启动service分为两种情况\n\n* startService\n* bindService\n\n我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。\n\n### 2.startService的方式\n\n#### 2.1 ContextImpl#startServiceCommon\n\n在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：\n\n```\n            ComponentName cn = ActivityManagerNative.getDefault().startService(\n                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(\n                            getContentResolver()), getOpPackageName(), user.getIdentifier());\n```\nActivityManagerNative.getDefault()，为binder客户端，上篇说到过。\n\n在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。\n\n因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。\n\n#### 2.2 ActivityManagerService#startService\n\n在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，\n\n```\n            final int callingPid = Binder.getCallingPid();\n            final int callingUid = Binder.getCallingUid();\n            final long origId = Binder.clearCallingIdentity();\n            ComponentName res = mServices.startServiceLocked(caller, service,\n                    resolvedType, callingPid, callingUid, callingPackage, userId);\n            Binder.restoreCallingIdentity(origId);\n            return res;\n```\n\n#### 2.3 ActivityService#startServiceLocked\n\n在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法\n\n#### 2.4 ActivityService#startServiceInnerLocked\n\n\n\n```\nString error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);\n```\n在这个方法中,后续操作交由bringUpServiceLocked处理。\n\n\n#### 2.5 ActivityService#bringUpServiceLocked\n\n在这个方法中，有两种情况：\n\n* 需要的进程存在\n* 需要的进程不存在\n\n当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。\n\n如果需要的进程不存在，则需要fork进程，这个后面的文章在说。\n\n解析来我们直接看realStartServiceLocked操作吧。\n\n#### 2.6 ActivityService#realStartServiceLocked\n\n改方法核心代码；\n\n```\n            app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),\n                    app.repProcState);\n```\n\n这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。\n\n#### 2.7 ActivityThread#handleCreateService\n\n```\n   private void handleCreateService(CreateServiceData data) {\n        // If we are getting ready to gc after going to the background, well\n        // we are back active so skip it.\n        unscheduleGcIdler();\n\n        LoadedApk packageInfo = getPackageInfoNoCheck(\n                data.info.applicationInfo, data.compatInfo);\n        Service service = null;\n        try {\n            java.lang.ClassLoader cl = packageInfo.getClassLoader();\n            service = (Service) cl.loadClass(data.info.name).newInstance();\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to instantiate service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n\n        try {\n            if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name);\n\n            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n            context.setOuterContext(service);\n\n            Application app = packageInfo.makeApplication(false, mInstrumentation);\n            service.attach(context, this, data.info.name, data.token, app,\n                    ActivityManagerNative.getDefault());\n            service.onCreate();\n            mServices.put(data.token, service);\n            try {\n                ActivityManagerNative.getDefault().serviceDoneExecuting(\n                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);\n            } catch (RemoteException e) {\n                // nothing to do.\n            }\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(service, e)) {\n                throw new RuntimeException(\n                    \"Unable to create service \" + data.info.name\n                    + \": \" + e.toString(), e);\n            }\n        }\n    }\n```\n\n* 构造service\n* 关联application\n* 调用onCreate 执行\n\n就这样，一个全新的service就启动了。\n\n\n\n\n\n\n### 3.bindService的方式\n\n这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；\n\n```\n                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,\n                        r.app.repProcState);\n\n```\n\n随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。\n\n### 4.上图\n这里只是简单的介绍了流程，很多细节的东西并没有看。\n\n![](/images/framework/service/startservice.png)\n\n\n![](/images/framework/service/bindservice.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Service启动流程","published":1,"updated":"2017-01-07T06:58:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy23000xhws6rp4on9ze","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<p>我们启动service分为两种情况</p>\n<ul>\n<li>startService</li>\n<li>bindService</li>\n</ul>\n<p>我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。</p>\n<h3 id=\"2-startService的方式\"><a href=\"#2-startService的方式\" class=\"headerlink\" title=\"2.startService的方式\"></a>2.startService的方式</h3><h4 id=\"2-1-ContextImpl-startServiceCommon\"><a href=\"#2-1-ContextImpl-startServiceCommon\" class=\"headerlink\" title=\"2.1 ContextImpl#startServiceCommon\"></a>2.1 ContextImpl#startServiceCommon</h4><p>在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ComponentName cn = ActivityManagerNative.getDefault().startService(</div><div class=\"line\">    mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</div><div class=\"line\">                getContentResolver()), getOpPackageName(), user.getIdentifier());</div></pre></td></tr></table></figure>\n<p>ActivityManagerNative.getDefault()，为binder客户端，上篇说到过。</p>\n<p>在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。</p>\n<p>因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。</p>\n<h4 id=\"2-2-ActivityManagerService-startService\"><a href=\"#2-2-ActivityManagerService-startService\" class=\"headerlink\" title=\"2.2 ActivityManagerService#startService\"></a>2.2 ActivityManagerService#startService</h4><p>在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int callingPid = Binder.getCallingPid();</div><div class=\"line\">final int callingUid = Binder.getCallingUid();</div><div class=\"line\">final long origId = Binder.clearCallingIdentity();</div><div class=\"line\">ComponentName res = mServices.startServiceLocked(caller, service,</div><div class=\"line\">        resolvedType, callingPid, callingUid, callingPackage, userId);</div><div class=\"line\">Binder.restoreCallingIdentity(origId);</div><div class=\"line\">return res;</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-ActivityService-startServiceLocked\"><a href=\"#2-3-ActivityService-startServiceLocked\" class=\"headerlink\" title=\"2.3 ActivityService#startServiceLocked\"></a>2.3 ActivityService#startServiceLocked</h4><p>在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法</p>\n<h4 id=\"2-4-ActivityService-startServiceInnerLocked\"><a href=\"#2-4-ActivityService-startServiceInnerLocked\" class=\"headerlink\" title=\"2.4 ActivityService#startServiceInnerLocked\"></a>2.4 ActivityService#startServiceInnerLocked</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);</div></pre></td></tr></table></figure>\n<p>在这个方法中,后续操作交由bringUpServiceLocked处理。</p>\n<h4 id=\"2-5-ActivityService-bringUpServiceLocked\"><a href=\"#2-5-ActivityService-bringUpServiceLocked\" class=\"headerlink\" title=\"2.5 ActivityService#bringUpServiceLocked\"></a>2.5 ActivityService#bringUpServiceLocked</h4><p>在这个方法中，有两种情况：</p>\n<ul>\n<li>需要的进程存在</li>\n<li>需要的进程不存在</li>\n</ul>\n<p>当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。</p>\n<p>如果需要的进程不存在，则需要fork进程，这个后面的文章在说。</p>\n<p>解析来我们直接看realStartServiceLocked操作吧。</p>\n<h4 id=\"2-6-ActivityService-realStartServiceLocked\"><a href=\"#2-6-ActivityService-realStartServiceLocked\" class=\"headerlink\" title=\"2.6 ActivityService#realStartServiceLocked\"></a>2.6 ActivityService#realStartServiceLocked</h4><p>改方法核心代码；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleCreateService(r, r.serviceInfo,</div><div class=\"line\">        mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</div><div class=\"line\">        app.repProcState);</div></pre></td></tr></table></figure>\n<p>这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。</p>\n<h4 id=\"2-7-ActivityThread-handleCreateService\"><a href=\"#2-7-ActivityThread-handleCreateService\" class=\"headerlink\" title=\"2.7 ActivityThread#handleCreateService\"></a>2.7 ActivityThread#handleCreateService</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void handleCreateService(CreateServiceData data) &#123;</div><div class=\"line\">     // If we are getting ready to gc after going to the background, well</div><div class=\"line\">     // we are back active so skip it.</div><div class=\"line\">     unscheduleGcIdler();</div><div class=\"line\"></div><div class=\"line\">     LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class=\"line\">             data.info.applicationInfo, data.compatInfo);</div><div class=\"line\">     Service service = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class=\"line\">         service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to instantiate service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</div><div class=\"line\"></div><div class=\"line\">         ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</div><div class=\"line\">         context.setOuterContext(service);</div><div class=\"line\"></div><div class=\"line\">         Application app = packageInfo.makeApplication(false, mInstrumentation);</div><div class=\"line\">         service.attach(context, this, data.info.name, data.token, app,</div><div class=\"line\">                 ActivityManagerNative.getDefault());</div><div class=\"line\">         service.onCreate();</div><div class=\"line\">         mServices.put(data.token, service);</div><div class=\"line\">         try &#123;</div><div class=\"line\">             ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class=\"line\">                     data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</div><div class=\"line\">         &#125; catch (RemoteException e) &#123;</div><div class=\"line\">             // nothing to do.</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to create service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造service</li>\n<li>关联application</li>\n<li>调用onCreate 执行</li>\n</ul>\n<p>就这样，一个全新的service就启动了。</p>\n<h3 id=\"3-bindService的方式\"><a href=\"#3-bindService的方式\" class=\"headerlink\" title=\"3.bindService的方式\"></a>3.bindService的方式</h3><p>这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</div><div class=\"line\">        r.app.repProcState);</div></pre></td></tr></table></figure>\n<p>随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。</p>\n<h3 id=\"4-上图\"><a href=\"#4-上图\" class=\"headerlink\" title=\"4.上图\"></a>4.上图</h3><p>这里只是简单的介绍了流程，很多细节的东西并没有看。</p>\n<p><img src=\"/images/framework/service/startservice.png\" alt=\"\"></p>\n<p><img src=\"/images/framework/service/bindservice.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>上一篇看了activity的启动流程，过程非常复杂，代码的细节都没多看，我们初学者，知道大体的流程就可以了。以后在慢慢看吗。今天来看下，service的流程，因为activiy涉及到activiy栈，所以比较难，但是我们的service不涉及，所以流程相对简单点。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<p>我们启动service分为两种情况</p>\n<ul>\n<li>startService</li>\n<li>bindService</li>\n</ul>\n<p>我们分开来看。我们知道Activity是Context,而Context的实现是ContextImpl,因此，我们从ContextImpl说起。</p>\n<h3 id=\"2-startService的方式\"><a href=\"#2-startService的方式\" class=\"headerlink\" title=\"2.startService的方式\"></a>2.startService的方式</h3><h4 id=\"2-1-ContextImpl-startServiceCommon\"><a href=\"#2-1-ContextImpl-startServiceCommon\" class=\"headerlink\" title=\"2.1 ContextImpl#startServiceCommon\"></a>2.1 ContextImpl#startServiceCommon</h4><p>在startService方法中，直接调用startServiceCommon，这个方法的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ComponentName cn = ActivityManagerNative.getDefault().startService(</div><div class=\"line\">    mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</div><div class=\"line\">                getContentResolver()), getOpPackageName(), user.getIdentifier());</div></pre></td></tr></table></figure>\n<p>ActivityManagerNative.getDefault()，为binder客户端，上篇说到过。</p>\n<p>在AMS中，客户端bp端为ActivityManagerNative的内部类，ActivityManagerProxy,服务端bn端对ActivityManagerService。</p>\n<p>因此，我们略过bp端，无非就是向其中数据，然后transact。我们直接看bn端对应的方法。</p>\n<h4 id=\"2-2-ActivityManagerService-startService\"><a href=\"#2-2-ActivityManagerService-startService\" class=\"headerlink\" title=\"2.2 ActivityManagerService#startService\"></a>2.2 ActivityManagerService#startService</h4><p>在这个方法中，并没有过多的操作，而是将操作传递给ActivityService，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int callingPid = Binder.getCallingPid();</div><div class=\"line\">final int callingUid = Binder.getCallingUid();</div><div class=\"line\">final long origId = Binder.clearCallingIdentity();</div><div class=\"line\">ComponentName res = mServices.startServiceLocked(caller, service,</div><div class=\"line\">        resolvedType, callingPid, callingUid, callingPackage, userId);</div><div class=\"line\">Binder.restoreCallingIdentity(origId);</div><div class=\"line\">return res;</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-ActivityService-startServiceLocked\"><a href=\"#2-3-ActivityService-startServiceLocked\" class=\"headerlink\" title=\"2.3 ActivityService#startServiceLocked\"></a>2.3 ActivityService#startServiceLocked</h4><p>在这个方法中，经过进程检验、service注册检查、ServiceRecord属性设置等一系列操作之后，调用startServiceInnerLocked方法</p>\n<h4 id=\"2-4-ActivityService-startServiceInnerLocked\"><a href=\"#2-4-ActivityService-startServiceInnerLocked\" class=\"headerlink\" title=\"2.4 ActivityService#startServiceInnerLocked\"></a>2.4 ActivityService#startServiceInnerLocked</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);</div></pre></td></tr></table></figure>\n<p>在这个方法中,后续操作交由bringUpServiceLocked处理。</p>\n<h4 id=\"2-5-ActivityService-bringUpServiceLocked\"><a href=\"#2-5-ActivityService-bringUpServiceLocked\" class=\"headerlink\" title=\"2.5 ActivityService#bringUpServiceLocked\"></a>2.5 ActivityService#bringUpServiceLocked</h4><p>在这个方法中，有两种情况：</p>\n<ul>\n<li>需要的进程存在</li>\n<li>需要的进程不存在</li>\n</ul>\n<p>当service需要的进程存在的时候，如果，service已经存在了，那么通过sendServiceArgsLocked方法的后续操作调用onStartCommand，如果不存在，则调用realStartServiceLocked进程create操作。</p>\n<p>如果需要的进程不存在，则需要fork进程，这个后面的文章在说。</p>\n<p>解析来我们直接看realStartServiceLocked操作吧。</p>\n<h4 id=\"2-6-ActivityService-realStartServiceLocked\"><a href=\"#2-6-ActivityService-realStartServiceLocked\" class=\"headerlink\" title=\"2.6 ActivityService#realStartServiceLocked\"></a>2.6 ActivityService#realStartServiceLocked</h4><p>改方法核心代码；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.thread.scheduleCreateService(r, r.serviceInfo,</div><div class=\"line\">        mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</div><div class=\"line\">        app.repProcState);</div></pre></td></tr></table></figure>\n<p>这样，通过调用ApplicationThread的对应方法，H类捕获CREATE_SERVICE消息，通过handleCreateService，来创建service。</p>\n<h4 id=\"2-7-ActivityThread-handleCreateService\"><a href=\"#2-7-ActivityThread-handleCreateService\" class=\"headerlink\" title=\"2.7 ActivityThread#handleCreateService\"></a>2.7 ActivityThread#handleCreateService</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void handleCreateService(CreateServiceData data) &#123;</div><div class=\"line\">     // If we are getting ready to gc after going to the background, well</div><div class=\"line\">     // we are back active so skip it.</div><div class=\"line\">     unscheduleGcIdler();</div><div class=\"line\"></div><div class=\"line\">     LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class=\"line\">             data.info.applicationInfo, data.compatInfo);</div><div class=\"line\">     Service service = null;</div><div class=\"line\">     try &#123;</div><div class=\"line\">         java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class=\"line\">         service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to instantiate service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</div><div class=\"line\"></div><div class=\"line\">         ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</div><div class=\"line\">         context.setOuterContext(service);</div><div class=\"line\"></div><div class=\"line\">         Application app = packageInfo.makeApplication(false, mInstrumentation);</div><div class=\"line\">         service.attach(context, this, data.info.name, data.token, app,</div><div class=\"line\">                 ActivityManagerNative.getDefault());</div><div class=\"line\">         service.onCreate();</div><div class=\"line\">         mServices.put(data.token, service);</div><div class=\"line\">         try &#123;</div><div class=\"line\">             ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class=\"line\">                     data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</div><div class=\"line\">         &#125; catch (RemoteException e) &#123;</div><div class=\"line\">             // nothing to do.</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; catch (Exception e) &#123;</div><div class=\"line\">         if (!mInstrumentation.onException(service, e)) &#123;</div><div class=\"line\">             throw new RuntimeException(</div><div class=\"line\">                 &quot;Unable to create service &quot; + data.info.name</div><div class=\"line\">                 + &quot;: &quot; + e.toString(), e);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>构造service</li>\n<li>关联application</li>\n<li>调用onCreate 执行</li>\n</ul>\n<p>就这样，一个全新的service就启动了。</p>\n<h3 id=\"3-bindService的方式\"><a href=\"#3-bindService的方式\" class=\"headerlink\" title=\"3.bindService的方式\"></a>3.bindService的方式</h3><p>这种方式会中甲调用直到ActivityService的bindServiceLocked方法，这个方法里首先会通过bringUpServiceLocked去船舰service，和我们上面一样，这个方法最后会调用requestServiceBindingLocked,requestServiceBindingLocked核心代码如下；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</div><div class=\"line\">        r.app.repProcState);</div></pre></td></tr></table></figure>\n<p>随后会在activitythread中，调handleBindService方法，去执行service的onbind方法，具体的就不说了。</p>\n<h3 id=\"4-上图\"><a href=\"#4-上图\" class=\"headerlink\" title=\"4.上图\"></a>4.上图</h3><p>这里只是简单的介绍了流程，很多细节的东西并没有看。</p>\n<p><img src=\"/images/framework/service/startservice.png\" alt=\"\"></p>\n<p><img src=\"/images/framework/service/bindservice.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"PMS初始化做了什么","date":"2017-01-05T09:21:21.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```java\n    public static PackageManagerService main(Context context, Installer installer,\n            boolean factoryTest, boolean onlyCore) {\n        PackageManagerService m = new PackageManagerService(context, installer,\n                factoryTest, onlyCore);\n        ServiceManager.addService(\"package\", m);\n        return m;\n    }\n```\n\n### 2.从pms构造函数说起\n\npms的构造函数相当长，根据[gityuan大神](http://gityuan.com/2016/11/06/packagemanager/)的提示，按照log的打印进行分布查看却是清晰了很多。\n\n#### 2.1 BOOT_PROGRESS_PMS_START\n\n```java\n        mContext = context;\n        mFactoryTest = factoryTest;\n        mOnlyCore = onlyCore;\n        mLazyDexOpt = \"eng\".equals(SystemProperties.get(\"ro.build.type\"));\n        mMetrics = new DisplayMetrics();\n        mSettings = new Settings(mPackages);\n        mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n\n        // TODO: add a property to control this?\n        long dexOptLRUThresholdInMinutes;\n        if (mLazyDexOpt) {\n            dexOptLRUThresholdInMinutes = 30; // only last 30 minutes of apps for eng builds.\n        } else {\n            dexOptLRUThresholdInMinutes = 7 * 24 * 60; // apps used in the 7 days for users.\n        }\n        mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * 60 * 1000;\n\n        String separateProcesses = SystemProperties.get(\"debug.separate_processes\");\n        if (separateProcesses != null && separateProcesses.length() > 0) {\n            if (\"*\".equals(separateProcesses)) {\n                mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;\n                mSeparateProcesses = null;\n                Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\");\n            } else {\n                mDefParseFlags = 0;\n                mSeparateProcesses = separateProcesses.split(\",\");\n                Slog.w(TAG, \"Running with debug.separate_processes: \"\n                        + separateProcesses);\n            }\n        } else {\n            mDefParseFlags = 0;\n            mSeparateProcesses = null;\n        }\n\n        mInstaller = installer;\n        mPackageDexOptimizer = new PackageDexOptimizer(this);\n        mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());\n\n        mOnPermissionChangeListeners = new OnPermissionChangeListeners(\n                FgThread.get().getLooper());\n\n        getDefaultDisplayMetrics(context, mMetrics);\n\n        SystemConfig systemConfig = SystemConfig.getInstance();\n        mGlobalGids = systemConfig.getGlobalGids();\n        mSystemPermissions = systemConfig.getSystemPermissions();\n        mAvailableFeatures = systemConfig.getAvailableFeatures();\n\n        synchronized (mInstallLock) {\n        // writer\n        synchronized (mPackages) {\n            mHandlerThread = new ServiceThread(TAG,\n                    Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);\n            mHandlerThread.start();\n            mHandler = new PackageHandler(mHandlerThread.getLooper());\n            Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);\n\n            File dataDir = Environment.getDataDirectory();\n            mAppDataDir = new File(dataDir, \"data\");\n            mAppInstallDir = new File(dataDir, \"app\");\n            mAppLib32InstallDir = new File(dataDir, \"app-lib\");\n            mAsecInternalPath = new File(dataDir, \"app-asec\").getPath();\n            mUserAppDataDir = new File(dataDir, \"user\");\n            mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\");\n\n            sUserManager = new UserManagerService(context, this,\n                    mInstallLock, mPackages);\n\n            // Propagate permission configuration in to package manager.\n            ArrayMap<String, SystemConfig.PermissionEntry> permConfig\n                    = systemConfig.getPermissions();\n            for (int i=0; i<permConfig.size(); i++) {\n                SystemConfig.PermissionEntry perm = permConfig.valueAt(i);\n                BasePermission bp = mSettings.mPermissions.get(perm.name);\n                if (bp == null) {\n                    bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN);\n                    mSettings.mPermissions.put(perm.name, bp);\n                }\n                if (perm.gids != null) {\n                    bp.setGids(perm.gids, perm.perUser);\n                }\n            }\n\n            ArrayMap<String, String> libConfig = systemConfig.getSharedLibraries();\n            for (int i=0; i<libConfig.size(); i++) {\n                mSharedLibraries.put(libConfig.keyAt(i),\n                        new SharedLibraryEntry(libConfig.valueAt(i), null));\n            }\n\n            mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();\n\n            mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false),\n                    mSdkVersion, mOnlyCore);\n\n            String customResolverActivity = Resources.getSystem().getString(\n                    R.string.config_customResolverActivity);\n            if (TextUtils.isEmpty(customResolverActivity)) {\n                customResolverActivity = null;\n            } else {\n                mCustomResolverComponentName = ComponentName.unflattenFromString(\n                        customResolverActivity);\n            }\n\n            long startTime = SystemClock.uptimeMillis();\n```\n\n* 构造Settings对象，添加shareUserId\n* 构造SystemConfig，获取mSystemPermissions灯属性\n* 创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象\n* 从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，\n\n#### 2.2 PMS_SYSTEM_SCAN_START\n\n```java\n            final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;\n\n            final ArraySet<String> alreadyDexOpted = new ArraySet<String>();\n\n            /**\n             * Add everything in the in the boot class path to the\n             * list of process files because dexopt will have been run\n             * if necessary during zygote startup.\n             */\n            final String bootClassPath = System.getenv(\"BOOTCLASSPATH\");\n            final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\");\n\n            if (bootClassPath != null) {\n                String[] bootClassPathElements = splitString(bootClassPath, ':');\n                for (String element : bootClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No BOOTCLASSPATH found!\");\n            }\n\n            if (systemServerClassPath != null) {\n                String[] systemServerClassPathElements = splitString(systemServerClassPath, ':');\n                for (String element : systemServerClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No SYSTEMSERVERCLASSPATH found!\");\n            }\n\n            final List<String> allInstructionSets = InstructionSets.getAllInstructionSets();\n            final String[] dexCodeInstructionSets =\n                    getDexCodeInstructionSets(\n                            allInstructionSets.toArray(new String[allInstructionSets.size()]));\n\n            /**\n             * Ensure all external libraries have had dexopt run on them.\n             */\n            if (mSharedLibraries.size() > 0) {\n                // NOTE: For now, we're compiling these system \"shared libraries\"\n                // (and framework jars) into all available architectures. It's possible\n                // to compile them only when we come across an app that uses them (there's\n                // already logic for that in scanPackageLI) but that adds some complexity.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (SharedLibraryEntry libEntry : mSharedLibraries.values()) {\n                        final String lib = libEntry.path;\n                        if (lib == null) {\n                            continue;\n                        }\n\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                alreadyDexOpted.add(lib);\n                                mInstaller.dexopt(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Library not found: \" + lib);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n\n            File frameworkDir = new File(Environment.getRootDirectory(), \"framework\");\n\n            // Gross hack for now: we know this file doesn't contain any\n            // code, so don't dexopt it to avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/framework-res.apk\");\n\n            // Gross hack for now: we know this file is only part of\n            // the boot class path for art, so don't dexopt it to\n            // avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/core-libart.jar\");\n\n            /**\n             * There are a number of commands implemented in Java, which\n             * we currently need to do the dexopt on so that they can be\n             * run from a non-root shell.\n             */\n            String[] frameworkFiles = frameworkDir.list();\n            if (frameworkFiles != null) {\n                // TODO: We could compile these only for the most preferred ABI. We should\n                // first double check that the dex files for these commands are not referenced\n                // by other system apps.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (int i=0; i<frameworkFiles.length; i++) {\n                        File libPath = new File(frameworkDir, frameworkFiles[i]);\n                        String path = libPath.getPath();\n                        // Skip the file if we already did it.\n                        if (alreadyDexOpted.contains(path)) {\n                            continue;\n                        }\n                        // Skip the file if it is not a type we want to dexopt.\n                        if (!path.endsWith(\".apk\") && !path.endsWith(\".jar\")) {\n                            continue;\n                        }\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                mInstaller.dexopt(path, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Jar not found: \" + path);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Exception reading jar: \" + path, e);\n                        }\n                    }\n                }\n            }\n\n            final VersionInfo ver = mSettings.getInternalVersion();\n            mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);\n            // when upgrading from pre-M, promote system app permissions from install to runtime\n            mPromoteSystemApps =\n                    mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;\n\n            // save off the names of pre-existing system packages prior to scanning; we don't\n            // want to automatically grant runtime permissions for new system apps\n            if (mPromoteSystemApps) {\n                Iterator<PackageSetting> pkgSettingIter = mSettings.mPackages.values().iterator();\n                while (pkgSettingIter.hasNext()) {\n                    PackageSetting ps = pkgSettingIter.next();\n                    if (isSystemApp(ps)) {\n                        mExistingSystemPackages.add(ps.name);\n                    }\n                }\n            }\n\n            // Collect vendor overlay packages.\n            // (Do this before scanning any apps.)\n            // For security and version matching reason, only consider\n            // overlay packages if they reside in VENDOR_OVERLAY_DIR.\n            File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);\n            scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);\n\n            // Find base frameworks (resource packages without code).\n            scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED,\n                    scanFlags | SCAN_NO_DEX, 0);\n\n            // Collected privileged system packages.\n            final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");\n            scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);\n\n            // Collect ordinary system packages.\n            final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");\n            scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all vendor packages.\n            File vendorAppDir = new File(\"/vendor/app\");\n            try {\n                vendorAppDir = vendorAppDir.getCanonicalFile();\n            } catch (IOException e) {\n                // failed to look up canonical path, continue with original one\n            }\n            scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all OEM packages.\n            final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");\n            scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            if (DEBUG_UPGRADE) Log.v(TAG, \"Running installd update commands\");\n            mInstaller.moveFiles();\n\n            // Prune any system packages that no longer exist.\n            final List<String> possiblyDeletedUpdatedSystemApps = new ArrayList<String>();\n            if (!mOnlyCore) {\n                Iterator<PackageSetting> psit = mSettings.mPackages.values().iterator();\n                while (psit.hasNext()) {\n                    PackageSetting ps = psit.next();\n\n                    /*\n                     * If this is not a system app, it can't be a\n                     * disable system app.\n                     */\n                    if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {\n                        continue;\n                    }\n\n                    /*\n                     * If the package is scanned, it's not erased.\n                     */\n                    final PackageParser.Package scannedPkg = mPackages.get(ps.name);\n                    if (scannedPkg != null) {\n                        /*\n                         * If the system app is both scanned and in the\n                         * disabled packages list, then it must have been\n                         * added via OTA. Remove it from the currently\n                         * scanned package so the previously user-installed\n                         * application can be scanned.\n                         */\n                        if (mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                            logCriticalInfo(Log.WARN, \"Expecting better updated system app for \"\n                                    + ps.name + \"; removing system app.  Last known codePath=\"\n                                    + ps.codePathString + \", installStatus=\" + ps.installStatus\n                                    + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\"\n                                    + scannedPkg.mVersionCode);\n                            removePackageLI(ps, true);\n                            mExpectingBetter.put(ps.name, ps.codePath);\n                        }\n\n                        continue;\n                    }\n\n                    if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                        psit.remove();\n                        logCriticalInfo(Log.WARN, \"System package \" + ps.name\n                                + \" no longer exists; wiping its data\");\n                        removeDataDirsLI(null, ps.name);\n                    } else {\n                        final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);\n                        if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {\n                            possiblyDeletedUpdatedSystemApps.add(ps.name);\n                        }\n                    }\n                }\n            }\n\n            //look for any incomplete package installations\n            ArrayList<PackageSetting> deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();\n            //clean up list\n            for(int i = 0; i < deletePkgsList.size(); i++) {\n                //clean up here\n                cleanupInstallFailedPackage(deletePkgsList.get(i));\n            }\n            //delete tmp files\n            deleteTempPackageFiles();\n\n            // Remove any shared userIDs that have no associated packages\n            mSettings.pruneSharedUsersLPw();\n\n            if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。\n\n* 首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,\n\n\t```\n/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found\n```\nSYSTEMSERVERCLASSPATH内容为下\n\n\t```\n/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found\n```\n\n* 获取构建时指定的cpu指令\n* 根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中\n* 将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表\n* 将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表\n* 收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息\n* 删除系统不存在的包removePackageLI\n* 清理安装失败的包 cleanupInstallFailedPackage\n* 删除临时文件\n* 移除不想干的包中的shared userIDs\n\n#### 2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\n\n```java\n          if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n* mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，\n\n\n#### 2.4 PMS_SCAN_END\n\n```java\n          int updateFlags = UPDATE_PERMISSIONS_ALL;\n            if (ver.sdkVersion != mSdkVersion) {\n                Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \"\n                        + mSdkVersion + \"; regranting permissions for internal storage\");\n                updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;\n            }\n            updatePermissionsLPw(null, null, updateFlags);\n            ver.sdkVersion = mSdkVersion;\n\n            // If this is the first boot or an update from pre-M, and it is a normal\n            // boot, then we need to initialize the default preferred apps across\n            // all defined users.\n            if (!onlyCore && (mPromoteSystemApps || !mRestoredSettings)) {\n                for (UserInfo user : sUserManager.getUsers(true)) {\n                    mSettings.applyDefaultPreferredAppsLPw(this, user.id);\n                    applyFactoryDefaultBrowserLPw(user.id);\n                    primeDomainVerificationsLPw(user.id);\n                }\n            }\n\n            // If this is first boot after an OTA, and a normal boot, then\n            // we need to clear code cache directories.\n            if (mIsUpgrade && !onlyCore) {\n                Slog.i(TAG, \"Build fingerprint changed; clearing code caches\");\n                for (int i = 0; i < mSettings.mPackages.size(); i++) {\n                    final PackageSetting ps = mSettings.mPackages.valueAt(i);\n                    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) {\n                        deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);\n                    }\n                }\n                ver.fingerprint = Build.FINGERPRINT;\n            }\n\n            checkDefaultBrowser();\n\n            // clear only after permissions and other defaults have been updated\n            mExistingSystemPackages.clear();\n            mPromoteSystemApps = false;\n\n            // All the changes are done during package scanning.\n            ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;\n\n            // can downgrade to reader\n            mSettings.writeLPr();\n```\n\n* 当sdk版本不一致时，需要更新权限\n* 当这是ota后的首次启动，正常启动则需要清除目录的缓存代码\n* 当权限和其他默认项都完成更新，则清理相关信息\n* 信息写回packages.xml文件\n\n这部分不是很懂。\n\n#### 2.5 BOOT_PROGRESS_PMS_READY\n\n```java\n          mRequiredVerifierPackage = getRequiredVerifierLPr();\n            mRequiredInstallerPackage = getRequiredInstallerLPr();\n\n            mInstallerService = new PackageInstallerService(context, this);\n\n            mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();\n            mIntentFilterVerifier = new IntentVerifierProxy(mContext,\n                    mIntentFilterVerifierComponent);\n\n        } // synchronized (mPackages)\n        } // synchronized (mInstallLock)\n\n        // Now after opening every single application zip, make sure they\n        // are all flushed.  Not really needed, but keeps things nice and\n        // tidy.\n        Runtime.getRuntime().gc();\n\n        // Expose private service for system components to use.\n        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());\n```\n\n* 初始化PackageInstallerService\n* gc，回收下内存\n\n\n### 3.Settings\n\n这个类负责读取data/system下的几个xml文件。收集其中的一些信息。\n\n* packages.xml\t记录所有安装app的信息\n* packages-backup.xml\t备份文件\n* packages-stopped.xml\t记录系统被强制停止的文件\n* packages-stopped-backup.xml\t备份文件\n* packages.list\t记录应用的数据信息\n\n### 4.scanDirLI\n\n这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。\n\n```java\n       final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(scanFile, parseFlags);\n        } catch (PackageParserException e) {\n            throw PackageManagerException.from(e);\n        }\n```\n\n重点看解析部分的代码。\n\n```java\n   public Package parsePackage(File packageFile, int flags) throws PackageParserException {\n        if (packageFile.isDirectory()) {\n            return parseClusterPackage(packageFile, flags);\n        } else {\n            return parseMonolithicPackage(packageFile, flags);\n        }\n    }\n```\n\n三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，\n\n```java\n            res = new Resources(assets, mMetrics, null);\n            assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                    Build.VERSION.RESOURCES_SDK_INT);\n            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\n\n            final String[] outError = new String[1];\n            final Package pkg = parseBaseApk(res, parser, flags, outError);\n```\n\n在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。\n\n```java\nif (tagName.equals(\"application\")) {\n                if (foundApp) {\n                    if (RIGID_PARSER) {\n                        outError[0] = \"<manifest> has more than one <application>\";\n                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                        return null;\n                    } else {\n                        Slog.w(TAG, \"<manifest> has more than one <application>\");\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                }\n\n                foundApp = true;\n                if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) {\n                    return null;\n                }\n            }\n```\n\n用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。\n\n```java\nif (tagName.equals(\"activity\")) {\n                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false,\n                        owner.baseHardwareAccelerated);\n                if (a == null) {\n                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                    return false;\n                }\n\n                owner.activities.add(a);\n\n            }\n```\n\n这里就不多说了。\n\n### 4. dex优化\n\n在Installer中，\n\n```java\n    public int dexopt(String apkPath, int uid, boolean isPublic, String pkgName,\n            String instructionSet, int dexoptNeeded, boolean vmSafeMode,\n            boolean debuggable, String outputPath) {\n        StringBuilder builder = new StringBuilder(\"dexopt\");\n        builder.append(' ');\n        builder.append(apkPath);\n        builder.append(' ');\n        builder.append(uid);\n        builder.append(isPublic ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(pkgName);\n        builder.append(' ');\n        builder.append(instructionSet);\n        builder.append(' ');\n        builder.append(dexoptNeeded);\n        builder.append(vmSafeMode ? \" 1\" : \" 0\");\n        builder.append(debuggable ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(outputPath != null ? outputPath : \"!\");\n        return execute(builder.toString());\n    }\n```\n\n进行参数封装，\n\n```java\n    public int execute(String cmd) {\n        String res = transact(cmd);\n        try {\n            return Integer.parseInt(res);\n        } catch (NumberFormatException ex) {\n            return -1;\n        }\n    }\n```\n\n在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。\n\n\n参考资料\n\n* [gityuan](http://gityuan.com/2016/11/06/packagemanager/)\n* Android 5.0 源代码\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/PMS初始化做了什么.md","raw":"---\ntitle: PMS初始化做了什么\ndate: 2017-01-05 17:21:21\ncategories: Android\ntags: \n- framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```java\n    public static PackageManagerService main(Context context, Installer installer,\n            boolean factoryTest, boolean onlyCore) {\n        PackageManagerService m = new PackageManagerService(context, installer,\n                factoryTest, onlyCore);\n        ServiceManager.addService(\"package\", m);\n        return m;\n    }\n```\n\n### 2.从pms构造函数说起\n\npms的构造函数相当长，根据[gityuan大神](http://gityuan.com/2016/11/06/packagemanager/)的提示，按照log的打印进行分布查看却是清晰了很多。\n\n#### 2.1 BOOT_PROGRESS_PMS_START\n\n```java\n        mContext = context;\n        mFactoryTest = factoryTest;\n        mOnlyCore = onlyCore;\n        mLazyDexOpt = \"eng\".equals(SystemProperties.get(\"ro.build.type\"));\n        mMetrics = new DisplayMetrics();\n        mSettings = new Settings(mPackages);\n        mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n        mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID,\n                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n\n        // TODO: add a property to control this?\n        long dexOptLRUThresholdInMinutes;\n        if (mLazyDexOpt) {\n            dexOptLRUThresholdInMinutes = 30; // only last 30 minutes of apps for eng builds.\n        } else {\n            dexOptLRUThresholdInMinutes = 7 * 24 * 60; // apps used in the 7 days for users.\n        }\n        mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * 60 * 1000;\n\n        String separateProcesses = SystemProperties.get(\"debug.separate_processes\");\n        if (separateProcesses != null && separateProcesses.length() > 0) {\n            if (\"*\".equals(separateProcesses)) {\n                mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;\n                mSeparateProcesses = null;\n                Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\");\n            } else {\n                mDefParseFlags = 0;\n                mSeparateProcesses = separateProcesses.split(\",\");\n                Slog.w(TAG, \"Running with debug.separate_processes: \"\n                        + separateProcesses);\n            }\n        } else {\n            mDefParseFlags = 0;\n            mSeparateProcesses = null;\n        }\n\n        mInstaller = installer;\n        mPackageDexOptimizer = new PackageDexOptimizer(this);\n        mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());\n\n        mOnPermissionChangeListeners = new OnPermissionChangeListeners(\n                FgThread.get().getLooper());\n\n        getDefaultDisplayMetrics(context, mMetrics);\n\n        SystemConfig systemConfig = SystemConfig.getInstance();\n        mGlobalGids = systemConfig.getGlobalGids();\n        mSystemPermissions = systemConfig.getSystemPermissions();\n        mAvailableFeatures = systemConfig.getAvailableFeatures();\n\n        synchronized (mInstallLock) {\n        // writer\n        synchronized (mPackages) {\n            mHandlerThread = new ServiceThread(TAG,\n                    Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);\n            mHandlerThread.start();\n            mHandler = new PackageHandler(mHandlerThread.getLooper());\n            Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);\n\n            File dataDir = Environment.getDataDirectory();\n            mAppDataDir = new File(dataDir, \"data\");\n            mAppInstallDir = new File(dataDir, \"app\");\n            mAppLib32InstallDir = new File(dataDir, \"app-lib\");\n            mAsecInternalPath = new File(dataDir, \"app-asec\").getPath();\n            mUserAppDataDir = new File(dataDir, \"user\");\n            mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\");\n\n            sUserManager = new UserManagerService(context, this,\n                    mInstallLock, mPackages);\n\n            // Propagate permission configuration in to package manager.\n            ArrayMap<String, SystemConfig.PermissionEntry> permConfig\n                    = systemConfig.getPermissions();\n            for (int i=0; i<permConfig.size(); i++) {\n                SystemConfig.PermissionEntry perm = permConfig.valueAt(i);\n                BasePermission bp = mSettings.mPermissions.get(perm.name);\n                if (bp == null) {\n                    bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN);\n                    mSettings.mPermissions.put(perm.name, bp);\n                }\n                if (perm.gids != null) {\n                    bp.setGids(perm.gids, perm.perUser);\n                }\n            }\n\n            ArrayMap<String, String> libConfig = systemConfig.getSharedLibraries();\n            for (int i=0; i<libConfig.size(); i++) {\n                mSharedLibraries.put(libConfig.keyAt(i),\n                        new SharedLibraryEntry(libConfig.valueAt(i), null));\n            }\n\n            mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();\n\n            mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false),\n                    mSdkVersion, mOnlyCore);\n\n            String customResolverActivity = Resources.getSystem().getString(\n                    R.string.config_customResolverActivity);\n            if (TextUtils.isEmpty(customResolverActivity)) {\n                customResolverActivity = null;\n            } else {\n                mCustomResolverComponentName = ComponentName.unflattenFromString(\n                        customResolverActivity);\n            }\n\n            long startTime = SystemClock.uptimeMillis();\n```\n\n* 构造Settings对象，添加shareUserId\n* 构造SystemConfig，获取mSystemPermissions灯属性\n* 创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象\n* 从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，\n\n#### 2.2 PMS_SYSTEM_SCAN_START\n\n```java\n            final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;\n\n            final ArraySet<String> alreadyDexOpted = new ArraySet<String>();\n\n            /**\n             * Add everything in the in the boot class path to the\n             * list of process files because dexopt will have been run\n             * if necessary during zygote startup.\n             */\n            final String bootClassPath = System.getenv(\"BOOTCLASSPATH\");\n            final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\");\n\n            if (bootClassPath != null) {\n                String[] bootClassPathElements = splitString(bootClassPath, ':');\n                for (String element : bootClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No BOOTCLASSPATH found!\");\n            }\n\n            if (systemServerClassPath != null) {\n                String[] systemServerClassPathElements = splitString(systemServerClassPath, ':');\n                for (String element : systemServerClassPathElements) {\n                    alreadyDexOpted.add(element);\n                }\n            } else {\n                Slog.w(TAG, \"No SYSTEMSERVERCLASSPATH found!\");\n            }\n\n            final List<String> allInstructionSets = InstructionSets.getAllInstructionSets();\n            final String[] dexCodeInstructionSets =\n                    getDexCodeInstructionSets(\n                            allInstructionSets.toArray(new String[allInstructionSets.size()]));\n\n            /**\n             * Ensure all external libraries have had dexopt run on them.\n             */\n            if (mSharedLibraries.size() > 0) {\n                // NOTE: For now, we're compiling these system \"shared libraries\"\n                // (and framework jars) into all available architectures. It's possible\n                // to compile them only when we come across an app that uses them (there's\n                // already logic for that in scanPackageLI) but that adds some complexity.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (SharedLibraryEntry libEntry : mSharedLibraries.values()) {\n                        final String lib = libEntry.path;\n                        if (lib == null) {\n                            continue;\n                        }\n\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                alreadyDexOpted.add(lib);\n                                mInstaller.dexopt(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Library not found: \" + lib);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n\n            File frameworkDir = new File(Environment.getRootDirectory(), \"framework\");\n\n            // Gross hack for now: we know this file doesn't contain any\n            // code, so don't dexopt it to avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/framework-res.apk\");\n\n            // Gross hack for now: we know this file is only part of\n            // the boot class path for art, so don't dexopt it to\n            // avoid the resulting log spew.\n            alreadyDexOpted.add(frameworkDir.getPath() + \"/core-libart.jar\");\n\n            /**\n             * There are a number of commands implemented in Java, which\n             * we currently need to do the dexopt on so that they can be\n             * run from a non-root shell.\n             */\n            String[] frameworkFiles = frameworkDir.list();\n            if (frameworkFiles != null) {\n                // TODO: We could compile these only for the most preferred ABI. We should\n                // first double check that the dex files for these commands are not referenced\n                // by other system apps.\n                for (String dexCodeInstructionSet : dexCodeInstructionSets) {\n                    for (int i=0; i<frameworkFiles.length; i++) {\n                        File libPath = new File(frameworkDir, frameworkFiles[i]);\n                        String path = libPath.getPath();\n                        // Skip the file if we already did it.\n                        if (alreadyDexOpted.contains(path)) {\n                            continue;\n                        }\n                        // Skip the file if it is not a type we want to dexopt.\n                        if (!path.endsWith(\".apk\") && !path.endsWith(\".jar\")) {\n                            continue;\n                        }\n                        try {\n                            int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, false);\n                            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n                                mInstaller.dexopt(path, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);\n                            }\n                        } catch (FileNotFoundException e) {\n                            Slog.w(TAG, \"Jar not found: \" + path);\n                        } catch (IOException e) {\n                            Slog.w(TAG, \"Exception reading jar: \" + path, e);\n                        }\n                    }\n                }\n            }\n\n            final VersionInfo ver = mSettings.getInternalVersion();\n            mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);\n            // when upgrading from pre-M, promote system app permissions from install to runtime\n            mPromoteSystemApps =\n                    mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;\n\n            // save off the names of pre-existing system packages prior to scanning; we don't\n            // want to automatically grant runtime permissions for new system apps\n            if (mPromoteSystemApps) {\n                Iterator<PackageSetting> pkgSettingIter = mSettings.mPackages.values().iterator();\n                while (pkgSettingIter.hasNext()) {\n                    PackageSetting ps = pkgSettingIter.next();\n                    if (isSystemApp(ps)) {\n                        mExistingSystemPackages.add(ps.name);\n                    }\n                }\n            }\n\n            // Collect vendor overlay packages.\n            // (Do this before scanning any apps.)\n            // For security and version matching reason, only consider\n            // overlay packages if they reside in VENDOR_OVERLAY_DIR.\n            File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);\n            scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);\n\n            // Find base frameworks (resource packages without code).\n            scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED,\n                    scanFlags | SCAN_NO_DEX, 0);\n\n            // Collected privileged system packages.\n            final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");\n            scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                    | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);\n\n            // Collect ordinary system packages.\n            final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");\n            scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all vendor packages.\n            File vendorAppDir = new File(\"/vendor/app\");\n            try {\n                vendorAppDir = vendorAppDir.getCanonicalFile();\n            } catch (IOException e) {\n                // failed to look up canonical path, continue with original one\n            }\n            scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            // Collect all OEM packages.\n            final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");\n            scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM\n                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);\n\n            if (DEBUG_UPGRADE) Log.v(TAG, \"Running installd update commands\");\n            mInstaller.moveFiles();\n\n            // Prune any system packages that no longer exist.\n            final List<String> possiblyDeletedUpdatedSystemApps = new ArrayList<String>();\n            if (!mOnlyCore) {\n                Iterator<PackageSetting> psit = mSettings.mPackages.values().iterator();\n                while (psit.hasNext()) {\n                    PackageSetting ps = psit.next();\n\n                    /*\n                     * If this is not a system app, it can't be a\n                     * disable system app.\n                     */\n                    if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {\n                        continue;\n                    }\n\n                    /*\n                     * If the package is scanned, it's not erased.\n                     */\n                    final PackageParser.Package scannedPkg = mPackages.get(ps.name);\n                    if (scannedPkg != null) {\n                        /*\n                         * If the system app is both scanned and in the\n                         * disabled packages list, then it must have been\n                         * added via OTA. Remove it from the currently\n                         * scanned package so the previously user-installed\n                         * application can be scanned.\n                         */\n                        if (mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                            logCriticalInfo(Log.WARN, \"Expecting better updated system app for \"\n                                    + ps.name + \"; removing system app.  Last known codePath=\"\n                                    + ps.codePathString + \", installStatus=\" + ps.installStatus\n                                    + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\"\n                                    + scannedPkg.mVersionCode);\n                            removePackageLI(ps, true);\n                            mExpectingBetter.put(ps.name, ps.codePath);\n                        }\n\n                        continue;\n                    }\n\n                    if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {\n                        psit.remove();\n                        logCriticalInfo(Log.WARN, \"System package \" + ps.name\n                                + \" no longer exists; wiping its data\");\n                        removeDataDirsLI(null, ps.name);\n                    } else {\n                        final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);\n                        if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {\n                            possiblyDeletedUpdatedSystemApps.add(ps.name);\n                        }\n                    }\n                }\n            }\n\n            //look for any incomplete package installations\n            ArrayList<PackageSetting> deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();\n            //clean up list\n            for(int i = 0; i < deletePkgsList.size(); i++) {\n                //clean up here\n                cleanupInstallFailedPackage(deletePkgsList.get(i));\n            }\n            //delete tmp files\n            deleteTempPackageFiles();\n\n            // Remove any shared userIDs that have no associated packages\n            mSettings.pruneSharedUsersLPw();\n\n            if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。\n\n* 首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,\n\n\t```\n/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found\n```\nSYSTEMSERVERCLASSPATH内容为下\n\n\t```\n/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found\n```\n\n* 获取构建时指定的cpu指令\n* 根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中\n* 将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表\n* 将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表\n* 收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息\n* 删除系统不存在的包removePackageLI\n* 清理安装失败的包 cleanupInstallFailedPackage\n* 删除临时文件\n* 移除不想干的包中的shared userIDs\n\n#### 2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\n\n```java\n          if (!mOnlyCore) {\n                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,\n                        SystemClock.uptimeMillis());\n                scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,\n                        scanFlags | SCAN_REQUIRE_KNOWN, 0);\n\n                /**\n                 * Remove disable package settings for any updated system\n                 * apps that were removed via an OTA. If they're not a\n                 * previously-updated app, remove them completely.\n                 * Otherwise, just revoke their system-level permissions.\n                 */\n                for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n                    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n                    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n                    String msg;\n                    if (deletedPkg == null) {\n                        msg = \"Updated system package \" + deletedAppName\n                                + \" no longer exists; wiping its data\";\n                        removeDataDirsLI(null, deletedAppName);\n                    } else {\n                        msg = \"Updated system app + \" + deletedAppName\n                                + \" no longer present; removing system privileges for \"\n                                + deletedAppName;\n\n                        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n                        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n                        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n                    }\n                    logCriticalInfo(Log.WARN, msg);\n                }\n\n                /**\n                 * Make sure all system apps that we expected to appear on\n                 * the userdata partition actually showed up. If they never\n                 * appeared, crawl back and revive the system version.\n                 */\n                for (int i = 0; i < mExpectingBetter.size(); i++) {\n                    final String packageName = mExpectingBetter.keyAt(i);\n                    if (!mPackages.containsKey(packageName)) {\n                        final File scanFile = mExpectingBetter.valueAt(i);\n\n                        logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                                + \" but never showed up; reverting to system\");\n\n                        final int reparseFlags;\n                        if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR\n                                    | PackageParser.PARSE_IS_PRIVILEGED;\n                        } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                            reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                                    | PackageParser.PARSE_IS_SYSTEM_DIR;\n                        } else {\n                            Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                            continue;\n                        }\n\n                        mSettings.enableSystemPackageLPw(packageName);\n\n                        try {\n                            scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);\n                        } catch (PackageManagerException e) {\n                            Slog.e(TAG, \"Failed to parse original system package: \"\n                                    + e.getMessage());\n                        }\n                    }\n                }\n            }\n            mExpectingBetter.clear();\n\n            // Now that we know all of the shared libraries, update all clients to have\n            // the correct library paths.\n            updateAllSharedLibrariesLPw();\n\n            for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n                // NOTE: We ignore potential failures here during a system scan (like\n                // the rest of the commands above) because there's precious little we\n                // can do about it. A settings error is reported, though.\n                adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                        false /* force dexopt */, false /* defer dexopt */);\n            }\n\n            // Now that we know all the packages we are keeping,\n            // read and update their last usage times.\n            mPackageUsage.readLP();\n```\n\n* mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，\n\n\n#### 2.4 PMS_SCAN_END\n\n```java\n          int updateFlags = UPDATE_PERMISSIONS_ALL;\n            if (ver.sdkVersion != mSdkVersion) {\n                Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \"\n                        + mSdkVersion + \"; regranting permissions for internal storage\");\n                updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;\n            }\n            updatePermissionsLPw(null, null, updateFlags);\n            ver.sdkVersion = mSdkVersion;\n\n            // If this is the first boot or an update from pre-M, and it is a normal\n            // boot, then we need to initialize the default preferred apps across\n            // all defined users.\n            if (!onlyCore && (mPromoteSystemApps || !mRestoredSettings)) {\n                for (UserInfo user : sUserManager.getUsers(true)) {\n                    mSettings.applyDefaultPreferredAppsLPw(this, user.id);\n                    applyFactoryDefaultBrowserLPw(user.id);\n                    primeDomainVerificationsLPw(user.id);\n                }\n            }\n\n            // If this is first boot after an OTA, and a normal boot, then\n            // we need to clear code cache directories.\n            if (mIsUpgrade && !onlyCore) {\n                Slog.i(TAG, \"Build fingerprint changed; clearing code caches\");\n                for (int i = 0; i < mSettings.mPackages.size(); i++) {\n                    final PackageSetting ps = mSettings.mPackages.valueAt(i);\n                    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) {\n                        deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);\n                    }\n                }\n                ver.fingerprint = Build.FINGERPRINT;\n            }\n\n            checkDefaultBrowser();\n\n            // clear only after permissions and other defaults have been updated\n            mExistingSystemPackages.clear();\n            mPromoteSystemApps = false;\n\n            // All the changes are done during package scanning.\n            ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;\n\n            // can downgrade to reader\n            mSettings.writeLPr();\n```\n\n* 当sdk版本不一致时，需要更新权限\n* 当这是ota后的首次启动，正常启动则需要清除目录的缓存代码\n* 当权限和其他默认项都完成更新，则清理相关信息\n* 信息写回packages.xml文件\n\n这部分不是很懂。\n\n#### 2.5 BOOT_PROGRESS_PMS_READY\n\n```java\n          mRequiredVerifierPackage = getRequiredVerifierLPr();\n            mRequiredInstallerPackage = getRequiredInstallerLPr();\n\n            mInstallerService = new PackageInstallerService(context, this);\n\n            mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();\n            mIntentFilterVerifier = new IntentVerifierProxy(mContext,\n                    mIntentFilterVerifierComponent);\n\n        } // synchronized (mPackages)\n        } // synchronized (mInstallLock)\n\n        // Now after opening every single application zip, make sure they\n        // are all flushed.  Not really needed, but keeps things nice and\n        // tidy.\n        Runtime.getRuntime().gc();\n\n        // Expose private service for system components to use.\n        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());\n```\n\n* 初始化PackageInstallerService\n* gc，回收下内存\n\n\n### 3.Settings\n\n这个类负责读取data/system下的几个xml文件。收集其中的一些信息。\n\n* packages.xml\t记录所有安装app的信息\n* packages-backup.xml\t备份文件\n* packages-stopped.xml\t记录系统被强制停止的文件\n* packages-stopped-backup.xml\t备份文件\n* packages.list\t记录应用的数据信息\n\n### 4.scanDirLI\n\n这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。\n\n```java\n       final PackageParser.Package pkg;\n        try {\n            pkg = pp.parsePackage(scanFile, parseFlags);\n        } catch (PackageParserException e) {\n            throw PackageManagerException.from(e);\n        }\n```\n\n重点看解析部分的代码。\n\n```java\n   public Package parsePackage(File packageFile, int flags) throws PackageParserException {\n        if (packageFile.isDirectory()) {\n            return parseClusterPackage(packageFile, flags);\n        } else {\n            return parseMonolithicPackage(packageFile, flags);\n        }\n    }\n```\n\n三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，\n\n```java\n            res = new Resources(assets, mMetrics, null);\n            assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                    Build.VERSION.RESOURCES_SDK_INT);\n            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\n\n            final String[] outError = new String[1];\n            final Package pkg = parseBaseApk(res, parser, flags, outError);\n```\n\n在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。\n\n```java\nif (tagName.equals(\"application\")) {\n                if (foundApp) {\n                    if (RIGID_PARSER) {\n                        outError[0] = \"<manifest> has more than one <application>\";\n                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                        return null;\n                    } else {\n                        Slog.w(TAG, \"<manifest> has more than one <application>\");\n                        XmlUtils.skipCurrentTag(parser);\n                        continue;\n                    }\n                }\n\n                foundApp = true;\n                if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) {\n                    return null;\n                }\n            }\n```\n\n用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。\n\n```java\nif (tagName.equals(\"activity\")) {\n                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false,\n                        owner.baseHardwareAccelerated);\n                if (a == null) {\n                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                    return false;\n                }\n\n                owner.activities.add(a);\n\n            }\n```\n\n这里就不多说了。\n\n### 4. dex优化\n\n在Installer中，\n\n```java\n    public int dexopt(String apkPath, int uid, boolean isPublic, String pkgName,\n            String instructionSet, int dexoptNeeded, boolean vmSafeMode,\n            boolean debuggable, String outputPath) {\n        StringBuilder builder = new StringBuilder(\"dexopt\");\n        builder.append(' ');\n        builder.append(apkPath);\n        builder.append(' ');\n        builder.append(uid);\n        builder.append(isPublic ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(pkgName);\n        builder.append(' ');\n        builder.append(instructionSet);\n        builder.append(' ');\n        builder.append(dexoptNeeded);\n        builder.append(vmSafeMode ? \" 1\" : \" 0\");\n        builder.append(debuggable ? \" 1\" : \" 0\");\n        builder.append(' ');\n        builder.append(outputPath != null ? outputPath : \"!\");\n        return execute(builder.toString());\n    }\n```\n\n进行参数封装，\n\n```java\n    public int execute(String cmd) {\n        String res = transact(cmd);\n        try {\n            return Integer.parseInt(res);\n        } catch (NumberFormatException ex) {\n            return -1;\n        }\n    }\n```\n\n在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。\n\n\n参考资料\n\n* [gityuan](http://gityuan.com/2016/11/06/packagemanager/)\n* Android 5.0 源代码\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"PMS初始化做了什么","published":1,"updated":"2017-01-07T06:58:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy250010hws6wgzsjnwl","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PackageManagerService <span class=\"title\">main</span><span class=\"params\">(Context context, Installer installer,</span></span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> factoryTest, <span class=\"keyword\">boolean</span> onlyCore) &#123;</div><div class=\"line\">    PackageManagerService m = <span class=\"keyword\">new</span> PackageManagerService(context, installer,</div><div class=\"line\">            factoryTest, onlyCore);</div><div class=\"line\">    ServiceManager.addService(<span class=\"string\">\"package\"</span>, m);</div><div class=\"line\">    <span class=\"keyword\">return</span> m;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-从pms构造函数说起\"><a href=\"#2-从pms构造函数说起\" class=\"headerlink\" title=\"2.从pms构造函数说起\"></a>2.从pms构造函数说起</h3><p>pms的构造函数相当长，根据<a href=\"http://gityuan.com/2016/11/06/packagemanager/\" target=\"_blank\" rel=\"external\">gityuan大神</a>的提示，按照log的打印进行分布查看却是清晰了很多。</p>\n<h4 id=\"2-1-BOOT-PROGRESS-PMS-START\"><a href=\"#2-1-BOOT-PROGRESS-PMS-START\" class=\"headerlink\" title=\"2.1 BOOT_PROGRESS_PMS_START\"></a>2.1 BOOT_PROGRESS_PMS_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">mContext = context;</div><div class=\"line\">mFactoryTest = factoryTest;</div><div class=\"line\">mOnlyCore = onlyCore;</div><div class=\"line\">mLazyDexOpt = <span class=\"string\">\"eng\"</span>.equals(SystemProperties.get(<span class=\"string\">\"ro.build.type\"</span>));</div><div class=\"line\">mMetrics = <span class=\"keyword\">new</span> DisplayMetrics();</div><div class=\"line\">mSettings = <span class=\"keyword\">new</span> Settings(mPackages);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.system\"</span>, Process.SYSTEM_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.phone\"</span>, RADIO_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.log\"</span>, LOG_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.nfc\"</span>, NFC_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.bluetooth\"</span>, BLUETOOTH_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.shell\"</span>, SHELL_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> add a property to control this?</span></div><div class=\"line\"><span class=\"keyword\">long</span> dexOptLRUThresholdInMinutes;</div><div class=\"line\"><span class=\"keyword\">if</span> (mLazyDexOpt) &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">30</span>; <span class=\"comment\">// only last 30 minutes of apps for eng builds.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">7</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span>; <span class=\"comment\">// apps used in the 7 days for users.</span></div><div class=\"line\">&#125;</div><div class=\"line\">mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\">String separateProcesses = SystemProperties.get(<span class=\"string\">\"debug.separate_processes\"</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (separateProcesses != <span class=\"keyword\">null</span> &amp;&amp; separateProcesses.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"*\"</span>.equals(separateProcesses)) &#123;</div><div class=\"line\">        mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</div><div class=\"line\">        mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: * (ALL)\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">        mSeparateProcesses = separateProcesses.split(<span class=\"string\">\",\"</span>);</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: \"</span></div><div class=\"line\">                + separateProcesses);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">    mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mInstaller = installer;</div><div class=\"line\">mPackageDexOptimizer = <span class=\"keyword\">new</span> PackageDexOptimizer(<span class=\"keyword\">this</span>);</div><div class=\"line\">mMoveCallbacks = <span class=\"keyword\">new</span> MoveCallbacks(FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">mOnPermissionChangeListeners = <span class=\"keyword\">new</span> OnPermissionChangeListeners(</div><div class=\"line\">        FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">getDefaultDisplayMetrics(context, mMetrics);</div><div class=\"line\"></div><div class=\"line\">SystemConfig systemConfig = SystemConfig.getInstance();</div><div class=\"line\">mGlobalGids = systemConfig.getGlobalGids();</div><div class=\"line\">mSystemPermissions = systemConfig.getSystemPermissions();</div><div class=\"line\">mAvailableFeatures = systemConfig.getAvailableFeatures();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mInstallLock) &#123;</div><div class=\"line\"><span class=\"comment\">// writer</span></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mPackages) &#123;</div><div class=\"line\">    mHandlerThread = <span class=\"keyword\">new</span> ServiceThread(TAG,</div><div class=\"line\">            Process.THREAD_PRIORITY_BACKGROUND, <span class=\"keyword\">true</span> <span class=\"comment\">/*allowIo*/</span>);</div><div class=\"line\">    mHandlerThread.start();</div><div class=\"line\">    mHandler = <span class=\"keyword\">new</span> PackageHandler(mHandlerThread.getLooper());</div><div class=\"line\">    Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</div><div class=\"line\"></div><div class=\"line\">    File dataDir = Environment.getDataDirectory();</div><div class=\"line\">    mAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"data\"</span>);</div><div class=\"line\">    mAppInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app\"</span>);</div><div class=\"line\">    mAppLib32InstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-lib\"</span>);</div><div class=\"line\">    mAsecInternalPath = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-asec\"</span>).getPath();</div><div class=\"line\">    mUserAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"user\"</span>);</div><div class=\"line\">    mDrmAppPrivateInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-private\"</span>);</div><div class=\"line\"></div><div class=\"line\">    sUserManager = <span class=\"keyword\">new</span> UserManagerService(context, <span class=\"keyword\">this</span>,</div><div class=\"line\">            mInstallLock, mPackages);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Propagate permission configuration in to package manager.</span></div><div class=\"line\">    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</div><div class=\"line\">            = systemConfig.getPermissions();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;permConfig.size(); i++) &#123;</div><div class=\"line\">        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</div><div class=\"line\">        BasePermission bp = mSettings.mPermissions.get(perm.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (bp == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp = <span class=\"keyword\">new</span> BasePermission(perm.name, <span class=\"string\">\"android\"</span>, BasePermission.TYPE_BUILTIN);</div><div class=\"line\">            mSettings.mPermissions.put(perm.name, bp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm.gids != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp.setGids(perm.gids, perm.perUser);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;libConfig.size(); i++) &#123;</div><div class=\"line\">        mSharedLibraries.put(libConfig.keyAt(i),</div><div class=\"line\">                <span class=\"keyword\">new</span> SharedLibraryEntry(libConfig.valueAt(i), <span class=\"keyword\">null</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</div><div class=\"line\"></div><div class=\"line\">    mRestoredSettings = mSettings.readLPw(<span class=\"keyword\">this</span>, sUserManager.getUsers(<span class=\"keyword\">false</span>),</div><div class=\"line\">            mSdkVersion, mOnlyCore);</div><div class=\"line\"></div><div class=\"line\">    String customResolverActivity = Resources.getSystem().getString(</div><div class=\"line\">            R.string.config_customResolverActivity);</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(customResolverActivity)) &#123;</div><div class=\"line\">        customResolverActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mCustomResolverComponentName = ComponentName.unflattenFromString(</div><div class=\"line\">                customResolverActivity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">long</span> startTime = SystemClock.uptimeMillis();</div></pre></td></tr></table></figure>\n<ul>\n<li>构造Settings对象，添加shareUserId</li>\n<li>构造SystemConfig，获取mSystemPermissions灯属性</li>\n<li>创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象</li>\n<li>从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，</li>\n</ul>\n<h4 id=\"2-2-PMS-SYSTEM-SCAN-START\"><a href=\"#2-2-PMS-SYSTEM-SCAN-START\" class=\"headerlink\" title=\"2.2 PMS_SYSTEM_SCAN_START\"></a>2.2 PMS_SYSTEM_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> ArraySet&lt;String&gt; alreadyDexOpted = <span class=\"keyword\">new</span> ArraySet&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Add everything in the in the boot class path to the</div><div class=\"line\"> * list of process files because dexopt will have been run</div><div class=\"line\"> * if necessary during zygote startup.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">final</span> String bootClassPath = System.getenv(<span class=\"string\">\"BOOTCLASSPATH\"</span>);</div><div class=\"line\"><span class=\"keyword\">final</span> String systemServerClassPath = System.getenv(<span class=\"string\">\"SYSTEMSERVERCLASSPATH\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (bootClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] bootClassPathElements = splitString(bootClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : bootClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No BOOTCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (systemServerClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : systemServerClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No SYSTEMSERVERCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</div><div class=\"line\"><span class=\"keyword\">final</span> String[] dexCodeInstructionSets =</div><div class=\"line\">        getDexCodeInstructionSets(</div><div class=\"line\">                allInstructionSets.toArray(<span class=\"keyword\">new</span> String[allInstructionSets.size()]));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Ensure all external libraries have had dexopt run on them.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">if</span> (mSharedLibraries.size() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> For now, we're compiling these system \"shared libraries\"</span></div><div class=\"line\">    <span class=\"comment\">// (and framework jars) into all available architectures. It's possible</span></div><div class=\"line\">    <span class=\"comment\">// to compile them only when we come across an app that uses them (there's</span></div><div class=\"line\">    <span class=\"comment\">// already logic for that in scanPackageLI) but that adds some complexity.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> String lib = libEntry.path;</div><div class=\"line\">            <span class=\"keyword\">if</span> (lib == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(lib, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    alreadyDexOpted.add(lib);</div><div class=\"line\">                    mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Library not found: \"</span> + lib);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Cannot dexopt \"</span> + lib + <span class=\"string\">\"; is it an APK or JAR? \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">File frameworkDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"framework\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file doesn't contain any</span></div><div class=\"line\"><span class=\"comment\">// code, so don't dexopt it to avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/framework-res.apk\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file is only part of</span></div><div class=\"line\"><span class=\"comment\">// the boot class path for art, so don't dexopt it to</span></div><div class=\"line\"><span class=\"comment\">// avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/core-libart.jar\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * There are a number of commands implemented in Java, which</div><div class=\"line\"> * we currently need to do the dexopt on so that they can be</div><div class=\"line\"> * run from a non-root shell.</div><div class=\"line\"> */</div><div class=\"line\">String[] frameworkFiles = frameworkDir.list();</div><div class=\"line\"><span class=\"keyword\">if</span> (frameworkFiles != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We could compile these only for the most preferred ABI. We should</span></div><div class=\"line\">    <span class=\"comment\">// first double check that the dex files for these commands are not referenced</span></div><div class=\"line\">    <span class=\"comment\">// by other system apps.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;frameworkFiles.length; i++) &#123;</div><div class=\"line\">            File libPath = <span class=\"keyword\">new</span> File(frameworkDir, frameworkFiles[i]);</div><div class=\"line\">            String path = libPath.getPath();</div><div class=\"line\">            <span class=\"comment\">// Skip the file if we already did it.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (alreadyDexOpted.contains(path)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// Skip the file if it is not a type we want to dexopt.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!path.endsWith(<span class=\"string\">\".apk\"</span>) &amp;&amp; !path.endsWith(<span class=\"string\">\".jar\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(path, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    mInstaller.dexopt(path, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Jar not found: \"</span> + path);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Exception reading jar: \"</span> + path, e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> VersionInfo ver = mSettings.getInternalVersion();</div><div class=\"line\">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</div><div class=\"line\"><span class=\"comment\">// when upgrading from pre-M, promote system app permissions from install to runtime</span></div><div class=\"line\">mPromoteSystemApps =</div><div class=\"line\">        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// save off the names of pre-existing system packages prior to scanning; we don't</span></div><div class=\"line\"><span class=\"comment\">// want to automatically grant runtime permissions for new system apps</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mPromoteSystemApps) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (pkgSettingIter.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = pkgSettingIter.next();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isSystemApp(ps)) &#123;</div><div class=\"line\">            mExistingSystemPackages.add(ps.name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect vendor overlay packages.</span></div><div class=\"line\"><span class=\"comment\">// (Do this before scanning any apps.)</span></div><div class=\"line\"><span class=\"comment\">// For security and version matching reason, only consider</span></div><div class=\"line\"><span class=\"comment\">// overlay packages if they reside in VENDOR_OVERLAY_DIR.</span></div><div class=\"line\">File vendorOverlayDir = <span class=\"keyword\">new</span> File(VENDOR_OVERLAY_DIR);</div><div class=\"line\">scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Find base frameworks (resource packages without code).</span></div><div class=\"line\">scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED,</div><div class=\"line\">        scanFlags | SCAN_NO_DEX, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collected privileged system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File privilegedAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"priv-app\"</span>);</div><div class=\"line\">scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect ordinary system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File systemAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all vendor packages.</span></div><div class=\"line\">File vendorAppDir = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/vendor/app\"</span>);</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    vendorAppDir = vendorAppDir.getCanonicalFile();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">    <span class=\"comment\">// failed to look up canonical path, continue with original one</span></div><div class=\"line\">&#125;</div><div class=\"line\">scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all OEM packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File oemAppDir = <span class=\"keyword\">new</span> File(Environment.getOemDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (DEBUG_UPGRADE) Log.v(TAG, <span class=\"string\">\"Running installd update commands\"</span>);</div><div class=\"line\">mInstaller.moveFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prune any system packages that no longer exist.</span></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; possiblyDeletedUpdatedSystemApps = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (psit.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = psit.next();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * If this is not a system app, it can't be a</div><div class=\"line\">         * disable system app.</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * If the package is scanned, it's not erased.</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">final</span> PackageParser.Package scannedPkg = mPackages.get(ps.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (scannedPkg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</span></div><div class=\"line\">             * If the system app is both scanned and in the</div><div class=\"line\">             * disabled packages list, then it must have been</div><div class=\"line\">             * added via OTA. Remove it from the currently</div><div class=\"line\">             * scanned package so the previously user-installed</div><div class=\"line\">             * application can be scanned.</div><div class=\"line\">             */</div><div class=\"line\">            <span class=\"keyword\">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">                logCriticalInfo(Log.WARN, <span class=\"string\">\"Expecting better updated system app for \"</span></div><div class=\"line\">                        + ps.name + <span class=\"string\">\"; removing system app.  Last known codePath=\"</span></div><div class=\"line\">                        + ps.codePathString + <span class=\"string\">\", installStatus=\"</span> + ps.installStatus</div><div class=\"line\">                        + <span class=\"string\">\", versionCode=\"</span> + ps.versionCode + <span class=\"string\">\"; scanned versionCode=\"</span></div><div class=\"line\">                        + scannedPkg.mVersionCode);</div><div class=\"line\">                removePackageLI(ps, <span class=\"keyword\">true</span>);</div><div class=\"line\">                mExpectingBetter.put(ps.name, ps.codePath);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">            psit.remove();</div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"System package \"</span> + ps.name</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>);</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, ps.name);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</div><div class=\"line\">            <span class=\"keyword\">if</span> (disabledPs.codePath == <span class=\"keyword\">null</span> || !disabledPs.codePath.exists()) &#123;</div><div class=\"line\">                possiblyDeletedUpdatedSystemApps.add(ps.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//look for any incomplete package installations</span></div><div class=\"line\">ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</div><div class=\"line\"><span class=\"comment\">//clean up list</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deletePkgsList.size(); i++) &#123;</div><div class=\"line\">    <span class=\"comment\">//clean up here</span></div><div class=\"line\">    cleanupInstallFailedPackage(deletePkgsList.get(i));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//delete tmp files</span></div><div class=\"line\">deleteTempPackageFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Remove any shared userIDs that have no associated packages</span></div><div class=\"line\">mSettings.pruneSharedUsersLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">    scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">            scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Remove disable package settings for any updated system</div><div class=\"line\">     * apps that were removed via an OTA. If they're not a</div><div class=\"line\">     * previously-updated app, remove them completely.</div><div class=\"line\">     * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">        PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">        mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">        String msg;</div><div class=\"line\">        <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                    + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">            deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">            PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">            deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">        &#125;</div><div class=\"line\">        logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Make sure all system apps that we expected to appear on</div><div class=\"line\">     * the userdata partition actually showed up. If they never</div><div class=\"line\">     * appeared, crawl back and revive the system version.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                    + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">            <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                        | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\"><span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">    <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">    <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">    adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">            <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\"><span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<p>扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。</p>\n<ul>\n<li><p>首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>SYSTEMSERVERCLASSPATH内容为下</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>获取构建时指定的cpu指令</li>\n<li>根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中</li>\n<li>将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表</li>\n<li>将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表</li>\n<li>收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息</li>\n<li>删除系统不存在的包removePackageLI</li>\n<li>清理安装失败的包 cleanupInstallFailedPackage</li>\n<li>删除临时文件</li>\n<li>移除不想干的包中的shared userIDs</li>\n</ul>\n<h4 id=\"2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\"><a href=\"#2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\" class=\"headerlink\" title=\"2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\"></a>2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">              SystemClock.uptimeMillis());</div><div class=\"line\">      scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">              scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</span></div><div class=\"line\">       * Remove disable package settings for any updated system</div><div class=\"line\">       * apps that were removed via an OTA. If they're not a</div><div class=\"line\">       * previously-updated app, remove them completely.</div><div class=\"line\">       * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">       */</div><div class=\"line\">      <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">          PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">          mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">          String msg;</div><div class=\"line\">          <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">              removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                      + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">              deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">              PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">              deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">          &#125;</div><div class=\"line\">          logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</span></div><div class=\"line\">       * Make sure all system apps that we expected to appear on</div><div class=\"line\">       * the userdata partition actually showed up. If they never</div><div class=\"line\">       * appeared, crawl back and revive the system version.</div><div class=\"line\">       */</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">              <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">              logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                      + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">              <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                          | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                  <span class=\"keyword\">continue</span>;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">              mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                  scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">              &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                          + e.getMessage());</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\">  <span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">  updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">      <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">      <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">      adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">              <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\">  <span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">  mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<ul>\n<li>mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，</li>\n</ul>\n<h4 id=\"2-4-PMS-SCAN-END\"><a href=\"#2-4-PMS-SCAN-END\" class=\"headerlink\" title=\"2.4 PMS_SCAN_END\"></a>2.4 PMS_SCAN_END</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> updateFlags = UPDATE_PERMISSIONS_ALL;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ver.sdkVersion != mSdkVersion) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Platform changed from \"</span> + ver.sdkVersion + <span class=\"string\">\" to \"</span></div><div class=\"line\">              + mSdkVersion + <span class=\"string\">\"; regranting permissions for internal storage\"</span>);</div><div class=\"line\">      updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</div><div class=\"line\">  &#125;</div><div class=\"line\">  updatePermissionsLPw(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, updateFlags);</div><div class=\"line\">  ver.sdkVersion = mSdkVersion;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is the first boot or an update from pre-M, and it is a normal</span></div><div class=\"line\">  <span class=\"comment\">// boot, then we need to initialize the default preferred apps across</span></div><div class=\"line\">  <span class=\"comment\">// all defined users.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (UserInfo user : sUserManager.getUsers(<span class=\"keyword\">true</span>)) &#123;</div><div class=\"line\">          mSettings.applyDefaultPreferredAppsLPw(<span class=\"keyword\">this</span>, user.id);</div><div class=\"line\">          applyFactoryDefaultBrowserLPw(user.id);</div><div class=\"line\">          primeDomainVerificationsLPw(user.id);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is first boot after an OTA, and a normal boot, then</span></div><div class=\"line\">  <span class=\"comment\">// we need to clear code cache directories.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Build fingerprint changed; clearing code caches\"</span>);</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mSettings.mPackages.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</div><div class=\"line\">              deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      ver.fingerprint = Build.FINGERPRINT;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  checkDefaultBrowser();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// clear only after permissions and other defaults have been updated</span></div><div class=\"line\">  mExistingSystemPackages.clear();</div><div class=\"line\">  mPromoteSystemApps = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// All the changes are done during package scanning.</span></div><div class=\"line\">  ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// can downgrade to reader</span></div><div class=\"line\">  mSettings.writeLPr();</div></pre></td></tr></table></figure>\n<ul>\n<li>当sdk版本不一致时，需要更新权限</li>\n<li>当这是ota后的首次启动，正常启动则需要清除目录的缓存代码</li>\n<li>当权限和其他默认项都完成更新，则清理相关信息</li>\n<li>信息写回packages.xml文件</li>\n</ul>\n<p>这部分不是很懂。</p>\n<h4 id=\"2-5-BOOT-PROGRESS-PMS-READY\"><a href=\"#2-5-BOOT-PROGRESS-PMS-READY\" class=\"headerlink\" title=\"2.5 BOOT_PROGRESS_PMS_READY\"></a>2.5 BOOT_PROGRESS_PMS_READY</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">  mRequiredVerifierPackage = getRequiredVerifierLPr();</div><div class=\"line\">    mRequiredInstallerPackage = getRequiredInstallerLPr();</div><div class=\"line\"></div><div class=\"line\">    mInstallerService = <span class=\"keyword\">new</span> PackageInstallerService(context, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</div><div class=\"line\">    mIntentFilterVerifier = <span class=\"keyword\">new</span> IntentVerifierProxy(mContext,</div><div class=\"line\">            mIntentFilterVerifierComponent);</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mPackages)</span></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mInstallLock)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now after opening every single application zip, make sure they</span></div><div class=\"line\"><span class=\"comment\">// are all flushed.  Not really needed, but keeps things nice and</span></div><div class=\"line\"><span class=\"comment\">// tidy.</span></div><div class=\"line\">Runtime.getRuntime().gc();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Expose private service for system components to use.</span></div><div class=\"line\">LocalServices.addService(PackageManagerInternal.class, <span class=\"keyword\">new</span> PackageManagerInternalImpl());</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化PackageInstallerService</li>\n<li>gc，回收下内存</li>\n</ul>\n<h3 id=\"3-Settings\"><a href=\"#3-Settings\" class=\"headerlink\" title=\"3.Settings\"></a>3.Settings</h3><p>这个类负责读取data/system下的几个xml文件。收集其中的一些信息。</p>\n<ul>\n<li>packages.xml    记录所有安装app的信息</li>\n<li>packages-backup.xml    备份文件</li>\n<li>packages-stopped.xml    记录系统被强制停止的文件</li>\n<li>packages-stopped-backup.xml    备份文件</li>\n<li>packages.list    记录应用的数据信息</li>\n</ul>\n<h3 id=\"4-scanDirLI\"><a href=\"#4-scanDirLI\" class=\"headerlink\" title=\"4.scanDirLI\"></a>4.scanDirLI</h3><p>这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> PackageParser.Package pkg;</div><div class=\"line\"> <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     pkg = pp.parsePackage(scanFile, parseFlags);</div><div class=\"line\"> &#125; <span class=\"keyword\">catch</span> (PackageParserException e) &#123;</div><div class=\"line\">     <span class=\"keyword\">throw</span> PackageManagerException.from(e);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>重点看解析部分的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Package <span class=\"title\">parsePackage</span><span class=\"params\">(File packageFile, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> PackageParserException </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (packageFile.isDirectory()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseClusterPackage(packageFile, flags);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseMonolithicPackage(packageFile, flags);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = <span class=\"keyword\">new</span> Resources(assets, mMetrics, <span class=\"keyword\">null</span>);</div><div class=\"line\">assets.setConfiguration(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        Build.VERSION.RESOURCES_SDK_INT);</div><div class=\"line\">parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> String[] outError = <span class=\"keyword\">new</span> String[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">final</span> Package pkg = parseBaseApk(res, parser, flags, outError);</div></pre></td></tr></table></figure>\n<p>在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"application\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (foundApp) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (RIGID_PARSER) &#123;</div><div class=\"line\">                        outError[<span class=\"number\">0</span>] = <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>;</div><div class=\"line\">                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        Slog.w(TAG, <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>);</div><div class=\"line\">                        XmlUtils.skipCurrentTag(parser);</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                foundApp = <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"activity\"</span>)) &#123;</div><div class=\"line\">                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, <span class=\"keyword\">false</span>,</div><div class=\"line\">                        owner.baseHardwareAccelerated);</div><div class=\"line\">                <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                owner.activities.add(a);</div><div class=\"line\"></div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>这里就不多说了。</p>\n<h3 id=\"4-dex优化\"><a href=\"#4-dex优化\" class=\"headerlink\" title=\"4. dex优化\"></a>4. dex优化</h3><p>在Installer中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dexopt</span><span class=\"params\">(String apkPath, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">boolean</span> isPublic, String pkgName,</span></span></div><div class=\"line\">        String instructionSet, <span class=\"keyword\">int</span> dexoptNeeded, <span class=\"keyword\">boolean</span> vmSafeMode,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> debuggable, String outputPath) &#123;</div><div class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"dexopt\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(apkPath);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(uid);</div><div class=\"line\">    builder.append(isPublic ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(pkgName);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(instructionSet);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(dexoptNeeded);</div><div class=\"line\">    builder.append(vmSafeMode ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(debuggable ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(outputPath != <span class=\"keyword\">null</span> ? outputPath : <span class=\"string\">\"!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> execute(builder.toString());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进行参数封装，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">execute</span><span class=\"params\">(String cmd)</span> </span>&#123;</div><div class=\"line\">    String res = transact(cmd);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Integer.parseInt(res);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException ex) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。</p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://gityuan.com/2016/11/06/packagemanager/\" target=\"_blank\" rel=\"external\">gityuan</a></li>\n<li>Android 5.0 源代码</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>在SystemServer初始化过程当中，会调用PackageManagerService.main方法进行pms的初始化，那么我们就看看pms的初始化过程经历了什么。</p>","more":"<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PackageManagerService <span class=\"title\">main</span><span class=\"params\">(Context context, Installer installer,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> factoryTest, <span class=\"keyword\">boolean</span> onlyCore)</span> </span>&#123;</div><div class=\"line\">    PackageManagerService m = <span class=\"keyword\">new</span> PackageManagerService(context, installer,</div><div class=\"line\">            factoryTest, onlyCore);</div><div class=\"line\">    ServiceManager.addService(<span class=\"string\">\"package\"</span>, m);</div><div class=\"line\">    <span class=\"keyword\">return</span> m;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-从pms构造函数说起\"><a href=\"#2-从pms构造函数说起\" class=\"headerlink\" title=\"2.从pms构造函数说起\"></a>2.从pms构造函数说起</h3><p>pms的构造函数相当长，根据<a href=\"http://gityuan.com/2016/11/06/packagemanager/\">gityuan大神</a>的提示，按照log的打印进行分布查看却是清晰了很多。</p>\n<h4 id=\"2-1-BOOT-PROGRESS-PMS-START\"><a href=\"#2-1-BOOT-PROGRESS-PMS-START\" class=\"headerlink\" title=\"2.1 BOOT_PROGRESS_PMS_START\"></a>2.1 BOOT_PROGRESS_PMS_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">mContext = context;</div><div class=\"line\">mFactoryTest = factoryTest;</div><div class=\"line\">mOnlyCore = onlyCore;</div><div class=\"line\">mLazyDexOpt = <span class=\"string\">\"eng\"</span>.equals(SystemProperties.get(<span class=\"string\">\"ro.build.type\"</span>));</div><div class=\"line\">mMetrics = <span class=\"keyword\">new</span> DisplayMetrics();</div><div class=\"line\">mSettings = <span class=\"keyword\">new</span> Settings(mPackages);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.system\"</span>, Process.SYSTEM_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.phone\"</span>, RADIO_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.log\"</span>, LOG_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.nfc\"</span>, NFC_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.bluetooth\"</span>, BLUETOOTH_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\">mSettings.addSharedUserLPw(<span class=\"string\">\"android.uid.shell\"</span>, SHELL_UID,</div><div class=\"line\">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> add a property to control this?</span></div><div class=\"line\"><span class=\"keyword\">long</span> dexOptLRUThresholdInMinutes;</div><div class=\"line\"><span class=\"keyword\">if</span> (mLazyDexOpt) &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">30</span>; <span class=\"comment\">// only last 30 minutes of apps for eng builds.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    dexOptLRUThresholdInMinutes = <span class=\"number\">7</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span>; <span class=\"comment\">// apps used in the 7 days for users.</span></div><div class=\"line\">&#125;</div><div class=\"line\">mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</div><div class=\"line\"></div><div class=\"line\">String separateProcesses = SystemProperties.get(<span class=\"string\">\"debug.separate_processes\"</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (separateProcesses != <span class=\"keyword\">null</span> &amp;&amp; separateProcesses.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"*\"</span>.equals(separateProcesses)) &#123;</div><div class=\"line\">        mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;</div><div class=\"line\">        mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: * (ALL)\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">        mSeparateProcesses = separateProcesses.split(<span class=\"string\">\",\"</span>);</div><div class=\"line\">        Slog.w(TAG, <span class=\"string\">\"Running with debug.separate_processes: \"</span></div><div class=\"line\">                + separateProcesses);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    mDefParseFlags = <span class=\"number\">0</span>;</div><div class=\"line\">    mSeparateProcesses = <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">mInstaller = installer;</div><div class=\"line\">mPackageDexOptimizer = <span class=\"keyword\">new</span> PackageDexOptimizer(<span class=\"keyword\">this</span>);</div><div class=\"line\">mMoveCallbacks = <span class=\"keyword\">new</span> MoveCallbacks(FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">mOnPermissionChangeListeners = <span class=\"keyword\">new</span> OnPermissionChangeListeners(</div><div class=\"line\">        FgThread.get().getLooper());</div><div class=\"line\"></div><div class=\"line\">getDefaultDisplayMetrics(context, mMetrics);</div><div class=\"line\"></div><div class=\"line\">SystemConfig systemConfig = SystemConfig.getInstance();</div><div class=\"line\">mGlobalGids = systemConfig.getGlobalGids();</div><div class=\"line\">mSystemPermissions = systemConfig.getSystemPermissions();</div><div class=\"line\">mAvailableFeatures = systemConfig.getAvailableFeatures();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mInstallLock) &#123;</div><div class=\"line\"><span class=\"comment\">// writer</span></div><div class=\"line\"><span class=\"keyword\">synchronized</span> (mPackages) &#123;</div><div class=\"line\">    mHandlerThread = <span class=\"keyword\">new</span> ServiceThread(TAG,</div><div class=\"line\">            Process.THREAD_PRIORITY_BACKGROUND, <span class=\"keyword\">true</span> <span class=\"comment\">/*allowIo*/</span>);</div><div class=\"line\">    mHandlerThread.start();</div><div class=\"line\">    mHandler = <span class=\"keyword\">new</span> PackageHandler(mHandlerThread.getLooper());</div><div class=\"line\">    Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</div><div class=\"line\"></div><div class=\"line\">    File dataDir = Environment.getDataDirectory();</div><div class=\"line\">    mAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"data\"</span>);</div><div class=\"line\">    mAppInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app\"</span>);</div><div class=\"line\">    mAppLib32InstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-lib\"</span>);</div><div class=\"line\">    mAsecInternalPath = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-asec\"</span>).getPath();</div><div class=\"line\">    mUserAppDataDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"user\"</span>);</div><div class=\"line\">    mDrmAppPrivateInstallDir = <span class=\"keyword\">new</span> File(dataDir, <span class=\"string\">\"app-private\"</span>);</div><div class=\"line\"></div><div class=\"line\">    sUserManager = <span class=\"keyword\">new</span> UserManagerService(context, <span class=\"keyword\">this</span>,</div><div class=\"line\">            mInstallLock, mPackages);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Propagate permission configuration in to package manager.</span></div><div class=\"line\">    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</div><div class=\"line\">            = systemConfig.getPermissions();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;permConfig.size(); i++) &#123;</div><div class=\"line\">        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</div><div class=\"line\">        BasePermission bp = mSettings.mPermissions.get(perm.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (bp == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp = <span class=\"keyword\">new</span> BasePermission(perm.name, <span class=\"string\">\"android\"</span>, BasePermission.TYPE_BUILTIN);</div><div class=\"line\">            mSettings.mPermissions.put(perm.name, bp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm.gids != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            bp.setGids(perm.gids, perm.perUser);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;libConfig.size(); i++) &#123;</div><div class=\"line\">        mSharedLibraries.put(libConfig.keyAt(i),</div><div class=\"line\">                <span class=\"keyword\">new</span> SharedLibraryEntry(libConfig.valueAt(i), <span class=\"keyword\">null</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</div><div class=\"line\"></div><div class=\"line\">    mRestoredSettings = mSettings.readLPw(<span class=\"keyword\">this</span>, sUserManager.getUsers(<span class=\"keyword\">false</span>),</div><div class=\"line\">            mSdkVersion, mOnlyCore);</div><div class=\"line\"></div><div class=\"line\">    String customResolverActivity = Resources.getSystem().getString(</div><div class=\"line\">            R.string.config_customResolverActivity);</div><div class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(customResolverActivity)) &#123;</div><div class=\"line\">        customResolverActivity = <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mCustomResolverComponentName = ComponentName.unflattenFromString(</div><div class=\"line\">                customResolverActivity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">long</span> startTime = SystemClock.uptimeMillis();</div></pre></td></tr></table></figure>\n<ul>\n<li>构造Settings对象，添加shareUserId</li>\n<li>构造SystemConfig，获取mSystemPermissions灯属性</li>\n<li>创建data/data,data/app/,data/app-lib,data-asec,data/user,data/app-privat等file对象</li>\n<li>从systemConfig中获取到所有的共享库，添加到mSharedLibraries中，</li>\n</ul>\n<h4 id=\"2-2-PMS-SYSTEM-SCAN-START\"><a href=\"#2-2-PMS-SYSTEM-SCAN-START\" class=\"headerlink\" title=\"2.2 PMS_SYSTEM_SCAN_START\"></a>2.2 PMS_SYSTEM_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> ArraySet&lt;String&gt; alreadyDexOpted = <span class=\"keyword\">new</span> ArraySet&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Add everything in the in the boot class path to the</div><div class=\"line\"> * list of process files because dexopt will have been run</div><div class=\"line\"> * if necessary during zygote startup.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">final</span> String bootClassPath = System.getenv(<span class=\"string\">\"BOOTCLASSPATH\"</span>);</div><div class=\"line\"><span class=\"keyword\">final</span> String systemServerClassPath = System.getenv(<span class=\"string\">\"SYSTEMSERVERCLASSPATH\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (bootClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] bootClassPathElements = splitString(bootClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : bootClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No BOOTCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (systemServerClassPath != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class=\"string\">':'</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String element : systemServerClassPathElements) &#123;</div><div class=\"line\">        alreadyDexOpted.add(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No SYSTEMSERVERCLASSPATH found!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</div><div class=\"line\"><span class=\"keyword\">final</span> String[] dexCodeInstructionSets =</div><div class=\"line\">        getDexCodeInstructionSets(</div><div class=\"line\">                allInstructionSets.toArray(<span class=\"keyword\">new</span> String[allInstructionSets.size()]));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Ensure all external libraries have had dexopt run on them.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mSharedLibraries.size() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> For now, we're compiling these system \"shared libraries\"</span></div><div class=\"line\">    <span class=\"comment\">// (and framework jars) into all available architectures. It's possible</span></div><div class=\"line\">    <span class=\"comment\">// to compile them only when we come across an app that uses them (there's</span></div><div class=\"line\">    <span class=\"comment\">// already logic for that in scanPackageLI) but that adds some complexity.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> String lib = libEntry.path;</div><div class=\"line\">            <span class=\"keyword\">if</span> (lib == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(lib, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    alreadyDexOpted.add(lib);</div><div class=\"line\">                    mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Library not found: \"</span> + lib);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Cannot dexopt \"</span> + lib + <span class=\"string\">\"; is it an APK or JAR? \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">File frameworkDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"framework\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file doesn't contain any</span></div><div class=\"line\"><span class=\"comment\">// code, so don't dexopt it to avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/framework-res.apk\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Gross hack for now: we know this file is only part of</span></div><div class=\"line\"><span class=\"comment\">// the boot class path for art, so don't dexopt it to</span></div><div class=\"line\"><span class=\"comment\">// avoid the resulting log spew.</span></div><div class=\"line\">alreadyDexOpted.add(frameworkDir.getPath() + <span class=\"string\">\"/core-libart.jar\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * There are a number of commands implemented in Java, which</div><div class=\"line\"> * we currently need to do the dexopt on so that they can be</div><div class=\"line\"> * run from a non-root shell.</div><div class=\"line\"> */</span></div><div class=\"line\">String[] frameworkFiles = frameworkDir.list();</div><div class=\"line\"><span class=\"keyword\">if</span> (frameworkFiles != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We could compile these only for the most preferred ABI. We should</span></div><div class=\"line\">    <span class=\"comment\">// first double check that the dex files for these commands are not referenced</span></div><div class=\"line\">    <span class=\"comment\">// by other system apps.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;frameworkFiles.length; i++) &#123;</div><div class=\"line\">            File libPath = <span class=\"keyword\">new</span> File(frameworkDir, frameworkFiles[i]);</div><div class=\"line\">            String path = libPath.getPath();</div><div class=\"line\">            <span class=\"comment\">// Skip the file if we already did it.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (alreadyDexOpted.contains(path)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// Skip the file if it is not a type we want to dexopt.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!path.endsWith(<span class=\"string\">\".apk\"</span>) &amp;&amp; !path.endsWith(<span class=\"string\">\".jar\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> dexoptNeeded = DexFile.getDexOptNeeded(path, <span class=\"keyword\">null</span>, dexCodeInstructionSet, <span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</div><div class=\"line\">                    mInstaller.dexopt(path, Process.SYSTEM_UID, <span class=\"keyword\">true</span>, dexCodeInstructionSet, dexoptNeeded);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Jar not found: \"</span> + path);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">                Slog.w(TAG, <span class=\"string\">\"Exception reading jar: \"</span> + path, e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> VersionInfo ver = mSettings.getInternalVersion();</div><div class=\"line\">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</div><div class=\"line\"><span class=\"comment\">// when upgrading from pre-M, promote system app permissions from install to runtime</span></div><div class=\"line\">mPromoteSystemApps =</div><div class=\"line\">        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// save off the names of pre-existing system packages prior to scanning; we don't</span></div><div class=\"line\"><span class=\"comment\">// want to automatically grant runtime permissions for new system apps</span></div><div class=\"line\"><span class=\"keyword\">if</span> (mPromoteSystemApps) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (pkgSettingIter.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = pkgSettingIter.next();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isSystemApp(ps)) &#123;</div><div class=\"line\">            mExistingSystemPackages.add(ps.name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect vendor overlay packages.</span></div><div class=\"line\"><span class=\"comment\">// (Do this before scanning any apps.)</span></div><div class=\"line\"><span class=\"comment\">// For security and version matching reason, only consider</span></div><div class=\"line\"><span class=\"comment\">// overlay packages if they reside in VENDOR_OVERLAY_DIR.</span></div><div class=\"line\">File vendorOverlayDir = <span class=\"keyword\">new</span> File(VENDOR_OVERLAY_DIR);</div><div class=\"line\">scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Find base frameworks (resource packages without code).</span></div><div class=\"line\">scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED,</div><div class=\"line\">        scanFlags | SCAN_NO_DEX, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collected privileged system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File privilegedAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"priv-app\"</span>);</div><div class=\"line\">scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect ordinary system packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File systemAppDir = <span class=\"keyword\">new</span> File(Environment.getRootDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all vendor packages.</span></div><div class=\"line\">File vendorAppDir = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/vendor/app\"</span>);</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    vendorAppDir = vendorAppDir.getCanonicalFile();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">    <span class=\"comment\">// failed to look up canonical path, continue with original one</span></div><div class=\"line\">&#125;</div><div class=\"line\">scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Collect all OEM packages.</span></div><div class=\"line\"><span class=\"keyword\">final</span> File oemAppDir = <span class=\"keyword\">new</span> File(Environment.getOemDirectory(), <span class=\"string\">\"app\"</span>);</div><div class=\"line\">scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (DEBUG_UPGRADE) Log.v(TAG, <span class=\"string\">\"Running installd update commands\"</span>);</div><div class=\"line\">mInstaller.moveFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prune any system packages that no longer exist.</span></div><div class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; possiblyDeletedUpdatedSystemApps = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</div><div class=\"line\">    <span class=\"keyword\">while</span> (psit.hasNext()) &#123;</div><div class=\"line\">        PackageSetting ps = psit.next();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * If this is not a system app, it can't be a</div><div class=\"line\">         * disable system app.</div><div class=\"line\">         */</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * If the package is scanned, it's not erased.</div><div class=\"line\">         */</span></div><div class=\"line\">        <span class=\"keyword\">final</span> PackageParser.Package scannedPkg = mPackages.get(ps.name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (scannedPkg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</div><div class=\"line\">             * If the system app is both scanned and in the</div><div class=\"line\">             * disabled packages list, then it must have been</div><div class=\"line\">             * added via OTA. Remove it from the currently</div><div class=\"line\">             * scanned package so the previously user-installed</div><div class=\"line\">             * application can be scanned.</div><div class=\"line\">             */</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">                logCriticalInfo(Log.WARN, <span class=\"string\">\"Expecting better updated system app for \"</span></div><div class=\"line\">                        + ps.name + <span class=\"string\">\"; removing system app.  Last known codePath=\"</span></div><div class=\"line\">                        + ps.codePathString + <span class=\"string\">\", installStatus=\"</span> + ps.installStatus</div><div class=\"line\">                        + <span class=\"string\">\", versionCode=\"</span> + ps.versionCode + <span class=\"string\">\"; scanned versionCode=\"</span></div><div class=\"line\">                        + scannedPkg.mVersionCode);</div><div class=\"line\">                removePackageLI(ps, <span class=\"keyword\">true</span>);</div><div class=\"line\">                mExpectingBetter.put(ps.name, ps.codePath);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</div><div class=\"line\">            psit.remove();</div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"System package \"</span> + ps.name</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>);</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, ps.name);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</div><div class=\"line\">            <span class=\"keyword\">if</span> (disabledPs.codePath == <span class=\"keyword\">null</span> || !disabledPs.codePath.exists()) &#123;</div><div class=\"line\">                possiblyDeletedUpdatedSystemApps.add(ps.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//look for any incomplete package installations</span></div><div class=\"line\">ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</div><div class=\"line\"><span class=\"comment\">//clean up list</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deletePkgsList.size(); i++) &#123;</div><div class=\"line\">    <span class=\"comment\">//clean up here</span></div><div class=\"line\">    cleanupInstallFailedPackage(deletePkgsList.get(i));</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//delete tmp files</span></div><div class=\"line\">deleteTempPackageFiles();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Remove any shared userIDs that have no associated packages</span></div><div class=\"line\">mSettings.pruneSharedUsersLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">    scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">            scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Remove disable package settings for any updated system</div><div class=\"line\">     * apps that were removed via an OTA. If they're not a</div><div class=\"line\">     * previously-updated app, remove them completely.</div><div class=\"line\">     * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">        PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">        mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">        String msg;</div><div class=\"line\">        <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">            removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                    + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                    + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">            deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">            PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">            deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">        &#125;</div><div class=\"line\">        logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Make sure all system apps that we expected to appear on</div><div class=\"line\">     * the userdata partition actually showed up. If they never</div><div class=\"line\">     * appeared, crawl back and revive the system version.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">            logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                    + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">            <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                        | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                        | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                        + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\"><span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">    <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">    <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">    adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">            <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\"><span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<p>扫描阶段，这个阶段主要是对 包进行解析，得到组件信息等内容，并且根据需要进行dex优化。</p>\n<ul>\n<li><p>首先将BOOTCLASSPATH，SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要dex优化列表，在我的小米note手机上，BOOTCLASSPATH内容为下,</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/core-junit.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/apache-xml.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/tcmiface.jar:/system/framework/qcmediaplayer.jar:/system/framework/WfdCommon.jar:/system/framework/qcom.fmradio.jar:/system/framework/oem-services.jar:/system/framework/com.qti.dpmframework.jar:/system/framework/dpmapi.jar:/system/framework/com.qti.location.sdk.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk: not found</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>SYSTEMSERVERCLASSPATH内容为下</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/system/bin/sh: /system/framework/services.jar:/system/framework/wifi-service.jar:/system/framework/ethernet-service.jar: not found</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>获取构建时指定的cpu指令</li>\n<li>根据cpu指令得到SharedLibrarie，判断是否需要dex优化，进行dex优化，并加入到alreadyDexOpted列表中</li>\n<li>将framework/framework-res.apk，framework/core-libart.jar，等加入到已优化列表</li>\n<li>将framework目录下，其他的apk或者jar，进行dex优化并加入已优化列表</li>\n<li>收集解析/vendor/overlay，/system/framework，/system/priv-app，/system/app，/vendor/priv-app，/vendor/app，/oem/app目录下app的信息</li>\n<li>删除系统不存在的包removePackageLI</li>\n<li>清理安装失败的包 cleanupInstallFailedPackage</li>\n<li>删除临时文件</li>\n<li>移除不想干的包中的shared userIDs</li>\n</ul>\n<h4 id=\"2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\"><a href=\"#2-3-BOOT-PROGRESS-PMS-DATA-SCAN-START\" class=\"headerlink\" title=\"2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START\"></a>2.3 BOOT_PROGRESS_PMS_DATA_SCAN_START</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!mOnlyCore) &#123;</div><div class=\"line\">      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</div><div class=\"line\">              SystemClock.uptimeMillis());</div><div class=\"line\">      scanDirLI(mAppInstallDir, <span class=\"number\">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</div><div class=\"line\">              scanFlags | SCAN_REQUIRE_KNOWN, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</div><div class=\"line\">       * Remove disable package settings for any updated system</div><div class=\"line\">       * apps that were removed via an OTA. If they're not a</div><div class=\"line\">       * previously-updated app, remove them completely.</div><div class=\"line\">       * Otherwise, just revoke their system-level permissions.</div><div class=\"line\">       */</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</div><div class=\"line\">          PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</div><div class=\"line\">          mSettings.removeDisabledSystemPackageLPw(deletedAppName);</div><div class=\"line\"></div><div class=\"line\">          String msg;</div><div class=\"line\">          <span class=\"keyword\">if</span> (deletedPkg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system package \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer exists; wiping its data\"</span>;</div><div class=\"line\">              removeDataDirsLI(<span class=\"keyword\">null</span>, deletedAppName);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              msg = <span class=\"string\">\"Updated system app + \"</span> + deletedAppName</div><div class=\"line\">                      + <span class=\"string\">\" no longer present; removing system privileges for \"</span></div><div class=\"line\">                      + deletedAppName;</div><div class=\"line\"></div><div class=\"line\">              deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\"></div><div class=\"line\">              PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</div><div class=\"line\">              deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</div><div class=\"line\">          &#125;</div><div class=\"line\">          logCriticalInfo(Log.WARN, msg);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/**</div><div class=\"line\">       * Make sure all system apps that we expected to appear on</div><div class=\"line\">       * the userdata partition actually showed up. If they never</div><div class=\"line\">       * appeared, crawl back and revive the system version.</div><div class=\"line\">       */</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> String packageName = mExpectingBetter.keyAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (!mPackages.containsKey(packageName)) &#123;</div><div class=\"line\">              <span class=\"keyword\">final</span> File scanFile = mExpectingBetter.valueAt(i);</div><div class=\"line\"></div><div class=\"line\">              logCriticalInfo(Log.WARN, <span class=\"string\">\"Expected better \"</span> + packageName</div><div class=\"line\">                      + <span class=\"string\">\" but never showed up; reverting to system\"</span>);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reparseFlags;</div><div class=\"line\">              <span class=\"keyword\">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR</div><div class=\"line\">                          | PackageParser.PARSE_IS_PRIVILEGED;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(vendorAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (FileUtils.contains(oemAppDir, scanFile)) &#123;</div><div class=\"line\">                  reparseFlags = PackageParser.PARSE_IS_SYSTEM</div><div class=\"line\">                          | PackageParser.PARSE_IS_SYSTEM_DIR;</div><div class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Ignoring unexpected fallback path \"</span> + scanFile);</div><div class=\"line\">                  <span class=\"keyword\">continue</span>;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">              mSettings.enableSystemPackageLPw(packageName);</div><div class=\"line\"></div><div class=\"line\">              <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                  scanPackageLI(scanFile, reparseFlags, scanFlags, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">              &#125; <span class=\"keyword\">catch</span> (PackageManagerException e) &#123;</div><div class=\"line\">                  Slog.e(TAG, <span class=\"string\">\"Failed to parse original system package: \"</span></div><div class=\"line\">                          + e.getMessage());</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  mExpectingBetter.clear();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all of the shared libraries, update all clients to have</span></div><div class=\"line\">  <span class=\"comment\">// the correct library paths.</span></div><div class=\"line\">  updateAllSharedLibrariesLPw();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</div><div class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> We ignore potential failures here during a system scan (like</span></div><div class=\"line\">      <span class=\"comment\">// the rest of the commands above) because there's precious little we</span></div><div class=\"line\">      <span class=\"comment\">// can do about it. A settings error is reported, though.</span></div><div class=\"line\">      adjustCpuAbisForSharedUserLPw(setting.packages, <span class=\"keyword\">null</span> <span class=\"comment\">/* scanned package */</span>,</div><div class=\"line\">              <span class=\"keyword\">false</span> <span class=\"comment\">/* force dexopt */</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* defer dexopt */</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Now that we know all the packages we are keeping,</span></div><div class=\"line\">  <span class=\"comment\">// read and update their last usage times.</span></div><div class=\"line\">  mPackageUsage.readLP();</div></pre></td></tr></table></figure>\n<ul>\n<li>mOnlyCore为false的情况下，会扫描/data/app，/data/app-private目录，</li>\n</ul>\n<h4 id=\"2-4-PMS-SCAN-END\"><a href=\"#2-4-PMS-SCAN-END\" class=\"headerlink\" title=\"2.4 PMS_SCAN_END\"></a>2.4 PMS_SCAN_END</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> updateFlags = UPDATE_PERMISSIONS_ALL;</div><div class=\"line\">  <span class=\"keyword\">if</span> (ver.sdkVersion != mSdkVersion) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Platform changed from \"</span> + ver.sdkVersion + <span class=\"string\">\" to \"</span></div><div class=\"line\">              + mSdkVersion + <span class=\"string\">\"; regranting permissions for internal storage\"</span>);</div><div class=\"line\">      updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</div><div class=\"line\">  &#125;</div><div class=\"line\">  updatePermissionsLPw(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, updateFlags);</div><div class=\"line\">  ver.sdkVersion = mSdkVersion;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is the first boot or an update from pre-M, and it is a normal</span></div><div class=\"line\">  <span class=\"comment\">// boot, then we need to initialize the default preferred apps across</span></div><div class=\"line\">  <span class=\"comment\">// all defined users.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (UserInfo user : sUserManager.getUsers(<span class=\"keyword\">true</span>)) &#123;</div><div class=\"line\">          mSettings.applyDefaultPreferredAppsLPw(<span class=\"keyword\">this</span>, user.id);</div><div class=\"line\">          applyFactoryDefaultBrowserLPw(user.id);</div><div class=\"line\">          primeDomainVerificationsLPw(user.id);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If this is first boot after an OTA, and a normal boot, then</span></div><div class=\"line\">  <span class=\"comment\">// we need to clear code cache directories.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</div><div class=\"line\">      Slog.i(TAG, <span class=\"string\">\"Build fingerprint changed; clearing code caches\"</span>);</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mSettings.mPackages.size(); i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</div><div class=\"line\">          <span class=\"keyword\">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</div><div class=\"line\">              deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      ver.fingerprint = Build.FINGERPRINT;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  checkDefaultBrowser();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// clear only after permissions and other defaults have been updated</span></div><div class=\"line\">  mExistingSystemPackages.clear();</div><div class=\"line\">  mPromoteSystemApps = <span class=\"keyword\">false</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// All the changes are done during package scanning.</span></div><div class=\"line\">  ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// can downgrade to reader</span></div><div class=\"line\">  mSettings.writeLPr();</div></pre></td></tr></table></figure>\n<ul>\n<li>当sdk版本不一致时，需要更新权限</li>\n<li>当这是ota后的首次启动，正常启动则需要清除目录的缓存代码</li>\n<li>当权限和其他默认项都完成更新，则清理相关信息</li>\n<li>信息写回packages.xml文件</li>\n</ul>\n<p>这部分不是很懂。</p>\n<h4 id=\"2-5-BOOT-PROGRESS-PMS-READY\"><a href=\"#2-5-BOOT-PROGRESS-PMS-READY\" class=\"headerlink\" title=\"2.5 BOOT_PROGRESS_PMS_READY\"></a>2.5 BOOT_PROGRESS_PMS_READY</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">  mRequiredVerifierPackage = getRequiredVerifierLPr();</div><div class=\"line\">    mRequiredInstallerPackage = getRequiredInstallerLPr();</div><div class=\"line\"></div><div class=\"line\">    mInstallerService = <span class=\"keyword\">new</span> PackageInstallerService(context, <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</div><div class=\"line\">    mIntentFilterVerifier = <span class=\"keyword\">new</span> IntentVerifierProxy(mContext,</div><div class=\"line\">            mIntentFilterVerifierComponent);</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mPackages)</span></div><div class=\"line\">&#125; <span class=\"comment\">// synchronized (mInstallLock)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Now after opening every single application zip, make sure they</span></div><div class=\"line\"><span class=\"comment\">// are all flushed.  Not really needed, but keeps things nice and</span></div><div class=\"line\"><span class=\"comment\">// tidy.</span></div><div class=\"line\">Runtime.getRuntime().gc();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Expose private service for system components to use.</span></div><div class=\"line\">LocalServices.addService(PackageManagerInternal.class, <span class=\"keyword\">new</span> PackageManagerInternalImpl());</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化PackageInstallerService</li>\n<li>gc，回收下内存</li>\n</ul>\n<h3 id=\"3-Settings\"><a href=\"#3-Settings\" class=\"headerlink\" title=\"3.Settings\"></a>3.Settings</h3><p>这个类负责读取data/system下的几个xml文件。收集其中的一些信息。</p>\n<ul>\n<li>packages.xml    记录所有安装app的信息</li>\n<li>packages-backup.xml    备份文件</li>\n<li>packages-stopped.xml    记录系统被强制停止的文件</li>\n<li>packages-stopped-backup.xml    备份文件</li>\n<li>packages.list    记录应用的数据信息</li>\n</ul>\n<h3 id=\"4-scanDirLI\"><a href=\"#4-scanDirLI\" class=\"headerlink\" title=\"4.scanDirLI\"></a>4.scanDirLI</h3><p>这个方法会调用scanPackageLI对apk进行扫描解析，在这里，会构造PackageParser.Package对象，并进行解析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> PackageParser.Package pkg;</div><div class=\"line\"> <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     pkg = pp.parsePackage(scanFile, parseFlags);</div><div class=\"line\"> &#125; <span class=\"keyword\">catch</span> (PackageParserException e) &#123;</div><div class=\"line\">     <span class=\"keyword\">throw</span> PackageManagerException.from(e);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>重点看解析部分的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Package <span class=\"title\">parsePackage</span><span class=\"params\">(File packageFile, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> PackageParserException </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (packageFile.isDirectory()) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseClusterPackage(packageFile, flags);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> parseMonolithicPackage(packageFile, flags);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>三名两个的区别就是 单个apk文件和apks。不管是单个  还是文件夹，都会调用parseBaseApk去解析，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = <span class=\"keyword\">new</span> Resources(assets, mMetrics, <span class=\"keyword\">null</span>);</div><div class=\"line\">assets.setConfiguration(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</div><div class=\"line\">        Build.VERSION.RESOURCES_SDK_INT);</div><div class=\"line\">parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> String[] outError = <span class=\"keyword\">new</span> String[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">final</span> Package pkg = parseBaseApk(res, parser, flags, outError);</div></pre></td></tr></table></figure>\n<p>在这里，会拿到配置文件，调用4个参数的这个方法去解析。这个方法里面都是类似这样的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"application\"</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (foundApp) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (RIGID_PARSER) &#123;</div><div class=\"line\">                        outError[<span class=\"number\">0</span>] = <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>;</div><div class=\"line\">                        mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        Slog.w(TAG, <span class=\"string\">\"&lt;manifest&gt; has more than one &lt;application&gt;\"</span>);</div><div class=\"line\">                        XmlUtils.skipCurrentTag(parser);</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                foundApp = <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>用xml解析 去解析配置文件中的各个标签，并且在parseBaseApplication中，会解析初我们的四大组件并存储起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tagName.equals(<span class=\"string\">\"activity\"</span>)) &#123;</div><div class=\"line\">                Activity a = parseActivity(owner, res, parser, attrs, flags, outError, <span class=\"keyword\">false</span>,</div><div class=\"line\">                        owner.baseHardwareAccelerated);</div><div class=\"line\">                <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                owner.activities.add(a);</div><div class=\"line\"></div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>这里就不多说了。</p>\n<h3 id=\"4-dex优化\"><a href=\"#4-dex优化\" class=\"headerlink\" title=\"4. dex优化\"></a>4. dex优化</h3><p>在Installer中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dexopt</span><span class=\"params\">(String apkPath, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">boolean</span> isPublic, String pkgName,</div><div class=\"line\">        String instructionSet, <span class=\"keyword\">int</span> dexoptNeeded, <span class=\"keyword\">boolean</span> vmSafeMode,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> debuggable, String outputPath)</span> </span>&#123;</div><div class=\"line\">    StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"dexopt\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(apkPath);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(uid);</div><div class=\"line\">    builder.append(isPublic ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(pkgName);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(instructionSet);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(dexoptNeeded);</div><div class=\"line\">    builder.append(vmSafeMode ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(debuggable ? <span class=\"string\">\" 1\"</span> : <span class=\"string\">\" 0\"</span>);</div><div class=\"line\">    builder.append(<span class=\"string\">' '</span>);</div><div class=\"line\">    builder.append(outputPath != <span class=\"keyword\">null</span> ? outputPath : <span class=\"string\">\"!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> execute(builder.toString());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进行参数封装，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">execute</span><span class=\"params\">(String cmd)</span> </span>&#123;</div><div class=\"line\">    String res = transact(cmd);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Integer.parseInt(res);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NumberFormatException ex) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在transact中，通过connect，socket连接installd守护进程，并通过writeCommand写入dex优化命令，用installd来完成dex优化。</p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://gityuan.com/2016/11/06/packagemanager/\">gityuan</a></li>\n<li>Android 5.0 源代码</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"ThreadLocal源码浅析","date":"2017-01-13T14:24:36.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\nThreadLocal是用来实现本地线程存储的，就是每个线程都有自己的值。java和android sdk中的这个类实现有点小差别，这篇文章以android sdk中的ThreadLocal源码来解析，看看是如何实现的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 设置值-set方法\n\n```\n    public void set(T value) {\n        Thread currentThread = Thread.currentThread();\n        Values values = values(currentThread);\n        if (values == null) {\n            values = initializeValues(currentThread);\n        }\n        values.put(this, value);\n    }\n```\n\nset值的方法很简单，首先是获取当前线程对象，然后，通过values方法获取当前线程的localValues对象，这是一个Values对象，在ThreadLocal中起着很很重要的作用。如果为null的话，用initializeValues为当前线程初始化一个Values对象。最后，将值put进去。\n\n#### Values的初始化\n\n在initializeValues方法中，只是初始化一个Values对象\n\n```\n    Values initializeValues(Thread current) {\n        return current.localValues = new Values();\n    }\n```\n\n我们看下Values的无参构造函数的实现。\n\n```\n        Values() {\n            initializeTable(INITIAL_SIZE);\n            this.size = 0;\n            this.tombstones = 0;\n        }\n\n```\n\n* initializeTable 初始化一个容量为INITIAL_SIZE(16)*2的Object数组\n* 设置存活对象数目size 为0\n* 设置死亡对象数目size 为0\n\n在看看initializeTable做了下啥\n\n```\n        private void initializeTable(int capacity) {\n            this.table = new Object[capacity * 2];\n            this.mask = table.length - 1;\n            this.clean = 0;\n            this.maximumLoad = capacity * 2 / 3; // 2/3\n        }\n\n```\n\n* 初始化一个容量为16*2的对象数组，为什么要这样呢？因为这里没有使用map的结构来保存key，value，要是用数组保存key，value，容量当然得为value的2倍。而这里是用数组的结构，我想是因为访问和修改的速度快的原因吧。\n* mark 用于散列索引,15\n* clean 指向下一个将要清除的位置，这里指向最后一个元素\n* maximumLoad 存活和死亡对象的最大数(用于扩容)，设置为容量的2/3\n\n#### 存储到values中\n\n```\n        void put(ThreadLocal<?> key, Object value) {\n            cleanUp();\n\n            // Keep track of first tombstone. That's where we want to go back\n            // and add an entry if necessary.\n            int firstTombstone = -1;\n\n            for (int index = key.hash & mask;; index = next(index)) {\n                Object k = table[index];\n\n                if (k == key.reference) {\n                    // Replace existing entry.\n                    table[index + 1] = value;\n                    return;\n                }\n\n                if (k == null) {\n                    if (firstTombstone == -1) {\n                        // Fill in null slot.\n                        table[index] = key.reference;\n                        table[index + 1] = value;\n                        size++;\n                        return;\n                    }\n\n                    // Go back and replace first tombstone.\n                    table[firstTombstone] = key.reference;\n                    table[firstTombstone + 1] = value;\n                    tombstones--;\n                    size++;\n                    return;\n                }\n\n                // Remember first tombstone.\n                if (firstTombstone == -1 && k == TOMBSTONE) {\n                    firstTombstone = index;\n                }\n            }\n        }\n```\n\n* 清理垃圾回收后的线程本地变量\n* firstTombstones为－1，用于追踪第一个死亡对象。\n* 循环，index值为threadlocal的hash变量和mask变量的&，hash值对应为0，mask，当我们初始化的时候设置为15，也就是1111，两个&之后为0，而next操作，我们这里可以看出是index+2\n* index处对应的就为key值，\n\t* 如果key.reference和k等，则将value存放于index+1处，替换已经存放的\n\t* 如果k为null，说明没放过\n\t\t* 如果firstTombstone为-1， 则index处放key.reference，index+1处放value\n\t\t* 如果不是，则将key和对应的value放在firstTombstone,firstTombstone+1处。\n\t* 不等于\tkey.reference，也不等于null，(threadlocal被gc回收了。)\n\t\t* firstTombstone 设置为index\n\n\nput的操作还是有点复杂的，要考虑到gc回收的问题。\n\n### 获取值-get方法\n\n```\n    public T get() {\n        // Optimized for the fast path.\n        Thread currentThread = Thread.currentThread();\n        Values values = values(currentThread);\n        if (values != null) {\n            Object[] table = values.table;\n            int index = hash & values.mask;\n            if (this.reference == table[index]) {\n                return (T) table[index + 1];\n            }\n        } else {\n            values = initializeValues(currentThread);\n        }\n\n        return (T) values.getAfterMiss(this);\n    }\n```\n\n在知道上面存在gc回收之后，这里就比较好理解了,gc回收之后，会吧index处的key，设置为TOMBSTONE对象。\n\n* 如果index处的值是this.reference,也就是没被gc回收，那么就是index+1处的值\n* 否则，getAfterMiss返回,这个函数后面会说到\n\n### gc带来的影响及处理\n\n因为key的reference变量是个WeakReference，因此，要考虑到gc的影响。\n\n```\n    private final Reference<ThreadLocal<T>> reference\n            = new WeakReference<ThreadLocal<T>>(this);\n```\n\n关于java中的四种引用类型及其gc，这里不说了。\n\n#### 清理过程\n\n清理过程有cleanUp来完成。\n\n```\n        private void cleanUp() {\n            if (rehash()) {\n                // If we rehashed, we needn't clean up (clean up happens as\n                // a side effect).\n                return;\n            }\n\n            if (size == 0) {\n                // No live entries == nothing to clean.\n                return;\n            }\n\n            // Clean log(table.length) entries picking up where we left off\n            // last time.\n            int index = clean;\n            Object[] table = this.table;\n            for (int counter = table.length; counter > 0; counter >>= 1,\n                    index = next(index)) {\n                Object k = table[index];\n\n                if (k == TOMBSTONE || k == null) {\n                    continue; // on to next entry\n                }\n\n                // The table can only contain null, tombstones and references.\n                @SuppressWarnings(\"unchecked\")\n                Reference<ThreadLocal<?>> reference\n                        = (Reference<ThreadLocal<?>>) k;\n                if (reference.get() == null) {\n                    // This thread local was reclaimed by the garbage collector.\n                    table[index] = TOMBSTONE;\n                    table[index + 1] = null;\n                    tombstones++;\n                    size--;\n                }\n            }\n\n            // Point cursor to next index.\n            clean = index;\n        }\n```\n\n\n* rehash返回true，或者live size为0，直接返回\n* clean的初始值为0\n* 不断从数组中取出key值，并判断是否被回收，如果被回收，则将key，设置为TOMBSTONE，value置null\n\n这个过程就是将gc回收掉的key对应的value回收。\n\n\n#### rehash过程-调整\n\n```\n        private boolean rehash() {\n            if (tombstones + size < maximumLoad) {\n                return false;\n            }\n\n            int capacity = table.length >> 1;\n\n            // Default to the same capacity. This will create a table of the\n            // same size and move over the live entries, analogous to a\n            // garbage collection. This should only happen if you churn a\n            // bunch of thread local garbage (removing and reinserting\n            // the same thread locals over and over will overwrite tombstones\n            // and not fill up the table).\n            int newCapacity = capacity;\n\n            if (size > (capacity >> 1)) {\n                // More than 1/2 filled w/ live entries.\n                // Double size.\n                newCapacity = capacity * 2;\n            }\n\n            Object[] oldTable = this.table;\n\n            // Allocate new table.\n            initializeTable(newCapacity);\n\n            // We won't have any tombstones after this.\n            this.tombstones = 0;\n\n            // If we have no live entries, we can quit here.\n            if (size == 0) {\n                return true;\n            }\n\n            // Move over entries.\n            for (int i = oldTable.length - 2; i >= 0; i -= 2) {\n                Object k = oldTable[i];\n                if (k == null || k == TOMBSTONE) {\n                    // Skip this entry.\n                    continue;\n                }\n\n                // The table can only contain null, tombstones and references.\n                @SuppressWarnings(\"unchecked\")\n                Reference<ThreadLocal<?>> reference\n                        = (Reference<ThreadLocal<?>>) k;\n                ThreadLocal<?> key = reference.get();\n                if (key != null) {\n                    // Entry is still live. Move it over.\n                    add(key, oldTable[i + 1]);\n                } else {\n                    // The key was reclaimed.\n                    size--;\n                }\n            }\n\n            return true;\n        }\n```\n\n* 如果死亡对象+存活对象达不到maximumLoad(阀值),不需要进行调整\n* 计算出值的容量(length/2)\n* 新容量仍然和旧容量一样，这是一种乐观的做法，当存活对象大于value容量/2时，才需要进行扩展\n* 申请新的数组，将旧值中没被gc的活对象添加进去。\n\n\n\n#### getAfterMiss过程\n\n在第一个槽位(index)处没发现合适值的时候，会调用这个方法返回一个。\n\n```\n        Object getAfterMiss(ThreadLocal<?> key) {\n            Object[] table = this.table;\n            int index = key.hash & mask;\n\n            // If the first slot is empty, the search is over.\n            if (table[index] == null) {\n                Object value = key.initialValue();\n\n                // If the table is still the same and the slot is still empty...\n                if (this.table == table && table[index] == null) {\n                    table[index] = key.reference;\n                    table[index + 1] = value;\n                    size++;\n\n                    cleanUp();\n                    return value;\n                }\n\n                // The table changed during initialValue().\n                put(key, value);\n                return value;\n            }\n\n            // Keep track of first tombstone. That's where we want to go back\n            // and add an entry if necessary.\n            int firstTombstone = -1;\n\n            // Continue search.\n            for (index = next(index);; index = next(index)) {\n                Object reference = table[index];\n                if (reference == key.reference) {\n                    return table[index + 1];\n                }\n\n                // If no entry was found...\n                if (reference == null) {\n                    Object value = key.initialValue();\n\n                    // If the table is still the same...\n                    if (this.table == table) {\n                        // If we passed a tombstone and that slot still\n                        // contains a tombstone...\n                        if (firstTombstone > -1\n                                && table[firstTombstone] == TOMBSTONE) {\n                            table[firstTombstone] = key.reference;\n                            table[firstTombstone + 1] = value;\n                            tombstones--;\n                            size++;\n\n                            // No need to clean up here. We aren't filling\n                            // in a null slot.\n                            return value;\n                        }\n\n                        // If this slot is still empty...\n                        if (table[index] == null) {\n                            table[index] = key.reference;\n                            table[index + 1] = value;\n                            size++;\n\n                            cleanUp();\n                            return value;\n                        }\n                    }\n\n                    // The table changed during initialValue().\n                    put(key, value);\n                    return value;\n                }\n\n                if (firstTombstone == -1 && reference == TOMBSTONE) {\n                    // Keep track of this tombstone so we can overwrite it.\n                    firstTombstone = index;\n                }\n            }\n        }\n```\n\n方法较长，逻辑如下：\n\n* 第一个槽位index处key为null，生成一个value，\n\t* 如果生成value的过程成数组没变，index处插入key，index+1处插入value，清理无用\n\t* 过程中，数组改变了.将value put进去 \n* 循环处理\n\t* 数组中的key和传入的key.reference相等，返回数组index+1处的值\n\t* 数组中的key为null，初始化一个value \n\t\t* 数组无变化，firstTombstone>-1,切firstTombstone为无效对象(TOMBSTONE)，修改firstTombstone为key，firstTombstone+1处为value，如果index处为null，加入到index处\n\n\t\t* 省略\n\t\t\n### 总结\n\n能看到，ThreadLocal的实现并不是想象中的那么简单。其中有一些问题我也没想明白，需要解析来思考下。\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/ThreadLocal源码浅析.md","raw":"---\ntitle: ThreadLocal源码浅析\ndate: 2017-01-13 22:24:36\ntags: 源码\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\nThreadLocal是用来实现本地线程存储的，就是每个线程都有自己的值。java和android sdk中的这个类实现有点小差别，这篇文章以android sdk中的ThreadLocal源码来解析，看看是如何实现的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 设置值-set方法\n\n```\n    public void set(T value) {\n        Thread currentThread = Thread.currentThread();\n        Values values = values(currentThread);\n        if (values == null) {\n            values = initializeValues(currentThread);\n        }\n        values.put(this, value);\n    }\n```\n\nset值的方法很简单，首先是获取当前线程对象，然后，通过values方法获取当前线程的localValues对象，这是一个Values对象，在ThreadLocal中起着很很重要的作用。如果为null的话，用initializeValues为当前线程初始化一个Values对象。最后，将值put进去。\n\n#### Values的初始化\n\n在initializeValues方法中，只是初始化一个Values对象\n\n```\n    Values initializeValues(Thread current) {\n        return current.localValues = new Values();\n    }\n```\n\n我们看下Values的无参构造函数的实现。\n\n```\n        Values() {\n            initializeTable(INITIAL_SIZE);\n            this.size = 0;\n            this.tombstones = 0;\n        }\n\n```\n\n* initializeTable 初始化一个容量为INITIAL_SIZE(16)*2的Object数组\n* 设置存活对象数目size 为0\n* 设置死亡对象数目size 为0\n\n在看看initializeTable做了下啥\n\n```\n        private void initializeTable(int capacity) {\n            this.table = new Object[capacity * 2];\n            this.mask = table.length - 1;\n            this.clean = 0;\n            this.maximumLoad = capacity * 2 / 3; // 2/3\n        }\n\n```\n\n* 初始化一个容量为16*2的对象数组，为什么要这样呢？因为这里没有使用map的结构来保存key，value，要是用数组保存key，value，容量当然得为value的2倍。而这里是用数组的结构，我想是因为访问和修改的速度快的原因吧。\n* mark 用于散列索引,15\n* clean 指向下一个将要清除的位置，这里指向最后一个元素\n* maximumLoad 存活和死亡对象的最大数(用于扩容)，设置为容量的2/3\n\n#### 存储到values中\n\n```\n        void put(ThreadLocal<?> key, Object value) {\n            cleanUp();\n\n            // Keep track of first tombstone. That's where we want to go back\n            // and add an entry if necessary.\n            int firstTombstone = -1;\n\n            for (int index = key.hash & mask;; index = next(index)) {\n                Object k = table[index];\n\n                if (k == key.reference) {\n                    // Replace existing entry.\n                    table[index + 1] = value;\n                    return;\n                }\n\n                if (k == null) {\n                    if (firstTombstone == -1) {\n                        // Fill in null slot.\n                        table[index] = key.reference;\n                        table[index + 1] = value;\n                        size++;\n                        return;\n                    }\n\n                    // Go back and replace first tombstone.\n                    table[firstTombstone] = key.reference;\n                    table[firstTombstone + 1] = value;\n                    tombstones--;\n                    size++;\n                    return;\n                }\n\n                // Remember first tombstone.\n                if (firstTombstone == -1 && k == TOMBSTONE) {\n                    firstTombstone = index;\n                }\n            }\n        }\n```\n\n* 清理垃圾回收后的线程本地变量\n* firstTombstones为－1，用于追踪第一个死亡对象。\n* 循环，index值为threadlocal的hash变量和mask变量的&，hash值对应为0，mask，当我们初始化的时候设置为15，也就是1111，两个&之后为0，而next操作，我们这里可以看出是index+2\n* index处对应的就为key值，\n\t* 如果key.reference和k等，则将value存放于index+1处，替换已经存放的\n\t* 如果k为null，说明没放过\n\t\t* 如果firstTombstone为-1， 则index处放key.reference，index+1处放value\n\t\t* 如果不是，则将key和对应的value放在firstTombstone,firstTombstone+1处。\n\t* 不等于\tkey.reference，也不等于null，(threadlocal被gc回收了。)\n\t\t* firstTombstone 设置为index\n\n\nput的操作还是有点复杂的，要考虑到gc回收的问题。\n\n### 获取值-get方法\n\n```\n    public T get() {\n        // Optimized for the fast path.\n        Thread currentThread = Thread.currentThread();\n        Values values = values(currentThread);\n        if (values != null) {\n            Object[] table = values.table;\n            int index = hash & values.mask;\n            if (this.reference == table[index]) {\n                return (T) table[index + 1];\n            }\n        } else {\n            values = initializeValues(currentThread);\n        }\n\n        return (T) values.getAfterMiss(this);\n    }\n```\n\n在知道上面存在gc回收之后，这里就比较好理解了,gc回收之后，会吧index处的key，设置为TOMBSTONE对象。\n\n* 如果index处的值是this.reference,也就是没被gc回收，那么就是index+1处的值\n* 否则，getAfterMiss返回,这个函数后面会说到\n\n### gc带来的影响及处理\n\n因为key的reference变量是个WeakReference，因此，要考虑到gc的影响。\n\n```\n    private final Reference<ThreadLocal<T>> reference\n            = new WeakReference<ThreadLocal<T>>(this);\n```\n\n关于java中的四种引用类型及其gc，这里不说了。\n\n#### 清理过程\n\n清理过程有cleanUp来完成。\n\n```\n        private void cleanUp() {\n            if (rehash()) {\n                // If we rehashed, we needn't clean up (clean up happens as\n                // a side effect).\n                return;\n            }\n\n            if (size == 0) {\n                // No live entries == nothing to clean.\n                return;\n            }\n\n            // Clean log(table.length) entries picking up where we left off\n            // last time.\n            int index = clean;\n            Object[] table = this.table;\n            for (int counter = table.length; counter > 0; counter >>= 1,\n                    index = next(index)) {\n                Object k = table[index];\n\n                if (k == TOMBSTONE || k == null) {\n                    continue; // on to next entry\n                }\n\n                // The table can only contain null, tombstones and references.\n                @SuppressWarnings(\"unchecked\")\n                Reference<ThreadLocal<?>> reference\n                        = (Reference<ThreadLocal<?>>) k;\n                if (reference.get() == null) {\n                    // This thread local was reclaimed by the garbage collector.\n                    table[index] = TOMBSTONE;\n                    table[index + 1] = null;\n                    tombstones++;\n                    size--;\n                }\n            }\n\n            // Point cursor to next index.\n            clean = index;\n        }\n```\n\n\n* rehash返回true，或者live size为0，直接返回\n* clean的初始值为0\n* 不断从数组中取出key值，并判断是否被回收，如果被回收，则将key，设置为TOMBSTONE，value置null\n\n这个过程就是将gc回收掉的key对应的value回收。\n\n\n#### rehash过程-调整\n\n```\n        private boolean rehash() {\n            if (tombstones + size < maximumLoad) {\n                return false;\n            }\n\n            int capacity = table.length >> 1;\n\n            // Default to the same capacity. This will create a table of the\n            // same size and move over the live entries, analogous to a\n            // garbage collection. This should only happen if you churn a\n            // bunch of thread local garbage (removing and reinserting\n            // the same thread locals over and over will overwrite tombstones\n            // and not fill up the table).\n            int newCapacity = capacity;\n\n            if (size > (capacity >> 1)) {\n                // More than 1/2 filled w/ live entries.\n                // Double size.\n                newCapacity = capacity * 2;\n            }\n\n            Object[] oldTable = this.table;\n\n            // Allocate new table.\n            initializeTable(newCapacity);\n\n            // We won't have any tombstones after this.\n            this.tombstones = 0;\n\n            // If we have no live entries, we can quit here.\n            if (size == 0) {\n                return true;\n            }\n\n            // Move over entries.\n            for (int i = oldTable.length - 2; i >= 0; i -= 2) {\n                Object k = oldTable[i];\n                if (k == null || k == TOMBSTONE) {\n                    // Skip this entry.\n                    continue;\n                }\n\n                // The table can only contain null, tombstones and references.\n                @SuppressWarnings(\"unchecked\")\n                Reference<ThreadLocal<?>> reference\n                        = (Reference<ThreadLocal<?>>) k;\n                ThreadLocal<?> key = reference.get();\n                if (key != null) {\n                    // Entry is still live. Move it over.\n                    add(key, oldTable[i + 1]);\n                } else {\n                    // The key was reclaimed.\n                    size--;\n                }\n            }\n\n            return true;\n        }\n```\n\n* 如果死亡对象+存活对象达不到maximumLoad(阀值),不需要进行调整\n* 计算出值的容量(length/2)\n* 新容量仍然和旧容量一样，这是一种乐观的做法，当存活对象大于value容量/2时，才需要进行扩展\n* 申请新的数组，将旧值中没被gc的活对象添加进去。\n\n\n\n#### getAfterMiss过程\n\n在第一个槽位(index)处没发现合适值的时候，会调用这个方法返回一个。\n\n```\n        Object getAfterMiss(ThreadLocal<?> key) {\n            Object[] table = this.table;\n            int index = key.hash & mask;\n\n            // If the first slot is empty, the search is over.\n            if (table[index] == null) {\n                Object value = key.initialValue();\n\n                // If the table is still the same and the slot is still empty...\n                if (this.table == table && table[index] == null) {\n                    table[index] = key.reference;\n                    table[index + 1] = value;\n                    size++;\n\n                    cleanUp();\n                    return value;\n                }\n\n                // The table changed during initialValue().\n                put(key, value);\n                return value;\n            }\n\n            // Keep track of first tombstone. That's where we want to go back\n            // and add an entry if necessary.\n            int firstTombstone = -1;\n\n            // Continue search.\n            for (index = next(index);; index = next(index)) {\n                Object reference = table[index];\n                if (reference == key.reference) {\n                    return table[index + 1];\n                }\n\n                // If no entry was found...\n                if (reference == null) {\n                    Object value = key.initialValue();\n\n                    // If the table is still the same...\n                    if (this.table == table) {\n                        // If we passed a tombstone and that slot still\n                        // contains a tombstone...\n                        if (firstTombstone > -1\n                                && table[firstTombstone] == TOMBSTONE) {\n                            table[firstTombstone] = key.reference;\n                            table[firstTombstone + 1] = value;\n                            tombstones--;\n                            size++;\n\n                            // No need to clean up here. We aren't filling\n                            // in a null slot.\n                            return value;\n                        }\n\n                        // If this slot is still empty...\n                        if (table[index] == null) {\n                            table[index] = key.reference;\n                            table[index + 1] = value;\n                            size++;\n\n                            cleanUp();\n                            return value;\n                        }\n                    }\n\n                    // The table changed during initialValue().\n                    put(key, value);\n                    return value;\n                }\n\n                if (firstTombstone == -1 && reference == TOMBSTONE) {\n                    // Keep track of this tombstone so we can overwrite it.\n                    firstTombstone = index;\n                }\n            }\n        }\n```\n\n方法较长，逻辑如下：\n\n* 第一个槽位index处key为null，生成一个value，\n\t* 如果生成value的过程成数组没变，index处插入key，index+1处插入value，清理无用\n\t* 过程中，数组改变了.将value put进去 \n* 循环处理\n\t* 数组中的key和传入的key.reference相等，返回数组index+1处的值\n\t* 数组中的key为null，初始化一个value \n\t\t* 数组无变化，firstTombstone>-1,切firstTombstone为无效对象(TOMBSTONE)，修改firstTombstone为key，firstTombstone+1处为value，如果index处为null，加入到index处\n\n\t\t* 省略\n\t\t\n### 总结\n\n能看到，ThreadLocal的实现并不是想象中的那么简单。其中有一些问题我也没想明白，需要解析来思考下。\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"ThreadLocal源码浅析","published":1,"updated":"2017-01-13T14:25:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy280014hws6jvb9u5cy","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>ThreadLocal是用来实现本地线程存储的，就是每个线程都有自己的值。java和android sdk中的这个类实现有点小差别，这篇文章以android sdk中的ThreadLocal源码来解析，看看是如何实现的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"设置值-set方法\"><a href=\"#设置值-set方法\" class=\"headerlink\" title=\"设置值-set方法\"></a>设置值-set方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void set(T value) &#123;</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    Values values = values(currentThread);</div><div class=\"line\">    if (values == null) &#123;</div><div class=\"line\">        values = initializeValues(currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\">    values.put(this, value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>set值的方法很简单，首先是获取当前线程对象，然后，通过values方法获取当前线程的localValues对象，这是一个Values对象，在ThreadLocal中起着很很重要的作用。如果为null的话，用initializeValues为当前线程初始化一个Values对象。最后，将值put进去。</p>\n<h4 id=\"Values的初始化\"><a href=\"#Values的初始化\" class=\"headerlink\" title=\"Values的初始化\"></a>Values的初始化</h4><p>在initializeValues方法中，只是初始化一个Values对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Values initializeValues(Thread current) &#123;</div><div class=\"line\">    return current.localValues = new Values();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看下Values的无参构造函数的实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Values() &#123;</div><div class=\"line\">    initializeTable(INITIAL_SIZE);</div><div class=\"line\">    this.size = 0;</div><div class=\"line\">    this.tombstones = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>initializeTable 初始化一个容量为INITIAL_SIZE(16)*2的Object数组</li>\n<li>设置存活对象数目size 为0</li>\n<li>设置死亡对象数目size 为0</li>\n</ul>\n<p>在看看initializeTable做了下啥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void initializeTable(int capacity) &#123;</div><div class=\"line\">    this.table = new Object[capacity * 2];</div><div class=\"line\">    this.mask = table.length - 1;</div><div class=\"line\">    this.clean = 0;</div><div class=\"line\">    this.maximumLoad = capacity * 2 / 3; // 2/3</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化一个容量为16*2的对象数组，为什么要这样呢？因为这里没有使用map的结构来保存key，value，要是用数组保存key，value，容量当然得为value的2倍。而这里是用数组的结构，我想是因为访问和修改的速度快的原因吧。</li>\n<li>mark 用于散列索引,15</li>\n<li>clean 指向下一个将要清除的位置，这里指向最后一个元素</li>\n<li>maximumLoad 存活和死亡对象的最大数(用于扩容)，设置为容量的2/3</li>\n</ul>\n<h4 id=\"存储到values中\"><a href=\"#存储到values中\" class=\"headerlink\" title=\"存储到values中\"></a>存储到values中</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">void put(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class=\"line\">    cleanUp();</div><div class=\"line\"></div><div class=\"line\">    // Keep track of first tombstone. That&apos;s where we want to go back</div><div class=\"line\">    // and add an entry if necessary.</div><div class=\"line\">    int firstTombstone = -1;</div><div class=\"line\"></div><div class=\"line\">    for (int index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class=\"line\">        Object k = table[index];</div><div class=\"line\"></div><div class=\"line\">        if (k == key.reference) &#123;</div><div class=\"line\">            // Replace existing entry.</div><div class=\"line\">            table[index + 1] = value;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (k == null) &#123;</div><div class=\"line\">            if (firstTombstone == -1) &#123;</div><div class=\"line\">                // Fill in null slot.</div><div class=\"line\">                table[index] = key.reference;</div><div class=\"line\">                table[index + 1] = value;</div><div class=\"line\">                size++;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Go back and replace first tombstone.</div><div class=\"line\">            table[firstTombstone] = key.reference;</div><div class=\"line\">            table[firstTombstone + 1] = value;</div><div class=\"line\">            tombstones--;</div><div class=\"line\">            size++;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Remember first tombstone.</div><div class=\"line\">        if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123;</div><div class=\"line\">            firstTombstone = index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>清理垃圾回收后的线程本地变量</li>\n<li>firstTombstones为－1，用于追踪第一个死亡对象。</li>\n<li>循环，index值为threadlocal的hash变量和mask变量的&amp;，hash值对应为0，mask，当我们初始化的时候设置为15，也就是1111，两个&amp;之后为0，而next操作，我们这里可以看出是index+2</li>\n<li>index处对应的就为key值，<ul>\n<li>如果key.reference和k等，则将value存放于index+1处，替换已经存放的</li>\n<li>如果k为null，说明没放过<ul>\n<li>如果firstTombstone为-1， 则index处放key.reference，index+1处放value</li>\n<li>如果不是，则将key和对应的value放在firstTombstone,firstTombstone+1处。</li>\n</ul>\n</li>\n<li>不等于    key.reference，也不等于null，(threadlocal被gc回收了。)<ul>\n<li>firstTombstone 设置为index</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>put的操作还是有点复杂的，要考虑到gc回收的问题。</p>\n<h3 id=\"获取值-get方法\"><a href=\"#获取值-get方法\" class=\"headerlink\" title=\"获取值-get方法\"></a>获取值-get方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public T get() &#123;</div><div class=\"line\">    // Optimized for the fast path.</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    Values values = values(currentThread);</div><div class=\"line\">    if (values != null) &#123;</div><div class=\"line\">        Object[] table = values.table;</div><div class=\"line\">        int index = hash &amp; values.mask;</div><div class=\"line\">        if (this.reference == table[index]) &#123;</div><div class=\"line\">            return (T) table[index + 1];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        values = initializeValues(currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return (T) values.getAfterMiss(this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在知道上面存在gc回收之后，这里就比较好理解了,gc回收之后，会吧index处的key，设置为TOMBSTONE对象。</p>\n<ul>\n<li>如果index处的值是this.reference,也就是没被gc回收，那么就是index+1处的值</li>\n<li>否则，getAfterMiss返回,这个函数后面会说到</li>\n</ul>\n<h3 id=\"gc带来的影响及处理\"><a href=\"#gc带来的影响及处理\" class=\"headerlink\" title=\"gc带来的影响及处理\"></a>gc带来的影响及处理</h3><p>因为key的reference变量是个WeakReference，因此，要考虑到gc的影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Reference&lt;ThreadLocal&lt;T&gt;&gt; reference</div><div class=\"line\">        = new WeakReference&lt;ThreadLocal&lt;T&gt;&gt;(this);</div></pre></td></tr></table></figure>\n<p>关于java中的四种引用类型及其gc，这里不说了。</p>\n<h4 id=\"清理过程\"><a href=\"#清理过程\" class=\"headerlink\" title=\"清理过程\"></a>清理过程</h4><p>清理过程有cleanUp来完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void cleanUp() &#123;</div><div class=\"line\">    if (rehash()) &#123;</div><div class=\"line\">        // If we rehashed, we needn&apos;t clean up (clean up happens as</div><div class=\"line\">        // a side effect).</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        // No live entries == nothing to clean.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Clean log(table.length) entries picking up where we left off</div><div class=\"line\">    // last time.</div><div class=\"line\">    int index = clean;</div><div class=\"line\">    Object[] table = this.table;</div><div class=\"line\">    for (int counter = table.length; counter &gt; 0; counter &gt;&gt;= 1,</div><div class=\"line\">            index = next(index)) &#123;</div><div class=\"line\">        Object k = table[index];</div><div class=\"line\"></div><div class=\"line\">        if (k == TOMBSTONE || k == null) &#123;</div><div class=\"line\">            continue; // on to next entry</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table can only contain null, tombstones and references.</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class=\"line\">                = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class=\"line\">        if (reference.get() == null) &#123;</div><div class=\"line\">            // This thread local was reclaimed by the garbage collector.</div><div class=\"line\">            table[index] = TOMBSTONE;</div><div class=\"line\">            table[index + 1] = null;</div><div class=\"line\">            tombstones++;</div><div class=\"line\">            size--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Point cursor to next index.</div><div class=\"line\">    clean = index;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>rehash返回true，或者live size为0，直接返回</li>\n<li>clean的初始值为0</li>\n<li>不断从数组中取出key值，并判断是否被回收，如果被回收，则将key，设置为TOMBSTONE，value置null</li>\n</ul>\n<p>这个过程就是将gc回收掉的key对应的value回收。</p>\n<h4 id=\"rehash过程-调整\"><a href=\"#rehash过程-调整\" class=\"headerlink\" title=\"rehash过程-调整\"></a>rehash过程-调整</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean rehash() &#123;</div><div class=\"line\">    if (tombstones + size &lt; maximumLoad) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int capacity = table.length &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">    // Default to the same capacity. This will create a table of the</div><div class=\"line\">    // same size and move over the live entries, analogous to a</div><div class=\"line\">    // garbage collection. This should only happen if you churn a</div><div class=\"line\">    // bunch of thread local garbage (removing and reinserting</div><div class=\"line\">    // the same thread locals over and over will overwrite tombstones</div><div class=\"line\">    // and not fill up the table).</div><div class=\"line\">    int newCapacity = capacity;</div><div class=\"line\"></div><div class=\"line\">    if (size &gt; (capacity &gt;&gt; 1)) &#123;</div><div class=\"line\">        // More than 1/2 filled w/ live entries.</div><div class=\"line\">        // Double size.</div><div class=\"line\">        newCapacity = capacity * 2;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Object[] oldTable = this.table;</div><div class=\"line\"></div><div class=\"line\">    // Allocate new table.</div><div class=\"line\">    initializeTable(newCapacity);</div><div class=\"line\"></div><div class=\"line\">    // We won&apos;t have any tombstones after this.</div><div class=\"line\">    this.tombstones = 0;</div><div class=\"line\"></div><div class=\"line\">    // If we have no live entries, we can quit here.</div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Move over entries.</div><div class=\"line\">    for (int i = oldTable.length - 2; i &gt;= 0; i -= 2) &#123;</div><div class=\"line\">        Object k = oldTable[i];</div><div class=\"line\">        if (k == null || k == TOMBSTONE) &#123;</div><div class=\"line\">            // Skip this entry.</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table can only contain null, tombstones and references.</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class=\"line\">                = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class=\"line\">        ThreadLocal&lt;?&gt; key = reference.get();</div><div class=\"line\">        if (key != null) &#123;</div><div class=\"line\">            // Entry is still live. Move it over.</div><div class=\"line\">            add(key, oldTable[i + 1]);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // The key was reclaimed.</div><div class=\"line\">            size--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果死亡对象+存活对象达不到maximumLoad(阀值),不需要进行调整</li>\n<li>计算出值的容量(length/2)</li>\n<li>新容量仍然和旧容量一样，这是一种乐观的做法，当存活对象大于value容量/2时，才需要进行扩展</li>\n<li>申请新的数组，将旧值中没被gc的活对象添加进去。</li>\n</ul>\n<h4 id=\"getAfterMiss过程\"><a href=\"#getAfterMiss过程\" class=\"headerlink\" title=\"getAfterMiss过程\"></a>getAfterMiss过程</h4><p>在第一个槽位(index)处没发现合适值的时候，会调用这个方法返回一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object getAfterMiss(ThreadLocal&lt;?&gt; key) &#123;</div><div class=\"line\">    Object[] table = this.table;</div><div class=\"line\">    int index = key.hash &amp; mask;</div><div class=\"line\"></div><div class=\"line\">    // If the first slot is empty, the search is over.</div><div class=\"line\">    if (table[index] == null) &#123;</div><div class=\"line\">        Object value = key.initialValue();</div><div class=\"line\"></div><div class=\"line\">        // If the table is still the same and the slot is still empty...</div><div class=\"line\">        if (this.table == table &amp;&amp; table[index] == null) &#123;</div><div class=\"line\">            table[index] = key.reference;</div><div class=\"line\">            table[index + 1] = value;</div><div class=\"line\">            size++;</div><div class=\"line\"></div><div class=\"line\">            cleanUp();</div><div class=\"line\">            return value;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table changed during initialValue().</div><div class=\"line\">        put(key, value);</div><div class=\"line\">        return value;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Keep track of first tombstone. That&apos;s where we want to go back</div><div class=\"line\">    // and add an entry if necessary.</div><div class=\"line\">    int firstTombstone = -1;</div><div class=\"line\"></div><div class=\"line\">    // Continue search.</div><div class=\"line\">    for (index = next(index);; index = next(index)) &#123;</div><div class=\"line\">        Object reference = table[index];</div><div class=\"line\">        if (reference == key.reference) &#123;</div><div class=\"line\">            return table[index + 1];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If no entry was found...</div><div class=\"line\">        if (reference == null) &#123;</div><div class=\"line\">            Object value = key.initialValue();</div><div class=\"line\"></div><div class=\"line\">            // If the table is still the same...</div><div class=\"line\">            if (this.table == table) &#123;</div><div class=\"line\">                // If we passed a tombstone and that slot still</div><div class=\"line\">                // contains a tombstone...</div><div class=\"line\">                if (firstTombstone &gt; -1</div><div class=\"line\">                        &amp;&amp; table[firstTombstone] == TOMBSTONE) &#123;</div><div class=\"line\">                    table[firstTombstone] = key.reference;</div><div class=\"line\">                    table[firstTombstone + 1] = value;</div><div class=\"line\">                    tombstones--;</div><div class=\"line\">                    size++;</div><div class=\"line\"></div><div class=\"line\">                    // No need to clean up here. We aren&apos;t filling</div><div class=\"line\">                    // in a null slot.</div><div class=\"line\">                    return value;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // If this slot is still empty...</div><div class=\"line\">                if (table[index] == null) &#123;</div><div class=\"line\">                    table[index] = key.reference;</div><div class=\"line\">                    table[index + 1] = value;</div><div class=\"line\">                    size++;</div><div class=\"line\"></div><div class=\"line\">                    cleanUp();</div><div class=\"line\">                    return value;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // The table changed during initialValue().</div><div class=\"line\">            put(key, value);</div><div class=\"line\">            return value;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (firstTombstone == -1 &amp;&amp; reference == TOMBSTONE) &#123;</div><div class=\"line\">            // Keep track of this tombstone so we can overwrite it.</div><div class=\"line\">            firstTombstone = index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法较长，逻辑如下：</p>\n<ul>\n<li>第一个槽位index处key为null，生成一个value，<ul>\n<li>如果生成value的过程成数组没变，index处插入key，index+1处插入value，清理无用</li>\n<li>过程中，数组改变了.将value put进去 </li>\n</ul>\n</li>\n<li><p>循环处理</p>\n<ul>\n<li>数组中的key和传入的key.reference相等，返回数组index+1处的值</li>\n<li><p>数组中的key为null，初始化一个value </p>\n<ul>\n<li><p>数组无变化，firstTombstone&gt;-1,切firstTombstone为无效对象(TOMBSTONE)，修改firstTombstone为key，firstTombstone+1处为value，如果index处为null，加入到index处</p>\n</li>\n<li><p>省略</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>能看到，ThreadLocal的实现并不是想象中的那么简单。其中有一些问题我也没想明白，需要解析来思考下。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>ThreadLocal是用来实现本地线程存储的，就是每个线程都有自己的值。java和android sdk中的这个类实现有点小差别，这篇文章以android sdk中的ThreadLocal源码来解析，看看是如何实现的。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"设置值-set方法\"><a href=\"#设置值-set方法\" class=\"headerlink\" title=\"设置值-set方法\"></a>设置值-set方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void set(T value) &#123;</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    Values values = values(currentThread);</div><div class=\"line\">    if (values == null) &#123;</div><div class=\"line\">        values = initializeValues(currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\">    values.put(this, value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>set值的方法很简单，首先是获取当前线程对象，然后，通过values方法获取当前线程的localValues对象，这是一个Values对象，在ThreadLocal中起着很很重要的作用。如果为null的话，用initializeValues为当前线程初始化一个Values对象。最后，将值put进去。</p>\n<h4 id=\"Values的初始化\"><a href=\"#Values的初始化\" class=\"headerlink\" title=\"Values的初始化\"></a>Values的初始化</h4><p>在initializeValues方法中，只是初始化一个Values对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Values initializeValues(Thread current) &#123;</div><div class=\"line\">    return current.localValues = new Values();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看下Values的无参构造函数的实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Values() &#123;</div><div class=\"line\">    initializeTable(INITIAL_SIZE);</div><div class=\"line\">    this.size = 0;</div><div class=\"line\">    this.tombstones = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>initializeTable 初始化一个容量为INITIAL_SIZE(16)*2的Object数组</li>\n<li>设置存活对象数目size 为0</li>\n<li>设置死亡对象数目size 为0</li>\n</ul>\n<p>在看看initializeTable做了下啥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void initializeTable(int capacity) &#123;</div><div class=\"line\">    this.table = new Object[capacity * 2];</div><div class=\"line\">    this.mask = table.length - 1;</div><div class=\"line\">    this.clean = 0;</div><div class=\"line\">    this.maximumLoad = capacity * 2 / 3; // 2/3</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>初始化一个容量为16*2的对象数组，为什么要这样呢？因为这里没有使用map的结构来保存key，value，要是用数组保存key，value，容量当然得为value的2倍。而这里是用数组的结构，我想是因为访问和修改的速度快的原因吧。</li>\n<li>mark 用于散列索引,15</li>\n<li>clean 指向下一个将要清除的位置，这里指向最后一个元素</li>\n<li>maximumLoad 存活和死亡对象的最大数(用于扩容)，设置为容量的2/3</li>\n</ul>\n<h4 id=\"存储到values中\"><a href=\"#存储到values中\" class=\"headerlink\" title=\"存储到values中\"></a>存储到values中</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">void put(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class=\"line\">    cleanUp();</div><div class=\"line\"></div><div class=\"line\">    // Keep track of first tombstone. That&apos;s where we want to go back</div><div class=\"line\">    // and add an entry if necessary.</div><div class=\"line\">    int firstTombstone = -1;</div><div class=\"line\"></div><div class=\"line\">    for (int index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class=\"line\">        Object k = table[index];</div><div class=\"line\"></div><div class=\"line\">        if (k == key.reference) &#123;</div><div class=\"line\">            // Replace existing entry.</div><div class=\"line\">            table[index + 1] = value;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (k == null) &#123;</div><div class=\"line\">            if (firstTombstone == -1) &#123;</div><div class=\"line\">                // Fill in null slot.</div><div class=\"line\">                table[index] = key.reference;</div><div class=\"line\">                table[index + 1] = value;</div><div class=\"line\">                size++;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Go back and replace first tombstone.</div><div class=\"line\">            table[firstTombstone] = key.reference;</div><div class=\"line\">            table[firstTombstone + 1] = value;</div><div class=\"line\">            tombstones--;</div><div class=\"line\">            size++;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Remember first tombstone.</div><div class=\"line\">        if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123;</div><div class=\"line\">            firstTombstone = index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>清理垃圾回收后的线程本地变量</li>\n<li>firstTombstones为－1，用于追踪第一个死亡对象。</li>\n<li>循环，index值为threadlocal的hash变量和mask变量的&amp;，hash值对应为0，mask，当我们初始化的时候设置为15，也就是1111，两个&amp;之后为0，而next操作，我们这里可以看出是index+2</li>\n<li>index处对应的就为key值，<ul>\n<li>如果key.reference和k等，则将value存放于index+1处，替换已经存放的</li>\n<li>如果k为null，说明没放过<ul>\n<li>如果firstTombstone为-1， 则index处放key.reference，index+1处放value</li>\n<li>如果不是，则将key和对应的value放在firstTombstone,firstTombstone+1处。</li>\n</ul>\n</li>\n<li>不等于    key.reference，也不等于null，(threadlocal被gc回收了。)<ul>\n<li>firstTombstone 设置为index</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>put的操作还是有点复杂的，要考虑到gc回收的问题。</p>\n<h3 id=\"获取值-get方法\"><a href=\"#获取值-get方法\" class=\"headerlink\" title=\"获取值-get方法\"></a>获取值-get方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public T get() &#123;</div><div class=\"line\">    // Optimized for the fast path.</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    Values values = values(currentThread);</div><div class=\"line\">    if (values != null) &#123;</div><div class=\"line\">        Object[] table = values.table;</div><div class=\"line\">        int index = hash &amp; values.mask;</div><div class=\"line\">        if (this.reference == table[index]) &#123;</div><div class=\"line\">            return (T) table[index + 1];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        values = initializeValues(currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return (T) values.getAfterMiss(this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在知道上面存在gc回收之后，这里就比较好理解了,gc回收之后，会吧index处的key，设置为TOMBSTONE对象。</p>\n<ul>\n<li>如果index处的值是this.reference,也就是没被gc回收，那么就是index+1处的值</li>\n<li>否则，getAfterMiss返回,这个函数后面会说到</li>\n</ul>\n<h3 id=\"gc带来的影响及处理\"><a href=\"#gc带来的影响及处理\" class=\"headerlink\" title=\"gc带来的影响及处理\"></a>gc带来的影响及处理</h3><p>因为key的reference变量是个WeakReference，因此，要考虑到gc的影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Reference&lt;ThreadLocal&lt;T&gt;&gt; reference</div><div class=\"line\">        = new WeakReference&lt;ThreadLocal&lt;T&gt;&gt;(this);</div></pre></td></tr></table></figure>\n<p>关于java中的四种引用类型及其gc，这里不说了。</p>\n<h4 id=\"清理过程\"><a href=\"#清理过程\" class=\"headerlink\" title=\"清理过程\"></a>清理过程</h4><p>清理过程有cleanUp来完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void cleanUp() &#123;</div><div class=\"line\">    if (rehash()) &#123;</div><div class=\"line\">        // If we rehashed, we needn&apos;t clean up (clean up happens as</div><div class=\"line\">        // a side effect).</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        // No live entries == nothing to clean.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Clean log(table.length) entries picking up where we left off</div><div class=\"line\">    // last time.</div><div class=\"line\">    int index = clean;</div><div class=\"line\">    Object[] table = this.table;</div><div class=\"line\">    for (int counter = table.length; counter &gt; 0; counter &gt;&gt;= 1,</div><div class=\"line\">            index = next(index)) &#123;</div><div class=\"line\">        Object k = table[index];</div><div class=\"line\"></div><div class=\"line\">        if (k == TOMBSTONE || k == null) &#123;</div><div class=\"line\">            continue; // on to next entry</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table can only contain null, tombstones and references.</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class=\"line\">                = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class=\"line\">        if (reference.get() == null) &#123;</div><div class=\"line\">            // This thread local was reclaimed by the garbage collector.</div><div class=\"line\">            table[index] = TOMBSTONE;</div><div class=\"line\">            table[index + 1] = null;</div><div class=\"line\">            tombstones++;</div><div class=\"line\">            size--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Point cursor to next index.</div><div class=\"line\">    clean = index;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>rehash返回true，或者live size为0，直接返回</li>\n<li>clean的初始值为0</li>\n<li>不断从数组中取出key值，并判断是否被回收，如果被回收，则将key，设置为TOMBSTONE，value置null</li>\n</ul>\n<p>这个过程就是将gc回收掉的key对应的value回收。</p>\n<h4 id=\"rehash过程-调整\"><a href=\"#rehash过程-调整\" class=\"headerlink\" title=\"rehash过程-调整\"></a>rehash过程-调整</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean rehash() &#123;</div><div class=\"line\">    if (tombstones + size &lt; maximumLoad) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int capacity = table.length &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">    // Default to the same capacity. This will create a table of the</div><div class=\"line\">    // same size and move over the live entries, analogous to a</div><div class=\"line\">    // garbage collection. This should only happen if you churn a</div><div class=\"line\">    // bunch of thread local garbage (removing and reinserting</div><div class=\"line\">    // the same thread locals over and over will overwrite tombstones</div><div class=\"line\">    // and not fill up the table).</div><div class=\"line\">    int newCapacity = capacity;</div><div class=\"line\"></div><div class=\"line\">    if (size &gt; (capacity &gt;&gt; 1)) &#123;</div><div class=\"line\">        // More than 1/2 filled w/ live entries.</div><div class=\"line\">        // Double size.</div><div class=\"line\">        newCapacity = capacity * 2;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Object[] oldTable = this.table;</div><div class=\"line\"></div><div class=\"line\">    // Allocate new table.</div><div class=\"line\">    initializeTable(newCapacity);</div><div class=\"line\"></div><div class=\"line\">    // We won&apos;t have any tombstones after this.</div><div class=\"line\">    this.tombstones = 0;</div><div class=\"line\"></div><div class=\"line\">    // If we have no live entries, we can quit here.</div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Move over entries.</div><div class=\"line\">    for (int i = oldTable.length - 2; i &gt;= 0; i -= 2) &#123;</div><div class=\"line\">        Object k = oldTable[i];</div><div class=\"line\">        if (k == null || k == TOMBSTONE) &#123;</div><div class=\"line\">            // Skip this entry.</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table can only contain null, tombstones and references.</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class=\"line\">                = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class=\"line\">        ThreadLocal&lt;?&gt; key = reference.get();</div><div class=\"line\">        if (key != null) &#123;</div><div class=\"line\">            // Entry is still live. Move it over.</div><div class=\"line\">            add(key, oldTable[i + 1]);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // The key was reclaimed.</div><div class=\"line\">            size--;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果死亡对象+存活对象达不到maximumLoad(阀值),不需要进行调整</li>\n<li>计算出值的容量(length/2)</li>\n<li>新容量仍然和旧容量一样，这是一种乐观的做法，当存活对象大于value容量/2时，才需要进行扩展</li>\n<li>申请新的数组，将旧值中没被gc的活对象添加进去。</li>\n</ul>\n<h4 id=\"getAfterMiss过程\"><a href=\"#getAfterMiss过程\" class=\"headerlink\" title=\"getAfterMiss过程\"></a>getAfterMiss过程</h4><p>在第一个槽位(index)处没发现合适值的时候，会调用这个方法返回一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object getAfterMiss(ThreadLocal&lt;?&gt; key) &#123;</div><div class=\"line\">    Object[] table = this.table;</div><div class=\"line\">    int index = key.hash &amp; mask;</div><div class=\"line\"></div><div class=\"line\">    // If the first slot is empty, the search is over.</div><div class=\"line\">    if (table[index] == null) &#123;</div><div class=\"line\">        Object value = key.initialValue();</div><div class=\"line\"></div><div class=\"line\">        // If the table is still the same and the slot is still empty...</div><div class=\"line\">        if (this.table == table &amp;&amp; table[index] == null) &#123;</div><div class=\"line\">            table[index] = key.reference;</div><div class=\"line\">            table[index + 1] = value;</div><div class=\"line\">            size++;</div><div class=\"line\"></div><div class=\"line\">            cleanUp();</div><div class=\"line\">            return value;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // The table changed during initialValue().</div><div class=\"line\">        put(key, value);</div><div class=\"line\">        return value;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Keep track of first tombstone. That&apos;s where we want to go back</div><div class=\"line\">    // and add an entry if necessary.</div><div class=\"line\">    int firstTombstone = -1;</div><div class=\"line\"></div><div class=\"line\">    // Continue search.</div><div class=\"line\">    for (index = next(index);; index = next(index)) &#123;</div><div class=\"line\">        Object reference = table[index];</div><div class=\"line\">        if (reference == key.reference) &#123;</div><div class=\"line\">            return table[index + 1];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If no entry was found...</div><div class=\"line\">        if (reference == null) &#123;</div><div class=\"line\">            Object value = key.initialValue();</div><div class=\"line\"></div><div class=\"line\">            // If the table is still the same...</div><div class=\"line\">            if (this.table == table) &#123;</div><div class=\"line\">                // If we passed a tombstone and that slot still</div><div class=\"line\">                // contains a tombstone...</div><div class=\"line\">                if (firstTombstone &gt; -1</div><div class=\"line\">                        &amp;&amp; table[firstTombstone] == TOMBSTONE) &#123;</div><div class=\"line\">                    table[firstTombstone] = key.reference;</div><div class=\"line\">                    table[firstTombstone + 1] = value;</div><div class=\"line\">                    tombstones--;</div><div class=\"line\">                    size++;</div><div class=\"line\"></div><div class=\"line\">                    // No need to clean up here. We aren&apos;t filling</div><div class=\"line\">                    // in a null slot.</div><div class=\"line\">                    return value;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // If this slot is still empty...</div><div class=\"line\">                if (table[index] == null) &#123;</div><div class=\"line\">                    table[index] = key.reference;</div><div class=\"line\">                    table[index + 1] = value;</div><div class=\"line\">                    size++;</div><div class=\"line\"></div><div class=\"line\">                    cleanUp();</div><div class=\"line\">                    return value;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // The table changed during initialValue().</div><div class=\"line\">            put(key, value);</div><div class=\"line\">            return value;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (firstTombstone == -1 &amp;&amp; reference == TOMBSTONE) &#123;</div><div class=\"line\">            // Keep track of this tombstone so we can overwrite it.</div><div class=\"line\">            firstTombstone = index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法较长，逻辑如下：</p>\n<ul>\n<li>第一个槽位index处key为null，生成一个value，<ul>\n<li>如果生成value的过程成数组没变，index处插入key，index+1处插入value，清理无用</li>\n<li>过程中，数组改变了.将value put进去 </li>\n</ul>\n</li>\n<li><p>循环处理</p>\n<ul>\n<li>数组中的key和传入的key.reference相等，返回数组index+1处的值</li>\n<li><p>数组中的key为null，初始化一个value </p>\n<ul>\n<li><p>数组无变化，firstTombstone&gt;-1,切firstTombstone为无效对象(TOMBSTONE)，修改firstTombstone为key，firstTombstone+1处为value，如果index处为null，加入到index处</p>\n</li>\n<li><p>省略</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>能看到，ThreadLocal的实现并不是想象中的那么简单。其中有一些问题我也没想明白，需要解析来思考下。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"broadcast流程浅析","date":"2016-12-27T07:45:50.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n个人看法。\n\n前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 静态广播\n* 动态广播\n* 发送广播\n* 动态注册广播接收者对广播的处理\n\n\n### 2. 静态广播的注册过程\n\n系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。\n\n在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。\n\n```\n        for (File file : files) {\n            final boolean isPackage = (isApkFile(file) || file.isDirectory())\n                    && !PackageInstallerService.isStageName(file.getName());\n            if (!isPackage) {\n                // Ignore entries which are not packages\n                continue;\n            }\n            try {\n                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,\n                        scanFlags, currentTime, null);\n            } catch (PackageManagerException e) {\n                                \n            }\n        }\n```\n\n如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用\n\n```\nprivate Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,\n            String[] outError) \n```\n\n方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到\n\n```\nowner.receivers.add(a);\n```\n\nPackage对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用\n\n```\nprivate PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  \n        int scanFlags, long currentTime, UserHandle user)\n```\n\n这个方法将其保存在ams里。这里就不多说了。\n\n### 3. 动态广播注册\n\n我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，\n\n```\n    private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,\n            IntentFilter filter, String broadcastPermission,\n            Handler scheduler, Context context) {\n        IIntentReceiver rd = null;\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n        try {\n            return ActivityManagerNative.getDefault().registerReceiver(\n                    mMainThread.getApplicationThread(), mBasePackageName,\n                    rd, filter, broadcastPermission, userId);\n        } catch (RemoteException e) {\n            return null;\n        }\n    }\n```\n\n* 注意这里的rd，\n* 看到，注册的过程和其他一样，也是交给了ams来完成。\n\n我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。\n\n* 收集粘性广播\n* 将我们这个广播接收者加入到mRegisteredReceivers中，\n* 插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。\n\n### 4. 发送广播\n\n不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,\n在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。\n\n```\nintent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);\n```\n\n这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。\n解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过\n\n```\nreceivers = collectReceiverComponents(intent, resolvedType, callingUid, users);\n```\n找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。\n\n```\n        if (!ordered && NR > 0) {\n            // If we are not serializing this broadcast, then send the\n            // registered receivers separately so they don't wait for the\n            // components to be launched.\n            final BroadcastQueue queue = broadcastQueueForIntent(intent);\n            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n                    callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,\n                    appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,\n                    resultExtras, ordered, sticky, false, userId);\n            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing parallel broadcast \" + r);\n            final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n            if (!replaced) {\n                queue.enqueueParallelBroadcastLocked(r);\n                queue.scheduleBroadcastsLocked();\n            }\n            registeredReceivers = null;\n            NR = 0;\n        }\n```\n\n解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。\n\n这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。\n\n```\n    public void scheduleBroadcastsLocked() {\n        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\"\n                + mQueueName + \"]: current=\"\n                + mBroadcastsScheduled);\n\n        if (mBroadcastsScheduled) {\n            return;\n        }\n        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n        mBroadcastsScheduled = true;\n    }\n```\n\n这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。\n\n在这个方法中，首先会处理普通广播代码如下。\n\n```\n            while (mParallelBroadcasts.size() > 0) {\n                r = mParallelBroadcasts.remove(0);\n                r.dispatchTime = SystemClock.uptimeMillis();\n                r.dispatchClockTime = System.currentTimeMillis();\n                final int N = r.receivers.size();\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n                for (int i=0; i<N; i++) {\n                    Object target = r.receivers.get(i);\n                    if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,\n                            \"Delivering non-ordered on [\" + mQueueName + \"] to registered \"\n                            + target + \": \" + r);\n                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n                }\n                addBroadcastToHistoryLocked(r);\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Done with parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n            }\n```\n\n可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。\n\n### 5. 动态注册广播接收者对广播的处理\n\ndeliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked\n\n```\n    private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n            Intent intent, int resultCode, String data, Bundle extras,\n            boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n        // Send the intent to the receiver asynchronously using one-way binder calls.\n        if (app != null) {\n            if (app.thread != null) {\n                // If we have an app thread, do the call through that so it is\n                // correctly ordered with other one-way calls.\n                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n            } else {\n                // Application has died. Receiver doesn't exist.\n                throw new RemoteException(\"app.thread must not be null\");\n            }\n        } else {\n            receiver.performReceive(intent, resultCode, data, extras, ordered,\n                    sticky, sendingUser);\n        }\n    }\n```\n\n* 如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，\n* 否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。\n\n```\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n```\n\n其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。\n\n而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。\n\n```\n        public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,\n                int resultCode, String dataStr, Bundle extras, boolean ordered,\n                boolean sticky, int sendingUser, int processState) throws RemoteException {\n            updateProcessState(processState, false);\n            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,\n                    sticky, sendingUser);\n        }\n\n```\nreceiver的performReceive方法中，调用ReceiverDispatcher的performReceive。\n\n```\n                if (rd != null) {\n                    rd.performReceive(intent, resultCode, data, extras,\n                            ordered, sticky, sendingUser);\n                }\n```\n\nReceiverDispatcher的performReceive中，通过handler，post一个runable消息。\n\n```\n\nmActivityThread.post(args)\n\n```\n在这个方法中，有如下代码\n\n```\nClassLoader cl =  mReceiver.getClass().getClassLoader();\nintent.setExtrasClassLoader(cl);\nsetExtrasClassLoader(cl);\nreceiver.setPendingResult(this);\nreceiver.onReceive(mContext, intent);\n```\n\n这样，BroadcastReceiver就创建并调用了onReceive方法。\n\n\n### 6. 上图\n\n![](/images/framework/broadcast/broadcast流程.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","source":"_posts/broadcast流程浅析.md","raw":"---\ntitle: broadcast流程浅析\ndate: 2016-12-27 15:45:50\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n个人看法。\n\n前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n* 静态广播\n* 动态广播\n* 发送广播\n* 动态注册广播接收者对广播的处理\n\n\n### 2. 静态广播的注册过程\n\n系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。\n\n在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。\n\n```\n        for (File file : files) {\n            final boolean isPackage = (isApkFile(file) || file.isDirectory())\n                    && !PackageInstallerService.isStageName(file.getName());\n            if (!isPackage) {\n                // Ignore entries which are not packages\n                continue;\n            }\n            try {\n                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,\n                        scanFlags, currentTime, null);\n            } catch (PackageManagerException e) {\n                                \n            }\n        }\n```\n\n如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用\n\n```\nprivate Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,\n            String[] outError) \n```\n\n方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到\n\n```\nowner.receivers.add(a);\n```\n\nPackage对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用\n\n```\nprivate PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  \n        int scanFlags, long currentTime, UserHandle user)\n```\n\n这个方法将其保存在ams里。这里就不多说了。\n\n### 3. 动态广播注册\n\n我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，\n\n```\n    private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,\n            IntentFilter filter, String broadcastPermission,\n            Handler scheduler, Context context) {\n        IIntentReceiver rd = null;\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n        try {\n            return ActivityManagerNative.getDefault().registerReceiver(\n                    mMainThread.getApplicationThread(), mBasePackageName,\n                    rd, filter, broadcastPermission, userId);\n        } catch (RemoteException e) {\n            return null;\n        }\n    }\n```\n\n* 注意这里的rd，\n* 看到，注册的过程和其他一样，也是交给了ams来完成。\n\n我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。\n\n* 收集粘性广播\n* 将我们这个广播接收者加入到mRegisteredReceivers中，\n* 插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。\n\n### 4. 发送广播\n\n不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,\n在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。\n\n```\nintent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);\n```\n\n这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。\n解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过\n\n```\nreceivers = collectReceiverComponents(intent, resolvedType, callingUid, users);\n```\n找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。\n\n```\n        if (!ordered && NR > 0) {\n            // If we are not serializing this broadcast, then send the\n            // registered receivers separately so they don't wait for the\n            // components to be launched.\n            final BroadcastQueue queue = broadcastQueueForIntent(intent);\n            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,\n                    callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,\n                    appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,\n                    resultExtras, ordered, sticky, false, userId);\n            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing parallel broadcast \" + r);\n            final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);\n            if (!replaced) {\n                queue.enqueueParallelBroadcastLocked(r);\n                queue.scheduleBroadcastsLocked();\n            }\n            registeredReceivers = null;\n            NR = 0;\n        }\n```\n\n解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。\n\n这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。\n\n```\n    public void scheduleBroadcastsLocked() {\n        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\"\n                + mQueueName + \"]: current=\"\n                + mBroadcastsScheduled);\n\n        if (mBroadcastsScheduled) {\n            return;\n        }\n        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));\n        mBroadcastsScheduled = true;\n    }\n```\n\n这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。\n\n在这个方法中，首先会处理普通广播代码如下。\n\n```\n            while (mParallelBroadcasts.size() > 0) {\n                r = mParallelBroadcasts.remove(0);\n                r.dispatchTime = SystemClock.uptimeMillis();\n                r.dispatchClockTime = System.currentTimeMillis();\n                final int N = r.receivers.size();\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n                for (int i=0; i<N; i++) {\n                    Object target = r.receivers.get(i);\n                    if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,\n                            \"Delivering non-ordered on [\" + mQueueName + \"] to registered \"\n                            + target + \": \" + r);\n                    deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);\n                }\n                addBroadcastToHistoryLocked(r);\n                if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Done with parallel broadcast [\"\n                        + mQueueName + \"] \" + r);\n            }\n```\n\n可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。\n\n### 5. 动态注册广播接收者对广播的处理\n\ndeliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked\n\n```\n    private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,\n            Intent intent, int resultCode, String data, Bundle extras,\n            boolean ordered, boolean sticky, int sendingUser) throws RemoteException {\n        // Send the intent to the receiver asynchronously using one-way binder calls.\n        if (app != null) {\n            if (app.thread != null) {\n                // If we have an app thread, do the call through that so it is\n                // correctly ordered with other one-way calls.\n                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,\n                        data, extras, ordered, sticky, sendingUser, app.repProcState);\n            } else {\n                // Application has died. Receiver doesn't exist.\n                throw new RemoteException(\"app.thread must not be null\");\n            }\n        } else {\n            receiver.performReceive(intent, resultCode, data, extras, ordered,\n                    sticky, sendingUser);\n        }\n    }\n```\n\n* 如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，\n* 否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。\n\n```\n        if (receiver != null) {\n            if (mPackageInfo != null && context != null) {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = mPackageInfo.getReceiverDispatcher(\n                    receiver, context, scheduler,\n                    mMainThread.getInstrumentation(), true);\n            } else {\n                if (scheduler == null) {\n                    scheduler = mMainThread.getHandler();\n                }\n                rd = new LoadedApk.ReceiverDispatcher(\n                        receiver, context, scheduler, null, true).getIIntentReceiver();\n            }\n        }\n```\n\n其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。\n\n而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。\n\n```\n        public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,\n                int resultCode, String dataStr, Bundle extras, boolean ordered,\n                boolean sticky, int sendingUser, int processState) throws RemoteException {\n            updateProcessState(processState, false);\n            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,\n                    sticky, sendingUser);\n        }\n\n```\nreceiver的performReceive方法中，调用ReceiverDispatcher的performReceive。\n\n```\n                if (rd != null) {\n                    rd.performReceive(intent, resultCode, data, extras,\n                            ordered, sticky, sendingUser);\n                }\n```\n\nReceiverDispatcher的performReceive中，通过handler，post一个runable消息。\n\n```\n\nmActivityThread.post(args)\n\n```\n在这个方法中，有如下代码\n\n```\nClassLoader cl =  mReceiver.getClass().getClassLoader();\nintent.setExtrasClassLoader(cl);\nsetExtrasClassLoader(cl);\nreceiver.setPendingResult(this);\nreceiver.onReceive(mContext, intent);\n```\n\n这样，BroadcastReceiver就创建并调用了onReceive方法。\n\n\n### 6. 上图\n\n![](/images/framework/broadcast/broadcast流程.png)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","slug":"broadcast流程浅析","published":1,"updated":"2017-01-07T06:57:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2b0017hws6a1v2jjxq","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>个人看法。</p>\n<p>前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<ul>\n<li>静态广播</li>\n<li>动态广播</li>\n<li>发送广播</li>\n<li>动态注册广播接收者对广播的处理</li>\n</ul>\n<h3 id=\"2-静态广播的注册过程\"><a href=\"#2-静态广播的注册过程\" class=\"headerlink\" title=\"2. 静态广播的注册过程\"></a>2. 静态广播的注册过程</h3><p>系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。</p>\n<p>在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (File file : files) &#123;</div><div class=\"line\">    final boolean isPackage = (isApkFile(file) || file.isDirectory())</div><div class=\"line\">            &amp;&amp; !PackageInstallerService.isStageName(file.getName());</div><div class=\"line\">    if (!isPackage) &#123;</div><div class=\"line\">        // Ignore entries which are not packages</div><div class=\"line\">        continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</div><div class=\"line\">                scanFlags, currentTime, null);</div><div class=\"line\">    &#125; catch (PackageManagerException e) &#123;</div><div class=\"line\">                        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,</div><div class=\"line\">            String[] outError)</div></pre></td></tr></table></figure>\n<p>方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">owner.receivers.add(a);</div></pre></td></tr></table></figure>\n<p>Package对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  </div><div class=\"line\">        int scanFlags, long currentTime, UserHandle user)</div></pre></td></tr></table></figure>\n<p>这个方法将其保存在ams里。这里就不多说了。</p>\n<h3 id=\"3-动态广播注册\"><a href=\"#3-动态广播注册\" class=\"headerlink\" title=\"3. 动态广播注册\"></a>3. 动态广播注册</h3><p>我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</div><div class=\"line\">        IntentFilter filter, String broadcastPermission,</div><div class=\"line\">        Handler scheduler, Context context) &#123;</div><div class=\"line\">    IIntentReceiver rd = null;</div><div class=\"line\">    if (receiver != null) &#123;</div><div class=\"line\">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler,</div><div class=\"line\">                mMainThread.getInstrumentation(), true);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                    receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        return ActivityManagerNative.getDefault().registerReceiver(</div><div class=\"line\">                mMainThread.getApplicationThread(), mBasePackageName,</div><div class=\"line\">                rd, filter, broadcastPermission, userId);</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意这里的rd，</li>\n<li>看到，注册的过程和其他一样，也是交给了ams来完成。</li>\n</ul>\n<p>我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。</p>\n<ul>\n<li>收集粘性广播</li>\n<li>将我们这个广播接收者加入到mRegisteredReceivers中，</li>\n<li>插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。</li>\n</ul>\n<h3 id=\"4-发送广播\"><a href=\"#4-发送广播\" class=\"headerlink\" title=\"4. 发送广播\"></a>4. 发送广播</h3><p>不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,<br>在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div></pre></td></tr></table></figure>\n<p>这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。<br>解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</div></pre></td></tr></table></figure>\n<p>找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!ordered &amp;&amp; NR &gt; 0) &#123;</div><div class=\"line\">    // If we are not serializing this broadcast, then send the</div><div class=\"line\">    // registered receivers separately so they don&apos;t wait for the</div><div class=\"line\">    // components to be launched.</div><div class=\"line\">    final BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class=\"line\">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</div><div class=\"line\">            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</div><div class=\"line\">            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</div><div class=\"line\">            resultExtras, ordered, sticky, false, userId);</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</div><div class=\"line\">    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</div><div class=\"line\">    if (!replaced) &#123;</div><div class=\"line\">        queue.enqueueParallelBroadcastLocked(r);</div><div class=\"line\">        queue.scheduleBroadcastsLocked();</div><div class=\"line\">    &#125;</div><div class=\"line\">    registeredReceivers = null;</div><div class=\"line\">    NR = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。</p>\n<p>这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleBroadcastsLocked() &#123;</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</div><div class=\"line\">            + mQueueName + &quot;]: current=&quot;</div><div class=\"line\">            + mBroadcastsScheduled);</div><div class=\"line\"></div><div class=\"line\">    if (mBroadcastsScheduled) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</div><div class=\"line\">    mBroadcastsScheduled = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。</p>\n<p>在这个方法中，首先会处理普通广播代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (mParallelBroadcasts.size() &gt; 0) &#123;</div><div class=\"line\">    r = mParallelBroadcasts.remove(0);</div><div class=\"line\">    r.dispatchTime = SystemClock.uptimeMillis();</div><div class=\"line\">    r.dispatchClockTime = System.currentTimeMillis();</div><div class=\"line\">    final int N = r.receivers.size();</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        Object target = r.receivers.get(i);</div><div class=\"line\">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</div><div class=\"line\">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</div><div class=\"line\">                + target + &quot;: &quot; + r);</div><div class=\"line\">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">    addBroadcastToHistoryLocked(r);</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。</p>\n<h3 id=\"5-动态注册广播接收者对广播的处理\"><a href=\"#5-动态注册广播接收者对广播的处理\" class=\"headerlink\" title=\"5. 动态注册广播接收者对广播的处理\"></a>5. 动态注册广播接收者对广播的处理</h3><p>deliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</div><div class=\"line\">        Intent intent, int resultCode, String data, Bundle extras,</div><div class=\"line\">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</div><div class=\"line\">    // Send the intent to the receiver asynchronously using one-way binder calls.</div><div class=\"line\">    if (app != null) &#123;</div><div class=\"line\">        if (app.thread != null) &#123;</div><div class=\"line\">            // If we have an app thread, do the call through that so it is</div><div class=\"line\">            // correctly ordered with other one-way calls.</div><div class=\"line\">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class=\"line\">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Application has died. Receiver doesn&apos;t exist.</div><div class=\"line\">            throw new RemoteException(&quot;app.thread must not be null&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class=\"line\">                sticky, sendingUser);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，</li>\n<li>否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (receiver != null) &#123;</div><div class=\"line\">    if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">            receiver, context, scheduler,</div><div class=\"line\">            mMainThread.getInstrumentation(), true);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。</p>\n<p>而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</div><div class=\"line\">        int resultCode, String dataStr, Bundle extras, boolean ordered,</div><div class=\"line\">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</div><div class=\"line\">    updateProcessState(processState, false);</div><div class=\"line\">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</div><div class=\"line\">            sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>receiver的performReceive方法中，调用ReceiverDispatcher的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (rd != null) &#123;</div><div class=\"line\">    rd.performReceive(intent, resultCode, data, extras,</div><div class=\"line\">            ordered, sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ReceiverDispatcher的performReceive中，通过handler，post一个runable消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">mActivityThread.post(args)</div></pre></td></tr></table></figure>\n<p>在这个方法中，有如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class=\"line\">intent.setExtrasClassLoader(cl);</div><div class=\"line\">setExtrasClassLoader(cl);</div><div class=\"line\">receiver.setPendingResult(this);</div><div class=\"line\">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>\n<p>这样，BroadcastReceiver就创建并调用了onReceive方法。</p>\n<h3 id=\"6-上图\"><a href=\"#6-上图\" class=\"headerlink\" title=\"6. 上图\"></a>6. 上图</h3><p><img src=\"/images/framework/broadcast/broadcast流程.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>个人看法。</p>\n<p>前两篇粗略的看了下四大组件里面的Activity、Service的启动流程，今天，我们来简单的看下BroadcastReceiver的流程。包括</p>","more":"<The rest of contents | 余下全文>\n\n\n<ul>\n<li>静态广播</li>\n<li>动态广播</li>\n<li>发送广播</li>\n<li>动态注册广播接收者对广播的处理</li>\n</ul>\n<h3 id=\"2-静态广播的注册过程\"><a href=\"#2-静态广播的注册过程\" class=\"headerlink\" title=\"2. 静态广播的注册过程\"></a>2. 静态广播的注册过程</h3><p>系统开机之后，会启动很多系统服务，如ams、pms等，而我们的静态广播，就是在pms中完成的，当然，pms中的工作也不只这些。</p>\n<p>在PackageManagerService的构造函数中，会调用scanDirLI扫描特定的文件夹，来解析我们已经安装的apk。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (File file : files) &#123;</div><div class=\"line\">    final boolean isPackage = (isApkFile(file) || file.isDirectory())</div><div class=\"line\">            &amp;&amp; !PackageInstallerService.isStageName(file.getName());</div><div class=\"line\">    if (!isPackage) &#123;</div><div class=\"line\">        // Ignore entries which are not packages</div><div class=\"line\">        continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</div><div class=\"line\">                scanFlags, currentTime, null);</div><div class=\"line\">    &#125; catch (PackageManagerException e) &#123;</div><div class=\"line\">                        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果是apk文件的话，就会调用scanPackageLI来扫描并解析。而在scanPackageLI中，会创建PackageParser对象，并调用他的parsePackage方法解析apk。而在这个方法中，会根据是文件还是文件夹去选择单个解析还是多个解析。我们以单个解析为例，parseMonolithicPackage。在这个方法中，又会调用parseBaseApk方法，解析生成Package对象，并返回。经过一些列调用之后，会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,</div><div class=\"line\">            String[] outError)</div></pre></td></tr></table></figure>\n<p>方法，而在这个方法中，会解析各个标签，其中就有appliction标签，这个标签的解析会调用parseBaseApplication方法，其中就会解析receiver标签，并将其加入到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">owner.receivers.add(a);</div></pre></td></tr></table></figure>\n<p>Package对象的receivers这个arraylist里面，这样，我们以安装app里面的静态广播就保存起来了。随后会调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,  </div><div class=\"line\">        int scanFlags, long currentTime, UserHandle user)</div></pre></td></tr></table></figure>\n<p>这个方法将其保存在ams里。这里就不多说了。</p>\n<h3 id=\"3-动态广播注册\"><a href=\"#3-动态广播注册\" class=\"headerlink\" title=\"3. 动态广播注册\"></a>3. 动态广播注册</h3><p>我们知道，动态广播通过registerReceiver来注册，按照我们以往的知识，我们知道它的实现过程在ContextImpl,最后都会调用到registerReceiverInternal方法中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</div><div class=\"line\">        IntentFilter filter, String broadcastPermission,</div><div class=\"line\">        Handler scheduler, Context context) &#123;</div><div class=\"line\">    IIntentReceiver rd = null;</div><div class=\"line\">    if (receiver != null) &#123;</div><div class=\"line\">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler,</div><div class=\"line\">                mMainThread.getInstrumentation(), true);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (scheduler == null) &#123;</div><div class=\"line\">                scheduler = mMainThread.getHandler();</div><div class=\"line\">            &#125;</div><div class=\"line\">            rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                    receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        return ActivityManagerNative.getDefault().registerReceiver(</div><div class=\"line\">                mMainThread.getApplicationThread(), mBasePackageName,</div><div class=\"line\">                rd, filter, broadcastPermission, userId);</div><div class=\"line\">    &#125; catch (RemoteException e) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意这里的rd，</li>\n<li>看到，注册的过程和其他一样，也是交给了ams来完成。</li>\n</ul>\n<p>我们直接看ams的registerReceiver方法。这个方法比较长，实际上逻辑是比较简单的。</p>\n<ul>\n<li>收集粘性广播</li>\n<li>将我们这个广播接收者加入到mRegisteredReceivers中，</li>\n<li>插入我们所有的粘性广播，并用scheduleBroadcastsLocked，来分发，这个后面说。</li>\n</ul>\n<h3 id=\"4-发送广播\"><a href=\"#4-发送广播\" class=\"headerlink\" title=\"4. 发送广播\"></a>4. 发送广播</h3><p>不管是发送普通广播、有序广播还是粘性广播，都会调用asm的broadcastIntent方法。因此我们就从ams的broadcastIntent开始看,<br>在这个方法中，又会调用broadcastIntentLocked方法。这个方法代码比较长，分段看看比较很重要的几段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div></pre></td></tr></table></figure>\n<p>这个标志位，是默认不发送给未启动的app。接下来会做一些权限校验的操作。然后会根据不同的action，做不同的处理。<br>解析来判断是不是粘性广播，如果是粘性广播的话，加入粘性列表。随后，会通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</div></pre></td></tr></table></figure>\n<p>找到所有匹配的BroadcastReceiver。再然后，如果不是有序广播，则构造BroadcastQueue，enqueueParallelBroadcastLocked插入广播记录，scheduleBroadcastsLocked，进行后续操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (!ordered &amp;&amp; NR &gt; 0) &#123;</div><div class=\"line\">    // If we are not serializing this broadcast, then send the</div><div class=\"line\">    // registered receivers separately so they don&apos;t wait for the</div><div class=\"line\">    // components to be launched.</div><div class=\"line\">    final BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class=\"line\">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</div><div class=\"line\">            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</div><div class=\"line\">            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</div><div class=\"line\">            resultExtras, ordered, sticky, false, userId);</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing parallel broadcast &quot; + r);</div><div class=\"line\">    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</div><div class=\"line\">    if (!replaced) &#123;</div><div class=\"line\">        queue.enqueueParallelBroadcastLocked(r);</div><div class=\"line\">        queue.scheduleBroadcastsLocked();</div><div class=\"line\">    &#125;</div><div class=\"line\">    registeredReceivers = null;</div><div class=\"line\">    NR = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析来，会根据接收者的优先级进行排序，得到一个优先级的list，并将通过enqueueOrderedBroadcastLocked加入到优先级广播这个list里，scheduleBroadcastsLocked进行后续操作。</p>\n<p>这样，广播的处理就转移到了BroadcastQueue的scheduleBroadcastsLocked中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleBroadcastsLocked() &#123;</div><div class=\"line\">    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</div><div class=\"line\">            + mQueueName + &quot;]: current=&quot;</div><div class=\"line\">            + mBroadcastsScheduled);</div><div class=\"line\"></div><div class=\"line\">    if (mBroadcastsScheduled) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</div><div class=\"line\">    mBroadcastsScheduled = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会发一个消息，当handler收到这个消息之后，会调用processNextBroadcast来处广播列表。</p>\n<p>在这个方法中，首先会处理普通广播代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (mParallelBroadcasts.size() &gt; 0) &#123;</div><div class=\"line\">    r = mParallelBroadcasts.remove(0);</div><div class=\"line\">    r.dispatchTime = SystemClock.uptimeMillis();</div><div class=\"line\">    r.dispatchClockTime = System.currentTimeMillis();</div><div class=\"line\">    final int N = r.receivers.size();</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        Object target = r.receivers.get(i);</div><div class=\"line\">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</div><div class=\"line\">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</div><div class=\"line\">                + target + &quot;: &quot; + r);</div><div class=\"line\">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</div><div class=\"line\">    &#125;</div><div class=\"line\">    addBroadcastToHistoryLocked(r);</div><div class=\"line\">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</div><div class=\"line\">            + mQueueName + &quot;] &quot; + r);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，普通广播由deliverToRegisteredReceiverLocked来完成。值得说明的是，这里处理的是我们动态注册的广播接收者。那么，静态注册的怎么处理呢？是通过processCurBroadcastLocked去处理的。</p>\n<h3 id=\"5-动态注册广播接收者对广播的处理\"><a href=\"#5-动态注册广播接收者对广播的处理\" class=\"headerlink\" title=\"5. 动态注册广播接收者对广播的处理\"></a>5. 动态注册广播接收者对广播的处理</h3><p>deliverToRegisteredReceiverLocked方法经过一些复杂的判断之后，会调用performReceiveLocked</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</div><div class=\"line\">        Intent intent, int resultCode, String data, Bundle extras,</div><div class=\"line\">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</div><div class=\"line\">    // Send the intent to the receiver asynchronously using one-way binder calls.</div><div class=\"line\">    if (app != null) &#123;</div><div class=\"line\">        if (app.thread != null) &#123;</div><div class=\"line\">            // If we have an app thread, do the call through that so it is</div><div class=\"line\">            // correctly ordered with other one-way calls.</div><div class=\"line\">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class=\"line\">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Application has died. Receiver doesn&apos;t exist.</div><div class=\"line\">            throw new RemoteException(&quot;app.thread must not be null&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class=\"line\">                sticky, sendingUser);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果进程存在并且，ApplicationThread不为null，就调用ApplicationThread的scheduleRegisteredReceiver方法，</li>\n<li>否则调用receiver的performReceive，这里的这个receiver，是我们在注册的时候得到的，是一个binder对象。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (receiver != null) &#123;</div><div class=\"line\">    if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = mPackageInfo.getReceiverDispatcher(</div><div class=\"line\">            receiver, context, scheduler,</div><div class=\"line\">            mMainThread.getInstrumentation(), true);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (scheduler == null) &#123;</div><div class=\"line\">            scheduler = mMainThread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        rd = new LoadedApk.ReceiverDispatcher(</div><div class=\"line\">                receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实现是LoadedApk的内部类ReceiverDispatcher的内部类InnerReceiver。</p>\n<p>而scheduleRegisteredReceiver方法，也是调用receiver的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</div><div class=\"line\">        int resultCode, String dataStr, Bundle extras, boolean ordered,</div><div class=\"line\">        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</div><div class=\"line\">    updateProcessState(processState, false);</div><div class=\"line\">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</div><div class=\"line\">            sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>receiver的performReceive方法中，调用ReceiverDispatcher的performReceive。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (rd != null) &#123;</div><div class=\"line\">    rd.performReceive(intent, resultCode, data, extras,</div><div class=\"line\">            ordered, sticky, sendingUser);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ReceiverDispatcher的performReceive中，通过handler，post一个runable消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">mActivityThread.post(args)</div></pre></td></tr></table></figure>\n<p>在这个方法中，有如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class=\"line\">intent.setExtrasClassLoader(cl);</div><div class=\"line\">setExtrasClassLoader(cl);</div><div class=\"line\">receiver.setPendingResult(this);</div><div class=\"line\">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>\n<p>这样，BroadcastReceiver就创建并调用了onReceive方法。</p>\n<h3 id=\"6-上图\"><a href=\"#6-上图\" class=\"headerlink\" title=\"6. 上图\"></a>6. 上图</h3><p><img src=\"/images/framework/broadcast/broadcast流程.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco初始化过程","date":"2016-12-12T06:27:31.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1.初始化相关\n\n* ImagePipelineFactory\n* PipelineDraweeControllerBuilderSupplier\n* SimpleDraweeView\n\n在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n* AnimatedImageFactory 负责解析 动态图，gif和webp\n* Bitmap.Config 图片质量\n* Supplier<MemoryCacheParams> 内存cache的配置参数\n* CacheKeyFactory 生成cachekey的工厂\n* Context\n* mDownsampleEnabled 是否允许下载相同的图片\n* mDecodeMemoryFileEnabled \n* FileCacheFactory 文件缓存的工厂\n* mEncodedMemoryCacheParamsSupplier \n* mExecutorSupplier 线程池集\n* ImageCacheStatsTracker 图片缓存状态跟踪器\n* ImageDecoder 图片解析\n* mIsPrefetchEnabledSupplier\n* mMainDiskCacheConfig disk磁盘缓存配置\n* mMemoryTrimmableRegistry 内存检测注入\n* NetworkFetcher 网络访问，用于封装网络\n* PlatformBitmapFactory 配置bitmap 平台信息\n* PoolFactory poolfactory\n* ProgressiveJpegConfig \n* mRequestListeners 请求监听器\n* mResizeAndRotateEnabledForNetwork 是否允许调整和旋转\n* mSmallImageDiskCacheConfig small disk config\n* ImagePipelineExperiments.Builder\n\n\n其中，大部分我们并不需要配置。\n\n#### 1.1 MemoryCacheParams\n\n内部含有五个成员\n\n* maxCacheSize cache 最大容量\n* maxCacheEntries cache中 最多呢个存多少个item（块）\n* maxEvictionQueueSize 准备回收 但是还没回收的 容量\n* maxEvictionQueueEntries 每个块的最大回收数\n* maxCacheEntrySize 每个块的最大的数\n\n从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，\n\n#### 1.2 CacheKeyFactory\n\n生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。\n\n\n默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。\n\n\n#### 1.3 FileCacheFactory中的DiskCacheConfig\n\n配置版本，cache路径，大小，error log等\n\n#### 1.4 ImageCacheStatsTracker\n\ncache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，\n\n#### 1.5 ImageDecoder\n\n图片解码的入口类。\n\n#### 1.6 NetworkFetcher\n\n网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的\n\n#### 1.7 PlatformBitmapFactory\n\n用于createbitmap，并且添加引用信息有三个实现类。\n\n* GingerbreadBitmapFactory\n* HoneycombBitmapFactory 对应kikat\n* ArtBitmapFactory 对应arm\n\n\n具体的实现这里暂时忽略。\n\n\n\n#### 1.8 PoolFactory\n根据PoolConfig，配置PoolFactory。\n\n```\n   private final PoolParams mBitmapPoolParams;\n  private final PoolStatsTracker mBitmapPoolStatsTracker;\n  private final PoolParams mFlexByteArrayPoolParams;\n  private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;\n  private final PoolParams mNativeMemoryChunkPoolParams;\n  private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;\n  private final PoolParams mSmallByteArrayPoolParams;\n  private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;\n  \n```\n\npoolparams负责配置各种参数，内含三种参数类型。\n\n* PoolParams\n\t* maxSizeSoftCap 最大软 size\n\t* maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存\n\t* bucketSizes 每个桶及其对应的容量\n\t* minBucketSize 桶最小size\n\t* maxBucketSize 桶最大size\n* PoolStatsTracker 状态监测，包括释放 申请内存等\n* MemoryTrimmableRegistry\n\n\n#### 1.9 ProgressiveJpegConfig\n\n渐近式jpeg，\n\n#### 1.10 DiskCacheConfig\n\n磁盘配置。略\n\n### 2. PipelineDraweeControllerBuilderSupplier\n\n\n构造出PipelineDraweeControllerBuilder。\n\n```\n  public PipelineDraweeControllerBuilderSupplier(\n      Context context,\n      ImagePipelineFactory imagePipelineFactory,\n      Set<ControllerListener> boundControllerListeners) {\n    mContext = context;\n    mImagePipeline = imagePipelineFactory.getImagePipeline();\n\n    final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();\n    AnimatedDrawableFactory animatedDrawableFactory = null;\n    if (animatedFactory != null) {\n      animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);\n    }\n\n    mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(\n        context.getResources(),\n        DeferredReleaser.getInstance(),\n        animatedDrawableFactory,\n        UiThreadImmediateExecutorService.getInstance(),\n        mImagePipeline.getBitmapMemoryCache());\n    mBoundControllerListeners = boundControllerListeners;\n  }\n```\n\n* imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。\n* mPipelineDraweeControllerFactory\n* mBoundControllerListeners 默认为null\n\n#### 2.1 ImagePipelineFactory\n\n内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。\n\n#### 2.2 PipelineDraweeControllerFactory\n\n负责构造PipelineDraweeController。有几个默认的参数。\n\n* Resources\n* DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。\n* AnimatedDrawableFactory\n* Executor\n* MemoryCache<CacheKey, CloseableImage>\n\n\n### 3 SimpleDraweeView#initialize\n\n只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","source":"_posts/fresco初始化过程.md","raw":"---\ntitle: fresco初始化过程\ndate: 2016-12-12 14:27:31\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1.初始化相关\n\n* ImagePipelineFactory\n* PipelineDraweeControllerBuilderSupplier\n* SimpleDraweeView\n\n在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n* AnimatedImageFactory 负责解析 动态图，gif和webp\n* Bitmap.Config 图片质量\n* Supplier<MemoryCacheParams> 内存cache的配置参数\n* CacheKeyFactory 生成cachekey的工厂\n* Context\n* mDownsampleEnabled 是否允许下载相同的图片\n* mDecodeMemoryFileEnabled \n* FileCacheFactory 文件缓存的工厂\n* mEncodedMemoryCacheParamsSupplier \n* mExecutorSupplier 线程池集\n* ImageCacheStatsTracker 图片缓存状态跟踪器\n* ImageDecoder 图片解析\n* mIsPrefetchEnabledSupplier\n* mMainDiskCacheConfig disk磁盘缓存配置\n* mMemoryTrimmableRegistry 内存检测注入\n* NetworkFetcher 网络访问，用于封装网络\n* PlatformBitmapFactory 配置bitmap 平台信息\n* PoolFactory poolfactory\n* ProgressiveJpegConfig \n* mRequestListeners 请求监听器\n* mResizeAndRotateEnabledForNetwork 是否允许调整和旋转\n* mSmallImageDiskCacheConfig small disk config\n* ImagePipelineExperiments.Builder\n\n\n其中，大部分我们并不需要配置。\n\n#### 1.1 MemoryCacheParams\n\n内部含有五个成员\n\n* maxCacheSize cache 最大容量\n* maxCacheEntries cache中 最多呢个存多少个item（块）\n* maxEvictionQueueSize 准备回收 但是还没回收的 容量\n* maxEvictionQueueEntries 每个块的最大回收数\n* maxCacheEntrySize 每个块的最大的数\n\n从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，\n\n#### 1.2 CacheKeyFactory\n\n生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。\n\n\n默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。\n\n\n#### 1.3 FileCacheFactory中的DiskCacheConfig\n\n配置版本，cache路径，大小，error log等\n\n#### 1.4 ImageCacheStatsTracker\n\ncache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，\n\n#### 1.5 ImageDecoder\n\n图片解码的入口类。\n\n#### 1.6 NetworkFetcher\n\n网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的\n\n#### 1.7 PlatformBitmapFactory\n\n用于createbitmap，并且添加引用信息有三个实现类。\n\n* GingerbreadBitmapFactory\n* HoneycombBitmapFactory 对应kikat\n* ArtBitmapFactory 对应arm\n\n\n具体的实现这里暂时忽略。\n\n\n\n#### 1.8 PoolFactory\n根据PoolConfig，配置PoolFactory。\n\n```\n   private final PoolParams mBitmapPoolParams;\n  private final PoolStatsTracker mBitmapPoolStatsTracker;\n  private final PoolParams mFlexByteArrayPoolParams;\n  private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;\n  private final PoolParams mNativeMemoryChunkPoolParams;\n  private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;\n  private final PoolParams mSmallByteArrayPoolParams;\n  private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;\n  \n```\n\npoolparams负责配置各种参数，内含三种参数类型。\n\n* PoolParams\n\t* maxSizeSoftCap 最大软 size\n\t* maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存\n\t* bucketSizes 每个桶及其对应的容量\n\t* minBucketSize 桶最小size\n\t* maxBucketSize 桶最大size\n* PoolStatsTracker 状态监测，包括释放 申请内存等\n* MemoryTrimmableRegistry\n\n\n#### 1.9 ProgressiveJpegConfig\n\n渐近式jpeg，\n\n#### 1.10 DiskCacheConfig\n\n磁盘配置。略\n\n### 2. PipelineDraweeControllerBuilderSupplier\n\n\n构造出PipelineDraweeControllerBuilder。\n\n```\n  public PipelineDraweeControllerBuilderSupplier(\n      Context context,\n      ImagePipelineFactory imagePipelineFactory,\n      Set<ControllerListener> boundControllerListeners) {\n    mContext = context;\n    mImagePipeline = imagePipelineFactory.getImagePipeline();\n\n    final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();\n    AnimatedDrawableFactory animatedDrawableFactory = null;\n    if (animatedFactory != null) {\n      animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);\n    }\n\n    mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(\n        context.getResources(),\n        DeferredReleaser.getInstance(),\n        animatedDrawableFactory,\n        UiThreadImmediateExecutorService.getInstance(),\n        mImagePipeline.getBitmapMemoryCache());\n    mBoundControllerListeners = boundControllerListeners;\n  }\n```\n\n* imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。\n* mPipelineDraweeControllerFactory\n* mBoundControllerListeners 默认为null\n\n#### 2.1 ImagePipelineFactory\n\n内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。\n\n#### 2.2 PipelineDraweeControllerFactory\n\n负责构造PipelineDraweeController。有几个默认的参数。\n\n* Resources\n* DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。\n* AnimatedDrawableFactory\n* Executor\n* MemoryCache<CacheKey, CloseableImage>\n\n\n### 3 SimpleDraweeView#initialize\n\n只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n","slug":"fresco初始化过程","published":1,"updated":"2017-01-07T06:58:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2c001bhws658xk526i","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-初始化相关\"><a href=\"#1-初始化相关\" class=\"headerlink\" title=\"1.初始化相关\"></a>1.初始化相关</h3><ul>\n<li>ImagePipelineFactory</li>\n<li>PipelineDraweeControllerBuilderSupplier</li>\n<li>SimpleDraweeView</li>\n</ul>\n<p>在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n<ul>\n<li>AnimatedImageFactory 负责解析 动态图，gif和webp</li>\n<li>Bitmap.Config 图片质量</li>\n<li>Supplier<memorycacheparams> 内存cache的配置参数</memorycacheparams></li>\n<li>CacheKeyFactory 生成cachekey的工厂</li>\n<li>Context</li>\n<li>mDownsampleEnabled 是否允许下载相同的图片</li>\n<li>mDecodeMemoryFileEnabled </li>\n<li>FileCacheFactory 文件缓存的工厂</li>\n<li>mEncodedMemoryCacheParamsSupplier </li>\n<li>mExecutorSupplier 线程池集</li>\n<li>ImageCacheStatsTracker 图片缓存状态跟踪器</li>\n<li>ImageDecoder 图片解析</li>\n<li>mIsPrefetchEnabledSupplier</li>\n<li>mMainDiskCacheConfig disk磁盘缓存配置</li>\n<li>mMemoryTrimmableRegistry 内存检测注入</li>\n<li>NetworkFetcher 网络访问，用于封装网络</li>\n<li>PlatformBitmapFactory 配置bitmap 平台信息</li>\n<li>PoolFactory poolfactory</li>\n<li>ProgressiveJpegConfig </li>\n<li>mRequestListeners 请求监听器</li>\n<li>mResizeAndRotateEnabledForNetwork 是否允许调整和旋转</li>\n<li>mSmallImageDiskCacheConfig small disk config</li>\n<li>ImagePipelineExperiments.Builder</li>\n</ul>\n<p>其中，大部分我们并不需要配置。</p>\n<h4 id=\"1-1-MemoryCacheParams\"><a href=\"#1-1-MemoryCacheParams\" class=\"headerlink\" title=\"1.1 MemoryCacheParams\"></a>1.1 MemoryCacheParams</h4><p>内部含有五个成员</p>\n<ul>\n<li>maxCacheSize cache 最大容量</li>\n<li>maxCacheEntries cache中 最多呢个存多少个item（块）</li>\n<li>maxEvictionQueueSize 准备回收 但是还没回收的 容量</li>\n<li>maxEvictionQueueEntries 每个块的最大回收数</li>\n<li>maxCacheEntrySize 每个块的最大的数</li>\n</ul>\n<p>从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，</p>\n<h4 id=\"1-2-CacheKeyFactory\"><a href=\"#1-2-CacheKeyFactory\" class=\"headerlink\" title=\"1.2 CacheKeyFactory\"></a>1.2 CacheKeyFactory</h4><p>生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。</p>\n<p>默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。</p>\n<h4 id=\"1-3-FileCacheFactory中的DiskCacheConfig\"><a href=\"#1-3-FileCacheFactory中的DiskCacheConfig\" class=\"headerlink\" title=\"1.3 FileCacheFactory中的DiskCacheConfig\"></a>1.3 FileCacheFactory中的DiskCacheConfig</h4><p>配置版本，cache路径，大小，error log等</p>\n<h4 id=\"1-4-ImageCacheStatsTracker\"><a href=\"#1-4-ImageCacheStatsTracker\" class=\"headerlink\" title=\"1.4 ImageCacheStatsTracker\"></a>1.4 ImageCacheStatsTracker</h4><p>cache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，</p>\n<h4 id=\"1-5-ImageDecoder\"><a href=\"#1-5-ImageDecoder\" class=\"headerlink\" title=\"1.5 ImageDecoder\"></a>1.5 ImageDecoder</h4><p>图片解码的入口类。</p>\n<h4 id=\"1-6-NetworkFetcher\"><a href=\"#1-6-NetworkFetcher\" class=\"headerlink\" title=\"1.6 NetworkFetcher\"></a>1.6 NetworkFetcher</h4><p>网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的</p>\n<h4 id=\"1-7-PlatformBitmapFactory\"><a href=\"#1-7-PlatformBitmapFactory\" class=\"headerlink\" title=\"1.7 PlatformBitmapFactory\"></a>1.7 PlatformBitmapFactory</h4><p>用于createbitmap，并且添加引用信息有三个实现类。</p>\n<ul>\n<li>GingerbreadBitmapFactory</li>\n<li>HoneycombBitmapFactory 对应kikat</li>\n<li>ArtBitmapFactory 对应arm</li>\n</ul>\n<p>具体的实现这里暂时忽略。</p>\n<h4 id=\"1-8-PoolFactory\"><a href=\"#1-8-PoolFactory\" class=\"headerlink\" title=\"1.8 PoolFactory\"></a>1.8 PoolFactory</h4><p>根据PoolConfig，配置PoolFactory。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private final PoolParams mBitmapPoolParams;</div><div class=\"line\">private final PoolStatsTracker mBitmapPoolStatsTracker;</div><div class=\"line\">private final PoolParams mFlexByteArrayPoolParams;</div><div class=\"line\">private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;</div><div class=\"line\">private final PoolParams mNativeMemoryChunkPoolParams;</div><div class=\"line\">private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;</div><div class=\"line\">private final PoolParams mSmallByteArrayPoolParams;</div><div class=\"line\">private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;</div></pre></td></tr></table></figure>\n<p>poolparams负责配置各种参数，内含三种参数类型。</p>\n<ul>\n<li>PoolParams<ul>\n<li>maxSizeSoftCap 最大软 size</li>\n<li>maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存</li>\n<li>bucketSizes 每个桶及其对应的容量</li>\n<li>minBucketSize 桶最小size</li>\n<li>maxBucketSize 桶最大size</li>\n</ul>\n</li>\n<li>PoolStatsTracker 状态监测，包括释放 申请内存等</li>\n<li>MemoryTrimmableRegistry</li>\n</ul>\n<h4 id=\"1-9-ProgressiveJpegConfig\"><a href=\"#1-9-ProgressiveJpegConfig\" class=\"headerlink\" title=\"1.9 ProgressiveJpegConfig\"></a>1.9 ProgressiveJpegConfig</h4><p>渐近式jpeg，</p>\n<h4 id=\"1-10-DiskCacheConfig\"><a href=\"#1-10-DiskCacheConfig\" class=\"headerlink\" title=\"1.10 DiskCacheConfig\"></a>1.10 DiskCacheConfig</h4><p>磁盘配置。略</p>\n<h3 id=\"2-PipelineDraweeControllerBuilderSupplier\"><a href=\"#2-PipelineDraweeControllerBuilderSupplier\" class=\"headerlink\" title=\"2. PipelineDraweeControllerBuilderSupplier\"></a>2. PipelineDraweeControllerBuilderSupplier</h3><p>构造出PipelineDraweeControllerBuilder。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public PipelineDraweeControllerBuilderSupplier(</div><div class=\"line\">    Context context,</div><div class=\"line\">    ImagePipelineFactory imagePipelineFactory,</div><div class=\"line\">    Set&lt;ControllerListener&gt; boundControllerListeners) &#123;</div><div class=\"line\">  mContext = context;</div><div class=\"line\">  mImagePipeline = imagePipelineFactory.getImagePipeline();</div><div class=\"line\"></div><div class=\"line\">  final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();</div><div class=\"line\">  AnimatedDrawableFactory animatedDrawableFactory = null;</div><div class=\"line\">  if (animatedFactory != null) &#123;</div><div class=\"line\">    animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(</div><div class=\"line\">      context.getResources(),</div><div class=\"line\">      DeferredReleaser.getInstance(),</div><div class=\"line\">      animatedDrawableFactory,</div><div class=\"line\">      UiThreadImmediateExecutorService.getInstance(),</div><div class=\"line\">      mImagePipeline.getBitmapMemoryCache());</div><div class=\"line\">  mBoundControllerListeners = boundControllerListeners;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。</li>\n<li>mPipelineDraweeControllerFactory</li>\n<li>mBoundControllerListeners 默认为null</li>\n</ul>\n<h4 id=\"2-1-ImagePipelineFactory\"><a href=\"#2-1-ImagePipelineFactory\" class=\"headerlink\" title=\"2.1 ImagePipelineFactory\"></a>2.1 ImagePipelineFactory</h4><p>内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。</p>\n<h4 id=\"2-2-PipelineDraweeControllerFactory\"><a href=\"#2-2-PipelineDraweeControllerFactory\" class=\"headerlink\" title=\"2.2 PipelineDraweeControllerFactory\"></a>2.2 PipelineDraweeControllerFactory</h4><p>负责构造PipelineDraweeController。有几个默认的参数。</p>\n<ul>\n<li>Resources</li>\n<li>DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。</li>\n<li>AnimatedDrawableFactory</li>\n<li>Executor</li>\n<li>MemoryCache<cachekey, closeableimage=\"\"></cachekey,></li>\n</ul>\n<h3 id=\"3-SimpleDraweeView-initialize\"><a href=\"#3-SimpleDraweeView-initialize\" class=\"headerlink\" title=\"3 SimpleDraweeView#initialize\"></a>3 SimpleDraweeView#initialize</h3><p>只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-初始化相关\"><a href=\"#1-初始化相关\" class=\"headerlink\" title=\"1.初始化相关\"></a>1.初始化相关</h3><ul>\n<li>ImagePipelineFactory</li>\n<li>PipelineDraweeControllerBuilderSupplier</li>\n<li>SimpleDraweeView</li>\n</ul>\n<p>在ImagePipelineFactory初始化ImagePipelineConfig，用来配置一个参数。ImagePipelineConfig通过建造者模式 可以让使用者配置许多参数。包括以下：</p>","more":"<The rest of contents | 余下全文>\n\n\n\n\n<ul>\n<li>AnimatedImageFactory 负责解析 动态图，gif和webp</li>\n<li>Bitmap.Config 图片质量</li>\n<li>Supplier<MemoryCacheParams> 内存cache的配置参数</li>\n<li>CacheKeyFactory 生成cachekey的工厂</li>\n<li>Context</li>\n<li>mDownsampleEnabled 是否允许下载相同的图片</li>\n<li>mDecodeMemoryFileEnabled </li>\n<li>FileCacheFactory 文件缓存的工厂</li>\n<li>mEncodedMemoryCacheParamsSupplier </li>\n<li>mExecutorSupplier 线程池集</li>\n<li>ImageCacheStatsTracker 图片缓存状态跟踪器</li>\n<li>ImageDecoder 图片解析</li>\n<li>mIsPrefetchEnabledSupplier</li>\n<li>mMainDiskCacheConfig disk磁盘缓存配置</li>\n<li>mMemoryTrimmableRegistry 内存检测注入</li>\n<li>NetworkFetcher 网络访问，用于封装网络</li>\n<li>PlatformBitmapFactory 配置bitmap 平台信息</li>\n<li>PoolFactory poolfactory</li>\n<li>ProgressiveJpegConfig </li>\n<li>mRequestListeners 请求监听器</li>\n<li>mResizeAndRotateEnabledForNetwork 是否允许调整和旋转</li>\n<li>mSmallImageDiskCacheConfig small disk config</li>\n<li>ImagePipelineExperiments.Builder</li>\n</ul>\n<p>其中，大部分我们并不需要配置。</p>\n<h4 id=\"1-1-MemoryCacheParams\"><a href=\"#1-1-MemoryCacheParams\" class=\"headerlink\" title=\"1.1 MemoryCacheParams\"></a>1.1 MemoryCacheParams</h4><p>内部含有五个成员</p>\n<ul>\n<li>maxCacheSize cache 最大容量</li>\n<li>maxCacheEntries cache中 最多呢个存多少个item（块）</li>\n<li>maxEvictionQueueSize 准备回收 但是还没回收的 容量</li>\n<li>maxEvictionQueueEntries 每个块的最大回收数</li>\n<li>maxCacheEntrySize 每个块的最大的数</li>\n</ul>\n<p>从这里可以看出来，内存cache中是分块（页）的。分页 或者分块的好处：查询快，</p>\n<h4 id=\"1-2-CacheKeyFactory\"><a href=\"#1-2-CacheKeyFactory\" class=\"headerlink\" title=\"1.2 CacheKeyFactory\"></a>1.2 CacheKeyFactory</h4><p>生成cache key的规则。包括bitmap，encoded，渐进式bitmap的等。</p>\n<p>默认的DefaultCacheKeyFactory，根据url，resizeoption等等确定。</p>\n<h4 id=\"1-3-FileCacheFactory中的DiskCacheConfig\"><a href=\"#1-3-FileCacheFactory中的DiskCacheConfig\" class=\"headerlink\" title=\"1.3 FileCacheFactory中的DiskCacheConfig\"></a>1.3 FileCacheFactory中的DiskCacheConfig</h4><p>配置版本，cache路径，大小，error log等</p>\n<h4 id=\"1-4-ImageCacheStatsTracker\"><a href=\"#1-4-ImageCacheStatsTracker\" class=\"headerlink\" title=\"1.4 ImageCacheStatsTracker\"></a>1.4 ImageCacheStatsTracker</h4><p>cache跟踪回调，有一些列回调。可以自己配置，做一些命中率 统计啥的，</p>\n<h4 id=\"1-5-ImageDecoder\"><a href=\"#1-5-ImageDecoder\" class=\"headerlink\" title=\"1.5 ImageDecoder\"></a>1.5 ImageDecoder</h4><p>图片解码的入口类。</p>\n<h4 id=\"1-6-NetworkFetcher\"><a href=\"#1-6-NetworkFetcher\" class=\"headerlink\" title=\"1.6 NetworkFetcher\"></a>1.6 NetworkFetcher</h4><p>网络库的上层封装。默认为HttpUrlConnectionNetworkFetcher，使用httpurlconnection进行下载，我们也可以配置成okhttp 的</p>\n<h4 id=\"1-7-PlatformBitmapFactory\"><a href=\"#1-7-PlatformBitmapFactory\" class=\"headerlink\" title=\"1.7 PlatformBitmapFactory\"></a>1.7 PlatformBitmapFactory</h4><p>用于createbitmap，并且添加引用信息有三个实现类。</p>\n<ul>\n<li>GingerbreadBitmapFactory</li>\n<li>HoneycombBitmapFactory 对应kikat</li>\n<li>ArtBitmapFactory 对应arm</li>\n</ul>\n<p>具体的实现这里暂时忽略。</p>\n<h4 id=\"1-8-PoolFactory\"><a href=\"#1-8-PoolFactory\" class=\"headerlink\" title=\"1.8 PoolFactory\"></a>1.8 PoolFactory</h4><p>根据PoolConfig，配置PoolFactory。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private final PoolParams mBitmapPoolParams;</div><div class=\"line\">private final PoolStatsTracker mBitmapPoolStatsTracker;</div><div class=\"line\">private final PoolParams mFlexByteArrayPoolParams;</div><div class=\"line\">private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;</div><div class=\"line\">private final PoolParams mNativeMemoryChunkPoolParams;</div><div class=\"line\">private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;</div><div class=\"line\">private final PoolParams mSmallByteArrayPoolParams;</div><div class=\"line\">private final PoolStatsTracker mSmallByteArrayPoolStatsTracker;</div></pre></td></tr></table></figure>\n<p>poolparams负责配置各种参数，内含三种参数类型。</p>\n<ul>\n<li>PoolParams<ul>\n<li>maxSizeSoftCap 最大软 size</li>\n<li>maxSizeHardCap 最大硬 size，通过观察DefaultBitmapPoolParams，看得出 这个是memory cache 缓存</li>\n<li>bucketSizes 每个桶及其对应的容量</li>\n<li>minBucketSize 桶最小size</li>\n<li>maxBucketSize 桶最大size</li>\n</ul>\n</li>\n<li>PoolStatsTracker 状态监测，包括释放 申请内存等</li>\n<li>MemoryTrimmableRegistry</li>\n</ul>\n<h4 id=\"1-9-ProgressiveJpegConfig\"><a href=\"#1-9-ProgressiveJpegConfig\" class=\"headerlink\" title=\"1.9 ProgressiveJpegConfig\"></a>1.9 ProgressiveJpegConfig</h4><p>渐近式jpeg，</p>\n<h4 id=\"1-10-DiskCacheConfig\"><a href=\"#1-10-DiskCacheConfig\" class=\"headerlink\" title=\"1.10 DiskCacheConfig\"></a>1.10 DiskCacheConfig</h4><p>磁盘配置。略</p>\n<h3 id=\"2-PipelineDraweeControllerBuilderSupplier\"><a href=\"#2-PipelineDraweeControllerBuilderSupplier\" class=\"headerlink\" title=\"2. PipelineDraweeControllerBuilderSupplier\"></a>2. PipelineDraweeControllerBuilderSupplier</h3><p>构造出PipelineDraweeControllerBuilder。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public PipelineDraweeControllerBuilderSupplier(</div><div class=\"line\">    Context context,</div><div class=\"line\">    ImagePipelineFactory imagePipelineFactory,</div><div class=\"line\">    Set&lt;ControllerListener&gt; boundControllerListeners) &#123;</div><div class=\"line\">  mContext = context;</div><div class=\"line\">  mImagePipeline = imagePipelineFactory.getImagePipeline();</div><div class=\"line\"></div><div class=\"line\">  final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();</div><div class=\"line\">  AnimatedDrawableFactory animatedDrawableFactory = null;</div><div class=\"line\">  if (animatedFactory != null) &#123;</div><div class=\"line\">    animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(</div><div class=\"line\">      context.getResources(),</div><div class=\"line\">      DeferredReleaser.getInstance(),</div><div class=\"line\">      animatedDrawableFactory,</div><div class=\"line\">      UiThreadImmediateExecutorService.getInstance(),</div><div class=\"line\">      mImagePipeline.getBitmapMemoryCache());</div><div class=\"line\">  mBoundControllerListeners = boundControllerListeners;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>imagePipelineFactory是通过ImagePipelineFactory.getInstance()返回的。而ImagePipelineFactory是通过传入imagePipelineConfig，根据我们的配置来完成初始化的。</li>\n<li>mPipelineDraweeControllerFactory</li>\n<li>mBoundControllerListeners 默认为null</li>\n</ul>\n<h4 id=\"2-1-ImagePipelineFactory\"><a href=\"#2-1-ImagePipelineFactory\" class=\"headerlink\" title=\"2.1 ImagePipelineFactory\"></a>2.1 ImagePipelineFactory</h4><p>内部提供了许多get方法去获取一些参数，和以往factory不同的一点是，构造函数中几乎不初始化我们需要的参数，只有在我们需要的时候才会去检查，没有初始化则初始化。</p>\n<h4 id=\"2-2-PipelineDraweeControllerFactory\"><a href=\"#2-2-PipelineDraweeControllerFactory\" class=\"headerlink\" title=\"2.2 PipelineDraweeControllerFactory\"></a>2.2 PipelineDraweeControllerFactory</h4><p>负责构造PipelineDraweeController。有几个默认的参数。</p>\n<ul>\n<li>Resources</li>\n<li>DeferredReleaser 延迟释放，当主线程处理完当前message之后才进行回收。</li>\n<li>AnimatedDrawableFactory</li>\n<li>Executor</li>\n<li>MemoryCache<CacheKey, CloseableImage></li>\n</ul>\n<h3 id=\"3-SimpleDraweeView-initialize\"><a href=\"#3-SimpleDraweeView-initialize\" class=\"headerlink\" title=\"3 SimpleDraweeView#initialize\"></a>3 SimpleDraweeView#initialize</h3><p>只是设置了sDraweeControllerBuilderSupplier，注意这是个静态变量。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"SystemServer进程的初始化","date":"2017-01-07T14:45:40.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n从上一篇我们知道，在Zygote进程的启动过程中，通过startSystemServer方法，来启动Android中另外一个核心进程SystemServer进程。那么，就来看下SystemServer进程的一些东西。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### ZygoteInit#startSystemServer\n\n```\n// 省去一部分参数代码\n        ZygoteConnection.Arguments parsedArgs = null;\n\n        int pid;\n\n        try {\n            parsedArgs = new ZygoteConnection.Arguments(args);\n            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n            /* Request to fork the system server process */\n            pid = Zygote.forkSystemServer(\n                    parsedArgs.uid, parsedArgs.gid,\n                    parsedArgs.gids,\n                    parsedArgs.debugFlags,\n                    null,\n                    parsedArgs.permittedCapabilities,\n                    parsedArgs.effectiveCapabilities);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        /* For child process */\n        if (pid == 0) {\n            if (hasSecondZygote(abiList)) {\n                waitForSecondaryZygote(socketName);\n            }\n\n            handleSystemServerProcess(parsedArgs);\n        }\n\n        return true;\n```\n\n* fork进程(和以前进程启动类似)\n* handleSystemServerProcess来处理SystemServer进程\n\n### ZygoteInit#handleSystemServerProcess\n\n```\n    private static void handleSystemServerProcess(\n            ZygoteConnection.Arguments parsedArgs)\n            throws ZygoteInit.MethodAndArgsCaller {\n\n        closeServerSocket();\n\n        // set umask to 0077 so new files and directories will default to owner-only permissions.\n        Os.umask(S_IRWXG | S_IRWXO);\n\n        if (parsedArgs.niceName != null) {\n            Process.setArgV0(parsedArgs.niceName);\n        }\n\n        final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\");\n        if (systemServerClasspath != null) {\n            performSystemServerDexOpt(systemServerClasspath);\n        }\n\n        if (parsedArgs.invokeWith != null) {\n            String[] args = parsedArgs.remainingArgs;\n            // If we have a non-null system server class path, we'll have to duplicate the\n            // existing arguments and append the classpath to it. ART will handle the classpath\n            // correctly when we exec a new process.\n            if (systemServerClasspath != null) {\n                String[] amendedArgs = new String[args.length + 2];\n                amendedArgs[0] = \"-cp\";\n                amendedArgs[1] = systemServerClasspath;\n                System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);\n            }\n\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(), null, args);\n        } else {\n            ClassLoader cl = null;\n            if (systemServerClasspath != null) {\n                cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());\n                Thread.currentThread().setContextClassLoader(cl);\n            }\n\n            /*\n             * Pass the remaining arguments to SystemServer.\n             */\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);\n        }\n\n        /* should never reach here */\n    }\n```\n\n* 通过umask设置创建文件的默认权限\n* 设置进程的nicename\n* 获取SYSTEMSERVERCLASSPATH环境变量值(一系列jar)，如果需要，进行dex优化\n* 在这里，invokeWith为null，所以会通过RuntimeInit.zygoteInit去启动\n\nRuntimeInit.zygoteInit中调用applicationInit，调用invokeStaticMain，然后就会调用SystemServer的main方法。\n\n```\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n```\n\n在SystemServer的构造函数中，获取mFactoryTestMode值，我们的重点在run方法。\n\n### SystemServer#run\n\nrun方法的代码如下：\n\n```\n    private void run() {\n        // If a device's clock is before 1970 (before 0), a lot of\n        // APIs crash dealing with negative numbers, notably\n        // java.io.File#setLastModified, so instead we fake it and\n        // hope that time from cell towers or NTP fixes it shortly.\n        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {\n            Slog.w(TAG, \"System clock is before 1970; setting to 1970.\");\n            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);\n        }\n\n        // If the system has \"persist.sys.language\" and friends set, replace them with\n        // \"persist.sys.locale\". Note that the default locale at this point is calculated\n        // using the \"-Duser.locale\" command line flag. That flag is usually populated by\n        // AndroidRuntime using the same set of system properties, but only the system_server\n        // and system apps are allowed to set them.\n        //\n        // NOTE: Most changes made here will need an equivalent change to\n        // core/jni/AndroidRuntime.cpp\n        if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) {\n            final String languageTag = Locale.getDefault().toLanguageTag();\n\n            SystemProperties.set(\"persist.sys.locale\", languageTag);\n            SystemProperties.set(\"persist.sys.language\", \"\");\n            SystemProperties.set(\"persist.sys.country\", \"\");\n            SystemProperties.set(\"persist.sys.localevar\", \"\");\n        }\n\n        // Here we go!\n        Slog.i(TAG, \"Entered the Android system server!\");\n        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());\n\n        // In case the runtime switched since last boot (such as when\n        // the old runtime was removed in an OTA), set the system\n        // property so that it is in sync. We can't do this in\n        // libnativehelper's JniInvocation::Init code where we already\n        // had to fallback to a different runtime because it is\n        // running as root and we need to be the system user to set\n        // the property. http://b/11463182\n        SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary());\n\n        // Enable the sampling profiler.\n        if (SamplingProfilerIntegration.isEnabled()) {\n            SamplingProfilerIntegration.start();\n            mProfilerSnapshotTimer = new Timer();\n            mProfilerSnapshotTimer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    SamplingProfilerIntegration.writeSnapshot(\"system_server\", null);\n                }\n            }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);\n        }\n\n        // Mmmmmm... more memory!\n        VMRuntime.getRuntime().clearGrowthLimit();\n\n        // The system server has to run all of the time, so it needs to be\n        // as efficient as possible with its memory usage.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);\n\n        // Some devices rely on runtime fingerprint generation, so make sure\n        // we've defined it before booting further.\n        Build.ensureFingerprintProperty();\n\n        // Within the system server, it is an error to access Environment paths without\n        // explicitly specifying a user.\n        Environment.setUserRequired(true);\n\n        // Ensure binder calls into the system always run at foreground priority.\n        BinderInternal.disableBackgroundScheduling(true);\n\n        // Prepare the main looper thread (this thread).\n        android.os.Process.setThreadPriority(\n                android.os.Process.THREAD_PRIORITY_FOREGROUND);\n        android.os.Process.setCanSelfBackground(false);\n        Looper.prepareMainLooper();\n\n        // Initialize native services.\n        System.loadLibrary(\"android_servers\");\n\n        // Check whether we failed to shut down last time we tried.\n        // This call may not return.\n        performPendingShutdown();\n\n        // Initialize the system context.\n        createSystemContext();\n\n        // Create the system service manager.\n        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);\n\n        // Start services.\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(\"System\", \"******************************************\");\n            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n            throw ex;\n        }\n\n        // For debug builds, log event loop stalls to dropbox for analysis.\n        if (StrictMode.conditionallyEnableDebugLogging()) {\n            Slog.i(TAG, \"Enabled StrictMode for system server main thread.\");\n        }\n\n        // Loop forever.\n        Looper.loop();\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n主要干了这些事：\n\n* 校验时间是否合法(1970)\n* 设置语言\n* 设置虚拟机库文件\n* 如果允许抽样分析器，则开启SamplingProfilerIntegration(抽样分析器)\n* clearGrowthLimit 清除内存增长上限\n* 设置内存使用率，setTargetHeapUtilization\n* 加载android_servers库\n* 创建上下文，创建SystemServiceManager，添加到LocalServices\n* startBootstrapServices 启动引导服务\n* startCoreServices 启动核心服务\n* startOtherServices 启动其他服务\n\n最后的启动服务 是核心，我们分别来看下。\n\n### SystemServer#startBootstrapServices\n\n```\n    private void startBootstrapServices() {\n        // Wait for installd to finish starting up so that it has a chance to\n        // create critical directories such as /data/user with the appropriate\n        // permissions.  We need this to complete before we initialize other services.\n        Installer installer = mSystemServiceManager.startService(Installer.class);\n\n        // Activity manager runs the show.\n        mActivityManagerService = mSystemServiceManager.startService(\n                ActivityManagerService.Lifecycle.class).getService();\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n        mActivityManagerService.setInstaller(installer);\n\n        // Power manager needs to be started early because other services need it.\n        // Native daemons may be watching for it to be registered so it must be ready\n        // to handle incoming binder calls immediately (including being able to verify\n        // the permissions for those calls).\n        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\n        // Now that the power manager has been started, let the activity manager\n        // initialize power management features.\n        mActivityManagerService.initPowerManagement();\n\n        // Manages LEDs and display backlight so we need it to bring up the display.\n        mSystemServiceManager.startService(LightsService.class);\n\n        // Display manager is needed to provide display metrics before package manager\n        // starts up.\n        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\n        // We need the default display before we can initialize the package manager.\n        mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);\n\n        // Only run \"core\" apps if we're encrypting the device.\n        String cryptState = SystemProperties.get(\"vold.decrypt\");\n        if (ENCRYPTING_STATE.equals(cryptState)) {\n            Slog.w(TAG, \"Detected encryption in progress - only parsing core apps\");\n            mOnlyCore = true;\n        } else if (ENCRYPTED_STATE.equals(cryptState)) {\n            Slog.w(TAG, \"Device encrypted - only parsing core apps\");\n            mOnlyCore = true;\n        }\n\n        // Start the package manager.\n        Slog.i(TAG, \"Package Manager\");\n        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,\n                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n        mFirstBoot = mPackageManagerService.isFirstBoot();\n        mPackageManager = mSystemContext.getPackageManager();\n\n        Slog.i(TAG, \"User Service\");\n        ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());\n\n        // Initialize attribute cache used to cache resources from packages.\n        AttributeCache.init(mSystemContext);\n\n        // Set up the Application instance for the system process and get started.\n        mActivityManagerService.setSystemProcess();\n\n        // The sensor service needs access to package manager service, app ops\n        // service, and permissions service, therefore we start it after them.\n        startSensorService();\n    }\n```\n\n* 启动Installer,用于应用程序安装，卸载，dex优化等等\n* 启动ActivityManagerService\n* 启动PowerManagerService\n* 启动LightsService\n* 启动DisplayManagerService\n* 启动PackageManagerService\n* 启动UserManagerService\n* 启动传感器服务(native)\n\n### SystemServer#startCoreServices\n\n```\n    private void startCoreServices() {\n        // Tracks the battery level.  Requires LightService.\n        mSystemServiceManager.startService(BatteryService.class);\n\n        // Tracks application usage stats.\n        mSystemServiceManager.startService(UsageStatsService.class);\n        mActivityManagerService.setUsageStatsManager(\n                LocalServices.getService(UsageStatsManagerInternal.class));\n        // Update after UsageStatsService is available, needed before performBootDexOpt.\n        mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();\n\n        // Tracks whether the updatable WebView is in a ready state and watches for update installs.\n        mSystemServiceManager.startService(WebViewUpdateService.class);\n    }\n```\n\n同样是启动几个核心的系统服务。\n\n### SystemServer#startOtherServices\n\n\n在这个方法中，同样启动了很多服务，不过，这里不仅仅有startService，也有ServiceManager.addService,不过这个是通过binder，像native注册的服务。\n\n```\n            case IServiceManager.ADD_SERVICE_TRANSACTION: {\n                data.enforceInterface(IServiceManager.descriptor);\n                String name = data.readString();\n                IBinder service = data.readStrongBinder();\n                boolean allowIsolated = data.readInt() != 0;\n                addService(name, service, allowIsolated);\n                return true;\n            }\n```\n\n当启动注册完毕之后，会调用各个服务的systemReady方法。这里就不介绍了。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/SystemServer进程的初始化.md","raw":"---\ntitle: SystemServer进程的初始化\ndate: 2017-01-07 22:45:40\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n从上一篇我们知道，在Zygote进程的启动过程中，通过startSystemServer方法，来启动Android中另外一个核心进程SystemServer进程。那么，就来看下SystemServer进程的一些东西。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### ZygoteInit#startSystemServer\n\n```\n// 省去一部分参数代码\n        ZygoteConnection.Arguments parsedArgs = null;\n\n        int pid;\n\n        try {\n            parsedArgs = new ZygoteConnection.Arguments(args);\n            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n            /* Request to fork the system server process */\n            pid = Zygote.forkSystemServer(\n                    parsedArgs.uid, parsedArgs.gid,\n                    parsedArgs.gids,\n                    parsedArgs.debugFlags,\n                    null,\n                    parsedArgs.permittedCapabilities,\n                    parsedArgs.effectiveCapabilities);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        /* For child process */\n        if (pid == 0) {\n            if (hasSecondZygote(abiList)) {\n                waitForSecondaryZygote(socketName);\n            }\n\n            handleSystemServerProcess(parsedArgs);\n        }\n\n        return true;\n```\n\n* fork进程(和以前进程启动类似)\n* handleSystemServerProcess来处理SystemServer进程\n\n### ZygoteInit#handleSystemServerProcess\n\n```\n    private static void handleSystemServerProcess(\n            ZygoteConnection.Arguments parsedArgs)\n            throws ZygoteInit.MethodAndArgsCaller {\n\n        closeServerSocket();\n\n        // set umask to 0077 so new files and directories will default to owner-only permissions.\n        Os.umask(S_IRWXG | S_IRWXO);\n\n        if (parsedArgs.niceName != null) {\n            Process.setArgV0(parsedArgs.niceName);\n        }\n\n        final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\");\n        if (systemServerClasspath != null) {\n            performSystemServerDexOpt(systemServerClasspath);\n        }\n\n        if (parsedArgs.invokeWith != null) {\n            String[] args = parsedArgs.remainingArgs;\n            // If we have a non-null system server class path, we'll have to duplicate the\n            // existing arguments and append the classpath to it. ART will handle the classpath\n            // correctly when we exec a new process.\n            if (systemServerClasspath != null) {\n                String[] amendedArgs = new String[args.length + 2];\n                amendedArgs[0] = \"-cp\";\n                amendedArgs[1] = systemServerClasspath;\n                System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);\n            }\n\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(), null, args);\n        } else {\n            ClassLoader cl = null;\n            if (systemServerClasspath != null) {\n                cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());\n                Thread.currentThread().setContextClassLoader(cl);\n            }\n\n            /*\n             * Pass the remaining arguments to SystemServer.\n             */\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);\n        }\n\n        /* should never reach here */\n    }\n```\n\n* 通过umask设置创建文件的默认权限\n* 设置进程的nicename\n* 获取SYSTEMSERVERCLASSPATH环境变量值(一系列jar)，如果需要，进行dex优化\n* 在这里，invokeWith为null，所以会通过RuntimeInit.zygoteInit去启动\n\nRuntimeInit.zygoteInit中调用applicationInit，调用invokeStaticMain，然后就会调用SystemServer的main方法。\n\n```\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n```\n\n在SystemServer的构造函数中，获取mFactoryTestMode值，我们的重点在run方法。\n\n### SystemServer#run\n\nrun方法的代码如下：\n\n```\n    private void run() {\n        // If a device's clock is before 1970 (before 0), a lot of\n        // APIs crash dealing with negative numbers, notably\n        // java.io.File#setLastModified, so instead we fake it and\n        // hope that time from cell towers or NTP fixes it shortly.\n        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {\n            Slog.w(TAG, \"System clock is before 1970; setting to 1970.\");\n            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);\n        }\n\n        // If the system has \"persist.sys.language\" and friends set, replace them with\n        // \"persist.sys.locale\". Note that the default locale at this point is calculated\n        // using the \"-Duser.locale\" command line flag. That flag is usually populated by\n        // AndroidRuntime using the same set of system properties, but only the system_server\n        // and system apps are allowed to set them.\n        //\n        // NOTE: Most changes made here will need an equivalent change to\n        // core/jni/AndroidRuntime.cpp\n        if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) {\n            final String languageTag = Locale.getDefault().toLanguageTag();\n\n            SystemProperties.set(\"persist.sys.locale\", languageTag);\n            SystemProperties.set(\"persist.sys.language\", \"\");\n            SystemProperties.set(\"persist.sys.country\", \"\");\n            SystemProperties.set(\"persist.sys.localevar\", \"\");\n        }\n\n        // Here we go!\n        Slog.i(TAG, \"Entered the Android system server!\");\n        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());\n\n        // In case the runtime switched since last boot (such as when\n        // the old runtime was removed in an OTA), set the system\n        // property so that it is in sync. We can't do this in\n        // libnativehelper's JniInvocation::Init code where we already\n        // had to fallback to a different runtime because it is\n        // running as root and we need to be the system user to set\n        // the property. http://b/11463182\n        SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary());\n\n        // Enable the sampling profiler.\n        if (SamplingProfilerIntegration.isEnabled()) {\n            SamplingProfilerIntegration.start();\n            mProfilerSnapshotTimer = new Timer();\n            mProfilerSnapshotTimer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    SamplingProfilerIntegration.writeSnapshot(\"system_server\", null);\n                }\n            }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);\n        }\n\n        // Mmmmmm... more memory!\n        VMRuntime.getRuntime().clearGrowthLimit();\n\n        // The system server has to run all of the time, so it needs to be\n        // as efficient as possible with its memory usage.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);\n\n        // Some devices rely on runtime fingerprint generation, so make sure\n        // we've defined it before booting further.\n        Build.ensureFingerprintProperty();\n\n        // Within the system server, it is an error to access Environment paths without\n        // explicitly specifying a user.\n        Environment.setUserRequired(true);\n\n        // Ensure binder calls into the system always run at foreground priority.\n        BinderInternal.disableBackgroundScheduling(true);\n\n        // Prepare the main looper thread (this thread).\n        android.os.Process.setThreadPriority(\n                android.os.Process.THREAD_PRIORITY_FOREGROUND);\n        android.os.Process.setCanSelfBackground(false);\n        Looper.prepareMainLooper();\n\n        // Initialize native services.\n        System.loadLibrary(\"android_servers\");\n\n        // Check whether we failed to shut down last time we tried.\n        // This call may not return.\n        performPendingShutdown();\n\n        // Initialize the system context.\n        createSystemContext();\n\n        // Create the system service manager.\n        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);\n\n        // Start services.\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(\"System\", \"******************************************\");\n            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n            throw ex;\n        }\n\n        // For debug builds, log event loop stalls to dropbox for analysis.\n        if (StrictMode.conditionallyEnableDebugLogging()) {\n            Slog.i(TAG, \"Enabled StrictMode for system server main thread.\");\n        }\n\n        // Loop forever.\n        Looper.loop();\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n主要干了这些事：\n\n* 校验时间是否合法(1970)\n* 设置语言\n* 设置虚拟机库文件\n* 如果允许抽样分析器，则开启SamplingProfilerIntegration(抽样分析器)\n* clearGrowthLimit 清除内存增长上限\n* 设置内存使用率，setTargetHeapUtilization\n* 加载android_servers库\n* 创建上下文，创建SystemServiceManager，添加到LocalServices\n* startBootstrapServices 启动引导服务\n* startCoreServices 启动核心服务\n* startOtherServices 启动其他服务\n\n最后的启动服务 是核心，我们分别来看下。\n\n### SystemServer#startBootstrapServices\n\n```\n    private void startBootstrapServices() {\n        // Wait for installd to finish starting up so that it has a chance to\n        // create critical directories such as /data/user with the appropriate\n        // permissions.  We need this to complete before we initialize other services.\n        Installer installer = mSystemServiceManager.startService(Installer.class);\n\n        // Activity manager runs the show.\n        mActivityManagerService = mSystemServiceManager.startService(\n                ActivityManagerService.Lifecycle.class).getService();\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n        mActivityManagerService.setInstaller(installer);\n\n        // Power manager needs to be started early because other services need it.\n        // Native daemons may be watching for it to be registered so it must be ready\n        // to handle incoming binder calls immediately (including being able to verify\n        // the permissions for those calls).\n        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\n        // Now that the power manager has been started, let the activity manager\n        // initialize power management features.\n        mActivityManagerService.initPowerManagement();\n\n        // Manages LEDs and display backlight so we need it to bring up the display.\n        mSystemServiceManager.startService(LightsService.class);\n\n        // Display manager is needed to provide display metrics before package manager\n        // starts up.\n        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\n        // We need the default display before we can initialize the package manager.\n        mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);\n\n        // Only run \"core\" apps if we're encrypting the device.\n        String cryptState = SystemProperties.get(\"vold.decrypt\");\n        if (ENCRYPTING_STATE.equals(cryptState)) {\n            Slog.w(TAG, \"Detected encryption in progress - only parsing core apps\");\n            mOnlyCore = true;\n        } else if (ENCRYPTED_STATE.equals(cryptState)) {\n            Slog.w(TAG, \"Device encrypted - only parsing core apps\");\n            mOnlyCore = true;\n        }\n\n        // Start the package manager.\n        Slog.i(TAG, \"Package Manager\");\n        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,\n                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n        mFirstBoot = mPackageManagerService.isFirstBoot();\n        mPackageManager = mSystemContext.getPackageManager();\n\n        Slog.i(TAG, \"User Service\");\n        ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());\n\n        // Initialize attribute cache used to cache resources from packages.\n        AttributeCache.init(mSystemContext);\n\n        // Set up the Application instance for the system process and get started.\n        mActivityManagerService.setSystemProcess();\n\n        // The sensor service needs access to package manager service, app ops\n        // service, and permissions service, therefore we start it after them.\n        startSensorService();\n    }\n```\n\n* 启动Installer,用于应用程序安装，卸载，dex优化等等\n* 启动ActivityManagerService\n* 启动PowerManagerService\n* 启动LightsService\n* 启动DisplayManagerService\n* 启动PackageManagerService\n* 启动UserManagerService\n* 启动传感器服务(native)\n\n### SystemServer#startCoreServices\n\n```\n    private void startCoreServices() {\n        // Tracks the battery level.  Requires LightService.\n        mSystemServiceManager.startService(BatteryService.class);\n\n        // Tracks application usage stats.\n        mSystemServiceManager.startService(UsageStatsService.class);\n        mActivityManagerService.setUsageStatsManager(\n                LocalServices.getService(UsageStatsManagerInternal.class));\n        // Update after UsageStatsService is available, needed before performBootDexOpt.\n        mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();\n\n        // Tracks whether the updatable WebView is in a ready state and watches for update installs.\n        mSystemServiceManager.startService(WebViewUpdateService.class);\n    }\n```\n\n同样是启动几个核心的系统服务。\n\n### SystemServer#startOtherServices\n\n\n在这个方法中，同样启动了很多服务，不过，这里不仅仅有startService，也有ServiceManager.addService,不过这个是通过binder，像native注册的服务。\n\n```\n            case IServiceManager.ADD_SERVICE_TRANSACTION: {\n                data.enforceInterface(IServiceManager.descriptor);\n                String name = data.readString();\n                IBinder service = data.readStrongBinder();\n                boolean allowIsolated = data.readInt() != 0;\n                addService(name, service, allowIsolated);\n                return true;\n            }\n```\n\n当启动注册完毕之后，会调用各个服务的systemReady方法。这里就不介绍了。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"SystemServer进程的初始化","published":1,"updated":"2017-01-07T14:47:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2d001ehws601hdgblp","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从上一篇我们知道，在Zygote进程的启动过程中，通过startSystemServer方法，来启动Android中另外一个核心进程SystemServer进程。那么，就来看下SystemServer进程的一些东西。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"ZygoteInit-startSystemServer\"><a href=\"#ZygoteInit-startSystemServer\" class=\"headerlink\" title=\"ZygoteInit#startSystemServer\"></a>ZygoteInit#startSystemServer</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 省去一部分参数代码</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs = null;</div><div class=\"line\"></div><div class=\"line\">        int pid;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            parsedArgs = new ZygoteConnection.Arguments(args);</div><div class=\"line\">            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">            /* Request to fork the system server process */</div><div class=\"line\">            pid = Zygote.forkSystemServer(</div><div class=\"line\">                    parsedArgs.uid, parsedArgs.gid,</div><div class=\"line\">                    parsedArgs.gids,</div><div class=\"line\">                    parsedArgs.debugFlags,</div><div class=\"line\">                    null,</div><div class=\"line\">                    parsedArgs.permittedCapabilities,</div><div class=\"line\">                    parsedArgs.effectiveCapabilities);</div><div class=\"line\">        &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(ex);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /* For child process */</div><div class=\"line\">        if (pid == 0) &#123;</div><div class=\"line\">            if (hasSecondZygote(abiList)) &#123;</div><div class=\"line\">                waitForSecondaryZygote(socketName);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handleSystemServerProcess(parsedArgs);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return true;</div></pre></td></tr></table></figure>\n<ul>\n<li>fork进程(和以前进程启动类似)</li>\n<li>handleSystemServerProcess来处理SystemServer进程</li>\n</ul>\n<h3 id=\"ZygoteInit-handleSystemServerProcess\"><a href=\"#ZygoteInit-handleSystemServerProcess\" class=\"headerlink\" title=\"ZygoteInit#handleSystemServerProcess\"></a>ZygoteInit#handleSystemServerProcess</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void handleSystemServerProcess(</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">    closeServerSocket();</div><div class=\"line\"></div><div class=\"line\">    // set umask to 0077 so new files and directories will default to owner-only permissions.</div><div class=\"line\">    Os.umask(S_IRWXG | S_IRWXO);</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.niceName != null) &#123;</div><div class=\"line\">        Process.setArgV0(parsedArgs.niceName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</div><div class=\"line\">    if (systemServerClasspath != null) &#123;</div><div class=\"line\">        performSystemServerDexOpt(systemServerClasspath);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">        String[] args = parsedArgs.remainingArgs;</div><div class=\"line\">        // If we have a non-null system server class path, we&apos;ll have to duplicate the</div><div class=\"line\">        // existing arguments and append the classpath to it. ART will handle the classpath</div><div class=\"line\">        // correctly when we exec a new process.</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            String[] amendedArgs = new String[args.length + 2];</div><div class=\"line\">            amendedArgs[0] = &quot;-cp&quot;;</div><div class=\"line\">            amendedArgs[1] = systemServerClasspath;</div><div class=\"line\">            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">                VMRuntime.getCurrentInstructionSet(), null, args);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ClassLoader cl = null;</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</div><div class=\"line\">            Thread.currentThread().setContextClassLoader(cl);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * Pass the remaining arguments to SystemServer.</div><div class=\"line\">         */</div><div class=\"line\">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* should never reach here */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过umask设置创建文件的默认权限</li>\n<li>设置进程的nicename</li>\n<li>获取SYSTEMSERVERCLASSPATH环境变量值(一系列jar)，如果需要，进行dex优化</li>\n<li>在这里，invokeWith为null，所以会通过RuntimeInit.zygoteInit去启动</li>\n</ul>\n<p>RuntimeInit.zygoteInit中调用applicationInit，调用invokeStaticMain，然后就会调用SystemServer的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\">    new SystemServer().run();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在SystemServer的构造函数中，获取mFactoryTestMode值，我们的重点在run方法。</p>\n<h3 id=\"SystemServer-run\"><a href=\"#SystemServer-run\" class=\"headerlink\" title=\"SystemServer#run\"></a>SystemServer#run</h3><p>run方法的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void run() &#123;</div><div class=\"line\">    // If a device&apos;s clock is before 1970 (before 0), a lot of</div><div class=\"line\">    // APIs crash dealing with negative numbers, notably</div><div class=\"line\">    // java.io.File#setLastModified, so instead we fake it and</div><div class=\"line\">    // hope that time from cell towers or NTP fixes it shortly.</div><div class=\"line\">    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</div><div class=\"line\">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If the system has &quot;persist.sys.language&quot; and friends set, replace them with</div><div class=\"line\">    // &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated</div><div class=\"line\">    // using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by</div><div class=\"line\">    // AndroidRuntime using the same set of system properties, but only the system_server</div><div class=\"line\">    // and system apps are allowed to set them.</div><div class=\"line\">    //</div><div class=\"line\">    // NOTE: Most changes made here will need an equivalent change to</div><div class=\"line\">    // core/jni/AndroidRuntime.cpp</div><div class=\"line\">    if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;</div><div class=\"line\">        final String languageTag = Locale.getDefault().toLanguageTag();</div><div class=\"line\"></div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Here we go!</div><div class=\"line\">    Slog.i(TAG, &quot;Entered the Android system server!&quot;);</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());</div><div class=\"line\"></div><div class=\"line\">    // In case the runtime switched since last boot (such as when</div><div class=\"line\">    // the old runtime was removed in an OTA), set the system</div><div class=\"line\">    // property so that it is in sync. We can&apos;t do this in</div><div class=\"line\">    // libnativehelper&apos;s JniInvocation::Init code where we already</div><div class=\"line\">    // had to fallback to a different runtime because it is</div><div class=\"line\">    // running as root and we need to be the system user to set</div><div class=\"line\">    // the property. http://b/11463182</div><div class=\"line\">    SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());</div><div class=\"line\"></div><div class=\"line\">    // Enable the sampling profiler.</div><div class=\"line\">    if (SamplingProfilerIntegration.isEnabled()) &#123;</div><div class=\"line\">        SamplingProfilerIntegration.start();</div><div class=\"line\">        mProfilerSnapshotTimer = new Timer();</div><div class=\"line\">        mProfilerSnapshotTimer.schedule(new TimerTask() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Mmmmmm... more memory!</div><div class=\"line\">    VMRuntime.getRuntime().clearGrowthLimit();</div><div class=\"line\"></div><div class=\"line\">    // The system server has to run all of the time, so it needs to be</div><div class=\"line\">    // as efficient as possible with its memory usage.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);</div><div class=\"line\"></div><div class=\"line\">    // Some devices rely on runtime fingerprint generation, so make sure</div><div class=\"line\">    // we&apos;ve defined it before booting further.</div><div class=\"line\">    Build.ensureFingerprintProperty();</div><div class=\"line\"></div><div class=\"line\">    // Within the system server, it is an error to access Environment paths without</div><div class=\"line\">    // explicitly specifying a user.</div><div class=\"line\">    Environment.setUserRequired(true);</div><div class=\"line\"></div><div class=\"line\">    // Ensure binder calls into the system always run at foreground priority.</div><div class=\"line\">    BinderInternal.disableBackgroundScheduling(true);</div><div class=\"line\"></div><div class=\"line\">    // Prepare the main looper thread (this thread).</div><div class=\"line\">    android.os.Process.setThreadPriority(</div><div class=\"line\">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</div><div class=\"line\">    android.os.Process.setCanSelfBackground(false);</div><div class=\"line\">    Looper.prepareMainLooper();</div><div class=\"line\"></div><div class=\"line\">    // Initialize native services.</div><div class=\"line\">    System.loadLibrary(&quot;android_servers&quot;);</div><div class=\"line\"></div><div class=\"line\">    // Check whether we failed to shut down last time we tried.</div><div class=\"line\">    // This call may not return.</div><div class=\"line\">    performPendingShutdown();</div><div class=\"line\"></div><div class=\"line\">    // Initialize the system context.</div><div class=\"line\">    createSystemContext();</div><div class=\"line\"></div><div class=\"line\">    // Create the system service manager.</div><div class=\"line\">    mSystemServiceManager = new SystemServiceManager(mSystemContext);</div><div class=\"line\">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</div><div class=\"line\"></div><div class=\"line\">    // Start services.</div><div class=\"line\">    try &#123;</div><div class=\"line\">        startBootstrapServices();</div><div class=\"line\">        startCoreServices();</div><div class=\"line\">        startOtherServices();</div><div class=\"line\">    &#125; catch (Throwable ex) &#123;</div><div class=\"line\">        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</div><div class=\"line\">        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // For debug builds, log event loop stalls to dropbox for analysis.</div><div class=\"line\">    if (StrictMode.conditionallyEnableDebugLogging()) &#123;</div><div class=\"line\">        Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Loop forever.</div><div class=\"line\">    Looper.loop();</div><div class=\"line\">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要干了这些事：</p>\n<ul>\n<li>校验时间是否合法(1970)</li>\n<li>设置语言</li>\n<li>设置虚拟机库文件</li>\n<li>如果允许抽样分析器，则开启SamplingProfilerIntegration(抽样分析器)</li>\n<li>clearGrowthLimit 清除内存增长上限</li>\n<li>设置内存使用率，setTargetHeapUtilization</li>\n<li>加载android_servers库</li>\n<li>创建上下文，创建SystemServiceManager，添加到LocalServices</li>\n<li>startBootstrapServices 启动引导服务</li>\n<li>startCoreServices 启动核心服务</li>\n<li>startOtherServices 启动其他服务</li>\n</ul>\n<p>最后的启动服务 是核心，我们分别来看下。</p>\n<h3 id=\"SystemServer-startBootstrapServices\"><a href=\"#SystemServer-startBootstrapServices\" class=\"headerlink\" title=\"SystemServer#startBootstrapServices\"></a>SystemServer#startBootstrapServices</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void startBootstrapServices() &#123;</div><div class=\"line\">    // Wait for installd to finish starting up so that it has a chance to</div><div class=\"line\">    // create critical directories such as /data/user with the appropriate</div><div class=\"line\">    // permissions.  We need this to complete before we initialize other services.</div><div class=\"line\">    Installer installer = mSystemServiceManager.startService(Installer.class);</div><div class=\"line\"></div><div class=\"line\">    // Activity manager runs the show.</div><div class=\"line\">    mActivityManagerService = mSystemServiceManager.startService(</div><div class=\"line\">            ActivityManagerService.Lifecycle.class).getService();</div><div class=\"line\">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</div><div class=\"line\">    mActivityManagerService.setInstaller(installer);</div><div class=\"line\"></div><div class=\"line\">    // Power manager needs to be started early because other services need it.</div><div class=\"line\">    // Native daemons may be watching for it to be registered so it must be ready</div><div class=\"line\">    // to handle incoming binder calls immediately (including being able to verify</div><div class=\"line\">    // the permissions for those calls).</div><div class=\"line\">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</div><div class=\"line\"></div><div class=\"line\">    // Now that the power manager has been started, let the activity manager</div><div class=\"line\">    // initialize power management features.</div><div class=\"line\">    mActivityManagerService.initPowerManagement();</div><div class=\"line\"></div><div class=\"line\">    // Manages LEDs and display backlight so we need it to bring up the display.</div><div class=\"line\">    mSystemServiceManager.startService(LightsService.class);</div><div class=\"line\"></div><div class=\"line\">    // Display manager is needed to provide display metrics before package manager</div><div class=\"line\">    // starts up.</div><div class=\"line\">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</div><div class=\"line\"></div><div class=\"line\">    // We need the default display before we can initialize the package manager.</div><div class=\"line\">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</div><div class=\"line\"></div><div class=\"line\">    // Only run &quot;core&quot; apps if we&apos;re encrypting the device.</div><div class=\"line\">    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</div><div class=\"line\">    if (ENCRYPTING_STATE.equals(cryptState)) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</div><div class=\"line\">        mOnlyCore = true;</div><div class=\"line\">    &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</div><div class=\"line\">        mOnlyCore = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Start the package manager.</div><div class=\"line\">    Slog.i(TAG, &quot;Package Manager&quot;);</div><div class=\"line\">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</div><div class=\"line\">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</div><div class=\"line\">    mFirstBoot = mPackageManagerService.isFirstBoot();</div><div class=\"line\">    mPackageManager = mSystemContext.getPackageManager();</div><div class=\"line\"></div><div class=\"line\">    Slog.i(TAG, &quot;User Service&quot;);</div><div class=\"line\">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</div><div class=\"line\"></div><div class=\"line\">    // Initialize attribute cache used to cache resources from packages.</div><div class=\"line\">    AttributeCache.init(mSystemContext);</div><div class=\"line\"></div><div class=\"line\">    // Set up the Application instance for the system process and get started.</div><div class=\"line\">    mActivityManagerService.setSystemProcess();</div><div class=\"line\"></div><div class=\"line\">    // The sensor service needs access to package manager service, app ops</div><div class=\"line\">    // service, and permissions service, therefore we start it after them.</div><div class=\"line\">    startSensorService();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>启动Installer,用于应用程序安装，卸载，dex优化等等</li>\n<li>启动ActivityManagerService</li>\n<li>启动PowerManagerService</li>\n<li>启动LightsService</li>\n<li>启动DisplayManagerService</li>\n<li>启动PackageManagerService</li>\n<li>启动UserManagerService</li>\n<li>启动传感器服务(native)</li>\n</ul>\n<h3 id=\"SystemServer-startCoreServices\"><a href=\"#SystemServer-startCoreServices\" class=\"headerlink\" title=\"SystemServer#startCoreServices\"></a>SystemServer#startCoreServices</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void startCoreServices() &#123;</div><div class=\"line\">    // Tracks the battery level.  Requires LightService.</div><div class=\"line\">    mSystemServiceManager.startService(BatteryService.class);</div><div class=\"line\"></div><div class=\"line\">    // Tracks application usage stats.</div><div class=\"line\">    mSystemServiceManager.startService(UsageStatsService.class);</div><div class=\"line\">    mActivityManagerService.setUsageStatsManager(</div><div class=\"line\">            LocalServices.getService(UsageStatsManagerInternal.class));</div><div class=\"line\">    // Update after UsageStatsService is available, needed before performBootDexOpt.</div><div class=\"line\">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</div><div class=\"line\"></div><div class=\"line\">    // Tracks whether the updatable WebView is in a ready state and watches for update installs.</div><div class=\"line\">    mSystemServiceManager.startService(WebViewUpdateService.class);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样是启动几个核心的系统服务。</p>\n<h3 id=\"SystemServer-startOtherServices\"><a href=\"#SystemServer-startOtherServices\" class=\"headerlink\" title=\"SystemServer#startOtherServices\"></a>SystemServer#startOtherServices</h3><p>在这个方法中，同样启动了很多服务，不过，这里不仅仅有startService，也有ServiceManager.addService,不过这个是通过binder，像native注册的服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">case IServiceManager.ADD_SERVICE_TRANSACTION: &#123;</div><div class=\"line\">    data.enforceInterface(IServiceManager.descriptor);</div><div class=\"line\">    String name = data.readString();</div><div class=\"line\">    IBinder service = data.readStrongBinder();</div><div class=\"line\">    boolean allowIsolated = data.readInt() != 0;</div><div class=\"line\">    addService(name, service, allowIsolated);</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当启动注册完毕之后，会调用各个服务的systemReady方法。这里就不介绍了。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>从上一篇我们知道，在Zygote进程的启动过程中，通过startSystemServer方法，来启动Android中另外一个核心进程SystemServer进程。那么，就来看下SystemServer进程的一些东西。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"ZygoteInit-startSystemServer\"><a href=\"#ZygoteInit-startSystemServer\" class=\"headerlink\" title=\"ZygoteInit#startSystemServer\"></a>ZygoteInit#startSystemServer</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 省去一部分参数代码</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs = null;</div><div class=\"line\"></div><div class=\"line\">        int pid;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            parsedArgs = new ZygoteConnection.Arguments(args);</div><div class=\"line\">            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">            /* Request to fork the system server process */</div><div class=\"line\">            pid = Zygote.forkSystemServer(</div><div class=\"line\">                    parsedArgs.uid, parsedArgs.gid,</div><div class=\"line\">                    parsedArgs.gids,</div><div class=\"line\">                    parsedArgs.debugFlags,</div><div class=\"line\">                    null,</div><div class=\"line\">                    parsedArgs.permittedCapabilities,</div><div class=\"line\">                    parsedArgs.effectiveCapabilities);</div><div class=\"line\">        &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(ex);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /* For child process */</div><div class=\"line\">        if (pid == 0) &#123;</div><div class=\"line\">            if (hasSecondZygote(abiList)) &#123;</div><div class=\"line\">                waitForSecondaryZygote(socketName);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handleSystemServerProcess(parsedArgs);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return true;</div></pre></td></tr></table></figure>\n<ul>\n<li>fork进程(和以前进程启动类似)</li>\n<li>handleSystemServerProcess来处理SystemServer进程</li>\n</ul>\n<h3 id=\"ZygoteInit-handleSystemServerProcess\"><a href=\"#ZygoteInit-handleSystemServerProcess\" class=\"headerlink\" title=\"ZygoteInit#handleSystemServerProcess\"></a>ZygoteInit#handleSystemServerProcess</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void handleSystemServerProcess(</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">    closeServerSocket();</div><div class=\"line\"></div><div class=\"line\">    // set umask to 0077 so new files and directories will default to owner-only permissions.</div><div class=\"line\">    Os.umask(S_IRWXG | S_IRWXO);</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.niceName != null) &#123;</div><div class=\"line\">        Process.setArgV0(parsedArgs.niceName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</div><div class=\"line\">    if (systemServerClasspath != null) &#123;</div><div class=\"line\">        performSystemServerDexOpt(systemServerClasspath);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">        String[] args = parsedArgs.remainingArgs;</div><div class=\"line\">        // If we have a non-null system server class path, we&apos;ll have to duplicate the</div><div class=\"line\">        // existing arguments and append the classpath to it. ART will handle the classpath</div><div class=\"line\">        // correctly when we exec a new process.</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            String[] amendedArgs = new String[args.length + 2];</div><div class=\"line\">            amendedArgs[0] = &quot;-cp&quot;;</div><div class=\"line\">            amendedArgs[1] = systemServerClasspath;</div><div class=\"line\">            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">                VMRuntime.getCurrentInstructionSet(), null, args);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ClassLoader cl = null;</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</div><div class=\"line\">            Thread.currentThread().setContextClassLoader(cl);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * Pass the remaining arguments to SystemServer.</div><div class=\"line\">         */</div><div class=\"line\">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* should never reach here */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过umask设置创建文件的默认权限</li>\n<li>设置进程的nicename</li>\n<li>获取SYSTEMSERVERCLASSPATH环境变量值(一系列jar)，如果需要，进行dex优化</li>\n<li>在这里，invokeWith为null，所以会通过RuntimeInit.zygoteInit去启动</li>\n</ul>\n<p>RuntimeInit.zygoteInit中调用applicationInit，调用invokeStaticMain，然后就会调用SystemServer的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\">    new SystemServer().run();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在SystemServer的构造函数中，获取mFactoryTestMode值，我们的重点在run方法。</p>\n<h3 id=\"SystemServer-run\"><a href=\"#SystemServer-run\" class=\"headerlink\" title=\"SystemServer#run\"></a>SystemServer#run</h3><p>run方法的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void run() &#123;</div><div class=\"line\">    // If a device&apos;s clock is before 1970 (before 0), a lot of</div><div class=\"line\">    // APIs crash dealing with negative numbers, notably</div><div class=\"line\">    // java.io.File#setLastModified, so instead we fake it and</div><div class=\"line\">    // hope that time from cell towers or NTP fixes it shortly.</div><div class=\"line\">    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</div><div class=\"line\">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If the system has &quot;persist.sys.language&quot; and friends set, replace them with</div><div class=\"line\">    // &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated</div><div class=\"line\">    // using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by</div><div class=\"line\">    // AndroidRuntime using the same set of system properties, but only the system_server</div><div class=\"line\">    // and system apps are allowed to set them.</div><div class=\"line\">    //</div><div class=\"line\">    // NOTE: Most changes made here will need an equivalent change to</div><div class=\"line\">    // core/jni/AndroidRuntime.cpp</div><div class=\"line\">    if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;</div><div class=\"line\">        final String languageTag = Locale.getDefault().toLanguageTag();</div><div class=\"line\"></div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);</div><div class=\"line\">        SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Here we go!</div><div class=\"line\">    Slog.i(TAG, &quot;Entered the Android system server!&quot;);</div><div class=\"line\">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());</div><div class=\"line\"></div><div class=\"line\">    // In case the runtime switched since last boot (such as when</div><div class=\"line\">    // the old runtime was removed in an OTA), set the system</div><div class=\"line\">    // property so that it is in sync. We can&apos;t do this in</div><div class=\"line\">    // libnativehelper&apos;s JniInvocation::Init code where we already</div><div class=\"line\">    // had to fallback to a different runtime because it is</div><div class=\"line\">    // running as root and we need to be the system user to set</div><div class=\"line\">    // the property. http://b/11463182</div><div class=\"line\">    SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());</div><div class=\"line\"></div><div class=\"line\">    // Enable the sampling profiler.</div><div class=\"line\">    if (SamplingProfilerIntegration.isEnabled()) &#123;</div><div class=\"line\">        SamplingProfilerIntegration.start();</div><div class=\"line\">        mProfilerSnapshotTimer = new Timer();</div><div class=\"line\">        mProfilerSnapshotTimer.schedule(new TimerTask() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Mmmmmm... more memory!</div><div class=\"line\">    VMRuntime.getRuntime().clearGrowthLimit();</div><div class=\"line\"></div><div class=\"line\">    // The system server has to run all of the time, so it needs to be</div><div class=\"line\">    // as efficient as possible with its memory usage.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);</div><div class=\"line\"></div><div class=\"line\">    // Some devices rely on runtime fingerprint generation, so make sure</div><div class=\"line\">    // we&apos;ve defined it before booting further.</div><div class=\"line\">    Build.ensureFingerprintProperty();</div><div class=\"line\"></div><div class=\"line\">    // Within the system server, it is an error to access Environment paths without</div><div class=\"line\">    // explicitly specifying a user.</div><div class=\"line\">    Environment.setUserRequired(true);</div><div class=\"line\"></div><div class=\"line\">    // Ensure binder calls into the system always run at foreground priority.</div><div class=\"line\">    BinderInternal.disableBackgroundScheduling(true);</div><div class=\"line\"></div><div class=\"line\">    // Prepare the main looper thread (this thread).</div><div class=\"line\">    android.os.Process.setThreadPriority(</div><div class=\"line\">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</div><div class=\"line\">    android.os.Process.setCanSelfBackground(false);</div><div class=\"line\">    Looper.prepareMainLooper();</div><div class=\"line\"></div><div class=\"line\">    // Initialize native services.</div><div class=\"line\">    System.loadLibrary(&quot;android_servers&quot;);</div><div class=\"line\"></div><div class=\"line\">    // Check whether we failed to shut down last time we tried.</div><div class=\"line\">    // This call may not return.</div><div class=\"line\">    performPendingShutdown();</div><div class=\"line\"></div><div class=\"line\">    // Initialize the system context.</div><div class=\"line\">    createSystemContext();</div><div class=\"line\"></div><div class=\"line\">    // Create the system service manager.</div><div class=\"line\">    mSystemServiceManager = new SystemServiceManager(mSystemContext);</div><div class=\"line\">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</div><div class=\"line\"></div><div class=\"line\">    // Start services.</div><div class=\"line\">    try &#123;</div><div class=\"line\">        startBootstrapServices();</div><div class=\"line\">        startCoreServices();</div><div class=\"line\">        startOtherServices();</div><div class=\"line\">    &#125; catch (Throwable ex) &#123;</div><div class=\"line\">        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</div><div class=\"line\">        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // For debug builds, log event loop stalls to dropbox for analysis.</div><div class=\"line\">    if (StrictMode.conditionallyEnableDebugLogging()) &#123;</div><div class=\"line\">        Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Loop forever.</div><div class=\"line\">    Looper.loop();</div><div class=\"line\">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要干了这些事：</p>\n<ul>\n<li>校验时间是否合法(1970)</li>\n<li>设置语言</li>\n<li>设置虚拟机库文件</li>\n<li>如果允许抽样分析器，则开启SamplingProfilerIntegration(抽样分析器)</li>\n<li>clearGrowthLimit 清除内存增长上限</li>\n<li>设置内存使用率，setTargetHeapUtilization</li>\n<li>加载android_servers库</li>\n<li>创建上下文，创建SystemServiceManager，添加到LocalServices</li>\n<li>startBootstrapServices 启动引导服务</li>\n<li>startCoreServices 启动核心服务</li>\n<li>startOtherServices 启动其他服务</li>\n</ul>\n<p>最后的启动服务 是核心，我们分别来看下。</p>\n<h3 id=\"SystemServer-startBootstrapServices\"><a href=\"#SystemServer-startBootstrapServices\" class=\"headerlink\" title=\"SystemServer#startBootstrapServices\"></a>SystemServer#startBootstrapServices</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void startBootstrapServices() &#123;</div><div class=\"line\">    // Wait for installd to finish starting up so that it has a chance to</div><div class=\"line\">    // create critical directories such as /data/user with the appropriate</div><div class=\"line\">    // permissions.  We need this to complete before we initialize other services.</div><div class=\"line\">    Installer installer = mSystemServiceManager.startService(Installer.class);</div><div class=\"line\"></div><div class=\"line\">    // Activity manager runs the show.</div><div class=\"line\">    mActivityManagerService = mSystemServiceManager.startService(</div><div class=\"line\">            ActivityManagerService.Lifecycle.class).getService();</div><div class=\"line\">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</div><div class=\"line\">    mActivityManagerService.setInstaller(installer);</div><div class=\"line\"></div><div class=\"line\">    // Power manager needs to be started early because other services need it.</div><div class=\"line\">    // Native daemons may be watching for it to be registered so it must be ready</div><div class=\"line\">    // to handle incoming binder calls immediately (including being able to verify</div><div class=\"line\">    // the permissions for those calls).</div><div class=\"line\">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</div><div class=\"line\"></div><div class=\"line\">    // Now that the power manager has been started, let the activity manager</div><div class=\"line\">    // initialize power management features.</div><div class=\"line\">    mActivityManagerService.initPowerManagement();</div><div class=\"line\"></div><div class=\"line\">    // Manages LEDs and display backlight so we need it to bring up the display.</div><div class=\"line\">    mSystemServiceManager.startService(LightsService.class);</div><div class=\"line\"></div><div class=\"line\">    // Display manager is needed to provide display metrics before package manager</div><div class=\"line\">    // starts up.</div><div class=\"line\">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</div><div class=\"line\"></div><div class=\"line\">    // We need the default display before we can initialize the package manager.</div><div class=\"line\">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</div><div class=\"line\"></div><div class=\"line\">    // Only run &quot;core&quot; apps if we&apos;re encrypting the device.</div><div class=\"line\">    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</div><div class=\"line\">    if (ENCRYPTING_STATE.equals(cryptState)) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</div><div class=\"line\">        mOnlyCore = true;</div><div class=\"line\">    &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</div><div class=\"line\">        Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</div><div class=\"line\">        mOnlyCore = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Start the package manager.</div><div class=\"line\">    Slog.i(TAG, &quot;Package Manager&quot;);</div><div class=\"line\">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</div><div class=\"line\">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</div><div class=\"line\">    mFirstBoot = mPackageManagerService.isFirstBoot();</div><div class=\"line\">    mPackageManager = mSystemContext.getPackageManager();</div><div class=\"line\"></div><div class=\"line\">    Slog.i(TAG, &quot;User Service&quot;);</div><div class=\"line\">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</div><div class=\"line\"></div><div class=\"line\">    // Initialize attribute cache used to cache resources from packages.</div><div class=\"line\">    AttributeCache.init(mSystemContext);</div><div class=\"line\"></div><div class=\"line\">    // Set up the Application instance for the system process and get started.</div><div class=\"line\">    mActivityManagerService.setSystemProcess();</div><div class=\"line\"></div><div class=\"line\">    // The sensor service needs access to package manager service, app ops</div><div class=\"line\">    // service, and permissions service, therefore we start it after them.</div><div class=\"line\">    startSensorService();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>启动Installer,用于应用程序安装，卸载，dex优化等等</li>\n<li>启动ActivityManagerService</li>\n<li>启动PowerManagerService</li>\n<li>启动LightsService</li>\n<li>启动DisplayManagerService</li>\n<li>启动PackageManagerService</li>\n<li>启动UserManagerService</li>\n<li>启动传感器服务(native)</li>\n</ul>\n<h3 id=\"SystemServer-startCoreServices\"><a href=\"#SystemServer-startCoreServices\" class=\"headerlink\" title=\"SystemServer#startCoreServices\"></a>SystemServer#startCoreServices</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void startCoreServices() &#123;</div><div class=\"line\">    // Tracks the battery level.  Requires LightService.</div><div class=\"line\">    mSystemServiceManager.startService(BatteryService.class);</div><div class=\"line\"></div><div class=\"line\">    // Tracks application usage stats.</div><div class=\"line\">    mSystemServiceManager.startService(UsageStatsService.class);</div><div class=\"line\">    mActivityManagerService.setUsageStatsManager(</div><div class=\"line\">            LocalServices.getService(UsageStatsManagerInternal.class));</div><div class=\"line\">    // Update after UsageStatsService is available, needed before performBootDexOpt.</div><div class=\"line\">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</div><div class=\"line\"></div><div class=\"line\">    // Tracks whether the updatable WebView is in a ready state and watches for update installs.</div><div class=\"line\">    mSystemServiceManager.startService(WebViewUpdateService.class);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样是启动几个核心的系统服务。</p>\n<h3 id=\"SystemServer-startOtherServices\"><a href=\"#SystemServer-startOtherServices\" class=\"headerlink\" title=\"SystemServer#startOtherServices\"></a>SystemServer#startOtherServices</h3><p>在这个方法中，同样启动了很多服务，不过，这里不仅仅有startService，也有ServiceManager.addService,不过这个是通过binder，像native注册的服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">case IServiceManager.ADD_SERVICE_TRANSACTION: &#123;</div><div class=\"line\">    data.enforceInterface(IServiceManager.descriptor);</div><div class=\"line\">    String name = data.readString();</div><div class=\"line\">    IBinder service = data.readStrongBinder();</div><div class=\"line\">    boolean allowIsolated = data.readInt() != 0;</div><div class=\"line\">    addService(name, service, allowIsolated);</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当启动注册完毕之后，会调用各个服务的systemReady方法。这里就不介绍了。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco内存管理","date":"2016-12-14T06:24:25.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. Fresco中的内存管理模块\n\nfresco中的内存分为两个部分，\n\n* 解码的\n\t* 在5.0之上存在java堆中\n\t* 在5.0之下位于Ashmem中 \t\n* 未解码的\n\t* 位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。\n\t\n而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2. 匿名共享内存部分\n\n这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。\n\n光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。\n\n\n```\nAndroidBitmap_lockPixels\nAndroidBitmap_unlockPixels\n\n```\n\npin和release实现的部分在Bitmaps.c部分。\n\n\n### 3. 从NetworkFetchProducer开始谈 native heap的管理\n\n\nNetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：\n\n```\n  private void onResponse(\n      FetchState fetchState,\n      InputStream responseData,\n      int responseContentLength)\n      throws IOException {\n    final PooledByteBufferOutputStream pooledOutputStream;\n    if (responseContentLength > 0) {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);\n    } else {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();\n    }\n    final byte[] ioArray = mByteArrayPool.get(READ_SIZE);\n    try {\n      int length;\n      while ((length = responseData.read(ioArray)) >= 0) {\n        if (length > 0) {\n          pooledOutputStream.write(ioArray, 0, length);\n          maybeHandleIntermediateResult(pooledOutputStream, fetchState);\n          float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);\n          fetchState.getConsumer().onProgressUpdate(progress);\n        }\n      }\n      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());\n      handleFinalResult(pooledOutputStream, fetchState);\n    } finally {\n      mByteArrayPool.release(ioArray);\n      pooledOutputStream.close();\n    }\n  }\n```\n\n* 通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流\n* 将内容输入\n* 通知上层处理\n\n我们分段来看\n\n#### 3.1 构造输出流\n\nPooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。\n\n这样就构造出一个输出流。\n\n#### 3.2 输出数据\n\n上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。\n\n\n```\n    ensureValid();\n    realloc(mCount + count);\n    mBufRef.get().write(mCount, buffer, offset, count);\n    mCount += count;\n```\n\n* 校验有效性\n* 重新申请内存\n* 将原来来写入到内存中的数据加上现在数据，复制到新的native内存中\n\n```\n    NativeMemoryChunk newbuf = mPool.get(newLength);\n    mBufRef.get().copy(0, newbuf, 0, mCount);\n    mBufRef.close();\n    mBufRef = CloseableReference.of(newbuf, mPool);\n```\n\nmPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。\n\n然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。\n\n\n最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。\n\n### 4. 对应的native操作。\n\n上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。\n\n![](/images/fresco/fresco_4.png)\n\n下面就来对其中一些进行说明。\n\n#### 4.1 NativeMemoryChunk_nativeAllocate\n\n这个是用来申请内存的。\n\n```\nstatic jlong NativeMemoryChunk_nativeAllocate(\n    JNIEnv* env,\n    jclass clzz,\n    jint size) {\n  UNUSED(clzz);\n  void* pointer = malloc(size);\n  if (!pointer) {\n    (*env)->ThrowNew(env, jRuntimeException_class, \"could not allocate memory\");\n    return 0;\n  }\n  return PTR_TO_JLONG(pointer);\n}\n```\n\n* 通过malloc申请size大小的一块内存\n* 通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。\n\n因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型\n\n#### 4.2 NativeMemoryChunk_nativeMemcpy\n\n这个方法很简单。\n\n```\nmemcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);\n```\n* 这里的参数，分别对应java中的两个NativeMemoryChunk，和大小\n* 首先用JLONG_TO_PTR这个宏，将long专为指针\n* 用memcpy函数，进行复制操作，\n\n\n#### 4.3 NativeMemoryChunk_nativeFree\n\n\n```\nfree(JLONG_TO_PTR(lpointer));\n```\n\n调用free函数将指针对应位置的内存释放掉。\n\n其他的几个函数 这里就不说了。\n\n\n\n需要注意的是，native内存管理实对应NativeMemoryChunkPool。\n\n\n### 5 以native内存为例，了解fresco内存池\n\n我们需要先来了解几个东西。\n\n* 池 负责存储某类型的数据\n* 桶 将池分为若干大小的块，每一个块就是一个桶\n* 每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。\n\n那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。\n\n![](/images/fresco/fresco_5.png)\n\n\n了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。\n\n#### 5.1 BasePool#get\n\n这个方法比较长，分段来看。\n\n```\n    int bucketedSize = getBucketedSize(size);\n    int sizeInBytes = -1;\n\n    synchronized (this) {\n      Bucket<V> bucket = getBucket(bucketedSize);\n\n      if (bucket != null) {\n        // find an existing value that we can reuse\n        V value = bucket.get();\n        if (value != null) {\n          Preconditions.checkState(mInUseValues.add(value));\n\n          // It is possible that we got a 'larger' value than we asked for.\n          // lets recompute size in bytes here\n          bucketedSize = getBucketedSizeForValue(value);\n          sizeInBytes = getSizeInBytes(bucketedSize);\n          mUsed.increment(sizeInBytes);\n          mFree.decrement(sizeInBytes);\n          mPoolStatsTracker.onValueReuse(sizeInBytes);\n          logStats();\n          if (FLog.isLoggable(FLog.VERBOSE)) {\n            FLog.v(\n                TAG,\n                \"get (reuse) (object, size) = (%x, %s)\",\n                System.identityHashCode(value),\n                bucketedSize);\n          }\n          return value;\n        }\n        // fall through\n      }\n      // check to see if we can allocate a value of the given size without exceeding the hard cap\n      sizeInBytes = getSizeInBytes(bucketedSize);\n      if (!canAllocate(sizeInBytes)) {\n        throw new PoolSizeViolationException(\n            mPoolParams.maxSizeHardCap,\n            mUsed.mNumBytes,\n            mFree.mNumBytes,\n            sizeInBytes);\n      }\n\n      // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes\n      mUsed.increment(sizeInBytes);\n      if (bucket != null) {\n        bucket.incrementInUseCount();\n      }\n    }\n```\n\n* 首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小\n* 通过getBucket方法获取对应桶容量的桶\n\t* 如果没有找到，就创建一个新的桶 \n* 如果桶不为null\n\t* 通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能\n\t* Counter 纪录使用容量和空闲容量\n\t* 状态追踪以及其他操作\n\t* 返回\n\n```\n    V value = null;\n    try {\n      // allocate the value outside the synchronized block, because it can be pretty expensive\n      // we could have done the allocation inside the synchronized block,\n      // but that would have blocked out other operations on the pool\n      value = alloc(bucketedSize);\n    } catch (Throwable e) {\n      // Assumption we made previously is not valid - allocation failed. We need to fix internal\n      // counters.\n      synchronized (this) {\n        mUsed.decrement(sizeInBytes);\n        Bucket<V> bucket = getBucket(bucketedSize);\n        if (bucket != null) {\n          bucket.decrementInUseCount();\n        }\n      }\n      Throwables.propagateIfPossible(e);\n    }\n        synchronized(this) {\n      Preconditions.checkState(mInUseValues.add(value));\n      // If we're over the pool's max size, try to trim the pool appropriately\n      trimToSoftCap();\n      mPoolStatsTracker.onAlloc(sizeInBytes);\n      logStats();\n      if (FLog.isLoggable(FLog.VERBOSE)) {\n        FLog.v(\n            TAG,\n            \"get (alloc) (object, size) = (%x, %s)\",\n            System.identityHashCode(value),\n            bucketedSize);\n      }\n    }\n\n    return value;\n```\n\n* 没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有\n* 如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。\n\n#### 5.2 BasePool#release\n\n这个方法是我们主动释放一个对象所占用的内存。\n\n实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","source":"_posts/fresco内存管理.md","raw":"---\ntitle: fresco内存管理\ndate: 2016-12-14 14:24:25\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. Fresco中的内存管理模块\n\nfresco中的内存分为两个部分，\n\n* 解码的\n\t* 在5.0之上存在java堆中\n\t* 在5.0之下位于Ashmem中 \t\n* 未解码的\n\t* 位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。\n\t\n而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n### 2. 匿名共享内存部分\n\n这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。\n\n光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。\n\n\n```\nAndroidBitmap_lockPixels\nAndroidBitmap_unlockPixels\n\n```\n\npin和release实现的部分在Bitmaps.c部分。\n\n\n### 3. 从NetworkFetchProducer开始谈 native heap的管理\n\n\nNetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：\n\n```\n  private void onResponse(\n      FetchState fetchState,\n      InputStream responseData,\n      int responseContentLength)\n      throws IOException {\n    final PooledByteBufferOutputStream pooledOutputStream;\n    if (responseContentLength > 0) {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);\n    } else {\n      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();\n    }\n    final byte[] ioArray = mByteArrayPool.get(READ_SIZE);\n    try {\n      int length;\n      while ((length = responseData.read(ioArray)) >= 0) {\n        if (length > 0) {\n          pooledOutputStream.write(ioArray, 0, length);\n          maybeHandleIntermediateResult(pooledOutputStream, fetchState);\n          float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);\n          fetchState.getConsumer().onProgressUpdate(progress);\n        }\n      }\n      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());\n      handleFinalResult(pooledOutputStream, fetchState);\n    } finally {\n      mByteArrayPool.release(ioArray);\n      pooledOutputStream.close();\n    }\n  }\n```\n\n* 通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流\n* 将内容输入\n* 通知上层处理\n\n我们分段来看\n\n#### 3.1 构造输出流\n\nPooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。\n\n这样就构造出一个输出流。\n\n#### 3.2 输出数据\n\n上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。\n\n\n```\n    ensureValid();\n    realloc(mCount + count);\n    mBufRef.get().write(mCount, buffer, offset, count);\n    mCount += count;\n```\n\n* 校验有效性\n* 重新申请内存\n* 将原来来写入到内存中的数据加上现在数据，复制到新的native内存中\n\n```\n    NativeMemoryChunk newbuf = mPool.get(newLength);\n    mBufRef.get().copy(0, newbuf, 0, mCount);\n    mBufRef.close();\n    mBufRef = CloseableReference.of(newbuf, mPool);\n```\n\nmPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。\n\n然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。\n\n\n最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。\n\n### 4. 对应的native操作。\n\n上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。\n\n![](/images/fresco/fresco_4.png)\n\n下面就来对其中一些进行说明。\n\n#### 4.1 NativeMemoryChunk_nativeAllocate\n\n这个是用来申请内存的。\n\n```\nstatic jlong NativeMemoryChunk_nativeAllocate(\n    JNIEnv* env,\n    jclass clzz,\n    jint size) {\n  UNUSED(clzz);\n  void* pointer = malloc(size);\n  if (!pointer) {\n    (*env)->ThrowNew(env, jRuntimeException_class, \"could not allocate memory\");\n    return 0;\n  }\n  return PTR_TO_JLONG(pointer);\n}\n```\n\n* 通过malloc申请size大小的一块内存\n* 通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。\n\n因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型\n\n#### 4.2 NativeMemoryChunk_nativeMemcpy\n\n这个方法很简单。\n\n```\nmemcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);\n```\n* 这里的参数，分别对应java中的两个NativeMemoryChunk，和大小\n* 首先用JLONG_TO_PTR这个宏，将long专为指针\n* 用memcpy函数，进行复制操作，\n\n\n#### 4.3 NativeMemoryChunk_nativeFree\n\n\n```\nfree(JLONG_TO_PTR(lpointer));\n```\n\n调用free函数将指针对应位置的内存释放掉。\n\n其他的几个函数 这里就不说了。\n\n\n\n需要注意的是，native内存管理实对应NativeMemoryChunkPool。\n\n\n### 5 以native内存为例，了解fresco内存池\n\n我们需要先来了解几个东西。\n\n* 池 负责存储某类型的数据\n* 桶 将池分为若干大小的块，每一个块就是一个桶\n* 每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。\n\n那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。\n\n![](/images/fresco/fresco_5.png)\n\n\n了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。\n\n#### 5.1 BasePool#get\n\n这个方法比较长，分段来看。\n\n```\n    int bucketedSize = getBucketedSize(size);\n    int sizeInBytes = -1;\n\n    synchronized (this) {\n      Bucket<V> bucket = getBucket(bucketedSize);\n\n      if (bucket != null) {\n        // find an existing value that we can reuse\n        V value = bucket.get();\n        if (value != null) {\n          Preconditions.checkState(mInUseValues.add(value));\n\n          // It is possible that we got a 'larger' value than we asked for.\n          // lets recompute size in bytes here\n          bucketedSize = getBucketedSizeForValue(value);\n          sizeInBytes = getSizeInBytes(bucketedSize);\n          mUsed.increment(sizeInBytes);\n          mFree.decrement(sizeInBytes);\n          mPoolStatsTracker.onValueReuse(sizeInBytes);\n          logStats();\n          if (FLog.isLoggable(FLog.VERBOSE)) {\n            FLog.v(\n                TAG,\n                \"get (reuse) (object, size) = (%x, %s)\",\n                System.identityHashCode(value),\n                bucketedSize);\n          }\n          return value;\n        }\n        // fall through\n      }\n      // check to see if we can allocate a value of the given size without exceeding the hard cap\n      sizeInBytes = getSizeInBytes(bucketedSize);\n      if (!canAllocate(sizeInBytes)) {\n        throw new PoolSizeViolationException(\n            mPoolParams.maxSizeHardCap,\n            mUsed.mNumBytes,\n            mFree.mNumBytes,\n            sizeInBytes);\n      }\n\n      // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes\n      mUsed.increment(sizeInBytes);\n      if (bucket != null) {\n        bucket.incrementInUseCount();\n      }\n    }\n```\n\n* 首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小\n* 通过getBucket方法获取对应桶容量的桶\n\t* 如果没有找到，就创建一个新的桶 \n* 如果桶不为null\n\t* 通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能\n\t* Counter 纪录使用容量和空闲容量\n\t* 状态追踪以及其他操作\n\t* 返回\n\n```\n    V value = null;\n    try {\n      // allocate the value outside the synchronized block, because it can be pretty expensive\n      // we could have done the allocation inside the synchronized block,\n      // but that would have blocked out other operations on the pool\n      value = alloc(bucketedSize);\n    } catch (Throwable e) {\n      // Assumption we made previously is not valid - allocation failed. We need to fix internal\n      // counters.\n      synchronized (this) {\n        mUsed.decrement(sizeInBytes);\n        Bucket<V> bucket = getBucket(bucketedSize);\n        if (bucket != null) {\n          bucket.decrementInUseCount();\n        }\n      }\n      Throwables.propagateIfPossible(e);\n    }\n        synchronized(this) {\n      Preconditions.checkState(mInUseValues.add(value));\n      // If we're over the pool's max size, try to trim the pool appropriately\n      trimToSoftCap();\n      mPoolStatsTracker.onAlloc(sizeInBytes);\n      logStats();\n      if (FLog.isLoggable(FLog.VERBOSE)) {\n        FLog.v(\n            TAG,\n            \"get (alloc) (object, size) = (%x, %s)\",\n            System.identityHashCode(value),\n            bucketedSize);\n      }\n    }\n\n    return value;\n```\n\n* 没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有\n* 如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。\n\n#### 5.2 BasePool#release\n\n这个方法是我们主动释放一个对象所占用的内存。\n\n实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n","slug":"fresco内存管理","published":1,"updated":"2017-01-07T06:58:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2f001ihws6zszfl4kb","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-Fresco中的内存管理模块\"><a href=\"#1-Fresco中的内存管理模块\" class=\"headerlink\" title=\"1. Fresco中的内存管理模块\"></a>1. Fresco中的内存管理模块</h3><p>fresco中的内存分为两个部分，</p>\n<ul>\n<li>解码的<ul>\n<li>在5.0之上存在java堆中</li>\n<li>在5.0之下位于Ashmem中     </li>\n</ul>\n</li>\n<li>未解码的<ul>\n<li>位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。</li>\n</ul>\n</li>\n</ul>\n<p>而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n\n<h3 id=\"2-匿名共享内存部分\"><a href=\"#2-匿名共享内存部分\" class=\"headerlink\" title=\"2. 匿名共享内存部分\"></a>2. 匿名共享内存部分</h3><p>这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。</p>\n<p>光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AndroidBitmap_lockPixels</div><div class=\"line\">AndroidBitmap_unlockPixels</div></pre></td></tr></table></figure>\n<p>pin和release实现的部分在Bitmaps.c部分。</p>\n<h3 id=\"3-从NetworkFetchProducer开始谈-native-heap的管理\"><a href=\"#3-从NetworkFetchProducer开始谈-native-heap的管理\" class=\"headerlink\" title=\"3. 从NetworkFetchProducer开始谈 native heap的管理\"></a>3. 从NetworkFetchProducer开始谈 native heap的管理</h3><p>NetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onResponse(</div><div class=\"line\">    FetchState fetchState,</div><div class=\"line\">    InputStream responseData,</div><div class=\"line\">    int responseContentLength)</div><div class=\"line\">    throws IOException &#123;</div><div class=\"line\">  final PooledByteBufferOutputStream pooledOutputStream;</div><div class=\"line\">  if (responseContentLength &gt; 0) &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream();</div><div class=\"line\">  &#125;</div><div class=\"line\">  final byte[] ioArray = mByteArrayPool.get(READ_SIZE);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    int length;</div><div class=\"line\">    while ((length = responseData.read(ioArray)) &gt;= 0) &#123;</div><div class=\"line\">      if (length &gt; 0) &#123;</div><div class=\"line\">        pooledOutputStream.write(ioArray, 0, length);</div><div class=\"line\">        maybeHandleIntermediateResult(pooledOutputStream, fetchState);</div><div class=\"line\">        float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);</div><div class=\"line\">        fetchState.getConsumer().onProgressUpdate(progress);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());</div><div class=\"line\">    handleFinalResult(pooledOutputStream, fetchState);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    mByteArrayPool.release(ioArray);</div><div class=\"line\">    pooledOutputStream.close();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流</li>\n<li>将内容输入</li>\n<li>通知上层处理</li>\n</ul>\n<p>我们分段来看</p>\n<h4 id=\"3-1-构造输出流\"><a href=\"#3-1-构造输出流\" class=\"headerlink\" title=\"3.1 构造输出流\"></a>3.1 构造输出流</h4><p>PooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。</p>\n<p>这样就构造出一个输出流。</p>\n<h4 id=\"3-2-输出数据\"><a href=\"#3-2-输出数据\" class=\"headerlink\" title=\"3.2 输出数据\"></a>3.2 输出数据</h4><p>上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ensureValid();</div><div class=\"line\">realloc(mCount + count);</div><div class=\"line\">mBufRef.get().write(mCount, buffer, offset, count);</div><div class=\"line\">mCount += count;</div></pre></td></tr></table></figure>\n<ul>\n<li>校验有效性</li>\n<li>重新申请内存</li>\n<li>将原来来写入到内存中的数据加上现在数据，复制到新的native内存中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMemoryChunk newbuf = mPool.get(newLength);</div><div class=\"line\">mBufRef.get().copy(0, newbuf, 0, mCount);</div><div class=\"line\">mBufRef.close();</div><div class=\"line\">mBufRef = CloseableReference.of(newbuf, mPool);</div></pre></td></tr></table></figure>\n<p>mPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。</p>\n<p>然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。</p>\n<p>最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。</p>\n<h3 id=\"4-对应的native操作。\"><a href=\"#4-对应的native操作。\" class=\"headerlink\" title=\"4. 对应的native操作。\"></a>4. 对应的native操作。</h3><p>上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。</p>\n<p><img src=\"/images/fresco/fresco_4.png\" alt=\"\"></p>\n<p>下面就来对其中一些进行说明。</p>\n<h4 id=\"4-1-NativeMemoryChunk-nativeAllocate\"><a href=\"#4-1-NativeMemoryChunk-nativeAllocate\" class=\"headerlink\" title=\"4.1 NativeMemoryChunk_nativeAllocate\"></a>4.1 NativeMemoryChunk_nativeAllocate</h4><p>这个是用来申请内存的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong NativeMemoryChunk_nativeAllocate(</div><div class=\"line\">    JNIEnv* env,</div><div class=\"line\">    jclass clzz,</div><div class=\"line\">    jint size) &#123;</div><div class=\"line\">  UNUSED(clzz);</div><div class=\"line\">  void* pointer = malloc(size);</div><div class=\"line\">  if (!pointer) &#123;</div><div class=\"line\">    (*env)-&gt;ThrowNew(env, jRuntimeException_class, &quot;could not allocate memory&quot;);</div><div class=\"line\">    return 0;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return PTR_TO_JLONG(pointer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过malloc申请size大小的一块内存</li>\n<li>通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。</li>\n</ul>\n<p>因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型</p>\n<h4 id=\"4-2-NativeMemoryChunk-nativeMemcpy\"><a href=\"#4-2-NativeMemoryChunk-nativeMemcpy\" class=\"headerlink\" title=\"4.2 NativeMemoryChunk_nativeMemcpy\"></a>4.2 NativeMemoryChunk_nativeMemcpy</h4><p>这个方法很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">memcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);</div></pre></td></tr></table></figure>\n<ul>\n<li>这里的参数，分别对应java中的两个NativeMemoryChunk，和大小</li>\n<li>首先用JLONG_TO_PTR这个宏，将long专为指针</li>\n<li>用memcpy函数，进行复制操作，</li>\n</ul>\n<h4 id=\"4-3-NativeMemoryChunk-nativeFree\"><a href=\"#4-3-NativeMemoryChunk-nativeFree\" class=\"headerlink\" title=\"4.3 NativeMemoryChunk_nativeFree\"></a>4.3 NativeMemoryChunk_nativeFree</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">free(JLONG_TO_PTR(lpointer));</div></pre></td></tr></table></figure>\n<p>调用free函数将指针对应位置的内存释放掉。</p>\n<p>其他的几个函数 这里就不说了。</p>\n<p>需要注意的是，native内存管理实对应NativeMemoryChunkPool。</p>\n<h3 id=\"5-以native内存为例，了解fresco内存池\"><a href=\"#5-以native内存为例，了解fresco内存池\" class=\"headerlink\" title=\"5 以native内存为例，了解fresco内存池\"></a>5 以native内存为例，了解fresco内存池</h3><p>我们需要先来了解几个东西。</p>\n<ul>\n<li>池 负责存储某类型的数据</li>\n<li>桶 将池分为若干大小的块，每一个块就是一个桶</li>\n<li>每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。</li>\n</ul>\n<p>那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。</p>\n<p><img src=\"/images/fresco/fresco_5.png\" alt=\"\"></p>\n<p>了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。</p>\n<h4 id=\"5-1-BasePool-get\"><a href=\"#5-1-BasePool-get\" class=\"headerlink\" title=\"5.1 BasePool#get\"></a>5.1 BasePool#get</h4><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">int bucketedSize = getBucketedSize(size);</div><div class=\"line\">int sizeInBytes = -1;</div><div class=\"line\"></div><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">  Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\"></div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    // find an existing value that we can reuse</div><div class=\"line\">    V value = bucket.get();</div><div class=\"line\">    if (value != null) &#123;</div><div class=\"line\">      Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\"></div><div class=\"line\">      // It is possible that we got a &apos;larger&apos; value than we asked for.</div><div class=\"line\">      // lets recompute size in bytes here</div><div class=\"line\">      bucketedSize = getBucketedSizeForValue(value);</div><div class=\"line\">      sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">      mUsed.increment(sizeInBytes);</div><div class=\"line\">      mFree.decrement(sizeInBytes);</div><div class=\"line\">      mPoolStatsTracker.onValueReuse(sizeInBytes);</div><div class=\"line\">      logStats();</div><div class=\"line\">      if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">        FLog.v(</div><div class=\"line\">            TAG,</div><div class=\"line\">            &quot;get (reuse) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">            System.identityHashCode(value),</div><div class=\"line\">            bucketedSize);</div><div class=\"line\">      &#125;</div><div class=\"line\">      return value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // fall through</div><div class=\"line\">  &#125;</div><div class=\"line\">  // check to see if we can allocate a value of the given size without exceeding the hard cap</div><div class=\"line\">  sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">  if (!canAllocate(sizeInBytes)) &#123;</div><div class=\"line\">    throw new PoolSizeViolationException(</div><div class=\"line\">        mPoolParams.maxSizeHardCap,</div><div class=\"line\">        mUsed.mNumBytes,</div><div class=\"line\">        mFree.mNumBytes,</div><div class=\"line\">        sizeInBytes);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes</div><div class=\"line\">  mUsed.increment(sizeInBytes);</div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    bucket.incrementInUseCount();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小</li>\n<li>通过getBucket方法获取对应桶容量的桶<ul>\n<li>如果没有找到，就创建一个新的桶 </li>\n</ul>\n</li>\n<li>如果桶不为null<ul>\n<li>通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能</li>\n<li>Counter 纪录使用容量和空闲容量</li>\n<li>状态追踪以及其他操作</li>\n<li>返回</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">V value = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">  // allocate the value outside the synchronized block, because it can be pretty expensive</div><div class=\"line\">  // we could have done the allocation inside the synchronized block,</div><div class=\"line\">  // but that would have blocked out other operations on the pool</div><div class=\"line\">  value = alloc(bucketedSize);</div><div class=\"line\">&#125; catch (Throwable e) &#123;</div><div class=\"line\">  // Assumption we made previously is not valid - allocation failed. We need to fix internal</div><div class=\"line\">  // counters.</div><div class=\"line\">  synchronized (this) &#123;</div><div class=\"line\">    mUsed.decrement(sizeInBytes);</div><div class=\"line\">    Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\">    if (bucket != null) &#123;</div><div class=\"line\">      bucket.decrementInUseCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Throwables.propagateIfPossible(e);</div><div class=\"line\">&#125;</div><div class=\"line\">    synchronized(this) &#123;</div><div class=\"line\">  Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\">  // If we&apos;re over the pool&apos;s max size, try to trim the pool appropriately</div><div class=\"line\">  trimToSoftCap();</div><div class=\"line\">  mPoolStatsTracker.onAlloc(sizeInBytes);</div><div class=\"line\">  logStats();</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;get (alloc) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">        System.identityHashCode(value),</div><div class=\"line\">        bucketedSize);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return value;</div></pre></td></tr></table></figure>\n<ul>\n<li>没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有</li>\n<li>如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。</li>\n</ul>\n<h4 id=\"5-2-BasePool-release\"><a href=\"#5-2-BasePool-release\" class=\"headerlink\" title=\"5.2 BasePool#release\"></a>5.2 BasePool#release</h4><p>这个方法是我们主动释放一个对象所占用的内存。</p>\n<p>实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-Fresco中的内存管理模块\"><a href=\"#1-Fresco中的内存管理模块\" class=\"headerlink\" title=\"1. Fresco中的内存管理模块\"></a>1. Fresco中的内存管理模块</h3><p>fresco中的内存分为两个部分，</p>\n<ul>\n<li>解码的<ul>\n<li>在5.0之上存在java堆中</li>\n<li>在5.0之下位于Ashmem中     </li>\n</ul>\n</li>\n<li>未解码的<ul>\n<li>位于native 堆中，这部分是在c++中申请的，不受限于app可以使用的最大内存。但是需要自己管理。</li>\n</ul>\n</li>\n</ul>\n<p>而这两部分都设计到native。 对应java层的代码在imagepipeine/memory 和nativecode中。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n\n<h3 id=\"2-匿名共享内存部分\"><a href=\"#2-匿名共享内存部分\" class=\"headerlink\" title=\"2. 匿名共享内存部分\"></a>2. 匿名共享内存部分</h3><p>这部分内存类似于Native内存区，但是它是受Android系统底层管理的，当Android系统内存不足时，会回收Ashmem区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护一个对象。在bitmap存在Ashmem，也很简单，只要我们将BitmapFactory.Options的inPurgeable属性设置为true即可，考虑到我们这里的图片可能会复用，我们会开启inMutable属性，关于这个属性，建议大家如看文档，看看inMutable和inBitmap。</p>\n<p>光这样是不够的，我们需要在需要的时候pin住，不需要的时候unpine，这些我们利用 bitmap.h 中的两个相关的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AndroidBitmap_lockPixels</div><div class=\"line\">AndroidBitmap_unlockPixels</div></pre></td></tr></table></figure>\n<p>pin和release实现的部分在Bitmaps.c部分。</p>\n<h3 id=\"3-从NetworkFetchProducer开始谈-native-heap的管理\"><a href=\"#3-从NetworkFetchProducer开始谈-native-heap的管理\" class=\"headerlink\" title=\"3. 从NetworkFetchProducer开始谈 native heap的管理\"></a>3. 从NetworkFetchProducer开始谈 native heap的管理</h3><p>NetworkFetchProducer负责从网络上下载图片，下载成功之后回调onResponse方法。改方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void onResponse(</div><div class=\"line\">    FetchState fetchState,</div><div class=\"line\">    InputStream responseData,</div><div class=\"line\">    int responseContentLength)</div><div class=\"line\">    throws IOException &#123;</div><div class=\"line\">  final PooledByteBufferOutputStream pooledOutputStream;</div><div class=\"line\">  if (responseContentLength &gt; 0) &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream();</div><div class=\"line\">  &#125;</div><div class=\"line\">  final byte[] ioArray = mByteArrayPool.get(READ_SIZE);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    int length;</div><div class=\"line\">    while ((length = responseData.read(ioArray)) &gt;= 0) &#123;</div><div class=\"line\">      if (length &gt; 0) &#123;</div><div class=\"line\">        pooledOutputStream.write(ioArray, 0, length);</div><div class=\"line\">        maybeHandleIntermediateResult(pooledOutputStream, fetchState);</div><div class=\"line\">        float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);</div><div class=\"line\">        fetchState.getConsumer().onProgressUpdate(progress);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());</div><div class=\"line\">    handleFinalResult(pooledOutputStream, fetchState);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    mByteArrayPool.release(ioArray);</div><div class=\"line\">    pooledOutputStream.close();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过mPooledByteBufferFactory申请同样大小的一块内存区域的输出流</li>\n<li>将内容输入</li>\n<li>通知上层处理</li>\n</ul>\n<p>我们分段来看</p>\n<h4 id=\"3-1-构造输出流\"><a href=\"#3-1-构造输出流\" class=\"headerlink\" title=\"3.1 构造输出流\"></a>3.1 构造输出流</h4><p>PooledByteBufferFactory对应的实现是NativePooledByteBufferFactory，在他的newOutputStream方法中，构造一个NativePooledByteBufferOutputStream，注意，要传入两个参数，一个是NativeMemoryChunkPool，对应natice 内存池，另外一个就是要申请的容量大小。</p>\n<p>这样就构造出一个输出流。</p>\n<h4 id=\"3-2-输出数据\"><a href=\"#3-2-输出数据\" class=\"headerlink\" title=\"3.2 输出数据\"></a>3.2 输出数据</h4><p>上面的步骤构造出NativePooledByteBufferOutputStream，接下来就是通过他的write方法输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ensureValid();</div><div class=\"line\">realloc(mCount + count);</div><div class=\"line\">mBufRef.get().write(mCount, buffer, offset, count);</div><div class=\"line\">mCount += count;</div></pre></td></tr></table></figure>\n<ul>\n<li>校验有效性</li>\n<li>重新申请内存</li>\n<li>将原来来写入到内存中的数据加上现在数据，复制到新的native内存中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">NativeMemoryChunk newbuf = mPool.get(newLength);</div><div class=\"line\">mBufRef.get().copy(0, newbuf, 0, mCount);</div><div class=\"line\">mBufRef.close();</div><div class=\"line\">mBufRef = CloseableReference.of(newbuf, mPool);</div></pre></td></tr></table></figure>\n<p>mPool在这里对应的实现是NativeMemoryChunkPool。get方法在basebool中，会做一些工作，这里不细说，最后会调用alloc方法申请内存，alloc方法中，构造NativeMemoryChunk对象，这个构造方法中会调用，nativeAllocate方法，在jni中申请内存，这个后面和其他的native处理一块说。</p>\n<p>然后会调用NativeMemoryChunk#copy 做一些内存操作。根据两块不同的内存大小，来做操作，这里的代码 非常好，会使的工作量降到最低。最后在doCopy中通过nativeMemcpy这个native函数实现。</p>\n<p>最后调用close方法，释放内存，这个最后会调用到NativeMemoryChunk＃close方法，调用nativeFree，释放内存。</p>\n<h3 id=\"4-对应的native操作。\"><a href=\"#4-对应的native操作。\" class=\"headerlink\" title=\"4. 对应的native操作。\"></a>4. 对应的native操作。</h3><p>上面提到的两个native操作，都在NativeMemoryChunk.c中。先看对应的方法表。</p>\n<p><img src=\"/images/fresco/fresco_4.png\" alt=\"\"></p>\n<p>下面就来对其中一些进行说明。</p>\n<h4 id=\"4-1-NativeMemoryChunk-nativeAllocate\"><a href=\"#4-1-NativeMemoryChunk-nativeAllocate\" class=\"headerlink\" title=\"4.1 NativeMemoryChunk_nativeAllocate\"></a>4.1 NativeMemoryChunk_nativeAllocate</h4><p>这个是用来申请内存的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong NativeMemoryChunk_nativeAllocate(</div><div class=\"line\">    JNIEnv* env,</div><div class=\"line\">    jclass clzz,</div><div class=\"line\">    jint size) &#123;</div><div class=\"line\">  UNUSED(clzz);</div><div class=\"line\">  void* pointer = malloc(size);</div><div class=\"line\">  if (!pointer) &#123;</div><div class=\"line\">    (*env)-&gt;ThrowNew(env, jRuntimeException_class, &quot;could not allocate memory&quot;);</div><div class=\"line\">    return 0;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return PTR_TO_JLONG(pointer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过malloc申请size大小的一块内存</li>\n<li>通过PTR_TO_JLONG这个宏，将指针的地址转为java中的long，返回给java。</li>\n</ul>\n<p>因此，NativeMemoryChunk中的mNativePtr就对应着他在native中的内存区域的首地址的long类型</p>\n<h4 id=\"4-2-NativeMemoryChunk-nativeMemcpy\"><a href=\"#4-2-NativeMemoryChunk-nativeMemcpy\" class=\"headerlink\" title=\"4.2 NativeMemoryChunk_nativeMemcpy\"></a>4.2 NativeMemoryChunk_nativeMemcpy</h4><p>这个方法很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">memcpy(JLONG_TO_PTR(dst), JLONG_TO_PTR(src), count);</div></pre></td></tr></table></figure>\n<ul>\n<li>这里的参数，分别对应java中的两个NativeMemoryChunk，和大小</li>\n<li>首先用JLONG_TO_PTR这个宏，将long专为指针</li>\n<li>用memcpy函数，进行复制操作，</li>\n</ul>\n<h4 id=\"4-3-NativeMemoryChunk-nativeFree\"><a href=\"#4-3-NativeMemoryChunk-nativeFree\" class=\"headerlink\" title=\"4.3 NativeMemoryChunk_nativeFree\"></a>4.3 NativeMemoryChunk_nativeFree</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">free(JLONG_TO_PTR(lpointer));</div></pre></td></tr></table></figure>\n<p>调用free函数将指针对应位置的内存释放掉。</p>\n<p>其他的几个函数 这里就不说了。</p>\n<p>需要注意的是，native内存管理实对应NativeMemoryChunkPool。</p>\n<h3 id=\"5-以native内存为例，了解fresco内存池\"><a href=\"#5-以native内存为例，了解fresco内存池\" class=\"headerlink\" title=\"5 以native内存为例，了解fresco内存池\"></a>5 以native内存为例，了解fresco内存池</h3><p>我们需要先来了解几个东西。</p>\n<ul>\n<li>池 负责存储某类型的数据</li>\n<li>桶 将池分为若干大小的块，每一个块就是一个桶</li>\n<li>每个同种都维护着一个队列，由LinkedList实现，实现先进先出的功能。</li>\n</ul>\n<p>那么，NativeMemoryChunkPool这个池的桶是怎么划分的呢？默认的情况下，这个池是由DefaultNativeMemoryChunkPoolParams来配置的。有如下默认的一些桶。</p>\n<p><img src=\"/images/fresco/fresco_5.png\" alt=\"\"></p>\n<p>了解了这些，我们就从BasePool的get方法看起，看看他是如何实现的。</p>\n<h4 id=\"5-1-BasePool-get\"><a href=\"#5-1-BasePool-get\" class=\"headerlink\" title=\"5.1 BasePool#get\"></a>5.1 BasePool#get</h4><p>这个方法比较长，分段来看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">int bucketedSize = getBucketedSize(size);</div><div class=\"line\">int sizeInBytes = -1;</div><div class=\"line\"></div><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">  Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\"></div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    // find an existing value that we can reuse</div><div class=\"line\">    V value = bucket.get();</div><div class=\"line\">    if (value != null) &#123;</div><div class=\"line\">      Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\"></div><div class=\"line\">      // It is possible that we got a &apos;larger&apos; value than we asked for.</div><div class=\"line\">      // lets recompute size in bytes here</div><div class=\"line\">      bucketedSize = getBucketedSizeForValue(value);</div><div class=\"line\">      sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">      mUsed.increment(sizeInBytes);</div><div class=\"line\">      mFree.decrement(sizeInBytes);</div><div class=\"line\">      mPoolStatsTracker.onValueReuse(sizeInBytes);</div><div class=\"line\">      logStats();</div><div class=\"line\">      if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">        FLog.v(</div><div class=\"line\">            TAG,</div><div class=\"line\">            &quot;get (reuse) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">            System.identityHashCode(value),</div><div class=\"line\">            bucketedSize);</div><div class=\"line\">      &#125;</div><div class=\"line\">      return value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // fall through</div><div class=\"line\">  &#125;</div><div class=\"line\">  // check to see if we can allocate a value of the given size without exceeding the hard cap</div><div class=\"line\">  sizeInBytes = getSizeInBytes(bucketedSize);</div><div class=\"line\">  if (!canAllocate(sizeInBytes)) &#123;</div><div class=\"line\">    throw new PoolSizeViolationException(</div><div class=\"line\">        mPoolParams.maxSizeHardCap,</div><div class=\"line\">        mUsed.mNumBytes,</div><div class=\"line\">        mFree.mNumBytes,</div><div class=\"line\">        sizeInBytes);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Optimistically assume that allocation succeeds - if it fails, we need to undo those changes</div><div class=\"line\">  mUsed.increment(sizeInBytes);</div><div class=\"line\">  if (bucket != null) &#123;</div><div class=\"line\">    bucket.incrementInUseCount();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先，通过getBucketedSize获取能容纳我们需要容量的桶,这个方法的实现在具体的池中，如NativeMemoryChunkPool，就是获取比容量大大师最近接容量的桶的大小</li>\n<li>通过getBucket方法获取对应桶容量的桶<ul>\n<li>如果没有找到，就创建一个新的桶 </li>\n</ul>\n</li>\n<li>如果桶不为null<ul>\n<li>通过Bucket的get方法获取一个对象，注意，这里用队列实现先进先出的功能</li>\n<li>Counter 纪录使用容量和空闲容量</li>\n<li>状态追踪以及其他操作</li>\n<li>返回</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">V value = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">  // allocate the value outside the synchronized block, because it can be pretty expensive</div><div class=\"line\">  // we could have done the allocation inside the synchronized block,</div><div class=\"line\">  // but that would have blocked out other operations on the pool</div><div class=\"line\">  value = alloc(bucketedSize);</div><div class=\"line\">&#125; catch (Throwable e) &#123;</div><div class=\"line\">  // Assumption we made previously is not valid - allocation failed. We need to fix internal</div><div class=\"line\">  // counters.</div><div class=\"line\">  synchronized (this) &#123;</div><div class=\"line\">    mUsed.decrement(sizeInBytes);</div><div class=\"line\">    Bucket&lt;V&gt; bucket = getBucket(bucketedSize);</div><div class=\"line\">    if (bucket != null) &#123;</div><div class=\"line\">      bucket.decrementInUseCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  Throwables.propagateIfPossible(e);</div><div class=\"line\">&#125;</div><div class=\"line\">    synchronized(this) &#123;</div><div class=\"line\">  Preconditions.checkState(mInUseValues.add(value));</div><div class=\"line\">  // If we&apos;re over the pool&apos;s max size, try to trim the pool appropriately</div><div class=\"line\">  trimToSoftCap();</div><div class=\"line\">  mPoolStatsTracker.onAlloc(sizeInBytes);</div><div class=\"line\">  logStats();</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;get (alloc) (object, size) = (%x, %s)&quot;,</div><div class=\"line\">        System.identityHashCode(value),</div><div class=\"line\">        bucketedSize);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return value;</div></pre></td></tr></table></figure>\n<ul>\n<li>没有可以复用的话 就去native堆中申请内存，alloc 的具体步骤上面有</li>\n<li>如果超过了最大容量，就调整容量，这里的调整是指通过free释放一部分内存，上面也说道过。</li>\n</ul>\n<h4 id=\"5-2-BasePool-release\"><a href=\"#5-2-BasePool-release\" class=\"headerlink\" title=\"5.2 BasePool#release\"></a>5.2 BasePool#release</h4><p>这个方法是我们主动释放一个对象所占用的内存。</p>\n<p>实现比较简单，就是调用free释放内存，并且调整池的已用大小、空闲大小这些参数。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco生产者Producer","date":"2016-12-13T03:26:58.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 从ImagePipeline#submitFetchRequest说起\n\n上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：\n\n* 从未解码的memory cache中获取\n* 从disk cache中获取\n* 从net中获取\n\n```\n      return CloseableProducerToDataSourceAdapter.create(\n          producerSequence,\n          settableProducerContext,\n          requestListener);\n```\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。\n\n\n### 2. Producer 生产者\n\n先看下相关的结构。\n\n![](/images/fresco/fresco_2.png)\n\n可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。\n\n\n### 3. 从已解码的内存中获取－BitmapMemoryCacheProducer\n\n\n这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。\n\n### 4. 从未解码的内存中获取－EncodedMemoryCacheProducer\n\n\n在这里要说明下\n\n* EncodedImage 未解码的载体\n* PooledByteBuffer 存储的字节码\n* CloseableBitmap 已解码的载体\n\n\n先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。\n\n### 5. 从本地文件获取－DiskCacheProducer\n\n文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。\n\n### 6. 从网络中获取－NetworkFetchProducer\n\n略，思路一致。\n\n\n_ _ _\n\n* [参考资料](https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/fresco生产者Producer.md","raw":"---\ntitle: fresco生产者Producer\ndate: 2016-12-13 11:26:58\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 从ImagePipeline#submitFetchRequest说起\n\n上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：\n\n* 从未解码的memory cache中获取\n* 从disk cache中获取\n* 从net中获取\n\n```\n      return CloseableProducerToDataSourceAdapter.create(\n          producerSequence,\n          settableProducerContext,\n          requestListener);\n```\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。\n\n\n### 2. Producer 生产者\n\n先看下相关的结构。\n\n![](/images/fresco/fresco_2.png)\n\n可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。\n\n\n### 3. 从已解码的内存中获取－BitmapMemoryCacheProducer\n\n\n这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。\n\n### 4. 从未解码的内存中获取－EncodedMemoryCacheProducer\n\n\n在这里要说明下\n\n* EncodedImage 未解码的载体\n* PooledByteBuffer 存储的字节码\n* CloseableBitmap 已解码的载体\n\n\n先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。\n\n### 5. 从本地文件获取－DiskCacheProducer\n\n文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。\n\n### 6. 从网络中获取－NetworkFetchProducer\n\n略，思路一致。\n\n\n_ _ _\n\n* [参考资料](https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"fresco生产者Producer","published":1,"updated":"2017-01-07T06:58:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2h001lhws6akaaqpj1","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-从ImagePipeline-submitFetchRequest说起\"><a href=\"#1-从ImagePipeline-submitFetchRequest说起\" class=\"headerlink\" title=\"1. 从ImagePipeline#submitFetchRequest说起\"></a>1. 从ImagePipeline#submitFetchRequest说起</h3><p>上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：</p>\n<ul>\n<li>从未解码的memory cache中获取</li>\n<li>从disk cache中获取</li>\n<li>从net中获取</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">return CloseableProducerToDataSourceAdapter.create(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    settableProducerContext,</div><div class=\"line\">    requestListener);</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p>在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。</p>\n<h3 id=\"2-Producer-生产者\"><a href=\"#2-Producer-生产者\" class=\"headerlink\" title=\"2. Producer 生产者\"></a>2. Producer 生产者</h3><p>先看下相关的结构。</p>\n<p><img src=\"/images/fresco/fresco_2.png\" alt=\"\"></p>\n<p>可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。</p>\n<h3 id=\"3-从已解码的内存中获取－BitmapMemoryCacheProducer\"><a href=\"#3-从已解码的内存中获取－BitmapMemoryCacheProducer\" class=\"headerlink\" title=\"3. 从已解码的内存中获取－BitmapMemoryCacheProducer\"></a>3. 从已解码的内存中获取－BitmapMemoryCacheProducer</h3><p>这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。</p>\n<h3 id=\"4-从未解码的内存中获取－EncodedMemoryCacheProducer\"><a href=\"#4-从未解码的内存中获取－EncodedMemoryCacheProducer\" class=\"headerlink\" title=\"4. 从未解码的内存中获取－EncodedMemoryCacheProducer\"></a>4. 从未解码的内存中获取－EncodedMemoryCacheProducer</h3><p>在这里要说明下</p>\n<ul>\n<li>EncodedImage 未解码的载体</li>\n<li>PooledByteBuffer 存储的字节码</li>\n<li>CloseableBitmap 已解码的载体</li>\n</ul>\n<p>先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。</p>\n<h3 id=\"5-从本地文件获取－DiskCacheProducer\"><a href=\"#5-从本地文件获取－DiskCacheProducer\" class=\"headerlink\" title=\"5. 从本地文件获取－DiskCacheProducer\"></a>5. 从本地文件获取－DiskCacheProducer</h3><p>文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。</p>\n<h3 id=\"6-从网络中获取－NetworkFetchProducer\"><a href=\"#6-从网络中获取－NetworkFetchProducer\" class=\"headerlink\" title=\"6. 从网络中获取－NetworkFetchProducer\"></a>6. 从网络中获取－NetworkFetchProducer</h3><p>略，思路一致。</p>\n<hr>\n<ul>\n<li><a href=\"https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5\" target=\"_blank\" rel=\"external\">参考资料</a>%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-从ImagePipeline-submitFetchRequest说起\"><a href=\"#1-从ImagePipeline-submitFetchRequest说起\" class=\"headerlink\" title=\"1. 从ImagePipeline#submitFetchRequest说起\"></a>1. 从ImagePipeline#submitFetchRequest说起</h3><p>上篇说到，这里干了三件事，第三件事，就是我们异步获取数据的过程，这里的异步获取数据包括三个方面：</p>\n<ul>\n<li>从未解码的memory cache中获取</li>\n<li>从disk cache中获取</li>\n<li>从net中获取</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">return CloseableProducerToDataSourceAdapter.create(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    settableProducerContext,</div><div class=\"line\">    requestListener);</div></pre></td></tr></table></figure>","more":"<The rest of contents | 余下全文>\n\n\n<p>在AbstractProducerToDataSourceAdapter中，创建了CloseableProducerToDataSourceAdapter，而这个继承了AbstractProducerToDataSourceAdapter，这个类的构造方法中，通过producer.produceResults(createConsumer(), settableProducerContext);来异步获取数据，并会将结果回调。</p>\n<h3 id=\"2-Producer-生产者\"><a href=\"#2-Producer-生产者\" class=\"headerlink\" title=\"2. Producer 生产者\"></a>2. Producer 生产者</h3><p>先看下相关的结构。</p>\n<p><img src=\"/images/fresco/fresco_2.png\" alt=\"\"></p>\n<p>可以看到有许多不同类型的Producer，这些都是用来从不同的区域获取数据。</p>\n<h3 id=\"3-从已解码的内存中获取－BitmapMemoryCacheProducer\"><a href=\"#3-从已解码的内存中获取－BitmapMemoryCacheProducer\" class=\"headerlink\" title=\"3. 从已解码的内存中获取－BitmapMemoryCacheProducer\"></a>3. 从已解码的内存中获取－BitmapMemoryCacheProducer</h3><p>这里的比较简单，他的produceResults方法中，通过mMemoryCache.get(cacheKey)来获取已解码的数据。</p>\n<h3 id=\"4-从未解码的内存中获取－EncodedMemoryCacheProducer\"><a href=\"#4-从未解码的内存中获取－EncodedMemoryCacheProducer\" class=\"headerlink\" title=\"4. 从未解码的内存中获取－EncodedMemoryCacheProducer\"></a>4. 从未解码的内存中获取－EncodedMemoryCacheProducer</h3><p>在这里要说明下</p>\n<ul>\n<li>EncodedImage 未解码的载体</li>\n<li>PooledByteBuffer 存储的字节码</li>\n<li>CloseableBitmap 已解码的载体</li>\n</ul>\n<p>先mMemoryCache.get(cacheKey) 获取未解码的数据，然后构造出未解码的载体EncodedImage，传给其他的生产者进行解码。</p>\n<h3 id=\"5-从本地文件获取－DiskCacheProducer\"><a href=\"#5-从本地文件获取－DiskCacheProducer\" class=\"headerlink\" title=\"5. 从本地文件获取－DiskCacheProducer\"></a>5. 从本地文件获取－DiskCacheProducer</h3><p>文件缓存对应的是BufferedDiskCache，大致步骤和上面的区别不大。这里就不再说了。</p>\n<h3 id=\"6-从网络中获取－NetworkFetchProducer\"><a href=\"#6-从网络中获取－NetworkFetchProducer\" class=\"headerlink\" title=\"6. 从网络中获取－NetworkFetchProducer\"></a>6. 从网络中获取－NetworkFetchProducer</h3><p>略，思路一致。</p>\n<hr>\n<ul>\n<li><a href=\"https://github.com/desmond1121/Fresco-Source-Analysis/blob/master/Fresco%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5\">参考资料</a>%20-%20Producer%E6%B5%81%E6%B0%B4%E7%BA%BF.md)</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"android应用进程是如何启动的","date":"2017-01-01T16:55:08.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n            if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                    app.processName);\n            checkTime(startTime, \"startProcess: asking zygote to start proc\");\n            Process.ProcessStartResult startResult = Process.start(entryPoint,\n                    app.processName, uid, uid, gids, debugFlags, mountExternal,\n                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                    app.info.dataDir, entryPointArgs);\n```\n\n* 其中entryPoint是进程的运行入口\n\n\n### 2.Process#start\n\n在start方法中，会调用startViaZygote方法。\n\n```\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                  final String niceName,\n                                  final int uid, final int gid,\n                                  final int[] gids,\n                                  int debugFlags, int mountExternal,\n                                  int targetSdkVersion,\n                                  String seInfo,\n                                  String abi,\n                                  String instructionSet,\n                                  String appDataDir,\n                                  String[] extraArgs)\n                                  throws ZygoteStartFailedEx {\n        synchronized(Process.class) {\n            ArrayList<String> argsForZygote = new ArrayList<String>();\n\n            // --runtime-args, --setuid=, --setgid=,\n            // and --setgroups= must go first\n            argsForZygote.add(\"--runtime-args\");\n            argsForZygote.add(\"--setuid=\" + uid);\n            argsForZygote.add(\"--setgid=\" + gid);\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {\n                argsForZygote.add(\"--enable-jni-logging\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {\n                argsForZygote.add(\"--enable-safemode\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {\n                argsForZygote.add(\"--enable-debugger\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {\n                argsForZygote.add(\"--enable-checkjni\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JIT) != 0) {\n                argsForZygote.add(\"--enable-jit\");\n            }\n            if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {\n                argsForZygote.add(\"--generate-debug-info\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {\n                argsForZygote.add(\"--enable-assert\");\n            }\n            if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {\n                argsForZygote.add(\"--mount-external-default\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {\n                argsForZygote.add(\"--mount-external-read\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {\n                argsForZygote.add(\"--mount-external-write\");\n            }\n            argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion);\n\n            //TODO optionally enable debuger\n            //argsForZygote.add(\"--enable-debugger\");\n\n            // --setgroups is a comma-separated list\n            if (gids != null && gids.length > 0) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(\"--setgroups=\");\n\n                int sz = gids.length;\n                for (int i = 0; i < sz; i++) {\n                    if (i != 0) {\n                        sb.append(',');\n                    }\n                    sb.append(gids[i]);\n                }\n\n                argsForZygote.add(sb.toString());\n            }\n\n            if (niceName != null) {\n                argsForZygote.add(\"--nice-name=\" + niceName);\n            }\n\n            if (seInfo != null) {\n                argsForZygote.add(\"--seinfo=\" + seInfo);\n            }\n\n            if (instructionSet != null) {\n                argsForZygote.add(\"--instruction-set=\" + instructionSet);\n            }\n\n            if (appDataDir != null) {\n                argsForZygote.add(\"--app-data-dir=\" + appDataDir);\n            }\n\n            argsForZygote.add(processClass);\n\n            if (extraArgs != null) {\n                for (String arg : extraArgs) {\n                    argsForZygote.add(arg);\n                }\n            }\n\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n        }\n    }\n```\n在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？\n\n### 3.Process#openZygoteSocketIfNeeded\n\n ```\n     private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n            try {\n                primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n            }\n        }\n\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        // The primary zygote didn't match. Try the secondary.\n        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n            try {\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n            }\n        }\n\n        if (secondaryZygoteState.matches(abi)) {\n            return secondaryZygoteState;\n        }\n\n        throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n    }\n ```\n \n 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。\n \n### 4. Process#zygoteSendArgsAndGetResult\n\n```\n            final BufferedWriter writer = zygoteState.writer;\n            final DataInputStream inputStream = zygoteState.inputStream;\n\n            writer.write(Integer.toString(args.size()));\n            writer.newLine();\n\n            int sz = args.size();\n            for (int i = 0; i < sz; i++) {\n                String arg = args.get(i);\n                if (arg.indexOf('\\n') >= 0) {\n                    throw new ZygoteStartFailedEx(\n                            \"embedded newlines not allowed\");\n                }\n                writer.write(arg);\n                writer.newLine();\n            }\n\n            writer.flush();\n\n            // Should there be a timeout on this?\n            ProcessStartResult result = new ProcessStartResult();\n            result.pid = inputStream.readInt();\n            if (result.pid < 0) {\n                throw new ZygoteStartFailedEx(\"fork() failed\");\n            }\n            result.usingWrapper = inputStream.readBoolean();\n            return result;\n```\n\n在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。\n\n那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。\n\n### 5. ZygoteInit#runSelectLoop\n\n```\n    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(sServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    boolean done = peers.get(i).runOnce();\n                    if (done) {\n                        peers.remove(i);\n                        fds.remove(i);\n                    }\n                }\n            }\n        }\n    }\n```\n\n首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。\n\n### 6.ZygoteConnection#runOnce\n\n```\n   boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n\n        String args[];\n        Arguments parsedArgs = null;\n        FileDescriptor[] descriptors;\n\n        try {\n            args = readArgumentList();\n            descriptors = mSocket.getAncillaryFileDescriptors();\n        } catch (IOException ex) {\n            Log.w(TAG, \"IOException on command socket \" + ex.getMessage());\n            closeSocket();\n            return true;\n        }\n\n        if (args == null) {\n            // EOF reached.\n            closeSocket();\n            return true;\n        }\n\n        /** the stderr of the most recent request, if avail */\n        PrintStream newStderr = null;\n\n        if (descriptors != null && descriptors.length >= 3) {\n            newStderr = new PrintStream(\n                    new FileOutputStream(descriptors[2]));\n        }\n\n        int pid = -1;\n        FileDescriptor childPipeFd = null;\n        FileDescriptor serverPipeFd = null;\n\n        try {\n            parsedArgs = new Arguments(args);\n\n            if (parsedArgs.abiListQuery) {\n                return handleAbiListQuery();\n            }\n\n            if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {\n                throw new ZygoteSecurityException(\"Client may not specify capabilities: \" +\n                        \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) +\n                        \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities));\n            }\n\n            applyUidSecurityPolicy(parsedArgs, peer);\n            applyInvokeWithSecurityPolicy(parsedArgs, peer);\n\n            applyDebuggerSystemProperty(parsedArgs);\n            applyInvokeWithSystemProperty(parsedArgs);\n\n            int[][] rlimits = null;\n\n            if (parsedArgs.rlimits != null) {\n                rlimits = parsedArgs.rlimits.toArray(intArray2d);\n            }\n\n            if (parsedArgs.invokeWith != null) {\n                FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);\n                childPipeFd = pipeFds[1];\n                serverPipeFd = pipeFds[0];\n                Os.fcntlInt(childPipeFd, F_SETFD, 0);\n            }\n\n            /**\n             * In order to avoid leaking descriptors to the Zygote child,\n             * the native code must close the two Zygote socket descriptors\n             * in the child process before it switches from Zygote-root to\n             * the UID and privileges of the application being launched.\n             *\n             * In order to avoid \"bad file descriptor\" errors when the\n             * two LocalSocket objects are closed, the Posix file\n             * descriptors are released via a dup2() call which closes\n             * the socket and substitutes an open descriptor to /dev/null.\n             */\n\n            int [] fdsToClose = { -1, -1 };\n\n            FileDescriptor fd = mSocket.getFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[0] = fd.getInt$();\n            }\n\n            fd = ZygoteInit.getServerSocketFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[1] = fd.getInt$();\n            }\n\n            fd = null;\n\n            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                    parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                    parsedArgs.appDataDir);\n        } catch (ErrnoException ex) {\n            logAndPrintError(newStderr, \"Exception creating pipe\", ex);\n        } catch (IllegalArgumentException ex) {\n            logAndPrintError(newStderr, \"Invalid zygote arguments\", ex);\n        } catch (ZygoteSecurityException ex) {\n            logAndPrintError(newStderr,\n                    \"Zygote security policy prevents request: \", ex);\n        }\n\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n```\n\n* readArgumentList读区启动参数\n* 构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数\n* 随后进行参数检查和配置\n* 调用Zygote.forkAndSpecialize进行fork进程，返回进程id\n\n\n### 7.Zygote#forkAndSpecialize\n\n```\n    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n```\n\n* VM_HOOKS是ZygoteHooks\n* 在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下\n\n\t```\nstatic JNINativeMethod gMethods[] = {\n  NATIVE_METHOD(ZygoteHooks, nativePreFork, \"()J\"),\n  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, \"(JILjava/lang/String;)V\"),\n};\n\t```\n* 然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。\n* 调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。\n\n\n### 8. nativePreFork\n\n```\nstatic jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {\n  Runtime* runtime = Runtime::Current();\n  CHECK(runtime->IsZygote()) << \"runtime instance not started with -Xzygote\";\n\n  runtime->PreZygoteFork();\n\n  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) {\n    // Tracing active, pause it.\n    Trace::Pause();\n  }\n\n  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.\n  return reinterpret_cast<jlong>(ThreadForEnv(env));\n}\n```\n这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略\n\n### 9. nativeForkAndSpecialize\n\n在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。\n\n```\nstatic pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,\n                                     jint debug_flags, jobjectArray javaRlimits,\n                                     jlong permittedCapabilities, jlong effectiveCapabilities,\n                                     jint mount_external,\n                                     jstring java_se_info, jstring java_se_name,\n                                     bool is_system_server, jintArray fdsToClose,\n                                     jstring instructionSet, jstring dataDir) {\n  SetSigChldHandler();\n\n  pid_t pid = fork();\n\n  if (pid == 0) {\n    // The child process.\n    gMallocLeakZygoteChild = 1;\n\n    // Clean up any descriptors which must be closed immediately\n    DetachDescriptors(env, fdsToClose);\n\n    // Keep capabilities across UID change, unless we're staying root.\n    if (uid != 0) {\n      EnableKeepCapabilities(env);\n    }\n\n    DropCapabilitiesBoundingSet(env);\n\n    bool use_native_bridge = !is_system_server && (instructionSet != NULL)\n        && android::NativeBridgeAvailable();\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());\n    }\n    if (use_native_bridge && dataDir == NULL) {\n      // dataDir should never be null if we need to use a native bridge.\n      // In general, dataDir will never be null for normal applications. It can only happen in\n      // special cases (for isolated processes which are not associated with any app). These are\n      // launched by the framework and should not be emulated anyway.\n      use_native_bridge = false;\n      ALOGW(\"Native bridge will not be used because dataDir == NULL.\");\n    }\n\n    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) {\n      ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno));\n      if (errno == ENOTCONN || errno == EROFS) {\n        // When device is actively encrypting, we get ENOTCONN here\n        // since FUSE was mounted before the framework restarted.\n        // When encrypted device is booting, we get EROFS since\n        // FUSE hasn't been created yet by init.\n        // In either case, continue without external storage.\n      } else {\n        ALOGE(\"Cannot continue without emulated storage\");\n        RuntimeAbort(env);\n      }\n    }\n\n    if (!is_system_server) {\n        int rc = createProcessGroup(uid, getpid());\n        if (rc != 0) {\n            if (rc == -EROFS) {\n                ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\");\n            } else {\n                ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc));\n            }\n        }\n    }\n\n    SetGids(env, javaGids);\n\n    SetRLimits(env, javaRlimits);\n\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      ScopedUtfChars data_dir(env, dataDir);\n      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());\n    }\n\n    int rc = setresgid(gid, gid, gid);\n    if (rc == -1) {\n      ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    rc = setresuid(uid, uid, uid);\n    if (rc == -1) {\n      ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    if (NeedsNoRandomizeWorkaround()) {\n        // Work around ARM kernel ASLR lossage (http://b/5817320).\n        int old_personality = personality(0xffffffff);\n        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);\n        if (new_personality == -1) {\n            ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno));\n        }\n    }\n\n    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);\n\n    SetSchedulerPolicy(env);\n\n    const char* se_info_c_str = NULL;\n    ScopedUtfChars* se_info = NULL;\n    if (java_se_info != NULL) {\n        se_info = new ScopedUtfChars(env, java_se_info);\n        se_info_c_str = se_info->c_str();\n        if (se_info_c_str == NULL) {\n          ALOGE(\"se_info_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    const char* se_name_c_str = NULL;\n    ScopedUtfChars* se_name = NULL;\n    if (java_se_name != NULL) {\n        se_name = new ScopedUtfChars(env, java_se_name);\n        se_name_c_str = se_name->c_str();\n        if (se_name_c_str == NULL) {\n          ALOGE(\"se_name_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);\n    if (rc == -1) {\n      ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid,\n            is_system_server, se_info_c_str, se_name_c_str);\n      RuntimeAbort(env);\n    }\n\n    // Make it easier to debug audit logs by setting the main thread's name to the\n    // nice name rather than \"app_process\".\n    if (se_info_c_str == NULL && is_system_server) {\n      se_name_c_str = \"system_server\";\n    }\n    if (se_info_c_str != NULL) {\n      SetThreadName(se_name_c_str);\n    }\n\n    delete se_info;\n    delete se_name;\n\n    UnsetSigChldHandler();\n\n    env->CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,\n                              is_system_server ? NULL : instructionSet);\n    if (env->ExceptionCheck()) {\n      ALOGE(\"Error calling post fork hooks.\");\n      RuntimeAbort(env);\n    }\n  } else if (pid > 0) {\n    // the parent process\n  }\n  return pid;\n}\n```\n\n* 设置子进程的signal信号处理函数 SetSigChldHandler函数\n* fork进程，fork函数\n* pid为0，进入子进程\n\t* DetachDescriptors 关闭清理文件描述符\n\t* SetGids 设置group\n\t* SetRLimits 设置资源限制\n\t* 进行其他的初始化设置\n\t* CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。\n\t* ...\n* 父进程分支，啥也不做\n* 返回pid\t \n当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作\n\n```\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n\n```\n\n我们重点看handleChildProc。\n\n### 10.ZygoteConnection#handleChildProc\n\n在这个方法中，有如下代码。\n\n```\n        if (parsedArgs.invokeWith != null) {\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(),\n                    pipeFd, parsedArgs.remainingArgs);\n        } else {\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                    parsedArgs.remainingArgs, null /* classLoader */);\n        }\n```\n\n大部分情况下，invokeWith为null，所以我们看下面的分支。\n\n\n### 11.RuntimeInit.zygoteInit\n\n```\n    public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n        redirectLogStreams();\n\n        commonInit();\n        nativeZygoteInit();\n        applicationInit(targetSdkVersion, argv, classLoader);\n    }\n```\n\n* 重定向log输出\n* commonInit,进行通用的一些设置如时区。\n* zygote初始化\n* 应用初始化\n\n### 12.nativeZygoteInit\n\n该函数的实现在AndroidRuntime.cpp中，\n\n```\nstatic void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)\n{\n    gCurRuntime->onZygoteInit();\n}\n```\n\n这里onZygoteInit在app_main.cpp中，这里就不多说了。\n\n### 13.RuntimeInit.applicationInit\n\n```\n    private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        // If the application calls System.exit(), terminate the process\n        // immediately without running any shutdown hooks.  It is not possible to\n        // shutdown an Android application gracefully.  Among other things, the\n        // Android runtime shutdown hooks close the Binder driver, which can cause\n        // leftover running threads to crash before the process actually exits.\n        nativeSetExitWithoutCleanup(true);\n\n        // We want to be fairly aggressive about heap utilization, to avoid\n        // holding on to a lot of memory that isn't needed.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);\n        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);\n\n        final Arguments args;\n        try {\n            args = new Arguments(argv);\n        } catch (IllegalArgumentException ex) {\n            Slog.e(TAG, ex.getMessage());\n            // let the process exit\n            return;\n        }\n\n        // The end of of the RuntimeInit event (see #zygoteInit).\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n        // Remaining arguments are passed to the start class's static main\n        invokeStaticMain(args.startClass, args.startArgs, classLoader);\n    }\n```\n\n这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。\n\n```\n    private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        Class<?> cl;\n\n        try {\n            cl = Class.forName(className, true, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(\n                    \"Missing class when invoking static main \" + className,\n                    ex);\n        }\n\n        Method m;\n        try {\n            m = cl.getMethod(\"main\", new Class[] { String[].class });\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(\n                    \"Missing static main on \" + className, ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(\n                    \"Problem getting static main on \" + className, ex);\n        }\n\n        int modifiers = m.getModifiers();\n        if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n            throw new RuntimeException(\n                    \"Main method is not public and static on \" + className);\n        }\n\n        /*\n         * This throw gets caught in ZygoteInit.main(), which responds\n         * by invoking the exception's run() method. This arrangement\n         * clears up all the stack frames that were required in setting\n         * up the process.\n         */\n        throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n    }\n```\n\n注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。\n\n```\n        public void run() {\n            try {\n                mMethod.invoke(null, new Object[] { mArgs });\n            } catch (IllegalAccessException ex) {\n                throw new RuntimeException(ex);\n            } catch (InvocationTargetException ex) {\n                Throwable cause = ex.getCause();\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                } else if (cause instanceof Error) {\n                    throw (Error) cause;\n                }\n                throw new RuntimeException(ex);\n            }\n        }\n```\n\n就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：\n\n在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/android应用进程是如何启动的.md","raw":"---\ntitle: android应用进程是如何启动的\ndate: 2017-01-02 00:55:08\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 1.前言\n\n我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n            if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                    app.processName);\n            checkTime(startTime, \"startProcess: asking zygote to start proc\");\n            Process.ProcessStartResult startResult = Process.start(entryPoint,\n                    app.processName, uid, uid, gids, debugFlags, mountExternal,\n                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                    app.info.dataDir, entryPointArgs);\n```\n\n* 其中entryPoint是进程的运行入口\n\n\n### 2.Process#start\n\n在start方法中，会调用startViaZygote方法。\n\n```\n    private static ProcessStartResult startViaZygote(final String processClass,\n                                  final String niceName,\n                                  final int uid, final int gid,\n                                  final int[] gids,\n                                  int debugFlags, int mountExternal,\n                                  int targetSdkVersion,\n                                  String seInfo,\n                                  String abi,\n                                  String instructionSet,\n                                  String appDataDir,\n                                  String[] extraArgs)\n                                  throws ZygoteStartFailedEx {\n        synchronized(Process.class) {\n            ArrayList<String> argsForZygote = new ArrayList<String>();\n\n            // --runtime-args, --setuid=, --setgid=,\n            // and --setgroups= must go first\n            argsForZygote.add(\"--runtime-args\");\n            argsForZygote.add(\"--setuid=\" + uid);\n            argsForZygote.add(\"--setgid=\" + gid);\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {\n                argsForZygote.add(\"--enable-jni-logging\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {\n                argsForZygote.add(\"--enable-safemode\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {\n                argsForZygote.add(\"--enable-debugger\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {\n                argsForZygote.add(\"--enable-checkjni\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_JIT) != 0) {\n                argsForZygote.add(\"--enable-jit\");\n            }\n            if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {\n                argsForZygote.add(\"--generate-debug-info\");\n            }\n            if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {\n                argsForZygote.add(\"--enable-assert\");\n            }\n            if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {\n                argsForZygote.add(\"--mount-external-default\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {\n                argsForZygote.add(\"--mount-external-read\");\n            } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {\n                argsForZygote.add(\"--mount-external-write\");\n            }\n            argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion);\n\n            //TODO optionally enable debuger\n            //argsForZygote.add(\"--enable-debugger\");\n\n            // --setgroups is a comma-separated list\n            if (gids != null && gids.length > 0) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(\"--setgroups=\");\n\n                int sz = gids.length;\n                for (int i = 0; i < sz; i++) {\n                    if (i != 0) {\n                        sb.append(',');\n                    }\n                    sb.append(gids[i]);\n                }\n\n                argsForZygote.add(sb.toString());\n            }\n\n            if (niceName != null) {\n                argsForZygote.add(\"--nice-name=\" + niceName);\n            }\n\n            if (seInfo != null) {\n                argsForZygote.add(\"--seinfo=\" + seInfo);\n            }\n\n            if (instructionSet != null) {\n                argsForZygote.add(\"--instruction-set=\" + instructionSet);\n            }\n\n            if (appDataDir != null) {\n                argsForZygote.add(\"--app-data-dir=\" + appDataDir);\n            }\n\n            argsForZygote.add(processClass);\n\n            if (extraArgs != null) {\n                for (String arg : extraArgs) {\n                    argsForZygote.add(arg);\n                }\n            }\n\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n        }\n    }\n```\n在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？\n\n### 3.Process#openZygoteSocketIfNeeded\n\n ```\n     private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n            try {\n                primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n            }\n        }\n\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        // The primary zygote didn't match. Try the secondary.\n        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n            try {\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n            }\n        }\n\n        if (secondaryZygoteState.matches(abi)) {\n            return secondaryZygoteState;\n        }\n\n        throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n    }\n ```\n \n 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。\n \n### 4. Process#zygoteSendArgsAndGetResult\n\n```\n            final BufferedWriter writer = zygoteState.writer;\n            final DataInputStream inputStream = zygoteState.inputStream;\n\n            writer.write(Integer.toString(args.size()));\n            writer.newLine();\n\n            int sz = args.size();\n            for (int i = 0; i < sz; i++) {\n                String arg = args.get(i);\n                if (arg.indexOf('\\n') >= 0) {\n                    throw new ZygoteStartFailedEx(\n                            \"embedded newlines not allowed\");\n                }\n                writer.write(arg);\n                writer.newLine();\n            }\n\n            writer.flush();\n\n            // Should there be a timeout on this?\n            ProcessStartResult result = new ProcessStartResult();\n            result.pid = inputStream.readInt();\n            if (result.pid < 0) {\n                throw new ZygoteStartFailedEx(\"fork() failed\");\n            }\n            result.usingWrapper = inputStream.readBoolean();\n            return result;\n```\n\n在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。\n\n那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。\n\n### 5. ZygoteInit#runSelectLoop\n\n```\n    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(sServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    boolean done = peers.get(i).runOnce();\n                    if (done) {\n                        peers.remove(i);\n                        fds.remove(i);\n                    }\n                }\n            }\n        }\n    }\n```\n\n首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。\n\n### 6.ZygoteConnection#runOnce\n\n```\n   boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n\n        String args[];\n        Arguments parsedArgs = null;\n        FileDescriptor[] descriptors;\n\n        try {\n            args = readArgumentList();\n            descriptors = mSocket.getAncillaryFileDescriptors();\n        } catch (IOException ex) {\n            Log.w(TAG, \"IOException on command socket \" + ex.getMessage());\n            closeSocket();\n            return true;\n        }\n\n        if (args == null) {\n            // EOF reached.\n            closeSocket();\n            return true;\n        }\n\n        /** the stderr of the most recent request, if avail */\n        PrintStream newStderr = null;\n\n        if (descriptors != null && descriptors.length >= 3) {\n            newStderr = new PrintStream(\n                    new FileOutputStream(descriptors[2]));\n        }\n\n        int pid = -1;\n        FileDescriptor childPipeFd = null;\n        FileDescriptor serverPipeFd = null;\n\n        try {\n            parsedArgs = new Arguments(args);\n\n            if (parsedArgs.abiListQuery) {\n                return handleAbiListQuery();\n            }\n\n            if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {\n                throw new ZygoteSecurityException(\"Client may not specify capabilities: \" +\n                        \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) +\n                        \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities));\n            }\n\n            applyUidSecurityPolicy(parsedArgs, peer);\n            applyInvokeWithSecurityPolicy(parsedArgs, peer);\n\n            applyDebuggerSystemProperty(parsedArgs);\n            applyInvokeWithSystemProperty(parsedArgs);\n\n            int[][] rlimits = null;\n\n            if (parsedArgs.rlimits != null) {\n                rlimits = parsedArgs.rlimits.toArray(intArray2d);\n            }\n\n            if (parsedArgs.invokeWith != null) {\n                FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);\n                childPipeFd = pipeFds[1];\n                serverPipeFd = pipeFds[0];\n                Os.fcntlInt(childPipeFd, F_SETFD, 0);\n            }\n\n            /**\n             * In order to avoid leaking descriptors to the Zygote child,\n             * the native code must close the two Zygote socket descriptors\n             * in the child process before it switches from Zygote-root to\n             * the UID and privileges of the application being launched.\n             *\n             * In order to avoid \"bad file descriptor\" errors when the\n             * two LocalSocket objects are closed, the Posix file\n             * descriptors are released via a dup2() call which closes\n             * the socket and substitutes an open descriptor to /dev/null.\n             */\n\n            int [] fdsToClose = { -1, -1 };\n\n            FileDescriptor fd = mSocket.getFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[0] = fd.getInt$();\n            }\n\n            fd = ZygoteInit.getServerSocketFileDescriptor();\n\n            if (fd != null) {\n                fdsToClose[1] = fd.getInt$();\n            }\n\n            fd = null;\n\n            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                    parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                    parsedArgs.appDataDir);\n        } catch (ErrnoException ex) {\n            logAndPrintError(newStderr, \"Exception creating pipe\", ex);\n        } catch (IllegalArgumentException ex) {\n            logAndPrintError(newStderr, \"Invalid zygote arguments\", ex);\n        } catch (ZygoteSecurityException ex) {\n            logAndPrintError(newStderr,\n                    \"Zygote security policy prevents request: \", ex);\n        }\n\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n```\n\n* readArgumentList读区启动参数\n* 构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数\n* 随后进行参数检查和配置\n* 调用Zygote.forkAndSpecialize进行fork进程，返回进程id\n\n\n### 7.Zygote#forkAndSpecialize\n\n```\n    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n```\n\n* VM_HOOKS是ZygoteHooks\n* 在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下\n\n\t```\nstatic JNINativeMethod gMethods[] = {\n  NATIVE_METHOD(ZygoteHooks, nativePreFork, \"()J\"),\n  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, \"(JILjava/lang/String;)V\"),\n};\n\t```\n* 然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。\n* 调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。\n\n\n### 8. nativePreFork\n\n```\nstatic jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {\n  Runtime* runtime = Runtime::Current();\n  CHECK(runtime->IsZygote()) << \"runtime instance not started with -Xzygote\";\n\n  runtime->PreZygoteFork();\n\n  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) {\n    // Tracing active, pause it.\n    Trace::Pause();\n  }\n\n  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.\n  return reinterpret_cast<jlong>(ThreadForEnv(env));\n}\n```\n这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略\n\n### 9. nativeForkAndSpecialize\n\n在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。\n\n```\nstatic pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,\n                                     jint debug_flags, jobjectArray javaRlimits,\n                                     jlong permittedCapabilities, jlong effectiveCapabilities,\n                                     jint mount_external,\n                                     jstring java_se_info, jstring java_se_name,\n                                     bool is_system_server, jintArray fdsToClose,\n                                     jstring instructionSet, jstring dataDir) {\n  SetSigChldHandler();\n\n  pid_t pid = fork();\n\n  if (pid == 0) {\n    // The child process.\n    gMallocLeakZygoteChild = 1;\n\n    // Clean up any descriptors which must be closed immediately\n    DetachDescriptors(env, fdsToClose);\n\n    // Keep capabilities across UID change, unless we're staying root.\n    if (uid != 0) {\n      EnableKeepCapabilities(env);\n    }\n\n    DropCapabilitiesBoundingSet(env);\n\n    bool use_native_bridge = !is_system_server && (instructionSet != NULL)\n        && android::NativeBridgeAvailable();\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());\n    }\n    if (use_native_bridge && dataDir == NULL) {\n      // dataDir should never be null if we need to use a native bridge.\n      // In general, dataDir will never be null for normal applications. It can only happen in\n      // special cases (for isolated processes which are not associated with any app). These are\n      // launched by the framework and should not be emulated anyway.\n      use_native_bridge = false;\n      ALOGW(\"Native bridge will not be used because dataDir == NULL.\");\n    }\n\n    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) {\n      ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno));\n      if (errno == ENOTCONN || errno == EROFS) {\n        // When device is actively encrypting, we get ENOTCONN here\n        // since FUSE was mounted before the framework restarted.\n        // When encrypted device is booting, we get EROFS since\n        // FUSE hasn't been created yet by init.\n        // In either case, continue without external storage.\n      } else {\n        ALOGE(\"Cannot continue without emulated storage\");\n        RuntimeAbort(env);\n      }\n    }\n\n    if (!is_system_server) {\n        int rc = createProcessGroup(uid, getpid());\n        if (rc != 0) {\n            if (rc == -EROFS) {\n                ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\");\n            } else {\n                ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc));\n            }\n        }\n    }\n\n    SetGids(env, javaGids);\n\n    SetRLimits(env, javaRlimits);\n\n    if (use_native_bridge) {\n      ScopedUtfChars isa_string(env, instructionSet);\n      ScopedUtfChars data_dir(env, dataDir);\n      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());\n    }\n\n    int rc = setresgid(gid, gid, gid);\n    if (rc == -1) {\n      ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    rc = setresuid(uid, uid, uid);\n    if (rc == -1) {\n      ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno));\n      RuntimeAbort(env);\n    }\n\n    if (NeedsNoRandomizeWorkaround()) {\n        // Work around ARM kernel ASLR lossage (http://b/5817320).\n        int old_personality = personality(0xffffffff);\n        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);\n        if (new_personality == -1) {\n            ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno));\n        }\n    }\n\n    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);\n\n    SetSchedulerPolicy(env);\n\n    const char* se_info_c_str = NULL;\n    ScopedUtfChars* se_info = NULL;\n    if (java_se_info != NULL) {\n        se_info = new ScopedUtfChars(env, java_se_info);\n        se_info_c_str = se_info->c_str();\n        if (se_info_c_str == NULL) {\n          ALOGE(\"se_info_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    const char* se_name_c_str = NULL;\n    ScopedUtfChars* se_name = NULL;\n    if (java_se_name != NULL) {\n        se_name = new ScopedUtfChars(env, java_se_name);\n        se_name_c_str = se_name->c_str();\n        if (se_name_c_str == NULL) {\n          ALOGE(\"se_name_c_str == NULL\");\n          RuntimeAbort(env);\n        }\n    }\n    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);\n    if (rc == -1) {\n      ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid,\n            is_system_server, se_info_c_str, se_name_c_str);\n      RuntimeAbort(env);\n    }\n\n    // Make it easier to debug audit logs by setting the main thread's name to the\n    // nice name rather than \"app_process\".\n    if (se_info_c_str == NULL && is_system_server) {\n      se_name_c_str = \"system_server\";\n    }\n    if (se_info_c_str != NULL) {\n      SetThreadName(se_name_c_str);\n    }\n\n    delete se_info;\n    delete se_name;\n\n    UnsetSigChldHandler();\n\n    env->CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,\n                              is_system_server ? NULL : instructionSet);\n    if (env->ExceptionCheck()) {\n      ALOGE(\"Error calling post fork hooks.\");\n      RuntimeAbort(env);\n    }\n  } else if (pid > 0) {\n    // the parent process\n  }\n  return pid;\n}\n```\n\n* 设置子进程的signal信号处理函数 SetSigChldHandler函数\n* fork进程，fork函数\n* pid为0，进入子进程\n\t* DetachDescriptors 关闭清理文件描述符\n\t* SetGids 设置group\n\t* SetRLimits 设置资源限制\n\t* 进行其他的初始化设置\n\t* CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。\n\t* ...\n* 父进程分支，啥也不做\n* 返回pid\t \n当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作\n\n```\n        try {\n            if (pid == 0) {\n                // in child\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n\n                // should never get here, the child is expected to either\n                // throw ZygoteInit.MethodAndArgsCaller or exec().\n                return true;\n            } else {\n                // in parent...pid of < 0 means failure\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n\n```\n\n我们重点看handleChildProc。\n\n### 10.ZygoteConnection#handleChildProc\n\n在这个方法中，有如下代码。\n\n```\n        if (parsedArgs.invokeWith != null) {\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(),\n                    pipeFd, parsedArgs.remainingArgs);\n        } else {\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                    parsedArgs.remainingArgs, null /* classLoader */);\n        }\n```\n\n大部分情况下，invokeWith为null，所以我们看下面的分支。\n\n\n### 11.RuntimeInit.zygoteInit\n\n```\n    public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n        redirectLogStreams();\n\n        commonInit();\n        nativeZygoteInit();\n        applicationInit(targetSdkVersion, argv, classLoader);\n    }\n```\n\n* 重定向log输出\n* commonInit,进行通用的一些设置如时区。\n* zygote初始化\n* 应用初始化\n\n### 12.nativeZygoteInit\n\n该函数的实现在AndroidRuntime.cpp中，\n\n```\nstatic void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)\n{\n    gCurRuntime->onZygoteInit();\n}\n```\n\n这里onZygoteInit在app_main.cpp中，这里就不多说了。\n\n### 13.RuntimeInit.applicationInit\n\n```\n    private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        // If the application calls System.exit(), terminate the process\n        // immediately without running any shutdown hooks.  It is not possible to\n        // shutdown an Android application gracefully.  Among other things, the\n        // Android runtime shutdown hooks close the Binder driver, which can cause\n        // leftover running threads to crash before the process actually exits.\n        nativeSetExitWithoutCleanup(true);\n\n        // We want to be fairly aggressive about heap utilization, to avoid\n        // holding on to a lot of memory that isn't needed.\n        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);\n        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);\n\n        final Arguments args;\n        try {\n            args = new Arguments(argv);\n        } catch (IllegalArgumentException ex) {\n            Slog.e(TAG, ex.getMessage());\n            // let the process exit\n            return;\n        }\n\n        // The end of of the RuntimeInit event (see #zygoteInit).\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n        // Remaining arguments are passed to the start class's static main\n        invokeStaticMain(args.startClass, args.startArgs, classLoader);\n    }\n```\n\n这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。\n\n```\n    private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n        Class<?> cl;\n\n        try {\n            cl = Class.forName(className, true, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new RuntimeException(\n                    \"Missing class when invoking static main \" + className,\n                    ex);\n        }\n\n        Method m;\n        try {\n            m = cl.getMethod(\"main\", new Class[] { String[].class });\n        } catch (NoSuchMethodException ex) {\n            throw new RuntimeException(\n                    \"Missing static main on \" + className, ex);\n        } catch (SecurityException ex) {\n            throw new RuntimeException(\n                    \"Problem getting static main on \" + className, ex);\n        }\n\n        int modifiers = m.getModifiers();\n        if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n            throw new RuntimeException(\n                    \"Main method is not public and static on \" + className);\n        }\n\n        /*\n         * This throw gets caught in ZygoteInit.main(), which responds\n         * by invoking the exception's run() method. This arrangement\n         * clears up all the stack frames that were required in setting\n         * up the process.\n         */\n        throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n    }\n```\n\n注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。\n\n```\n        public void run() {\n            try {\n                mMethod.invoke(null, new Object[] { mArgs });\n            } catch (IllegalAccessException ex) {\n                throw new RuntimeException(ex);\n            } catch (InvocationTargetException ex) {\n                Throwable cause = ex.getCause();\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                } else if (cause instanceof Error) {\n                    throw (Error) cause;\n                }\n                throw new RuntimeException(ex);\n            }\n        }\n```\n\n就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：\n\n在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"android应用进程是如何启动的","published":1,"updated":"2017-01-07T06:57:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2k001phws62dm1qq73","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</div><div class=\"line\">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</div><div class=\"line\">        app.processName);</div><div class=\"line\">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</div><div class=\"line\">Process.ProcessStartResult startResult = Process.start(entryPoint,</div><div class=\"line\">        app.processName, uid, uid, gids, debugFlags, mountExternal,</div><div class=\"line\">        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</div><div class=\"line\">        app.info.dataDir, entryPointArgs);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中entryPoint是进程的运行入口</li>\n</ul>\n<h3 id=\"2-Process-start\"><a href=\"#2-Process-start\" class=\"headerlink\" title=\"2.Process#start\"></a>2.Process#start</h3><p>在start方法中，会调用startViaZygote方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static ProcessStartResult startViaZygote(final String processClass,</div><div class=\"line\">                              final String niceName,</div><div class=\"line\">                              final int uid, final int gid,</div><div class=\"line\">                              final int[] gids,</div><div class=\"line\">                              int debugFlags, int mountExternal,</div><div class=\"line\">                              int targetSdkVersion,</div><div class=\"line\">                              String seInfo,</div><div class=\"line\">                              String abi,</div><div class=\"line\">                              String instructionSet,</div><div class=\"line\">                              String appDataDir,</div><div class=\"line\">                              String[] extraArgs)</div><div class=\"line\">                              throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    synchronized(Process.class) &#123;</div><div class=\"line\">        ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\">        // --runtime-args, --setuid=, --setgid=,</div><div class=\"line\">        // and --setgroups= must go first</div><div class=\"line\">        argsForZygote.add(&quot;--runtime-args&quot;);</div><div class=\"line\">        argsForZygote.add(&quot;--setuid=&quot; + uid);</div><div class=\"line\">        argsForZygote.add(&quot;--setgid=&quot; + gid);</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jni-logging&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-safemode&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-checkjni&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jit&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--generate-debug-info&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-assert&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-default&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-read&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-write&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">        //TODO optionally enable debuger</div><div class=\"line\">        //argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\"></div><div class=\"line\">        // --setgroups is a comma-separated list</div><div class=\"line\">        if (gids != null &amp;&amp; gids.length &gt; 0) &#123;</div><div class=\"line\">            StringBuilder sb = new StringBuilder();</div><div class=\"line\">            sb.append(&quot;--setgroups=&quot;);</div><div class=\"line\"></div><div class=\"line\">            int sz = gids.length;</div><div class=\"line\">            for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">                if (i != 0) &#123;</div><div class=\"line\">                    sb.append(&apos;,&apos;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                sb.append(gids[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            argsForZygote.add(sb.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (niceName != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--nice-name=&quot; + niceName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (seInfo != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--seinfo=&quot; + seInfo);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (instructionSet != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--instruction-set=&quot; + instructionSet);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (appDataDir != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        argsForZygote.add(processClass);</div><div class=\"line\"></div><div class=\"line\">        if (extraArgs != null) &#123;</div><div class=\"line\">            for (String arg : extraArgs) &#123;</div><div class=\"line\">                argsForZygote.add(arg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？</p>\n<h3 id=\"3-Process-openZygoteSocketIfNeeded\"><a href=\"#3-Process-openZygoteSocketIfNeeded\" class=\"headerlink\" title=\"3.Process#openZygoteSocketIfNeeded\"></a>3.Process#openZygoteSocketIfNeeded</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (primaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return primaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The primary zygote didn&apos;t match. Try the secondary.</div><div class=\"line\">    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (secondaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return secondaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。</p>\n<h3 id=\"4-Process-zygoteSendArgsAndGetResult\"><a href=\"#4-Process-zygoteSendArgsAndGetResult\" class=\"headerlink\" title=\"4. Process#zygoteSendArgsAndGetResult\"></a>4. Process#zygoteSendArgsAndGetResult</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">final BufferedWriter writer = zygoteState.writer;</div><div class=\"line\">final DataInputStream inputStream = zygoteState.inputStream;</div><div class=\"line\"></div><div class=\"line\">writer.write(Integer.toString(args.size()));</div><div class=\"line\">writer.newLine();</div><div class=\"line\"></div><div class=\"line\">int sz = args.size();</div><div class=\"line\">for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">    String arg = args.get(i);</div><div class=\"line\">    if (arg.indexOf(&apos;\\n&apos;) &gt;= 0) &#123;</div><div class=\"line\">        throw new ZygoteStartFailedEx(</div><div class=\"line\">                &quot;embedded newlines not allowed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    writer.write(arg);</div><div class=\"line\">    writer.newLine();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">writer.flush();</div><div class=\"line\"></div><div class=\"line\">// Should there be a timeout on this?</div><div class=\"line\">ProcessStartResult result = new ProcessStartResult();</div><div class=\"line\">result.pid = inputStream.readInt();</div><div class=\"line\">if (result.pid &lt; 0) &#123;</div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">result.usingWrapper = inputStream.readBoolean();</div><div class=\"line\">return result;</div></pre></td></tr></table></figure>\n<p>在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。</p>\n<p>那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。</p>\n<h3 id=\"5-ZygoteInit-runSelectLoop\"><a href=\"#5-ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"5. ZygoteInit#runSelectLoop\"></a>5. ZygoteInit#runSelectLoop</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</div><div class=\"line\">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</div><div class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</div><div class=\"line\"></div><div class=\"line\">    fds.add(sServerSocket.getFileDescriptor());</div><div class=\"line\">    peers.add(null);</div><div class=\"line\"></div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</div><div class=\"line\">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</div><div class=\"line\">            pollFds[i] = new StructPollfd();</div><div class=\"line\">            pollFds[i].fd = fds.get(i);</div><div class=\"line\">            pollFds[i].events = (short) POLLIN;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.poll(pollFds, -1);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;poll failed&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class=\"line\">                peers.add(newPeer);</div><div class=\"line\">                fds.add(newPeer.getFileDesciptor());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                boolean done = peers.get(i).runOnce();</div><div class=\"line\">                if (done) &#123;</div><div class=\"line\">                    peers.remove(i);</div><div class=\"line\">                    fds.remove(i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。</p>\n<h3 id=\"6-ZygoteConnection-runOnce\"><a href=\"#6-ZygoteConnection-runOnce\" class=\"headerlink\" title=\"6.ZygoteConnection#runOnce\"></a>6.ZygoteConnection#runOnce</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">     String args[];</div><div class=\"line\">     Arguments parsedArgs = null;</div><div class=\"line\">     FileDescriptor[] descriptors;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         args = readArgumentList();</div><div class=\"line\">         descriptors = mSocket.getAncillaryFileDescriptors();</div><div class=\"line\">     &#125; catch (IOException ex) &#123;</div><div class=\"line\">         Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage());</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     if (args == null) &#123;</div><div class=\"line\">         // EOF reached.</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     /** the stderr of the most recent request, if avail */</div><div class=\"line\">     PrintStream newStderr = null;</div><div class=\"line\"></div><div class=\"line\">     if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123;</div><div class=\"line\">         newStderr = new PrintStream(</div><div class=\"line\">                 new FileOutputStream(descriptors[2]));</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     int pid = -1;</div><div class=\"line\">     FileDescriptor childPipeFd = null;</div><div class=\"line\">     FileDescriptor serverPipeFd = null;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         parsedArgs = new Arguments(args);</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.abiListQuery) &#123;</div><div class=\"line\">             return handleAbiListQuery();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123;</div><div class=\"line\">             throw new ZygoteSecurityException(&quot;Client may not specify capabilities: &quot; +</div><div class=\"line\">                     &quot;permitted=0x&quot; + Long.toHexString(parsedArgs.permittedCapabilities) +</div><div class=\"line\">                     &quot;, effective=0x&quot; + Long.toHexString(parsedArgs.effectiveCapabilities));</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         applyUidSecurityPolicy(parsedArgs, peer);</div><div class=\"line\">         applyInvokeWithSecurityPolicy(parsedArgs, peer);</div><div class=\"line\"></div><div class=\"line\">         applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">         applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">         int[][] rlimits = null;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.rlimits != null) &#123;</div><div class=\"line\">             rlimits = parsedArgs.rlimits.toArray(intArray2d);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">             FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</div><div class=\"line\">             childPipeFd = pipeFds[1];</div><div class=\"line\">             serverPipeFd = pipeFds[0];</div><div class=\"line\">             Os.fcntlInt(childPipeFd, F_SETFD, 0);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         /**</div><div class=\"line\">          * In order to avoid leaking descriptors to the Zygote child,</div><div class=\"line\">          * the native code must close the two Zygote socket descriptors</div><div class=\"line\">          * in the child process before it switches from Zygote-root to</div><div class=\"line\">          * the UID and privileges of the application being launched.</div><div class=\"line\">          *</div><div class=\"line\">          * In order to avoid &quot;bad file descriptor&quot; errors when the</div><div class=\"line\">          * two LocalSocket objects are closed, the Posix file</div><div class=\"line\">          * descriptors are released via a dup2() call which closes</div><div class=\"line\">          * the socket and substitutes an open descriptor to /dev/null.</div><div class=\"line\">          */</div><div class=\"line\"></div><div class=\"line\">         int [] fdsToClose = &#123; -1, -1 &#125;;</div><div class=\"line\"></div><div class=\"line\">         FileDescriptor fd = mSocket.getFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[0] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = ZygoteInit.getServerSocketFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[1] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = null;</div><div class=\"line\"></div><div class=\"line\">         pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class=\"line\">                 parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class=\"line\">                 parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class=\"line\">                 parsedArgs.appDataDir);</div><div class=\"line\">     &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex);</div><div class=\"line\">     &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex);</div><div class=\"line\">     &#125; catch (ZygoteSecurityException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr,</div><div class=\"line\">                 &quot;Zygote security policy prevents request: &quot;, ex);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (pid == 0) &#123;</div><div class=\"line\">             // in child</div><div class=\"line\">             IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">             serverPipeFd = null;</div><div class=\"line\">             handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">             // should never get here, the child is expected to either</div><div class=\"line\">             // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">             return true;</div><div class=\"line\">         &#125; else &#123;</div><div class=\"line\">             // in parent...pid of &lt; 0 means failure</div><div class=\"line\">             IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">             childPipeFd = null;</div><div class=\"line\">             return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">         IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>readArgumentList读区启动参数</li>\n<li>构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数</li>\n<li>随后进行参数检查和配置</li>\n<li>调用Zygote.forkAndSpecialize进行fork进程，返回进程id</li>\n</ul>\n<h3 id=\"7-Zygote-forkAndSpecialize\"><a href=\"#7-Zygote-forkAndSpecialize\" class=\"headerlink\" title=\"7.Zygote#forkAndSpecialize\"></a>7.Zygote#forkAndSpecialize</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();</div><div class=\"line\">    int pid = nativeForkAndSpecialize(</div><div class=\"line\">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class=\"line\">              instructionSet, appDataDir);</div><div class=\"line\">    // Enable tracing as soon as possible for the child process.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\"></div><div class=\"line\">        // Note that this event ends at the end of handleChildProc,</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon();</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>VM_HOOKS是ZygoteHooks</li>\n<li><p>在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePreFork, &quot;()J&quot;),</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, &quot;(JILjava/lang/String;)V&quot;),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。</p>\n</li>\n<li>调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。</li>\n</ul>\n<h3 id=\"8-nativePreFork\"><a href=\"#8-nativePreFork\" class=\"headerlink\" title=\"8. nativePreFork\"></a>8. nativePreFork</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</div><div class=\"line\">  Runtime* runtime = Runtime::Current();</div><div class=\"line\">  CHECK(runtime-&gt;IsZygote()) &lt;&lt; &quot;runtime instance not started with -Xzygote&quot;;</div><div class=\"line\"></div><div class=\"line\">  runtime-&gt;PreZygoteFork();</div><div class=\"line\"></div><div class=\"line\">  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</div><div class=\"line\">    // Tracing active, pause it.</div><div class=\"line\">    Trace::Pause();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.</div><div class=\"line\">  return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略</p>\n<h3 id=\"9-nativeForkAndSpecialize\"><a href=\"#9-nativeForkAndSpecialize\" class=\"headerlink\" title=\"9. nativeForkAndSpecialize\"></a>9. nativeForkAndSpecialize</h3><p>在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div></pre></td><td class=\"code\"><pre><div class=\"line\">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</div><div class=\"line\">                                     jint debug_flags, jobjectArray javaRlimits,</div><div class=\"line\">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</div><div class=\"line\">                                     jint mount_external,</div><div class=\"line\">                                     jstring java_se_info, jstring java_se_name,</div><div class=\"line\">                                     bool is_system_server, jintArray fdsToClose,</div><div class=\"line\">                                     jstring instructionSet, jstring dataDir) &#123;</div><div class=\"line\">  SetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">  pid_t pid = fork();</div><div class=\"line\"></div><div class=\"line\">  if (pid == 0) &#123;</div><div class=\"line\">    // The child process.</div><div class=\"line\">    gMallocLeakZygoteChild = 1;</div><div class=\"line\"></div><div class=\"line\">    // Clean up any descriptors which must be closed immediately</div><div class=\"line\">    DetachDescriptors(env, fdsToClose);</div><div class=\"line\"></div><div class=\"line\">    // Keep capabilities across UID change, unless we&apos;re staying root.</div><div class=\"line\">    if (uid != 0) &#123;</div><div class=\"line\">      EnableKeepCapabilities(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    DropCapabilitiesBoundingSet(env);</div><div class=\"line\"></div><div class=\"line\">    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)</div><div class=\"line\">        &amp;&amp; android::NativeBridgeAvailable();</div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (use_native_bridge &amp;&amp; dataDir == NULL) &#123;</div><div class=\"line\">      // dataDir should never be null if we need to use a native bridge.</div><div class=\"line\">      // In general, dataDir will never be null for normal applications. It can only happen in</div><div class=\"line\">      // special cases (for isolated processes which are not associated with any app). These are</div><div class=\"line\">      // launched by the framework and should not be emulated anyway.</div><div class=\"line\">      use_native_bridge = false;</div><div class=\"line\">      ALOGW(&quot;Native bridge will not be used because dataDir == NULL.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</div><div class=\"line\">      ALOGW(&quot;Failed to mount emulated storage: %s&quot;, strerror(errno));</div><div class=\"line\">      if (errno == ENOTCONN || errno == EROFS) &#123;</div><div class=\"line\">        // When device is actively encrypting, we get ENOTCONN here</div><div class=\"line\">        // since FUSE was mounted before the framework restarted.</div><div class=\"line\">        // When encrypted device is booting, we get EROFS since</div><div class=\"line\">        // FUSE hasn&apos;t been created yet by init.</div><div class=\"line\">        // In either case, continue without external storage.</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        ALOGE(&quot;Cannot continue without emulated storage&quot;);</div><div class=\"line\">        RuntimeAbort(env);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!is_system_server) &#123;</div><div class=\"line\">        int rc = createProcessGroup(uid, getpid());</div><div class=\"line\">        if (rc != 0) &#123;</div><div class=\"line\">            if (rc == -EROFS) &#123;</div><div class=\"line\">                ALOGW(&quot;createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                ALOGE(&quot;createProcessGroup(%d, %d) failed: %s&quot;, uid, pid, strerror(-rc));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetGids(env, javaGids);</div><div class=\"line\"></div><div class=\"line\">    SetRLimits(env, javaRlimits);</div><div class=\"line\"></div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      ScopedUtfChars data_dir(env, dataDir);</div><div class=\"line\">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int rc = setresgid(gid, gid, gid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresgid(%d) failed: %s&quot;, gid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    rc = setresuid(uid, uid, uid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresuid(%d) failed: %s&quot;, uid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (NeedsNoRandomizeWorkaround()) &#123;</div><div class=\"line\">        // Work around ARM kernel ASLR lossage (http://b/5817320).</div><div class=\"line\">        int old_personality = personality(0xffffffff);</div><div class=\"line\">        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</div><div class=\"line\">        if (new_personality == -1) &#123;</div><div class=\"line\">            ALOGW(&quot;personality(%d) failed: %s&quot;, new_personality, strerror(errno));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</div><div class=\"line\"></div><div class=\"line\">    SetSchedulerPolicy(env);</div><div class=\"line\"></div><div class=\"line\">    const char* se_info_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_info = NULL;</div><div class=\"line\">    if (java_se_info != NULL) &#123;</div><div class=\"line\">        se_info = new ScopedUtfChars(env, java_se_info);</div><div class=\"line\">        se_info_c_str = se_info-&gt;c_str();</div><div class=\"line\">        if (se_info_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_info_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const char* se_name_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_name = NULL;</div><div class=\"line\">    if (java_se_name != NULL) &#123;</div><div class=\"line\">        se_name = new ScopedUtfChars(env, java_se_name);</div><div class=\"line\">        se_name_c_str = se_name-&gt;c_str();</div><div class=\"line\">        if (se_name_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_name_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;selinux_android_setcontext(%d, %d, \\&quot;%s\\&quot;, \\&quot;%s\\&quot;) failed&quot;, uid,</div><div class=\"line\">            is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Make it easier to debug audit logs by setting the main thread&apos;s name to the</div><div class=\"line\">    // nice name rather than &quot;app_process&quot;.</div><div class=\"line\">    if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</div><div class=\"line\">      se_name_c_str = &quot;system_server&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (se_info_c_str != NULL) &#123;</div><div class=\"line\">      SetThreadName(se_name_c_str);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    delete se_info;</div><div class=\"line\">    delete se_name;</div><div class=\"line\"></div><div class=\"line\">    UnsetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</div><div class=\"line\">                              is_system_server ? NULL : instructionSet);</div><div class=\"line\">    if (env-&gt;ExceptionCheck()) &#123;</div><div class=\"line\">      ALOGE(&quot;Error calling post fork hooks.&quot;);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else if (pid &gt; 0) &#123;</div><div class=\"line\">    // the parent process</div><div class=\"line\">  &#125;</div><div class=\"line\">  return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>设置子进程的signal信号处理函数 SetSigChldHandler函数</li>\n<li>fork进程，fork函数</li>\n<li>pid为0，进入子进程<ul>\n<li>DetachDescriptors 关闭清理文件描述符</li>\n<li>SetGids 设置group</li>\n<li>SetRLimits 设置资源限制</li>\n<li>进行其他的初始化设置</li>\n<li>CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。</li>\n<li>…</li>\n</ul>\n</li>\n<li>父进程分支，啥也不做</li>\n<li>返回pid<br>当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        // in child</div><div class=\"line\">        IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">        serverPipeFd = null;</div><div class=\"line\">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">        // should never get here, the child is expected to either</div><div class=\"line\">        // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // in parent...pid of &lt; 0 means failure</div><div class=\"line\">        IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">        childPipeFd = null;</div><div class=\"line\">        return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">    IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们重点看handleChildProc。</p>\n<h3 id=\"10-ZygoteConnection-handleChildProc\"><a href=\"#10-ZygoteConnection-handleChildProc\" class=\"headerlink\" title=\"10.ZygoteConnection#handleChildProc\"></a>10.ZygoteConnection#handleChildProc</h3><p>在这个方法中，有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">    WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">            parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">            VMRuntime.getCurrentInstructionSet(),</div><div class=\"line\">            pipeFd, parsedArgs.remainingArgs);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</div><div class=\"line\">            parsedArgs.remainingArgs, null /* classLoader */);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大部分情况下，invokeWith为null，所以我们看下面的分支。</p>\n<h3 id=\"11-RuntimeInit-zygoteInit\"><a href=\"#11-RuntimeInit-zygoteInit\" class=\"headerlink\" title=\"11.RuntimeInit.zygoteInit\"></a>11.RuntimeInit.zygoteInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</div><div class=\"line\"></div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</div><div class=\"line\">    redirectLogStreams();</div><div class=\"line\"></div><div class=\"line\">    commonInit();</div><div class=\"line\">    nativeZygoteInit();</div><div class=\"line\">    applicationInit(targetSdkVersion, argv, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>重定向log输出</li>\n<li>commonInit,进行通用的一些设置如时区。</li>\n<li>zygote初始化</li>\n<li>应用初始化</li>\n</ul>\n<h3 id=\"12-nativeZygoteInit\"><a href=\"#12-nativeZygoteInit\" class=\"headerlink\" title=\"12.nativeZygoteInit\"></a>12.nativeZygoteInit</h3><p>该函数的实现在AndroidRuntime.cpp中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</div><div class=\"line\">&#123;</div><div class=\"line\">    gCurRuntime-&gt;onZygoteInit();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里onZygoteInit在app_main.cpp中，这里就不多说了。</p>\n<h3 id=\"13-RuntimeInit-applicationInit\"><a href=\"#13-RuntimeInit-applicationInit\" class=\"headerlink\" title=\"13.RuntimeInit.applicationInit\"></a>13.RuntimeInit.applicationInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    // If the application calls System.exit(), terminate the process</div><div class=\"line\">    // immediately without running any shutdown hooks.  It is not possible to</div><div class=\"line\">    // shutdown an Android application gracefully.  Among other things, the</div><div class=\"line\">    // Android runtime shutdown hooks close the Binder driver, which can cause</div><div class=\"line\">    // leftover running threads to crash before the process actually exits.</div><div class=\"line\">    nativeSetExitWithoutCleanup(true);</div><div class=\"line\"></div><div class=\"line\">    // We want to be fairly aggressive about heap utilization, to avoid</div><div class=\"line\">    // holding on to a lot of memory that isn&apos;t needed.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</div><div class=\"line\">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">    final Arguments args;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        args = new Arguments(argv);</div><div class=\"line\">    &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">        Slog.e(TAG, ex.getMessage());</div><div class=\"line\">        // let the process exit</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The end of of the RuntimeInit event (see #zygoteInit).</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class=\"line\"></div><div class=\"line\">    // Remaining arguments are passed to the start class&apos;s static main</div><div class=\"line\">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    Class&lt;?&gt; cl;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        cl = Class.forName(className, true, classLoader);</div><div class=\"line\">    &#125; catch (ClassNotFoundException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing class when invoking static main &quot; + className,</div><div class=\"line\">                ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Method m;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</div><div class=\"line\">    &#125; catch (NoSuchMethodException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing static main on &quot; + className, ex);</div><div class=\"line\">    &#125; catch (SecurityException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Problem getting static main on &quot; + className, ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int modifiers = m.getModifiers();</div><div class=\"line\">    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Main method is not public and static on &quot; + className);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * This throw gets caught in ZygoteInit.main(), which responds</div><div class=\"line\">     * by invoking the exception&apos;s run() method. This arrangement</div><div class=\"line\">     * clears up all the stack frames that were required in setting</div><div class=\"line\">     * up the process.</div><div class=\"line\">     */</div><div class=\"line\">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</div><div class=\"line\">    &#125; catch (IllegalAccessException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125; catch (InvocationTargetException ex) &#123;</div><div class=\"line\">        Throwable cause = ex.getCause();</div><div class=\"line\">        if (cause instanceof RuntimeException) &#123;</div><div class=\"line\">            throw (RuntimeException) cause;</div><div class=\"line\">        &#125; else if (cause instanceof Error) &#123;</div><div class=\"line\">            throw (Error) cause;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：</p>\n<p>在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>我们在了解了四大组件之后，有必要去了解下进程是如何启动的，毕竟，进程是一个很重要的感念。我们知道，我们可以在配置文件中，通过process属性指定进程。在ams中，如果组件需要运行在一个新的进程中，这时候就会去新建进程。让我们看下代码。</p>","more":"<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</div><div class=\"line\">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</div><div class=\"line\">        app.processName);</div><div class=\"line\">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</div><div class=\"line\">Process.ProcessStartResult startResult = Process.start(entryPoint,</div><div class=\"line\">        app.processName, uid, uid, gids, debugFlags, mountExternal,</div><div class=\"line\">        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</div><div class=\"line\">        app.info.dataDir, entryPointArgs);</div></pre></td></tr></table></figure>\n<ul>\n<li>其中entryPoint是进程的运行入口</li>\n</ul>\n<h3 id=\"2-Process-start\"><a href=\"#2-Process-start\" class=\"headerlink\" title=\"2.Process#start\"></a>2.Process#start</h3><p>在start方法中，会调用startViaZygote方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static ProcessStartResult startViaZygote(final String processClass,</div><div class=\"line\">                              final String niceName,</div><div class=\"line\">                              final int uid, final int gid,</div><div class=\"line\">                              final int[] gids,</div><div class=\"line\">                              int debugFlags, int mountExternal,</div><div class=\"line\">                              int targetSdkVersion,</div><div class=\"line\">                              String seInfo,</div><div class=\"line\">                              String abi,</div><div class=\"line\">                              String instructionSet,</div><div class=\"line\">                              String appDataDir,</div><div class=\"line\">                              String[] extraArgs)</div><div class=\"line\">                              throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    synchronized(Process.class) &#123;</div><div class=\"line\">        ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</div><div class=\"line\"></div><div class=\"line\">        // --runtime-args, --setuid=, --setgid=,</div><div class=\"line\">        // and --setgroups= must go first</div><div class=\"line\">        argsForZygote.add(&quot;--runtime-args&quot;);</div><div class=\"line\">        argsForZygote.add(&quot;--setuid=&quot; + uid);</div><div class=\"line\">        argsForZygote.add(&quot;--setgid=&quot; + gid);</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jni-logging&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-safemode&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-checkjni&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-jit&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--generate-debug-info&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--enable-assert&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-default&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-read&quot;);</div><div class=\"line\">        &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--mount-external-write&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">        //TODO optionally enable debuger</div><div class=\"line\">        //argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class=\"line\"></div><div class=\"line\">        // --setgroups is a comma-separated list</div><div class=\"line\">        if (gids != null &amp;&amp; gids.length &gt; 0) &#123;</div><div class=\"line\">            StringBuilder sb = new StringBuilder();</div><div class=\"line\">            sb.append(&quot;--setgroups=&quot;);</div><div class=\"line\"></div><div class=\"line\">            int sz = gids.length;</div><div class=\"line\">            for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">                if (i != 0) &#123;</div><div class=\"line\">                    sb.append(&apos;,&apos;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                sb.append(gids[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            argsForZygote.add(sb.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (niceName != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--nice-name=&quot; + niceName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (seInfo != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--seinfo=&quot; + seInfo);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (instructionSet != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--instruction-set=&quot; + instructionSet);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (appDataDir != null) &#123;</div><div class=\"line\">            argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        argsForZygote.add(processClass);</div><div class=\"line\"></div><div class=\"line\">        if (extraArgs != null) &#123;</div><div class=\"line\">            for (String arg : extraArgs) &#123;</div><div class=\"line\">                argsForZygote.add(arg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在经过一系列参数设置之后，会调用zygoteSendArgsAndGetResult方法，这里需要两个参数，一个是ZygoteState，通过openZygoteSocketIfNeeded函数返回，另一个就是启动配置。接下来就看下openZygoteSocketIfNeeded干了什么？</p>\n<h3 id=\"3-Process-openZygoteSocketIfNeeded\"><a href=\"#3-Process-openZygoteSocketIfNeeded\" class=\"headerlink\" title=\"3.Process#openZygoteSocketIfNeeded\"></a>3.Process#openZygoteSocketIfNeeded</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</div><div class=\"line\">    if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (primaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return primaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The primary zygote didn&apos;t match. Try the secondary.</div><div class=\"line\">    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (secondaryZygoteState.matches(abi)) &#123;</div><div class=\"line\">        return secondaryZygoteState;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这个方法会根据需要是否开启和zygote进程的socket通道，去做操作。在这里能看到两种不同的，这里是因为android5.0开始，支持64位编译，上面分别对应32和64，这里就不说多了。这里通过ZygoteState的connect方法，去链接到在zygote进程中的server端。</p>\n<h3 id=\"4-Process-zygoteSendArgsAndGetResult\"><a href=\"#4-Process-zygoteSendArgsAndGetResult\" class=\"headerlink\" title=\"4. Process#zygoteSendArgsAndGetResult\"></a>4. Process#zygoteSendArgsAndGetResult</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">final BufferedWriter writer = zygoteState.writer;</div><div class=\"line\">final DataInputStream inputStream = zygoteState.inputStream;</div><div class=\"line\"></div><div class=\"line\">writer.write(Integer.toString(args.size()));</div><div class=\"line\">writer.newLine();</div><div class=\"line\"></div><div class=\"line\">int sz = args.size();</div><div class=\"line\">for (int i = 0; i &lt; sz; i++) &#123;</div><div class=\"line\">    String arg = args.get(i);</div><div class=\"line\">    if (arg.indexOf(&apos;\\n&apos;) &gt;= 0) &#123;</div><div class=\"line\">        throw new ZygoteStartFailedEx(</div><div class=\"line\">                &quot;embedded newlines not allowed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    writer.write(arg);</div><div class=\"line\">    writer.newLine();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">writer.flush();</div><div class=\"line\"></div><div class=\"line\">// Should there be a timeout on this?</div><div class=\"line\">ProcessStartResult result = new ProcessStartResult();</div><div class=\"line\">result.pid = inputStream.readInt();</div><div class=\"line\">if (result.pid &lt; 0) &#123;</div><div class=\"line\">    throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">result.usingWrapper = inputStream.readBoolean();</div><div class=\"line\">return result;</div></pre></td></tr></table></figure>\n<p>在这个方法中，向socke通道写入进程启动参数，等待socket server相应并返回，读取返回结果。</p>\n<p>那么，现在我们就需要这里socket服务端的处理。因为这里没有分析zygote进程的启动，所以讲起来比较麻烦，直接告诉大家，其socket服务端实现在ZygoteInit中，在mian方法中，会调用registerZygoteSocket方法去启动socket server。在然后会调用runSelectLoop方法，去等待socket客户端的连接。</p>\n<h3 id=\"5-ZygoteInit-runSelectLoop\"><a href=\"#5-ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"5. ZygoteInit#runSelectLoop\"></a>5. ZygoteInit#runSelectLoop</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</div><div class=\"line\">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</div><div class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</div><div class=\"line\"></div><div class=\"line\">    fds.add(sServerSocket.getFileDescriptor());</div><div class=\"line\">    peers.add(null);</div><div class=\"line\"></div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</div><div class=\"line\">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</div><div class=\"line\">            pollFds[i] = new StructPollfd();</div><div class=\"line\">            pollFds[i].fd = fds.get(i);</div><div class=\"line\">            pollFds[i].events = (short) POLLIN;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.poll(pollFds, -1);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;poll failed&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class=\"line\">                peers.add(newPeer);</div><div class=\"line\">                fds.add(newPeer.getFileDesciptor());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                boolean done = peers.get(i).runOnce();</div><div class=\"line\">                if (done) &#123;</div><div class=\"line\">                    peers.remove(i);</div><div class=\"line\">                    fds.remove(i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先会通过Os.poll等待事件的到来，这里应该是用的poll模型，然后处理，当i=0的时候，为socket请求连接的事件，这时会调用acceptCommandPeer与客户端建立一个连接，然后加入监听数组，等待参数的到来，一旦i!=0,则为参数到来，那么，就调用runOnce去处理参数。完成之后，移除连接、移除监听。</p>\n<h3 id=\"6-ZygoteConnection-runOnce\"><a href=\"#6-ZygoteConnection-runOnce\" class=\"headerlink\" title=\"6.ZygoteConnection#runOnce\"></a>6.ZygoteConnection#runOnce</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">     String args[];</div><div class=\"line\">     Arguments parsedArgs = null;</div><div class=\"line\">     FileDescriptor[] descriptors;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         args = readArgumentList();</div><div class=\"line\">         descriptors = mSocket.getAncillaryFileDescriptors();</div><div class=\"line\">     &#125; catch (IOException ex) &#123;</div><div class=\"line\">         Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage());</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     if (args == null) &#123;</div><div class=\"line\">         // EOF reached.</div><div class=\"line\">         closeSocket();</div><div class=\"line\">         return true;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     /** the stderr of the most recent request, if avail */</div><div class=\"line\">     PrintStream newStderr = null;</div><div class=\"line\"></div><div class=\"line\">     if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123;</div><div class=\"line\">         newStderr = new PrintStream(</div><div class=\"line\">                 new FileOutputStream(descriptors[2]));</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     int pid = -1;</div><div class=\"line\">     FileDescriptor childPipeFd = null;</div><div class=\"line\">     FileDescriptor serverPipeFd = null;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         parsedArgs = new Arguments(args);</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.abiListQuery) &#123;</div><div class=\"line\">             return handleAbiListQuery();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123;</div><div class=\"line\">             throw new ZygoteSecurityException(&quot;Client may not specify capabilities: &quot; +</div><div class=\"line\">                     &quot;permitted=0x&quot; + Long.toHexString(parsedArgs.permittedCapabilities) +</div><div class=\"line\">                     &quot;, effective=0x&quot; + Long.toHexString(parsedArgs.effectiveCapabilities));</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         applyUidSecurityPolicy(parsedArgs, peer);</div><div class=\"line\">         applyInvokeWithSecurityPolicy(parsedArgs, peer);</div><div class=\"line\"></div><div class=\"line\">         applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">         applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">         int[][] rlimits = null;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.rlimits != null) &#123;</div><div class=\"line\">             rlimits = parsedArgs.rlimits.toArray(intArray2d);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">             FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</div><div class=\"line\">             childPipeFd = pipeFds[1];</div><div class=\"line\">             serverPipeFd = pipeFds[0];</div><div class=\"line\">             Os.fcntlInt(childPipeFd, F_SETFD, 0);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         /**</div><div class=\"line\">          * In order to avoid leaking descriptors to the Zygote child,</div><div class=\"line\">          * the native code must close the two Zygote socket descriptors</div><div class=\"line\">          * in the child process before it switches from Zygote-root to</div><div class=\"line\">          * the UID and privileges of the application being launched.</div><div class=\"line\">          *</div><div class=\"line\">          * In order to avoid &quot;bad file descriptor&quot; errors when the</div><div class=\"line\">          * two LocalSocket objects are closed, the Posix file</div><div class=\"line\">          * descriptors are released via a dup2() call which closes</div><div class=\"line\">          * the socket and substitutes an open descriptor to /dev/null.</div><div class=\"line\">          */</div><div class=\"line\"></div><div class=\"line\">         int [] fdsToClose = &#123; -1, -1 &#125;;</div><div class=\"line\"></div><div class=\"line\">         FileDescriptor fd = mSocket.getFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[0] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = ZygoteInit.getServerSocketFileDescriptor();</div><div class=\"line\"></div><div class=\"line\">         if (fd != null) &#123;</div><div class=\"line\">             fdsToClose[1] = fd.getInt$();</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         fd = null;</div><div class=\"line\"></div><div class=\"line\">         pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class=\"line\">                 parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class=\"line\">                 parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class=\"line\">                 parsedArgs.appDataDir);</div><div class=\"line\">     &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex);</div><div class=\"line\">     &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex);</div><div class=\"line\">     &#125; catch (ZygoteSecurityException ex) &#123;</div><div class=\"line\">         logAndPrintError(newStderr,</div><div class=\"line\">                 &quot;Zygote security policy prevents request: &quot;, ex);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     try &#123;</div><div class=\"line\">         if (pid == 0) &#123;</div><div class=\"line\">             // in child</div><div class=\"line\">             IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">             serverPipeFd = null;</div><div class=\"line\">             handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">             // should never get here, the child is expected to either</div><div class=\"line\">             // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">             return true;</div><div class=\"line\">         &#125; else &#123;</div><div class=\"line\">             // in parent...pid of &lt; 0 means failure</div><div class=\"line\">             IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">             childPipeFd = null;</div><div class=\"line\">             return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125; finally &#123;</div><div class=\"line\">         IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">         IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>readArgumentList读区启动参数</li>\n<li>构造Arguments，在这个的构造函数中，会调用parseArgs去解析参数</li>\n<li>随后进行参数检查和配置</li>\n<li>调用Zygote.forkAndSpecialize进行fork进程，返回进程id</li>\n</ul>\n<h3 id=\"7-Zygote-forkAndSpecialize\"><a href=\"#7-Zygote-forkAndSpecialize\" class=\"headerlink\" title=\"7.Zygote#forkAndSpecialize\"></a>7.Zygote#forkAndSpecialize</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();</div><div class=\"line\">    int pid = nativeForkAndSpecialize(</div><div class=\"line\">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class=\"line\">              instructionSet, appDataDir);</div><div class=\"line\">    // Enable tracing as soon as possible for the child process.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\"></div><div class=\"line\">        // Note that this event ends at the end of handleChildProc,</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon();</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>VM_HOOKS是ZygoteHooks</li>\n<li><p>在preFork中，会中断HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon，这四个守护线程。并调用nativePreFork在native层做一些fork之前的操作。其对应实现在daivik_system_ZygoteHocks.cc文件中，函数对应表如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePreFork, &quot;()J&quot;),</div><div class=\"line\">  NATIVE_METHOD(ZygoteHooks, nativePostForkChild, &quot;(JILjava/lang/String;)V&quot;),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后调用nativeForkAndSpecialize去fork进程，对应实现在com_android_internal_os_Zygote.cpp中。</p>\n</li>\n<li>调用VM_HOOKS的postForkCommon，去启动先前中断的几个线程。</li>\n</ul>\n<h3 id=\"8-nativePreFork\"><a href=\"#8-nativePreFork\" class=\"headerlink\" title=\"8. nativePreFork\"></a>8. nativePreFork</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</div><div class=\"line\">  Runtime* runtime = Runtime::Current();</div><div class=\"line\">  CHECK(runtime-&gt;IsZygote()) &lt;&lt; &quot;runtime instance not started with -Xzygote&quot;;</div><div class=\"line\"></div><div class=\"line\">  runtime-&gt;PreZygoteFork();</div><div class=\"line\"></div><div class=\"line\">  if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</div><div class=\"line\">    // Tracing active, pause it.</div><div class=\"line\">    Trace::Pause();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.</div><div class=\"line\">  return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里会调用runtime、runtime中调用heap，最终调用heap的PreZygoteFork方法。去做一些初始化操作，本人太渣，看不太懂。略</p>\n<h3 id=\"9-nativeForkAndSpecialize\"><a href=\"#9-nativeForkAndSpecialize\" class=\"headerlink\" title=\"9. nativeForkAndSpecialize\"></a>9. nativeForkAndSpecialize</h3><p>在com_android_internal_os_Zygote_nativeForkAndSpecialize方法中，会调用ForkAndSpecializeCommon。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div></pre></td><td class=\"code\"><pre><div class=\"line\">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</div><div class=\"line\">                                     jint debug_flags, jobjectArray javaRlimits,</div><div class=\"line\">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</div><div class=\"line\">                                     jint mount_external,</div><div class=\"line\">                                     jstring java_se_info, jstring java_se_name,</div><div class=\"line\">                                     bool is_system_server, jintArray fdsToClose,</div><div class=\"line\">                                     jstring instructionSet, jstring dataDir) &#123;</div><div class=\"line\">  SetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">  pid_t pid = fork();</div><div class=\"line\"></div><div class=\"line\">  if (pid == 0) &#123;</div><div class=\"line\">    // The child process.</div><div class=\"line\">    gMallocLeakZygoteChild = 1;</div><div class=\"line\"></div><div class=\"line\">    // Clean up any descriptors which must be closed immediately</div><div class=\"line\">    DetachDescriptors(env, fdsToClose);</div><div class=\"line\"></div><div class=\"line\">    // Keep capabilities across UID change, unless we&apos;re staying root.</div><div class=\"line\">    if (uid != 0) &#123;</div><div class=\"line\">      EnableKeepCapabilities(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    DropCapabilitiesBoundingSet(env);</div><div class=\"line\"></div><div class=\"line\">    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)</div><div class=\"line\">        &amp;&amp; android::NativeBridgeAvailable();</div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (use_native_bridge &amp;&amp; dataDir == NULL) &#123;</div><div class=\"line\">      // dataDir should never be null if we need to use a native bridge.</div><div class=\"line\">      // In general, dataDir will never be null for normal applications. It can only happen in</div><div class=\"line\">      // special cases (for isolated processes which are not associated with any app). These are</div><div class=\"line\">      // launched by the framework and should not be emulated anyway.</div><div class=\"line\">      use_native_bridge = false;</div><div class=\"line\">      ALOGW(&quot;Native bridge will not be used because dataDir == NULL.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</div><div class=\"line\">      ALOGW(&quot;Failed to mount emulated storage: %s&quot;, strerror(errno));</div><div class=\"line\">      if (errno == ENOTCONN || errno == EROFS) &#123;</div><div class=\"line\">        // When device is actively encrypting, we get ENOTCONN here</div><div class=\"line\">        // since FUSE was mounted before the framework restarted.</div><div class=\"line\">        // When encrypted device is booting, we get EROFS since</div><div class=\"line\">        // FUSE hasn&apos;t been created yet by init.</div><div class=\"line\">        // In either case, continue without external storage.</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        ALOGE(&quot;Cannot continue without emulated storage&quot;);</div><div class=\"line\">        RuntimeAbort(env);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!is_system_server) &#123;</div><div class=\"line\">        int rc = createProcessGroup(uid, getpid());</div><div class=\"line\">        if (rc != 0) &#123;</div><div class=\"line\">            if (rc == -EROFS) &#123;</div><div class=\"line\">                ALOGW(&quot;createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                ALOGE(&quot;createProcessGroup(%d, %d) failed: %s&quot;, uid, pid, strerror(-rc));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetGids(env, javaGids);</div><div class=\"line\"></div><div class=\"line\">    SetRLimits(env, javaRlimits);</div><div class=\"line\"></div><div class=\"line\">    if (use_native_bridge) &#123;</div><div class=\"line\">      ScopedUtfChars isa_string(env, instructionSet);</div><div class=\"line\">      ScopedUtfChars data_dir(env, dataDir);</div><div class=\"line\">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int rc = setresgid(gid, gid, gid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresgid(%d) failed: %s&quot;, gid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    rc = setresuid(uid, uid, uid);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;setresuid(%d) failed: %s&quot;, uid, strerror(errno));</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (NeedsNoRandomizeWorkaround()) &#123;</div><div class=\"line\">        // Work around ARM kernel ASLR lossage (http://b/5817320).</div><div class=\"line\">        int old_personality = personality(0xffffffff);</div><div class=\"line\">        int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</div><div class=\"line\">        if (new_personality == -1) &#123;</div><div class=\"line\">            ALOGW(&quot;personality(%d) failed: %s&quot;, new_personality, strerror(errno));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</div><div class=\"line\"></div><div class=\"line\">    SetSchedulerPolicy(env);</div><div class=\"line\"></div><div class=\"line\">    const char* se_info_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_info = NULL;</div><div class=\"line\">    if (java_se_info != NULL) &#123;</div><div class=\"line\">        se_info = new ScopedUtfChars(env, java_se_info);</div><div class=\"line\">        se_info_c_str = se_info-&gt;c_str();</div><div class=\"line\">        if (se_info_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_info_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const char* se_name_c_str = NULL;</div><div class=\"line\">    ScopedUtfChars* se_name = NULL;</div><div class=\"line\">    if (java_se_name != NULL) &#123;</div><div class=\"line\">        se_name = new ScopedUtfChars(env, java_se_name);</div><div class=\"line\">        se_name_c_str = se_name-&gt;c_str();</div><div class=\"line\">        if (se_name_c_str == NULL) &#123;</div><div class=\"line\">          ALOGE(&quot;se_name_c_str == NULL&quot;);</div><div class=\"line\">          RuntimeAbort(env);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">    if (rc == -1) &#123;</div><div class=\"line\">      ALOGE(&quot;selinux_android_setcontext(%d, %d, \\&quot;%s\\&quot;, \\&quot;%s\\&quot;) failed&quot;, uid,</div><div class=\"line\">            is_system_server, se_info_c_str, se_name_c_str);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Make it easier to debug audit logs by setting the main thread&apos;s name to the</div><div class=\"line\">    // nice name rather than &quot;app_process&quot;.</div><div class=\"line\">    if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</div><div class=\"line\">      se_name_c_str = &quot;system_server&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (se_info_c_str != NULL) &#123;</div><div class=\"line\">      SetThreadName(se_name_c_str);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    delete se_info;</div><div class=\"line\">    delete se_name;</div><div class=\"line\"></div><div class=\"line\">    UnsetSigChldHandler();</div><div class=\"line\"></div><div class=\"line\">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</div><div class=\"line\">                              is_system_server ? NULL : instructionSet);</div><div class=\"line\">    if (env-&gt;ExceptionCheck()) &#123;</div><div class=\"line\">      ALOGE(&quot;Error calling post fork hooks.&quot;);</div><div class=\"line\">      RuntimeAbort(env);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else if (pid &gt; 0) &#123;</div><div class=\"line\">    // the parent process</div><div class=\"line\">  &#125;</div><div class=\"line\">  return pid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>设置子进程的signal信号处理函数 SetSigChldHandler函数</li>\n<li>fork进程，fork函数</li>\n<li>pid为0，进入子进程<ul>\n<li>DetachDescriptors 关闭清理文件描述符</li>\n<li>SetGids 设置group</li>\n<li>SetRLimits 设置资源限制</li>\n<li>进行其他的初始化设置</li>\n<li>CallStaticVoidMethod，调用ZygotecallPostForkChildHooks方法。这里又会调用nativePostForkChild。</li>\n<li>…</li>\n</ul>\n</li>\n<li>父进程分支，啥也不做</li>\n<li>返回pid<br>当这些都执行完之后，回到ZygoteConnection的runonce方法，进行后续操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        // in child</div><div class=\"line\">        IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">        serverPipeFd = null;</div><div class=\"line\">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class=\"line\"></div><div class=\"line\">        // should never get here, the child is expected to either</div><div class=\"line\">        // throw ZygoteInit.MethodAndArgsCaller or exec().</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // in parent...pid of &lt; 0 means failure</div><div class=\"line\">        IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">        childPipeFd = null;</div><div class=\"line\">        return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    IoUtils.closeQuietly(childPipeFd);</div><div class=\"line\">    IoUtils.closeQuietly(serverPipeFd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们重点看handleChildProc。</p>\n<h3 id=\"10-ZygoteConnection-handleChildProc\"><a href=\"#10-ZygoteConnection-handleChildProc\" class=\"headerlink\" title=\"10.ZygoteConnection#handleChildProc\"></a>10.ZygoteConnection#handleChildProc</h3><p>在这个方法中，有如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">    WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">            parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">            VMRuntime.getCurrentInstructionSet(),</div><div class=\"line\">            pipeFd, parsedArgs.remainingArgs);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</div><div class=\"line\">            parsedArgs.remainingArgs, null /* classLoader */);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大部分情况下，invokeWith为null，所以我们看下面的分支。</p>\n<h3 id=\"11-RuntimeInit-zygoteInit\"><a href=\"#11-RuntimeInit-zygoteInit\" class=\"headerlink\" title=\"11.RuntimeInit.zygoteInit\"></a>11.RuntimeInit.zygoteInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</div><div class=\"line\"></div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</div><div class=\"line\">    redirectLogStreams();</div><div class=\"line\"></div><div class=\"line\">    commonInit();</div><div class=\"line\">    nativeZygoteInit();</div><div class=\"line\">    applicationInit(targetSdkVersion, argv, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>重定向log输出</li>\n<li>commonInit,进行通用的一些设置如时区。</li>\n<li>zygote初始化</li>\n<li>应用初始化</li>\n</ul>\n<h3 id=\"12-nativeZygoteInit\"><a href=\"#12-nativeZygoteInit\" class=\"headerlink\" title=\"12.nativeZygoteInit\"></a>12.nativeZygoteInit</h3><p>该函数的实现在AndroidRuntime.cpp中，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</div><div class=\"line\">&#123;</div><div class=\"line\">    gCurRuntime-&gt;onZygoteInit();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里onZygoteInit在app_main.cpp中，这里就不多说了。</p>\n<h3 id=\"13-RuntimeInit-applicationInit\"><a href=\"#13-RuntimeInit-applicationInit\" class=\"headerlink\" title=\"13.RuntimeInit.applicationInit\"></a>13.RuntimeInit.applicationInit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    // If the application calls System.exit(), terminate the process</div><div class=\"line\">    // immediately without running any shutdown hooks.  It is not possible to</div><div class=\"line\">    // shutdown an Android application gracefully.  Among other things, the</div><div class=\"line\">    // Android runtime shutdown hooks close the Binder driver, which can cause</div><div class=\"line\">    // leftover running threads to crash before the process actually exits.</div><div class=\"line\">    nativeSetExitWithoutCleanup(true);</div><div class=\"line\"></div><div class=\"line\">    // We want to be fairly aggressive about heap utilization, to avoid</div><div class=\"line\">    // holding on to a lot of memory that isn&apos;t needed.</div><div class=\"line\">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</div><div class=\"line\">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">    final Arguments args;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        args = new Arguments(argv);</div><div class=\"line\">    &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">        Slog.e(TAG, ex.getMessage());</div><div class=\"line\">        // let the process exit</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The end of of the RuntimeInit event (see #zygoteInit).</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class=\"line\"></div><div class=\"line\">    // Remaining arguments are passed to the start class&apos;s static main</div><div class=\"line\">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里设置一些参数，并且调用invokeStaticMain，从名字上来看，就知道是调用静态main方法，也就是我们指定的进程入口ActivityThread的main方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\">    Class&lt;?&gt; cl;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        cl = Class.forName(className, true, classLoader);</div><div class=\"line\">    &#125; catch (ClassNotFoundException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing class when invoking static main &quot; + className,</div><div class=\"line\">                ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Method m;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</div><div class=\"line\">    &#125; catch (NoSuchMethodException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Missing static main on &quot; + className, ex);</div><div class=\"line\">    &#125; catch (SecurityException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Problem getting static main on &quot; + className, ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int modifiers = m.getModifiers();</div><div class=\"line\">    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">                &quot;Main method is not public and static on &quot; + className);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * This throw gets caught in ZygoteInit.main(), which responds</div><div class=\"line\">     * by invoking the exception&apos;s run() method. This arrangement</div><div class=\"line\">     * clears up all the stack frames that were required in setting</div><div class=\"line\">     * up the process.</div><div class=\"line\">     */</div><div class=\"line\">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意看最后一行代码的注释，因为我们之前经过了复杂的调用，堆栈信息比较多了，这里通过抛异常处理来清理调用栈。最后调用如下代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</div><div class=\"line\">    &#125; catch (IllegalAccessException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125; catch (InvocationTargetException ex) &#123;</div><div class=\"line\">        Throwable cause = ex.getCause();</div><div class=\"line\">        if (cause instanceof RuntimeException) &#123;</div><div class=\"line\">            throw (RuntimeException) cause;</div><div class=\"line\">        &#125; else if (cause instanceof Error) &#123;</div><div class=\"line\">            throw (Error) cause;</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就这样我们的应用进程就启动起来了。当然，启动应用程序也是这个流程，简单说下吧：</p>\n<p>在点击luncher上的图标，会通过startactivity启动我们的程序，但是，这时候没有进程，通过上面这些繁琐的流程启动之后，在启动activity，这样，应用程序也启动起来了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"Zygote进程的初始化","date":"2017-01-07T06:49:32.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 前言\n\nZygote进程是Android进程中的核心进程，为啥呢？前面介绍过的进程启动篇中，我们知道，我们的应用进程都是在Zygote进程中fork出来的，这难道还不能证明他的重要性么。\n而Zygote进程是在init进程中，通过解析init.rc文件，启动的。我们看下init.rc中相关的部分。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\nimport /init.${ro.zygote}.rc\n```\n\n没错，就是这个，在Android5.0之后，开始支持64位编译，因为我看的源码是6.0的，那么就看下init.zygote64.rc文件吧。\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    socket zygote stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart media\n    onrestart restart netd\n```\n\n根据init.rc语法中service部分\n\n```\nservice <name> <pathname> [ <argument> ]*\n\t<option>\n\t<option>\n```\n可知，上面指定的路径为/system/bin/app_process64，参数为-Xzygote /system/bin --zygote --start-system-server\n\n而android启动中各种命令对应的在/framework/base/cmds下，而这个下面app_process下，只有app_main，一个cpp文件，因此，我么从这个cpp文件说起\n\n### app_main的main函数\n\n代码分段开赛\n\n```\n    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));\n    // Process command line arguments\n    // ignore argv[0]\n    argc--;\n    argv++;\n        int i;\n    for (i = 0; i < argc; i++) {\n        if (argv[i][0] != '-') {\n            break;\n        }\n        if (argv[i][1] == '-' && argv[i][2] == 0) {\n            ++i; // Skip --.\n            break;\n        }\n        runtime.addOption(strdup(argv[i]));\n    }\n```\n\n* 首先创建AppRuntime，也在该文件中，并且保存参数，添加option选项\n\n\n```\n    // Parse runtime arguments.  Stop at first unrecognized option.\n    bool zygote = false;\n    bool startSystemServer = false;\n    bool application = false;\n    String8 niceName;\n    String8 className;\n\n    ++i;  // Skip unused \"parent dir\" argument.\n    while (i < argc) {\n        const char* arg = argv[i++];\n        if (strcmp(arg, \"--zygote\") == 0) {\n            zygote = true;\n            niceName = ZYGOTE_NICE_NAME;\n        } else if (strcmp(arg, \"--start-system-server\") == 0) {\n            startSystemServer = true;\n        } else if (strcmp(arg, \"--application\") == 0) {\n            application = true;\n        } else if (strncmp(arg, \"--nice-name=\", 12) == 0) {\n            niceName.setTo(arg + 12);\n        } else if (strncmp(arg, \"--\", 2) != 0) {\n            className.setTo(arg);\n            break;\n        } else {\n            --i;\n            break;\n        }\n    }\n```\n\n* 对参数进行解析，解析完毕之后，如下\n* niceName ,zygote\n* startSystemServer为true\n* zygote为true\n\n```\n    Vector<String8> args;\n    if (!className.isEmpty()) {\n        // We're not in zygote mode, the only argument we need to pass\n        // to RuntimeInit is the application argument.\n        //\n        // The Remainder of args get passed to startup class main(). Make\n        // copies of them before we overwrite them with the process name.\n        args.add(application ? String8(\"application\") : String8(\"tool\"));\n        runtime.setClassNameAndArgs(className, argc - i, argv + i);\n    } else {\n        // We're in zygote mode.\n        maybeCreateDalvikCache();\n\n        if (startSystemServer) {\n            args.add(String8(\"start-system-server\"));\n        }\n\n        char prop[PROP_VALUE_MAX];\n        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {\n            LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\",\n                ABI_LIST_PROPERTY);\n            return 11;\n        }\n\n        String8 abiFlag(\"--abi-list=\");\n        abiFlag.append(prop);\n        args.add(abiFlag);\n\n        // In zygote mode, pass all remaining arguments to the zygote\n        // main() method.\n        for (; i < argc; ++i) {\n            args.add(String8(argv[i]));\n        }\n    }\n\n    if (!niceName.isEmpty()) {\n        runtime.setArgv0(niceName.string());\n        set_process_name(niceName.string());\n    }\n```\n\n* 准备参数\n* 设置进程nicename\n\n```\n    if (zygote) {\n        runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\n    } else if (className) {\n        runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote);\n    } else {\n        fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\n        app_usage();\n        LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\n        return 10;\n    }\n```\n\n最后，调用runtime.start方法。因为AppRuntime继承了AndroidRuntime,start方法的实现在AndroidRuntime中，因此，我们看AndroidRuntime。\n\n### AndroidRuntime#start 方法\n\n在这个方法中呢，做了很多事情，我们来看代码。\n\n```\n    for (size_t i = 0; i < options.size(); ++i) {\n        if (options[i] == startSystemServer) {\n           /* track our progress through the boot sequence */\n           const int LOG_BOOT_PROGRESS_START = 3000;\n           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));\n        }\n    }\n\n    const char* rootDir = getenv(\"ANDROID_ROOT\");\n    if (rootDir == NULL) {\n        rootDir = \"/system\";\n        if (!hasDir(\"/system\")) {\n            LOG_FATAL(\"No root directory specified, and /android does not exist.\");\n            return;\n        }\n        setenv(\"ANDROID_ROOT\", rootDir, 1);\n    }\n\n    //const char* kernelHack = getenv(\"LD_ASSUME_KERNEL\");\n    //ALOGD(\"Found LD_ASSUME_KERNEL='%s'\\n\", kernelHack);\n\n    /* start the virtual machine */\n    JniInvocation jni_invocation;\n    jni_invocation.Init(NULL);\n    JNIEnv* env;\n    if (startVm(&mJavaVM, &env, zygote) != 0) {\n        return;\n    }\n    onVmCreated(env);\n\n    /*\n     * Register android functions.\n     */\n    if (startReg(env) < 0) {\n        ALOGE(\"Unable to register all android natives\\n\");\n        return;\n    }\n\n    /*\n     * We want to call main() with a String array with arguments in it.\n     * At present we have two arguments, the class name and an option string.\n     * Create an array to hold them.\n     */\n    jclass stringClass;\n    jobjectArray strArray;\n    jstring classNameStr;\n\n    stringClass = env->FindClass(\"java/lang/String\");\n    assert(stringClass != NULL);\n    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);\n    assert(strArray != NULL);\n    classNameStr = env->NewStringUTF(className);\n    assert(classNameStr != NULL);\n    env->SetObjectArrayElement(strArray, 0, classNameStr);\n\n    for (size_t i = 0; i < options.size(); ++i) {\n        jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());\n        assert(optionsStr != NULL);\n        env->SetObjectArrayElement(strArray, i + 1, optionsStr);\n    }\n\n    /*\n     * Start VM.  This thread becomes the main thread of the VM, and will\n     * not return until the VM exits.\n     */\n    char* slashClassName = toSlashClassName(className);\n    jclass startClass = env->FindClass(slashClassName);\n    if (startClass == NULL) {\n        ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName);\n        /* keep going */\n    } else {\n        jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\",\n            \"([Ljava/lang/String;)V\");\n        if (startMeth == NULL) {\n            ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className);\n            /* keep going */\n        } else {\n            env->CallStaticVoidMethod(startClass, startMeth, strArray);\n\n#if 0\n            if (env->ExceptionCheck())\n                threadExitUncaughtException(env);\n#endif\n        }\n    }\n    free(slashClassName);\n```\n\n做了哪些事呢？\n\n* 获取系统目录，设置环境变量\n* startVm 启动虚拟机\n* 调用onVmCreated\n* startReg 注册系统的jni函数,如nativeZygoteInit等\n* 最后调用ZygoteInit的main方法\n\n### ZygoteInit#main\n\n改方法如下\n\n```\n    public static void main(String argv[]) {\n        try {\n            RuntimeInit.enableDdms();\n            // Start profiling the zygote initialization.\n            SamplingProfilerIntegration.start();\n\n            boolean startSystemServer = false;\n            String socketName = \"zygote\";\n            String abiList = null;\n            for (int i = 1; i < argv.length; i++) {\n                if (\"start-system-server\".equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n                }\n            }\n\n            if (abiList == null) {\n                throw new RuntimeException(\"No ABI list supplied.\");\n            }\n\n            registerZygoteSocket(socketName);\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,\n                SystemClock.uptimeMillis());\n            preload();\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,\n                SystemClock.uptimeMillis());\n\n            // Finish profiling the zygote initialization.\n            SamplingProfilerIntegration.writeZygoteSnapshot();\n\n            // Do an initial gc to clean up after startup\n            gcAndFinalize();\n\n            // Disable tracing so that forked processes do not inherit stale tracing tags from\n            // Zygote.\n            Trace.setTracingEnabled(false);\n\n            if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n            }\n\n            Log.i(TAG, \"Accepting command socket connections\");\n            runSelectLoop(abiList);\n\n            closeServerSocket();\n        } catch (MethodAndArgsCaller caller) {\n            caller.run();\n        } catch (RuntimeException ex) {\n            Log.e(TAG, \"Zygote died with exception\", ex);\n            closeServerSocket();\n            throw ex;\n        }\n    }\n```\n\n* 根据传入的参数初始化一些参数，\n* registerZygoteSocket 注册zygote socket\n* preload 预加载一些东西\n* startSystemServer 启动SystemServer进程\n* runSelectLoop进入循环，监听连接、入去参数，fork进程\n\n在registerZygoteSocket中，会创建本地socket 服务端。\n\n### ZygoteInit#preload\n\n```\n    static void preload() {\n        Log.d(TAG, \"begin preload\");\n        preloadClasses();\n        preloadResources();\n        preloadOpenGL();\n        preloadSharedLibraries();\n        preloadTextResources();\n        // Ask the WebViewFactory to do any initialization that must run in the zygote process,\n        // for memory sharing purposes.\n        WebViewFactory.prepareWebViewInZygote();\n        Log.d(TAG, \"end preload\");\n    }\n```\n\n* preloadClasses,加载/system/etc/preloaded-classes文件中的类\n* preloadResources家在系统资源，preloaded_drawables和preloaded_color_state_lists\n* preloadOpenGL 加载opengl\n* preloadSharedLibraries，加载android，compiler_rt，jnigraphics三个共享库\n* preloadTextResources 记载超文本链接符号，大概就是哪些标签吧，我们textview加载html.\n* 预加载webview用到的一些东西\n\n\n### ZygoteInit#runSelectLoop\n\n这个讲进程启动的时候，已经说到过了，这里就不细说了，就是不断监听socket客户端的接入，并且读取参数，进行fork进程。\n\n### 遗留\n\n关于SystemServer的启动，留在下篇吧。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/Zygote进程的初始化.md","raw":"---\ntitle: Zygote进程的初始化\ndate: 2017-01-07 14:49:32\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n\n### 前言\n\nZygote进程是Android进程中的核心进程，为啥呢？前面介绍过的进程启动篇中，我们知道，我们的应用进程都是在Zygote进程中fork出来的，这难道还不能证明他的重要性么。\n而Zygote进程是在init进程中，通过解析init.rc文件，启动的。我们看下init.rc中相关的部分。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\nimport /init.${ro.zygote}.rc\n```\n\n没错，就是这个，在Android5.0之后，开始支持64位编译，因为我看的源码是6.0的，那么就看下init.zygote64.rc文件吧。\n\n```\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    socket zygote stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart media\n    onrestart restart netd\n```\n\n根据init.rc语法中service部分\n\n```\nservice <name> <pathname> [ <argument> ]*\n\t<option>\n\t<option>\n```\n可知，上面指定的路径为/system/bin/app_process64，参数为-Xzygote /system/bin --zygote --start-system-server\n\n而android启动中各种命令对应的在/framework/base/cmds下，而这个下面app_process下，只有app_main，一个cpp文件，因此，我么从这个cpp文件说起\n\n### app_main的main函数\n\n代码分段开赛\n\n```\n    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));\n    // Process command line arguments\n    // ignore argv[0]\n    argc--;\n    argv++;\n        int i;\n    for (i = 0; i < argc; i++) {\n        if (argv[i][0] != '-') {\n            break;\n        }\n        if (argv[i][1] == '-' && argv[i][2] == 0) {\n            ++i; // Skip --.\n            break;\n        }\n        runtime.addOption(strdup(argv[i]));\n    }\n```\n\n* 首先创建AppRuntime，也在该文件中，并且保存参数，添加option选项\n\n\n```\n    // Parse runtime arguments.  Stop at first unrecognized option.\n    bool zygote = false;\n    bool startSystemServer = false;\n    bool application = false;\n    String8 niceName;\n    String8 className;\n\n    ++i;  // Skip unused \"parent dir\" argument.\n    while (i < argc) {\n        const char* arg = argv[i++];\n        if (strcmp(arg, \"--zygote\") == 0) {\n            zygote = true;\n            niceName = ZYGOTE_NICE_NAME;\n        } else if (strcmp(arg, \"--start-system-server\") == 0) {\n            startSystemServer = true;\n        } else if (strcmp(arg, \"--application\") == 0) {\n            application = true;\n        } else if (strncmp(arg, \"--nice-name=\", 12) == 0) {\n            niceName.setTo(arg + 12);\n        } else if (strncmp(arg, \"--\", 2) != 0) {\n            className.setTo(arg);\n            break;\n        } else {\n            --i;\n            break;\n        }\n    }\n```\n\n* 对参数进行解析，解析完毕之后，如下\n* niceName ,zygote\n* startSystemServer为true\n* zygote为true\n\n```\n    Vector<String8> args;\n    if (!className.isEmpty()) {\n        // We're not in zygote mode, the only argument we need to pass\n        // to RuntimeInit is the application argument.\n        //\n        // The Remainder of args get passed to startup class main(). Make\n        // copies of them before we overwrite them with the process name.\n        args.add(application ? String8(\"application\") : String8(\"tool\"));\n        runtime.setClassNameAndArgs(className, argc - i, argv + i);\n    } else {\n        // We're in zygote mode.\n        maybeCreateDalvikCache();\n\n        if (startSystemServer) {\n            args.add(String8(\"start-system-server\"));\n        }\n\n        char prop[PROP_VALUE_MAX];\n        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {\n            LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\",\n                ABI_LIST_PROPERTY);\n            return 11;\n        }\n\n        String8 abiFlag(\"--abi-list=\");\n        abiFlag.append(prop);\n        args.add(abiFlag);\n\n        // In zygote mode, pass all remaining arguments to the zygote\n        // main() method.\n        for (; i < argc; ++i) {\n            args.add(String8(argv[i]));\n        }\n    }\n\n    if (!niceName.isEmpty()) {\n        runtime.setArgv0(niceName.string());\n        set_process_name(niceName.string());\n    }\n```\n\n* 准备参数\n* 设置进程nicename\n\n```\n    if (zygote) {\n        runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\n    } else if (className) {\n        runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote);\n    } else {\n        fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\n        app_usage();\n        LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\n        return 10;\n    }\n```\n\n最后，调用runtime.start方法。因为AppRuntime继承了AndroidRuntime,start方法的实现在AndroidRuntime中，因此，我们看AndroidRuntime。\n\n### AndroidRuntime#start 方法\n\n在这个方法中呢，做了很多事情，我们来看代码。\n\n```\n    for (size_t i = 0; i < options.size(); ++i) {\n        if (options[i] == startSystemServer) {\n           /* track our progress through the boot sequence */\n           const int LOG_BOOT_PROGRESS_START = 3000;\n           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));\n        }\n    }\n\n    const char* rootDir = getenv(\"ANDROID_ROOT\");\n    if (rootDir == NULL) {\n        rootDir = \"/system\";\n        if (!hasDir(\"/system\")) {\n            LOG_FATAL(\"No root directory specified, and /android does not exist.\");\n            return;\n        }\n        setenv(\"ANDROID_ROOT\", rootDir, 1);\n    }\n\n    //const char* kernelHack = getenv(\"LD_ASSUME_KERNEL\");\n    //ALOGD(\"Found LD_ASSUME_KERNEL='%s'\\n\", kernelHack);\n\n    /* start the virtual machine */\n    JniInvocation jni_invocation;\n    jni_invocation.Init(NULL);\n    JNIEnv* env;\n    if (startVm(&mJavaVM, &env, zygote) != 0) {\n        return;\n    }\n    onVmCreated(env);\n\n    /*\n     * Register android functions.\n     */\n    if (startReg(env) < 0) {\n        ALOGE(\"Unable to register all android natives\\n\");\n        return;\n    }\n\n    /*\n     * We want to call main() with a String array with arguments in it.\n     * At present we have two arguments, the class name and an option string.\n     * Create an array to hold them.\n     */\n    jclass stringClass;\n    jobjectArray strArray;\n    jstring classNameStr;\n\n    stringClass = env->FindClass(\"java/lang/String\");\n    assert(stringClass != NULL);\n    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);\n    assert(strArray != NULL);\n    classNameStr = env->NewStringUTF(className);\n    assert(classNameStr != NULL);\n    env->SetObjectArrayElement(strArray, 0, classNameStr);\n\n    for (size_t i = 0; i < options.size(); ++i) {\n        jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());\n        assert(optionsStr != NULL);\n        env->SetObjectArrayElement(strArray, i + 1, optionsStr);\n    }\n\n    /*\n     * Start VM.  This thread becomes the main thread of the VM, and will\n     * not return until the VM exits.\n     */\n    char* slashClassName = toSlashClassName(className);\n    jclass startClass = env->FindClass(slashClassName);\n    if (startClass == NULL) {\n        ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName);\n        /* keep going */\n    } else {\n        jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\",\n            \"([Ljava/lang/String;)V\");\n        if (startMeth == NULL) {\n            ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className);\n            /* keep going */\n        } else {\n            env->CallStaticVoidMethod(startClass, startMeth, strArray);\n\n#if 0\n            if (env->ExceptionCheck())\n                threadExitUncaughtException(env);\n#endif\n        }\n    }\n    free(slashClassName);\n```\n\n做了哪些事呢？\n\n* 获取系统目录，设置环境变量\n* startVm 启动虚拟机\n* 调用onVmCreated\n* startReg 注册系统的jni函数,如nativeZygoteInit等\n* 最后调用ZygoteInit的main方法\n\n### ZygoteInit#main\n\n改方法如下\n\n```\n    public static void main(String argv[]) {\n        try {\n            RuntimeInit.enableDdms();\n            // Start profiling the zygote initialization.\n            SamplingProfilerIntegration.start();\n\n            boolean startSystemServer = false;\n            String socketName = \"zygote\";\n            String abiList = null;\n            for (int i = 1; i < argv.length; i++) {\n                if (\"start-system-server\".equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n                }\n            }\n\n            if (abiList == null) {\n                throw new RuntimeException(\"No ABI list supplied.\");\n            }\n\n            registerZygoteSocket(socketName);\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,\n                SystemClock.uptimeMillis());\n            preload();\n            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,\n                SystemClock.uptimeMillis());\n\n            // Finish profiling the zygote initialization.\n            SamplingProfilerIntegration.writeZygoteSnapshot();\n\n            // Do an initial gc to clean up after startup\n            gcAndFinalize();\n\n            // Disable tracing so that forked processes do not inherit stale tracing tags from\n            // Zygote.\n            Trace.setTracingEnabled(false);\n\n            if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n            }\n\n            Log.i(TAG, \"Accepting command socket connections\");\n            runSelectLoop(abiList);\n\n            closeServerSocket();\n        } catch (MethodAndArgsCaller caller) {\n            caller.run();\n        } catch (RuntimeException ex) {\n            Log.e(TAG, \"Zygote died with exception\", ex);\n            closeServerSocket();\n            throw ex;\n        }\n    }\n```\n\n* 根据传入的参数初始化一些参数，\n* registerZygoteSocket 注册zygote socket\n* preload 预加载一些东西\n* startSystemServer 启动SystemServer进程\n* runSelectLoop进入循环，监听连接、入去参数，fork进程\n\n在registerZygoteSocket中，会创建本地socket 服务端。\n\n### ZygoteInit#preload\n\n```\n    static void preload() {\n        Log.d(TAG, \"begin preload\");\n        preloadClasses();\n        preloadResources();\n        preloadOpenGL();\n        preloadSharedLibraries();\n        preloadTextResources();\n        // Ask the WebViewFactory to do any initialization that must run in the zygote process,\n        // for memory sharing purposes.\n        WebViewFactory.prepareWebViewInZygote();\n        Log.d(TAG, \"end preload\");\n    }\n```\n\n* preloadClasses,加载/system/etc/preloaded-classes文件中的类\n* preloadResources家在系统资源，preloaded_drawables和preloaded_color_state_lists\n* preloadOpenGL 加载opengl\n* preloadSharedLibraries，加载android，compiler_rt，jnigraphics三个共享库\n* preloadTextResources 记载超文本链接符号，大概就是哪些标签吧，我们textview加载html.\n* 预加载webview用到的一些东西\n\n\n### ZygoteInit#runSelectLoop\n\n这个讲进程启动的时候，已经说到过了，这里就不细说了，就是不断监听socket客户端的接入，并且读取参数，进行fork进程。\n\n### 遗留\n\n关于SystemServer的启动，留在下篇吧。\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"Zygote进程的初始化","published":1,"updated":"2017-01-07T06:52:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2l001shws6jnqu9ilu","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Zygote进程是Android进程中的核心进程，为啥呢？前面介绍过的进程启动篇中，我们知道，我们的应用进程都是在Zygote进程中fork出来的，这难道还不能证明他的重要性么。<br>而Zygote进程是在init进程中，通过解析init.rc文件，启动的。我们看下init.rc中相关的部分。<br><a id=\"more\"></a></p>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import /init.$&#123;ro.zygote&#125;.rc</div></pre></td></tr></table></figure>\n<p>没错，就是这个，在Android5.0之后，开始支持64位编译，因为我看的源码是6.0的，那么就看下init.zygote64.rc文件吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</div><div class=\"line\">    class main</div><div class=\"line\">    socket zygote stream 660 root system</div><div class=\"line\">    onrestart write /sys/android_power/request_state wake</div><div class=\"line\">    onrestart write /sys/power/state on</div><div class=\"line\">    onrestart restart media</div><div class=\"line\">    onrestart restart netd</div></pre></td></tr></table></figure>\n<p>根据init.rc语法中service部分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</div><div class=\"line\">\t&lt;option&gt;</div><div class=\"line\">\t&lt;option&gt;</div></pre></td></tr></table></figure>\n<p>可知，上面指定的路径为/system/bin/app_process64，参数为-Xzygote /system/bin –zygote –start-system-server</p>\n<p>而android启动中各种命令对应的在/framework/base/cmds下，而这个下面app_process下，只有app_main，一个cpp文件，因此，我么从这个cpp文件说起</p>\n<h3 id=\"app-main的main函数\"><a href=\"#app-main的main函数\" class=\"headerlink\" title=\"app_main的main函数\"></a>app_main的main函数</h3><p>代码分段开赛</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</div><div class=\"line\">// Process command line arguments</div><div class=\"line\">// ignore argv[0]</div><div class=\"line\">argc--;</div><div class=\"line\">argv++;</div><div class=\"line\">    int i;</div><div class=\"line\">for (i = 0; i &lt; argc; i++) &#123;</div><div class=\"line\">    if (argv[i][0] != &apos;-&apos;) &#123;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (argv[i][1] == &apos;-&apos; &amp;&amp; argv[i][2] == 0) &#123;</div><div class=\"line\">        ++i; // Skip --.</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    runtime.addOption(strdup(argv[i]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先创建AppRuntime，也在该文件中，并且保存参数，添加option选项</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Parse runtime arguments.  Stop at first unrecognized option.</div><div class=\"line\">bool zygote = false;</div><div class=\"line\">bool startSystemServer = false;</div><div class=\"line\">bool application = false;</div><div class=\"line\">String8 niceName;</div><div class=\"line\">String8 className;</div><div class=\"line\"></div><div class=\"line\">++i;  // Skip unused &quot;parent dir&quot; argument.</div><div class=\"line\">while (i &lt; argc) &#123;</div><div class=\"line\">    const char* arg = argv[i++];</div><div class=\"line\">    if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;</div><div class=\"line\">        zygote = true;</div><div class=\"line\">        niceName = ZYGOTE_NICE_NAME;</div><div class=\"line\">    &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;</div><div class=\"line\">        startSystemServer = true;</div><div class=\"line\">    &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;</div><div class=\"line\">        application = true;</div><div class=\"line\">    &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;</div><div class=\"line\">        niceName.setTo(arg + 12);</div><div class=\"line\">    &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;</div><div class=\"line\">        className.setTo(arg);</div><div class=\"line\">        break;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        --i;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>对参数进行解析，解析完毕之后，如下</li>\n<li>niceName ,zygote</li>\n<li>startSystemServer为true</li>\n<li>zygote为true</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vector&lt;String8&gt; args;</div><div class=\"line\">if (!className.isEmpty()) &#123;</div><div class=\"line\">    // We&apos;re not in zygote mode, the only argument we need to pass</div><div class=\"line\">    // to RuntimeInit is the application argument.</div><div class=\"line\">    //</div><div class=\"line\">    // The Remainder of args get passed to startup class main(). Make</div><div class=\"line\">    // copies of them before we overwrite them with the process name.</div><div class=\"line\">    args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;));</div><div class=\"line\">    runtime.setClassNameAndArgs(className, argc - i, argv + i);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // We&apos;re in zygote mode.</div><div class=\"line\">    maybeCreateDalvikCache();</div><div class=\"line\"></div><div class=\"line\">    if (startSystemServer) &#123;</div><div class=\"line\">        args.add(String8(&quot;start-system-server&quot;));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    char prop[PROP_VALUE_MAX];</div><div class=\"line\">    if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123;</div><div class=\"line\">        LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;,</div><div class=\"line\">            ABI_LIST_PROPERTY);</div><div class=\"line\">        return 11;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    String8 abiFlag(&quot;--abi-list=&quot;);</div><div class=\"line\">    abiFlag.append(prop);</div><div class=\"line\">    args.add(abiFlag);</div><div class=\"line\"></div><div class=\"line\">    // In zygote mode, pass all remaining arguments to the zygote</div><div class=\"line\">    // main() method.</div><div class=\"line\">    for (; i &lt; argc; ++i) &#123;</div><div class=\"line\">        args.add(String8(argv[i]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!niceName.isEmpty()) &#123;</div><div class=\"line\">    runtime.setArgv0(niceName.string());</div><div class=\"line\">    set_process_name(niceName.string());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>准备参数</li>\n<li>设置进程nicename</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (zygote) &#123;</div><div class=\"line\">    runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</div><div class=\"line\">&#125; else if (className) &#123;</div><div class=\"line\">    runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;);</div><div class=\"line\">    app_usage();</div><div class=\"line\">    LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</div><div class=\"line\">    return 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，调用runtime.start方法。因为AppRuntime继承了AndroidRuntime,start方法的实现在AndroidRuntime中，因此，我们看AndroidRuntime。</p>\n<h3 id=\"AndroidRuntime-start-方法\"><a href=\"#AndroidRuntime-start-方法\" class=\"headerlink\" title=\"AndroidRuntime#start 方法\"></a>AndroidRuntime#start 方法</h3><p>在这个方法中呢，做了很多事情，我们来看代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</div><div class=\"line\">        if (options[i] == startSystemServer) &#123;</div><div class=\"line\">           /* track our progress through the boot sequence */</div><div class=\"line\">           const int LOG_BOOT_PROGRESS_START = 3000;</div><div class=\"line\">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);</div><div class=\"line\">    if (rootDir == NULL) &#123;</div><div class=\"line\">        rootDir = &quot;/system&quot;;</div><div class=\"line\">        if (!hasDir(&quot;/system&quot;)) &#123;</div><div class=\"line\">            LOG_FATAL(&quot;No root directory specified, and /android does not exist.&quot;);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</div><div class=\"line\">    //ALOGD(&quot;Found LD_ASSUME_KERNEL=&apos;%s&apos;\\n&quot;, kernelHack);</div><div class=\"line\"></div><div class=\"line\">    /* start the virtual machine */</div><div class=\"line\">    JniInvocation jni_invocation;</div><div class=\"line\">    jni_invocation.Init(NULL);</div><div class=\"line\">    JNIEnv* env;</div><div class=\"line\">    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    onVmCreated(env);</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Register android functions.</div><div class=\"line\">     */</div><div class=\"line\">    if (startReg(env) &lt; 0) &#123;</div><div class=\"line\">        ALOGE(&quot;Unable to register all android natives\\n&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * We want to call main() with a String array with arguments in it.</div><div class=\"line\">     * At present we have two arguments, the class name and an option string.</div><div class=\"line\">     * Create an array to hold them.</div><div class=\"line\">     */</div><div class=\"line\">    jclass stringClass;</div><div class=\"line\">    jobjectArray strArray;</div><div class=\"line\">    jstring classNameStr;</div><div class=\"line\"></div><div class=\"line\">    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);</div><div class=\"line\">    assert(stringClass != NULL);</div><div class=\"line\">    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);</div><div class=\"line\">    assert(strArray != NULL);</div><div class=\"line\">    classNameStr = env-&gt;NewStringUTF(className);</div><div class=\"line\">    assert(classNameStr != NULL);</div><div class=\"line\">    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</div><div class=\"line\">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());</div><div class=\"line\">        assert(optionsStr != NULL);</div><div class=\"line\">        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Start VM.  This thread becomes the main thread of the VM, and will</div><div class=\"line\">     * not return until the VM exits.</div><div class=\"line\">     */</div><div class=\"line\">    char* slashClassName = toSlashClassName(className);</div><div class=\"line\">    jclass startClass = env-&gt;FindClass(slashClassName);</div><div class=\"line\">    if (startClass == NULL) &#123;</div><div class=\"line\">        ALOGE(&quot;JavaVM unable to locate class &apos;%s&apos;\\n&quot;, slashClassName);</div><div class=\"line\">        /* keep going */</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</div><div class=\"line\">            &quot;([Ljava/lang/String;)V&quot;);</div><div class=\"line\">        if (startMeth == NULL) &#123;</div><div class=\"line\">            ALOGE(&quot;JavaVM unable to find main() in &apos;%s&apos;\\n&quot;, className);</div><div class=\"line\">            /* keep going */</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">            if (env-&gt;ExceptionCheck())</div><div class=\"line\">                threadExitUncaughtException(env);</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(slashClassName);</div></pre></td></tr></table></figure>\n<p>做了哪些事呢？</p>\n<ul>\n<li>获取系统目录，设置环境变量</li>\n<li>startVm 启动虚拟机</li>\n<li>调用onVmCreated</li>\n<li>startReg 注册系统的jni函数,如nativeZygoteInit等</li>\n<li>最后调用ZygoteInit的main方法</li>\n</ul>\n<h3 id=\"ZygoteInit-main\"><a href=\"#ZygoteInit-main\" class=\"headerlink\" title=\"ZygoteInit#main\"></a>ZygoteInit#main</h3><p>改方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String argv[]) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        RuntimeInit.enableDdms();</div><div class=\"line\">        // Start profiling the zygote initialization.</div><div class=\"line\">        SamplingProfilerIntegration.start();</div><div class=\"line\"></div><div class=\"line\">        boolean startSystemServer = false;</div><div class=\"line\">        String socketName = &quot;zygote&quot;;</div><div class=\"line\">        String abiList = null;</div><div class=\"line\">        for (int i = 1; i &lt; argv.length; i++) &#123;</div><div class=\"line\">            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</div><div class=\"line\">                startSystemServer = true;</div><div class=\"line\">            &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</div><div class=\"line\">                abiList = argv[i].substring(ABI_LIST_ARG.length());</div><div class=\"line\">            &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</div><div class=\"line\">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (abiList == null) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;No ABI list supplied.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        registerZygoteSocket(socketName);</div><div class=\"line\">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">        preload();</div><div class=\"line\">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\"></div><div class=\"line\">        // Finish profiling the zygote initialization.</div><div class=\"line\">        SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class=\"line\"></div><div class=\"line\">        // Do an initial gc to clean up after startup</div><div class=\"line\">        gcAndFinalize();</div><div class=\"line\"></div><div class=\"line\">        // Disable tracing so that forked processes do not inherit stale tracing tags from</div><div class=\"line\">        // Zygote.</div><div class=\"line\">        Trace.setTracingEnabled(false);</div><div class=\"line\"></div><div class=\"line\">        if (startSystemServer) &#123;</div><div class=\"line\">            startSystemServer(abiList, socketName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Log.i(TAG, &quot;Accepting command socket connections&quot;);</div><div class=\"line\">        runSelectLoop(abiList);</div><div class=\"line\"></div><div class=\"line\">        closeServerSocket();</div><div class=\"line\">    &#125; catch (MethodAndArgsCaller caller) &#123;</div><div class=\"line\">        caller.run();</div><div class=\"line\">    &#125; catch (RuntimeException ex) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</div><div class=\"line\">        closeServerSocket();</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据传入的参数初始化一些参数，</li>\n<li>registerZygoteSocket 注册zygote socket</li>\n<li>preload 预加载一些东西</li>\n<li>startSystemServer 启动SystemServer进程</li>\n<li>runSelectLoop进入循环，监听连接、入去参数，fork进程</li>\n</ul>\n<p>在registerZygoteSocket中，会创建本地socket 服务端。</p>\n<h3 id=\"ZygoteInit-preload\"><a href=\"#ZygoteInit-preload\" class=\"headerlink\" title=\"ZygoteInit#preload\"></a>ZygoteInit#preload</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void preload() &#123;</div><div class=\"line\">    Log.d(TAG, &quot;begin preload&quot;);</div><div class=\"line\">    preloadClasses();</div><div class=\"line\">    preloadResources();</div><div class=\"line\">    preloadOpenGL();</div><div class=\"line\">    preloadSharedLibraries();</div><div class=\"line\">    preloadTextResources();</div><div class=\"line\">    // Ask the WebViewFactory to do any initialization that must run in the zygote process,</div><div class=\"line\">    // for memory sharing purposes.</div><div class=\"line\">    WebViewFactory.prepareWebViewInZygote();</div><div class=\"line\">    Log.d(TAG, &quot;end preload&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>preloadClasses,加载/system/etc/preloaded-classes文件中的类</li>\n<li>preloadResources家在系统资源，preloaded_drawables和preloaded_color_state_lists</li>\n<li>preloadOpenGL 加载opengl</li>\n<li>preloadSharedLibraries，加载android，compiler_rt，jnigraphics三个共享库</li>\n<li>preloadTextResources 记载超文本链接符号，大概就是哪些标签吧，我们textview加载html.</li>\n<li>预加载webview用到的一些东西</li>\n</ul>\n<h3 id=\"ZygoteInit-runSelectLoop\"><a href=\"#ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"ZygoteInit#runSelectLoop\"></a>ZygoteInit#runSelectLoop</h3><p>这个讲进程启动的时候，已经说到过了，这里就不细说了，就是不断监听socket客户端的接入，并且读取参数，进行fork进程。</p>\n<h3 id=\"遗留\"><a href=\"#遗留\" class=\"headerlink\" title=\"遗留\"></a>遗留</h3><p>关于SystemServer的启动，留在下篇吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Zygote进程是Android进程中的核心进程，为啥呢？前面介绍过的进程启动篇中，我们知道，我们的应用进程都是在Zygote进程中fork出来的，这难道还不能证明他的重要性么。<br>而Zygote进程是在init进程中，通过解析init.rc文件，启动的。我们看下init.rc中相关的部分。<br>","more":"</p>\n<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import /init.$&#123;ro.zygote&#125;.rc</div></pre></td></tr></table></figure>\n<p>没错，就是这个，在Android5.0之后，开始支持64位编译，因为我看的源码是6.0的，那么就看下init.zygote64.rc文件吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</div><div class=\"line\">    class main</div><div class=\"line\">    socket zygote stream 660 root system</div><div class=\"line\">    onrestart write /sys/android_power/request_state wake</div><div class=\"line\">    onrestart write /sys/power/state on</div><div class=\"line\">    onrestart restart media</div><div class=\"line\">    onrestart restart netd</div></pre></td></tr></table></figure>\n<p>根据init.rc语法中service部分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</div><div class=\"line\">\t&lt;option&gt;</div><div class=\"line\">\t&lt;option&gt;</div></pre></td></tr></table></figure>\n<p>可知，上面指定的路径为/system/bin/app_process64，参数为-Xzygote /system/bin –zygote –start-system-server</p>\n<p>而android启动中各种命令对应的在/framework/base/cmds下，而这个下面app_process下，只有app_main，一个cpp文件，因此，我么从这个cpp文件说起</p>\n<h3 id=\"app-main的main函数\"><a href=\"#app-main的main函数\" class=\"headerlink\" title=\"app_main的main函数\"></a>app_main的main函数</h3><p>代码分段开赛</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</div><div class=\"line\">// Process command line arguments</div><div class=\"line\">// ignore argv[0]</div><div class=\"line\">argc--;</div><div class=\"line\">argv++;</div><div class=\"line\">    int i;</div><div class=\"line\">for (i = 0; i &lt; argc; i++) &#123;</div><div class=\"line\">    if (argv[i][0] != &apos;-&apos;) &#123;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (argv[i][1] == &apos;-&apos; &amp;&amp; argv[i][2] == 0) &#123;</div><div class=\"line\">        ++i; // Skip --.</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    runtime.addOption(strdup(argv[i]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先创建AppRuntime，也在该文件中，并且保存参数，添加option选项</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Parse runtime arguments.  Stop at first unrecognized option.</div><div class=\"line\">bool zygote = false;</div><div class=\"line\">bool startSystemServer = false;</div><div class=\"line\">bool application = false;</div><div class=\"line\">String8 niceName;</div><div class=\"line\">String8 className;</div><div class=\"line\"></div><div class=\"line\">++i;  // Skip unused &quot;parent dir&quot; argument.</div><div class=\"line\">while (i &lt; argc) &#123;</div><div class=\"line\">    const char* arg = argv[i++];</div><div class=\"line\">    if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;</div><div class=\"line\">        zygote = true;</div><div class=\"line\">        niceName = ZYGOTE_NICE_NAME;</div><div class=\"line\">    &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;</div><div class=\"line\">        startSystemServer = true;</div><div class=\"line\">    &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;</div><div class=\"line\">        application = true;</div><div class=\"line\">    &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;</div><div class=\"line\">        niceName.setTo(arg + 12);</div><div class=\"line\">    &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;</div><div class=\"line\">        className.setTo(arg);</div><div class=\"line\">        break;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        --i;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>对参数进行解析，解析完毕之后，如下</li>\n<li>niceName ,zygote</li>\n<li>startSystemServer为true</li>\n<li>zygote为true</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vector&lt;String8&gt; args;</div><div class=\"line\">if (!className.isEmpty()) &#123;</div><div class=\"line\">    // We&apos;re not in zygote mode, the only argument we need to pass</div><div class=\"line\">    // to RuntimeInit is the application argument.</div><div class=\"line\">    //</div><div class=\"line\">    // The Remainder of args get passed to startup class main(). Make</div><div class=\"line\">    // copies of them before we overwrite them with the process name.</div><div class=\"line\">    args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;));</div><div class=\"line\">    runtime.setClassNameAndArgs(className, argc - i, argv + i);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // We&apos;re in zygote mode.</div><div class=\"line\">    maybeCreateDalvikCache();</div><div class=\"line\"></div><div class=\"line\">    if (startSystemServer) &#123;</div><div class=\"line\">        args.add(String8(&quot;start-system-server&quot;));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    char prop[PROP_VALUE_MAX];</div><div class=\"line\">    if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123;</div><div class=\"line\">        LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;,</div><div class=\"line\">            ABI_LIST_PROPERTY);</div><div class=\"line\">        return 11;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    String8 abiFlag(&quot;--abi-list=&quot;);</div><div class=\"line\">    abiFlag.append(prop);</div><div class=\"line\">    args.add(abiFlag);</div><div class=\"line\"></div><div class=\"line\">    // In zygote mode, pass all remaining arguments to the zygote</div><div class=\"line\">    // main() method.</div><div class=\"line\">    for (; i &lt; argc; ++i) &#123;</div><div class=\"line\">        args.add(String8(argv[i]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!niceName.isEmpty()) &#123;</div><div class=\"line\">    runtime.setArgv0(niceName.string());</div><div class=\"line\">    set_process_name(niceName.string());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>准备参数</li>\n<li>设置进程nicename</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (zygote) &#123;</div><div class=\"line\">    runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</div><div class=\"line\">&#125; else if (className) &#123;</div><div class=\"line\">    runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;);</div><div class=\"line\">    app_usage();</div><div class=\"line\">    LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</div><div class=\"line\">    return 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，调用runtime.start方法。因为AppRuntime继承了AndroidRuntime,start方法的实现在AndroidRuntime中，因此，我们看AndroidRuntime。</p>\n<h3 id=\"AndroidRuntime-start-方法\"><a href=\"#AndroidRuntime-start-方法\" class=\"headerlink\" title=\"AndroidRuntime#start 方法\"></a>AndroidRuntime#start 方法</h3><p>在这个方法中呢，做了很多事情，我们来看代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</div><div class=\"line\">        if (options[i] == startSystemServer) &#123;</div><div class=\"line\">           /* track our progress through the boot sequence */</div><div class=\"line\">           const int LOG_BOOT_PROGRESS_START = 3000;</div><div class=\"line\">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);</div><div class=\"line\">    if (rootDir == NULL) &#123;</div><div class=\"line\">        rootDir = &quot;/system&quot;;</div><div class=\"line\">        if (!hasDir(&quot;/system&quot;)) &#123;</div><div class=\"line\">            LOG_FATAL(&quot;No root directory specified, and /android does not exist.&quot;);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</div><div class=\"line\">    //ALOGD(&quot;Found LD_ASSUME_KERNEL=&apos;%s&apos;\\n&quot;, kernelHack);</div><div class=\"line\"></div><div class=\"line\">    /* start the virtual machine */</div><div class=\"line\">    JniInvocation jni_invocation;</div><div class=\"line\">    jni_invocation.Init(NULL);</div><div class=\"line\">    JNIEnv* env;</div><div class=\"line\">    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    onVmCreated(env);</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Register android functions.</div><div class=\"line\">     */</div><div class=\"line\">    if (startReg(env) &lt; 0) &#123;</div><div class=\"line\">        ALOGE(&quot;Unable to register all android natives\\n&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * We want to call main() with a String array with arguments in it.</div><div class=\"line\">     * At present we have two arguments, the class name and an option string.</div><div class=\"line\">     * Create an array to hold them.</div><div class=\"line\">     */</div><div class=\"line\">    jclass stringClass;</div><div class=\"line\">    jobjectArray strArray;</div><div class=\"line\">    jstring classNameStr;</div><div class=\"line\"></div><div class=\"line\">    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);</div><div class=\"line\">    assert(stringClass != NULL);</div><div class=\"line\">    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);</div><div class=\"line\">    assert(strArray != NULL);</div><div class=\"line\">    classNameStr = env-&gt;NewStringUTF(className);</div><div class=\"line\">    assert(classNameStr != NULL);</div><div class=\"line\">    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</div><div class=\"line\"></div><div class=\"line\">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</div><div class=\"line\">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());</div><div class=\"line\">        assert(optionsStr != NULL);</div><div class=\"line\">        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Start VM.  This thread becomes the main thread of the VM, and will</div><div class=\"line\">     * not return until the VM exits.</div><div class=\"line\">     */</div><div class=\"line\">    char* slashClassName = toSlashClassName(className);</div><div class=\"line\">    jclass startClass = env-&gt;FindClass(slashClassName);</div><div class=\"line\">    if (startClass == NULL) &#123;</div><div class=\"line\">        ALOGE(&quot;JavaVM unable to locate class &apos;%s&apos;\\n&quot;, slashClassName);</div><div class=\"line\">        /* keep going */</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</div><div class=\"line\">            &quot;([Ljava/lang/String;)V&quot;);</div><div class=\"line\">        if (startMeth == NULL) &#123;</div><div class=\"line\">            ALOGE(&quot;JavaVM unable to find main() in &apos;%s&apos;\\n&quot;, className);</div><div class=\"line\">            /* keep going */</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">            if (env-&gt;ExceptionCheck())</div><div class=\"line\">                threadExitUncaughtException(env);</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(slashClassName);</div></pre></td></tr></table></figure>\n<p>做了哪些事呢？</p>\n<ul>\n<li>获取系统目录，设置环境变量</li>\n<li>startVm 启动虚拟机</li>\n<li>调用onVmCreated</li>\n<li>startReg 注册系统的jni函数,如nativeZygoteInit等</li>\n<li>最后调用ZygoteInit的main方法</li>\n</ul>\n<h3 id=\"ZygoteInit-main\"><a href=\"#ZygoteInit-main\" class=\"headerlink\" title=\"ZygoteInit#main\"></a>ZygoteInit#main</h3><p>改方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String argv[]) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        RuntimeInit.enableDdms();</div><div class=\"line\">        // Start profiling the zygote initialization.</div><div class=\"line\">        SamplingProfilerIntegration.start();</div><div class=\"line\"></div><div class=\"line\">        boolean startSystemServer = false;</div><div class=\"line\">        String socketName = &quot;zygote&quot;;</div><div class=\"line\">        String abiList = null;</div><div class=\"line\">        for (int i = 1; i &lt; argv.length; i++) &#123;</div><div class=\"line\">            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</div><div class=\"line\">                startSystemServer = true;</div><div class=\"line\">            &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</div><div class=\"line\">                abiList = argv[i].substring(ABI_LIST_ARG.length());</div><div class=\"line\">            &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</div><div class=\"line\">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (abiList == null) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;No ABI list supplied.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        registerZygoteSocket(socketName);</div><div class=\"line\">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\">        preload();</div><div class=\"line\">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class=\"line\">            SystemClock.uptimeMillis());</div><div class=\"line\"></div><div class=\"line\">        // Finish profiling the zygote initialization.</div><div class=\"line\">        SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class=\"line\"></div><div class=\"line\">        // Do an initial gc to clean up after startup</div><div class=\"line\">        gcAndFinalize();</div><div class=\"line\"></div><div class=\"line\">        // Disable tracing so that forked processes do not inherit stale tracing tags from</div><div class=\"line\">        // Zygote.</div><div class=\"line\">        Trace.setTracingEnabled(false);</div><div class=\"line\"></div><div class=\"line\">        if (startSystemServer) &#123;</div><div class=\"line\">            startSystemServer(abiList, socketName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Log.i(TAG, &quot;Accepting command socket connections&quot;);</div><div class=\"line\">        runSelectLoop(abiList);</div><div class=\"line\"></div><div class=\"line\">        closeServerSocket();</div><div class=\"line\">    &#125; catch (MethodAndArgsCaller caller) &#123;</div><div class=\"line\">        caller.run();</div><div class=\"line\">    &#125; catch (RuntimeException ex) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</div><div class=\"line\">        closeServerSocket();</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据传入的参数初始化一些参数，</li>\n<li>registerZygoteSocket 注册zygote socket</li>\n<li>preload 预加载一些东西</li>\n<li>startSystemServer 启动SystemServer进程</li>\n<li>runSelectLoop进入循环，监听连接、入去参数，fork进程</li>\n</ul>\n<p>在registerZygoteSocket中，会创建本地socket 服务端。</p>\n<h3 id=\"ZygoteInit-preload\"><a href=\"#ZygoteInit-preload\" class=\"headerlink\" title=\"ZygoteInit#preload\"></a>ZygoteInit#preload</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void preload() &#123;</div><div class=\"line\">    Log.d(TAG, &quot;begin preload&quot;);</div><div class=\"line\">    preloadClasses();</div><div class=\"line\">    preloadResources();</div><div class=\"line\">    preloadOpenGL();</div><div class=\"line\">    preloadSharedLibraries();</div><div class=\"line\">    preloadTextResources();</div><div class=\"line\">    // Ask the WebViewFactory to do any initialization that must run in the zygote process,</div><div class=\"line\">    // for memory sharing purposes.</div><div class=\"line\">    WebViewFactory.prepareWebViewInZygote();</div><div class=\"line\">    Log.d(TAG, &quot;end preload&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>preloadClasses,加载/system/etc/preloaded-classes文件中的类</li>\n<li>preloadResources家在系统资源，preloaded_drawables和preloaded_color_state_lists</li>\n<li>preloadOpenGL 加载opengl</li>\n<li>preloadSharedLibraries，加载android，compiler_rt，jnigraphics三个共享库</li>\n<li>preloadTextResources 记载超文本链接符号，大概就是哪些标签吧，我们textview加载html.</li>\n<li>预加载webview用到的一些东西</li>\n</ul>\n<h3 id=\"ZygoteInit-runSelectLoop\"><a href=\"#ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"ZygoteInit#runSelectLoop\"></a>ZygoteInit#runSelectLoop</h3><p>这个讲进程启动的时候，已经说到过了，这里就不细说了，就是不断监听socket客户端的接入，并且读取参数，进行fork进程。</p>\n<h3 id=\"遗留\"><a href=\"#遗留\" class=\"headerlink\" title=\"遗留\"></a>遗留</h3><p>关于SystemServer的启动，留在下篇吧。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco加载数据","date":"2016-12-12T15:51:23.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n![](/images/fresco/fresco_1.png)\n\n\n### 2.SimpleDraweeView#setImageURI\n\n在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\n* 根据attrs更新GenericDraweeHierarchyBuilder\n* 更新图像的宽高比\n* 设置Hierarchy\n\n在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。\n\n继续看DraweeView#setImageURI\n\n```\n  public void setImageURI(Uri uri, @Nullable Object callerContext) {\n    DraweeController controller = mSimpleDraweeControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\n    setController(controller);\n  }er.setImageURI(uri);\n  }\n```\n\n先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：\n\n```\n  public void setController(@Nullable DraweeController draweeController) {\n    boolean wasAttached = mIsControllerAttached;\n    if (wasAttached) {\n      detachController();\n    }\n\n    // Clear the old controller\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);\n      mController.setHierarchy(null);\n    }\n    mController = draweeController;\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);\n      mController.setHierarchy(mHierarchy);\n    } else {\n      mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);\n    }\n\n    if (wasAttached) {\n      attachController();\n    }\n  }\n\n```\n\n* 如果已经关联过controller，则取消与拿来的关联\n* 如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，\n* 如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件\n* 关联controller\n\n在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。\n\n### 3.AbstractDraweeController#onAttach\n\n```\n  public void onAttach() {\n    if (FLog.isLoggable(FLog.VERBOSE)) {\n      FLog.v(\n          TAG,\n          \"controller %x %s: onAttach: %s\",\n          System.identityHashCode(this),\n          mId,\n          mIsRequestSubmitted ? \"request already submitted\" : \"request needs submit\");\n    }\n    mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);\n    Preconditions.checkNotNull(mSettableDraweeHierarchy);\n    mDeferredReleaser.cancelDeferredRelease(this);\n    mIsAttached = true;\n    if (!mIsRequestSubmitted) {\n      submitRequest();\n    }\n  }\n```\n\n\n* 打印日志\n* 纪录事件\n* 发送请求\n\n### 4. submitRequest\n\n这个方法分为俩个部分。\n\n* 读取memory cache 同步\n* 读取除了memorycache 的其他部分\n\n\n#### 4.1 读取缓存部分\n\n```\n    final T closeableImage = getCachedImage();\n    if (closeableImage != null) {\n      mDataSource = null;\n      mIsRequestSubmitted = true;\n      mHasFetchFailed = false;\n      mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);\n      getControllerListener().onSubmit(mId, mCallerContext);\n      onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);\n      return;\n    }\n```\n\n* 通过getCachedImage 获取缓存数据\n* 纪录缓存命中事件\n* 回调，后面再将\n\n我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中\n\n```\n  @Override\n  protected CloseableReference<CloseableImage> getCachedImage() {\n    if (mMemoryCache == null || mCacheKey == null) {\n      return null;\n    }\n    // We get the CacheKey\n    CloseableReference<CloseableImage> closeableImage = mMemoryCache.get(mCacheKey);\n    if (closeableImage != null && !closeableImage.get().getQualityInfo().isOfFullQuality()) {\n      closeableImage.close();\n      return null;\n    }\n    return closeableImage;\n  }\n```\n\n可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。\n\n现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。\n\n从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。\n\n\n到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方\n\n* ImagePipelineFactory#getBitmapMemoryCache\n* BitmapMemoryCacheFactory\n* InstrumentedMemoryCache\n\n```\n  @Override\n  public CloseableReference<V> get(K key) {\n    CloseableReference<V> result = mDelegate.get(key);\n    if (result == null) {\n      mTracker.onCacheMiss();\n    } else {\n      mTracker.onCacheHit(key);\n    }\n    return result;\n  }\n```\n\n我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。\n\n#### 4.2 其他部分\n\n首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。\n\n而从其他部分获取的关键就在于fetchDecodedImage中的如下代码\n\n```\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext);\n```\n我们看看getDecodedImageProducerSequence的具体实现。\n\n```\n  public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(\n      ImageRequest imageRequest) {\n    Producer<CloseableReference<CloseableImage>> pipelineSequence =\n        getBasicDecodedImageSequence(imageRequest);\n    if (imageRequest.getPostprocessor() != null) {\n      return getPostprocessorSequence(pipelineSequence);\n    } else {\n      return pipelineSequence;\n    }\n  }\n```\n\n我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。\n\n> swallow result if prefetch -> bitmap cache get ->\n  background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->\n  encoded cache -> disk cache -> (webp transcode) -> network fetch.\n\n\n这里的具体细节我们不管，继续看submitFetchRequest，\n在submitFetchRequest函数中做了三件事：\n\n* 取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；\n* 将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。\n* 创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。\n\n至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。\n\n\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","source":"_posts/fresco加载数据.md","raw":"---\ntitle: fresco加载数据\ndate: 2016-12-12 23:51:23\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 前言\n\n一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n![](/images/fresco/fresco_1.png)\n\n\n### 2.SimpleDraweeView#setImageURI\n\n在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\n* 根据attrs更新GenericDraweeHierarchyBuilder\n* 更新图像的宽高比\n* 设置Hierarchy\n\n在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。\n\n继续看DraweeView#setImageURI\n\n```\n  public void setImageURI(Uri uri, @Nullable Object callerContext) {\n    DraweeController controller = mSimpleDraweeControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\n    setController(controller);\n  }er.setImageURI(uri);\n  }\n```\n\n先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：\n\n```\n  public void setController(@Nullable DraweeController draweeController) {\n    boolean wasAttached = mIsControllerAttached;\n    if (wasAttached) {\n      detachController();\n    }\n\n    // Clear the old controller\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);\n      mController.setHierarchy(null);\n    }\n    mController = draweeController;\n    if (mController != null) {\n      mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);\n      mController.setHierarchy(mHierarchy);\n    } else {\n      mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);\n    }\n\n    if (wasAttached) {\n      attachController();\n    }\n  }\n\n```\n\n* 如果已经关联过controller，则取消与拿来的关联\n* 如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，\n* 如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件\n* 关联controller\n\n在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。\n\n### 3.AbstractDraweeController#onAttach\n\n```\n  public void onAttach() {\n    if (FLog.isLoggable(FLog.VERBOSE)) {\n      FLog.v(\n          TAG,\n          \"controller %x %s: onAttach: %s\",\n          System.identityHashCode(this),\n          mId,\n          mIsRequestSubmitted ? \"request already submitted\" : \"request needs submit\");\n    }\n    mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);\n    Preconditions.checkNotNull(mSettableDraweeHierarchy);\n    mDeferredReleaser.cancelDeferredRelease(this);\n    mIsAttached = true;\n    if (!mIsRequestSubmitted) {\n      submitRequest();\n    }\n  }\n```\n\n\n* 打印日志\n* 纪录事件\n* 发送请求\n\n### 4. submitRequest\n\n这个方法分为俩个部分。\n\n* 读取memory cache 同步\n* 读取除了memorycache 的其他部分\n\n\n#### 4.1 读取缓存部分\n\n```\n    final T closeableImage = getCachedImage();\n    if (closeableImage != null) {\n      mDataSource = null;\n      mIsRequestSubmitted = true;\n      mHasFetchFailed = false;\n      mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);\n      getControllerListener().onSubmit(mId, mCallerContext);\n      onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);\n      return;\n    }\n```\n\n* 通过getCachedImage 获取缓存数据\n* 纪录缓存命中事件\n* 回调，后面再将\n\n我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中\n\n```\n  @Override\n  protected CloseableReference<CloseableImage> getCachedImage() {\n    if (mMemoryCache == null || mCacheKey == null) {\n      return null;\n    }\n    // We get the CacheKey\n    CloseableReference<CloseableImage> closeableImage = mMemoryCache.get(mCacheKey);\n    if (closeableImage != null && !closeableImage.get().getQualityInfo().isOfFullQuality()) {\n      closeableImage.close();\n      return null;\n    }\n    return closeableImage;\n  }\n```\n\n可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。\n\n现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。\n\n从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。\n\n\n到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方\n\n* ImagePipelineFactory#getBitmapMemoryCache\n* BitmapMemoryCacheFactory\n* InstrumentedMemoryCache\n\n```\n  @Override\n  public CloseableReference<V> get(K key) {\n    CloseableReference<V> result = mDelegate.get(key);\n    if (result == null) {\n      mTracker.onCacheMiss();\n    } else {\n      mTracker.onCacheHit(key);\n    }\n    return result;\n  }\n```\n\n我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。\n\n#### 4.2 其他部分\n\n首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。\n\n而从其他部分获取的关键就在于fetchDecodedImage中的如下代码\n\n```\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext);\n```\n我们看看getDecodedImageProducerSequence的具体实现。\n\n```\n  public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(\n      ImageRequest imageRequest) {\n    Producer<CloseableReference<CloseableImage>> pipelineSequence =\n        getBasicDecodedImageSequence(imageRequest);\n    if (imageRequest.getPostprocessor() != null) {\n      return getPostprocessorSequence(pipelineSequence);\n    } else {\n      return pipelineSequence;\n    }\n  }\n```\n\n我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。\n\n> swallow result if prefetch -> bitmap cache get ->\n  background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->\n  encoded cache -> disk cache -> (webp transcode) -> network fetch.\n\n\n这里的具体细节我们不管，继续看submitFetchRequest，\n在submitFetchRequest函数中做了三件事：\n\n* 取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；\n* 将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。\n* 创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。\n\n至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。\n\n\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","slug":"fresco加载数据","published":1,"updated":"2017-01-07T06:58:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2n001vhws608neprhk","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<p><img src=\"/images/fresco/fresco_1.png\" alt=\"\"></p>\n<h3 id=\"2-SimpleDraweeView-setImageURI\"><a href=\"#2-SimpleDraweeView-setImageURI\" class=\"headerlink\" title=\"2.SimpleDraweeView#setImageURI\"></a>2.SimpleDraweeView#setImageURI</h3><p>在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据attrs更新GenericDraweeHierarchyBuilder</li>\n<li>更新图像的宽高比</li>\n<li>设置Hierarchy</li>\n</ul>\n<p>在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。</p>\n<p>继续看DraweeView#setImageURI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setImageURI(Uri uri, @Nullable Object callerContext) &#123;</div><div class=\"line\">  DraweeController controller = mSimpleDraweeControllerBuilder</div><div class=\"line\">      .setCallerContext(callerContext)</div><div class=\"line\">      .setUri(uri)</div><div class=\"line\">      .setOldController(getController())</div><div class=\"line\">      .build();</div><div class=\"line\">  setController(controller);</div><div class=\"line\">&#125;er.setImageURI(uri);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setController(@Nullable DraweeController draweeController) &#123;</div><div class=\"line\">  boolean wasAttached = mIsControllerAttached;</div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    detachController();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Clear the old controller</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(null);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mController = draweeController;</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(mHierarchy);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    attachController();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果已经关联过controller，则取消与拿来的关联</li>\n<li>如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，</li>\n<li>如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件</li>\n<li>关联controller</li>\n</ul>\n<p>在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。</p>\n<h3 id=\"3-AbstractDraweeController-onAttach\"><a href=\"#3-AbstractDraweeController-onAttach\" class=\"headerlink\" title=\"3.AbstractDraweeController#onAttach\"></a>3.AbstractDraweeController#onAttach</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void onAttach() &#123;</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;controller %x %s: onAttach: %s&quot;,</div><div class=\"line\">        System.identityHashCode(this),</div><div class=\"line\">        mId,</div><div class=\"line\">        mIsRequestSubmitted ? &quot;request already submitted&quot; : &quot;request needs submit&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</div><div class=\"line\">  Preconditions.checkNotNull(mSettableDraweeHierarchy);</div><div class=\"line\">  mDeferredReleaser.cancelDeferredRelease(this);</div><div class=\"line\">  mIsAttached = true;</div><div class=\"line\">  if (!mIsRequestSubmitted) &#123;</div><div class=\"line\">    submitRequest();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>打印日志</li>\n<li>纪录事件</li>\n<li>发送请求</li>\n</ul>\n<h3 id=\"4-submitRequest\"><a href=\"#4-submitRequest\" class=\"headerlink\" title=\"4. submitRequest\"></a>4. submitRequest</h3><p>这个方法分为俩个部分。</p>\n<ul>\n<li>读取memory cache 同步</li>\n<li>读取除了memorycache 的其他部分</li>\n</ul>\n<h4 id=\"4-1-读取缓存部分\"><a href=\"#4-1-读取缓存部分\" class=\"headerlink\" title=\"4.1 读取缓存部分\"></a>4.1 读取缓存部分</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">final T closeableImage = getCachedImage();</div><div class=\"line\">if (closeableImage != null) &#123;</div><div class=\"line\">  mDataSource = null;</div><div class=\"line\">  mIsRequestSubmitted = true;</div><div class=\"line\">  mHasFetchFailed = false;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);</div><div class=\"line\">  getControllerListener().onSubmit(mId, mCallerContext);</div><div class=\"line\">  onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);</div><div class=\"line\">  return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过getCachedImage 获取缓存数据</li>\n<li>纪录缓存命中事件</li>\n<li>回调，后面再将</li>\n</ul>\n<p>我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected CloseableReference&lt;CloseableImage&gt; getCachedImage() &#123;</div><div class=\"line\">  if (mMemoryCache == null || mCacheKey == null) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  // We get the CacheKey</div><div class=\"line\">  CloseableReference&lt;CloseableImage&gt; closeableImage = mMemoryCache.get(mCacheKey);</div><div class=\"line\">  if (closeableImage != null &amp;&amp; !closeableImage.get().getQualityInfo().isOfFullQuality()) &#123;</div><div class=\"line\">    closeableImage.close();</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return closeableImage;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。</p>\n<p>现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。</p>\n<p>从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。</p>\n<p>到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方</p>\n<ul>\n<li>ImagePipelineFactory#getBitmapMemoryCache</li>\n<li>BitmapMemoryCacheFactory</li>\n<li>InstrumentedMemoryCache</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;V&gt; get(K key) &#123;</div><div class=\"line\">  CloseableReference&lt;V&gt; result = mDelegate.get(key);</div><div class=\"line\">  if (result == null) &#123;</div><div class=\"line\">    mTracker.onCacheMiss();</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mTracker.onCacheHit(key);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。</p>\n<h4 id=\"4-2-其他部分\"><a href=\"#4-2-其他部分\" class=\"headerlink\" title=\"4.2 其他部分\"></a>4.2 其他部分</h4><p>首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。</p>\n<p>而从其他部分获取的关键就在于fetchDecodedImage中的如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</div><div class=\"line\">    mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</div><div class=\"line\">return submitFetchRequest(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    imageRequest,</div><div class=\"line\">    lowestPermittedRequestLevelOnSubmit,</div><div class=\"line\">    callerContext);</div></pre></td></tr></table></figure>\n<p>我们看看getDecodedImageProducerSequence的具体实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDecodedImageProducerSequence(</div><div class=\"line\">    ImageRequest imageRequest) &#123;</div><div class=\"line\">  Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; pipelineSequence =</div><div class=\"line\">      getBasicDecodedImageSequence(imageRequest);</div><div class=\"line\">  if (imageRequest.getPostprocessor() != null) &#123;</div><div class=\"line\">    return getPostprocessorSequence(pipelineSequence);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    return pipelineSequence;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。</p>\n<blockquote>\n<p>swallow result if prefetch -&gt; bitmap cache get -&gt;<br>  background thread hand-off -&gt; multiplex -&gt; bitmap cache -&gt; decode -&gt; multiplex -&gt;<br>  encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.</p>\n</blockquote>\n<p>这里的具体细节我们不管，继续看submitFetchRequest，<br>在submitFetchRequest函数中做了三件事：</p>\n<ul>\n<li>取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；</li>\n<li>将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。</li>\n<li>创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。</li>\n</ul>\n<p>至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n</the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般我们通过SimpleDraweeView#setImageURI 去使用，我们现在就来看看它的实现。先来看看继承结构。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<p><img src=\"/images/fresco/fresco_1.png\" alt=\"\"></p>\n<h3 id=\"2-SimpleDraweeView-setImageURI\"><a href=\"#2-SimpleDraweeView-setImageURI\" class=\"headerlink\" title=\"2.SimpleDraweeView#setImageURI\"></a>2.SimpleDraweeView#setImageURI</h3><p>在这个方法当中，最终都会调用setController方法。这个方法的实现在DraweeView中，在此之前，我们需要看下GenericDraweeView的初始化，在这个的初始化的时候，会调用其inflateHierarchy方法去设置Hierarchy。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据attrs更新GenericDraweeHierarchyBuilder</li>\n<li>更新图像的宽高比</li>\n<li>设置Hierarchy</li>\n</ul>\n<p>在DraweeView的setHierarchy方法中，更新mDraweeHolder，然后设置image为mDraweeHolder.getTopLevelDrawable()。</p>\n<p>继续看DraweeView#setImageURI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setImageURI(Uri uri, @Nullable Object callerContext) &#123;</div><div class=\"line\">  DraweeController controller = mSimpleDraweeControllerBuilder</div><div class=\"line\">      .setCallerContext(callerContext)</div><div class=\"line\">      .setUri(uri)</div><div class=\"line\">      .setOldController(getController())</div><div class=\"line\">      .build();</div><div class=\"line\">  setController(controller);</div><div class=\"line\">&#125;er.setImageURI(uri);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先构造出一个新的DraweeController，然后setController，这个的实现在DraweeView中，就是调用DraweeHolder.setController方法，setController的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void setController(@Nullable DraweeController draweeController) &#123;</div><div class=\"line\">  boolean wasAttached = mIsControllerAttached;</div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    detachController();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  // Clear the old controller</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(null);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mController = draweeController;</div><div class=\"line\">  if (mController != null) &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);</div><div class=\"line\">    mController.setHierarchy(mHierarchy);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  if (wasAttached) &#123;</div><div class=\"line\">    attachController();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果已经关联过controller，则取消与拿来的关联</li>\n<li>如果mcontroller不为null，则纪录ON_CLEAR_OLD_CONTROLLER事件，并将mController的Hierarchy设为null，</li>\n<li>如果传入了参数不为null，则纪录ON_SET_CONTROLLER事件并设置Hierarchy，否则只纪录事件</li>\n<li>关联controller</li>\n</ul>\n<p>在attachController方法中，会调用，onattcah方法。根据上下文，我们知道这个是通过PipelineDraweeControllerBuilder#build方法构建出来的。中间过程的代码这里就不说了，我们只要知道，这里的controller，默认是PipelineDraweeController的一个实例即可。我们看下他的父类的onAttach方法在干什么。</p>\n<h3 id=\"3-AbstractDraweeController-onAttach\"><a href=\"#3-AbstractDraweeController-onAttach\" class=\"headerlink\" title=\"3.AbstractDraweeController#onAttach\"></a>3.AbstractDraweeController#onAttach</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void onAttach() &#123;</div><div class=\"line\">  if (FLog.isLoggable(FLog.VERBOSE)) &#123;</div><div class=\"line\">    FLog.v(</div><div class=\"line\">        TAG,</div><div class=\"line\">        &quot;controller %x %s: onAttach: %s&quot;,</div><div class=\"line\">        System.identityHashCode(this),</div><div class=\"line\">        mId,</div><div class=\"line\">        mIsRequestSubmitted ? &quot;request already submitted&quot; : &quot;request needs submit&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</div><div class=\"line\">  Preconditions.checkNotNull(mSettableDraweeHierarchy);</div><div class=\"line\">  mDeferredReleaser.cancelDeferredRelease(this);</div><div class=\"line\">  mIsAttached = true;</div><div class=\"line\">  if (!mIsRequestSubmitted) &#123;</div><div class=\"line\">    submitRequest();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>打印日志</li>\n<li>纪录事件</li>\n<li>发送请求</li>\n</ul>\n<h3 id=\"4-submitRequest\"><a href=\"#4-submitRequest\" class=\"headerlink\" title=\"4. submitRequest\"></a>4. submitRequest</h3><p>这个方法分为俩个部分。</p>\n<ul>\n<li>读取memory cache 同步</li>\n<li>读取除了memorycache 的其他部分</li>\n</ul>\n<h4 id=\"4-1-读取缓存部分\"><a href=\"#4-1-读取缓存部分\" class=\"headerlink\" title=\"4.1 读取缓存部分\"></a>4.1 读取缓存部分</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">final T closeableImage = getCachedImage();</div><div class=\"line\">if (closeableImage != null) &#123;</div><div class=\"line\">  mDataSource = null;</div><div class=\"line\">  mIsRequestSubmitted = true;</div><div class=\"line\">  mHasFetchFailed = false;</div><div class=\"line\">  mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);</div><div class=\"line\">  getControllerListener().onSubmit(mId, mCallerContext);</div><div class=\"line\">  onNewResultInternal(mId, mDataSource, closeableImage, 1.0f, true, true);</div><div class=\"line\">  return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过getCachedImage 获取缓存数据</li>\n<li>纪录缓存命中事件</li>\n<li>回调，后面再将</li>\n</ul>\n<p>我们重点看下如果获取缓存。获取缓存的实现在PipelineDraweeController的getCachedImage方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected CloseableReference&lt;CloseableImage&gt; getCachedImage() &#123;</div><div class=\"line\">  if (mMemoryCache == null || mCacheKey == null) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  // We get the CacheKey</div><div class=\"line\">  CloseableReference&lt;CloseableImage&gt; closeableImage = mMemoryCache.get(mCacheKey);</div><div class=\"line\">  if (closeableImage != null &amp;&amp; !closeableImage.get().getQualityInfo().isOfFullQuality()) &#123;</div><div class=\"line\">    closeableImage.close();</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return closeableImage;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，从MemoryCache中根据key获取，这里的key是怎么来的呢？是在我们生成PipelineDraweeController的时候，生成的。具体的实现在PipelineDraweeControllerBuilder中，这个中不仅生成cachekey，也根据uri生成ImageRequest。</p>\n<p>现在我们需要知道MemoryCache是如何初始化的。一切源于PipelineDraweeControllerBuilderSupplier，就是最初的初始化过程，而在其的get方法中，new了PipelineDraweeControllerBuilder。在PipelineDraweeControllerBuilderSupplier的构造函数中，构造了PipelineDraweeControllerFactory对象，其中就有MemoryCache部分，这里 的过程比较绕。</p>\n<p>从哪些非常绕的过程中知道，PipelineDraweeControllerFactory的初始化在PipelineDraweeControllerBuilderSupplier的初始化方法中，而cache是 mImagePipeline.getBitmapMemoryCache()得到的。不说了，这部分东西比较绕，所有的初始化过程基本就在上篇。</p>\n<p>到这里就知道MemoryCache是mBitmapMemoryCache。而他的默认实现是InstrumentedMemoryCache。这里涉及到三个地方</p>\n<ul>\n<li>ImagePipelineFactory#getBitmapMemoryCache</li>\n<li>BitmapMemoryCacheFactory</li>\n<li>InstrumentedMemoryCache</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;V&gt; get(K key) &#123;</div><div class=\"line\">  CloseableReference&lt;V&gt; result = mDelegate.get(key);</div><div class=\"line\">  if (result == null) &#123;</div><div class=\"line\">    mTracker.onCacheMiss();</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mTracker.onCacheHit(key);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们需要搞懂mDelegate，mTracker，才能知道接下来的流程。mDelegate的类型为CountingMemoryCache，对应的获取过程在ImagePipelineFactory#getBitmapCountingMemoryCache方法。这里不追踪代码了，他是CountingMemoryCache类的实力。最终就是从lru中，取出。mTracker是用来统计的，这里不说了。在追下去就出不来了。</p>\n<h4 id=\"4-2-其他部分\"><a href=\"#4-2-其他部分\" class=\"headerlink\" title=\"4.2 其他部分\"></a>4.2 其他部分</h4><p>首先看DataSource是怎么来的，相关的代码在AbstractDraweeControllerBuilder#obtainDataSourceSupplier方法中，如果是请求uri那种的，是有mImageRequest的。那么就是getDataSourceSupplierForRequest，通过追代码能够发现，最后是在PipelineDraweeControllerBuilder的getDataSourceForRequest方法中，ImagePipeline#fetchDecodedImage获取的。在追踪发现，实现为SimpleDataSource。</p>\n<p>而从其他部分获取的关键就在于fetchDecodedImage中的如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</div><div class=\"line\">    mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</div><div class=\"line\">return submitFetchRequest(</div><div class=\"line\">    producerSequence,</div><div class=\"line\">    imageRequest,</div><div class=\"line\">    lowestPermittedRequestLevelOnSubmit,</div><div class=\"line\">    callerContext);</div></pre></td></tr></table></figure>\n<p>我们看看getDecodedImageProducerSequence的具体实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDecodedImageProducerSequence(</div><div class=\"line\">    ImageRequest imageRequest) &#123;</div><div class=\"line\">  Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; pipelineSequence =</div><div class=\"line\">      getBasicDecodedImageSequence(imageRequest);</div><div class=\"line\">  if (imageRequest.getPostprocessor() != null) &#123;</div><div class=\"line\">    return getPostprocessorSequence(pipelineSequence);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    return pipelineSequence;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先看getBasicDecodedImageSequence，在这个方法中，判断是不是uri是不是网络类型，如果是网络类型，getNetworkFetchSequence，其他类型则选取对应的实现。</p>\n<blockquote>\n<p>swallow result if prefetch -&gt; bitmap cache get -&gt;<br>  background thread hand-off -&gt; multiplex -&gt; bitmap cache -&gt; decode -&gt; multiplex -&gt;<br>  encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.</p>\n</blockquote>\n<p>这里的具体细节我们不管，继续看submitFetchRequest，<br>在submitFetchRequest函数中做了三件事：</p>\n<ul>\n<li>取ImageRequest的LowestPermittedRequestLevel和传入的RequestLevel中最高的一级作为此次数据获取的最高缓存获取层；</li>\n<li>将ImageRequest、本次请求的唯一标识、ImageRequestListener（提供ImageRqeuest事件的回调）、是否需要渐进式加载图片等信息封装进SettableProducerContext。</li>\n<li>创建AbstractproducerToDataSourceAdapter，它实际上是一种DataSource，在这个过程中会让producer通过SettableProducerContext获取数据。</li>\n</ul>\n<p>至此我们就获取了所需要的DataSource，并将它设置给DraweeController。最后便是获取结果并显示了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"layout":"使用hexo+githb","title":"pages搭建个人博客","date":"2016-11-29T03:49:42.000Z","_content":"<Excerpt in index | 首页摘要> \n### 搭建步骤\n\n1. 下载nodejs并安装\n2. 安装hexo npm install -g hexo-cli\n<!-- more -->\n<The rest of contents | 余下全文>\n3. 初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx\n4. 进入本地仓库，初始化hexo站点，hexo init\n5. 修改配置_config.yml，public_dir 为 ./\n6. 修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下\n7. 修改root目录下的_congig.yml文件，修改```theme: spfk``` 并且修改deploy 为 \n\t\n\t```\ndeploy:\n  type: git\n  repo: https://github.com/Guolei1130/Guolei1130.github.io.git\n  branch: master \n\t``` \n根据需求或者主题需要，修改其他相应的配置\n\n8. hexo generate 重新生成静态网页\n9. hexo new blogname，生成你的blog\n10. push到github,进行测试\n\n\n\n### 一些基本操作\n\n* hexo new blogname 生成blog\n* hexo generate(g)  重新生成静态页面\n* hexo server(s)  启动本地服务器\n\n### 关于博客中的图片\n\n个人建议放在_posts同级目录，规则按image/年/月/文章/来放\n\n### 关于删除文章\n\n直接删除_post下的即可\n\n\n\n### 多说\n\n大部分主题支持pv统计和多说，pv统计，大多数我们不需要改\n去http://duoshuo.com/create-site/注册，并修改theme中的配置\n\n```\nduoshuo: \n  on: true\n  domain: guolei1130\n  # 是否开启多说评论，http://duoshuo.com/create-site/\n  # 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\n  # http://<要填的部分>.duoshuo.com (domain只填上<>里的内容，不要填整个网址)\n```\n\n配置完push到github，就可在多说管理后台进行管理\n\n### 关于全文模式\n先在主题的配置文件中，添加\n```\nauto_excerpt:\nenable: false\nlength: 150\n```\n\n然后在文章的最前面加\n\n```\n<Excerpt in index | 首页摘要> \n```\n\n在文章最后增加 \n\n```\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n```\n\n### 关于图片资源问题\n\n有两种办法\n\n* 将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法\n* 找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/hexo+github pages搭建个人博客.md","raw":"layout: 使用hexo+githb\ntitle: pages搭建个人博客\ncategories: hexo\ndate: 2016-11-29 11:49:42\ntags: hexo\n\n---\n<Excerpt in index | 首页摘要> \n### 搭建步骤\n\n1. 下载nodejs并安装\n2. 安装hexo npm install -g hexo-cli\n<!-- more -->\n<The rest of contents | 余下全文>\n3. 初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx\n4. 进入本地仓库，初始化hexo站点，hexo init\n5. 修改配置_config.yml，public_dir 为 ./\n6. 修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下\n7. 修改root目录下的_congig.yml文件，修改```theme: spfk``` 并且修改deploy 为 \n\t\n\t```\ndeploy:\n  type: git\n  repo: https://github.com/Guolei1130/Guolei1130.github.io.git\n  branch: master \n\t``` \n根据需求或者主题需要，修改其他相应的配置\n\n8. hexo generate 重新生成静态网页\n9. hexo new blogname，生成你的blog\n10. push到github,进行测试\n\n\n\n### 一些基本操作\n\n* hexo new blogname 生成blog\n* hexo generate(g)  重新生成静态页面\n* hexo server(s)  启动本地服务器\n\n### 关于博客中的图片\n\n个人建议放在_posts同级目录，规则按image/年/月/文章/来放\n\n### 关于删除文章\n\n直接删除_post下的即可\n\n\n\n### 多说\n\n大部分主题支持pv统计和多说，pv统计，大多数我们不需要改\n去http://duoshuo.com/create-site/注册，并修改theme中的配置\n\n```\nduoshuo: \n  on: true\n  domain: guolei1130\n  # 是否开启多说评论，http://duoshuo.com/create-site/\n  # 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\n  # http://<要填的部分>.duoshuo.com (domain只填上<>里的内容，不要填整个网址)\n```\n\n配置完push到github，就可在多说管理后台进行管理\n\n### 关于全文模式\n先在主题的配置文件中，添加\n```\nauto_excerpt:\nenable: false\nlength: 150\n```\n\n然后在文章的最前面加\n\n```\n<Excerpt in index | 首页摘要> \n```\n\n在文章最后增加 \n\n```\n+ <!-- more -->\n<The rest of contents | 余下全文>\n\n```\n\n### 关于图片资源问题\n\n有两种办法\n\n* 将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法\n* 找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"hexo+github pages搭建个人博客","published":1,"updated":"2017-01-07T06:58:36.000Z","comments":1,"photos":[],"link":"","_id":"ciy1ncy2o001zhws6w71r8ojz","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"> </excerpt></p>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3><ol>\n<li>下载nodejs并安装</li>\n<li>安装hexo npm install -g hexo-cli<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\"></the></li>\n<li>初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx</li>\n<li>进入本地仓库，初始化hexo站点，hexo init</li>\n<li>修改配置_config.yml，public_dir 为 ./</li>\n<li>修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下</li>\n<li>修改root目录下的_congig.yml文件，修改<figure class=\"highlight plain\"><figcaption><span>spfk``` 并且修改deploy 为 </span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t</div></pre></td></tr></table></figure></li>\n</ol>\n<p>deploy:<br>  type: git<br>  repo: <a href=\"https://github.com/Guolei1130/Guolei1130.github.io.git\" target=\"_blank\" rel=\"external\">https://github.com/Guolei1130/Guolei1130.github.io.git</a><br>  branch: master<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据需求或者主题需要，修改其他相应的配置</div><div class=\"line\"></div><div class=\"line\">8. hexo generate 重新生成静态网页</div><div class=\"line\">9. hexo new blogname，生成你的blog</div><div class=\"line\">10. push到github,进行测试</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 一些基本操作</div><div class=\"line\"></div><div class=\"line\">* hexo new blogname 生成blog</div><div class=\"line\">* hexo generate(g)  重新生成静态页面</div><div class=\"line\">* hexo server(s)  启动本地服务器</div><div class=\"line\"></div><div class=\"line\">### 关于博客中的图片</div><div class=\"line\"></div><div class=\"line\">个人建议放在_posts同级目录，规则按image/年/月/文章/来放</div><div class=\"line\"></div><div class=\"line\">### 关于删除文章</div><div class=\"line\"></div><div class=\"line\">直接删除_post下的即可</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 多说</div><div class=\"line\"></div><div class=\"line\">大部分主题支持pv统计和多说，pv统计，大多数我们不需要改</div><div class=\"line\">去http://duoshuo.com/create-site/注册，并修改theme中的配置</div></pre></td></tr></table></figure></p>\n<p>duoshuo:<br>  on: true<br>  domain: guolei1130</p>\n<h1 id=\"是否开启多说评论，http-duoshuo-com-create-site\"><a href=\"#是否开启多说评论，http-duoshuo-com-create-site\" class=\"headerlink\" title=\"是否开启多说评论，http://duoshuo.com/create-site/\"></a>是否开启多说评论，<a href=\"http://duoshuo.com/create-site/\" target=\"_blank\" rel=\"external\">http://duoshuo.com/create-site/</a></h1><h1 id=\"使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\"><a href=\"#使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\" class=\"headerlink\" title=\"使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\"></a>使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分</h1><h1 id=\"http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\"><a href=\"#http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\" class=\"headerlink\" title=\"http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)\"></a>http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">配置完push到github，就可在多说管理后台进行管理</div><div class=\"line\"></div><div class=\"line\">### 关于全文模式</div><div class=\"line\">先在主题的配置文件中，添加</div></pre></td></tr></table></figure>\n<p>auto_excerpt:<br>enable: false<br>length: 150<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后在文章的最前面加</div></pre></td></tr></table></figure></p>\n<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在文章最后增加</div></pre></td></tr></table></figure></excerpt></p>\n<ul>\n<li><!-- more -->\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n</the></li>\n</ul>\n<p>```</p>\n<h3 id=\"关于图片资源问题\"><a href=\"#关于图片资源问题\" class=\"headerlink\" title=\"关于图片资源问题\"></a>关于图片资源问题</h3><p>有两种办法</p>\n<ul>\n<li>将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法</li>\n<li>找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","excerpt":"<p><Excerpt in index | 首页摘要> </p>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3><ol>\n<li>下载nodejs并安装</li>\n<li>安装hexo npm install -g hexo-cli","more":"<The rest of contents | 余下全文></li>\n<li>初始化gitpage，注意即使用户名大些 也弄小写，然后在电脑中 git clone xxx</li>\n<li>进入本地仓库，初始化hexo站点，hexo init</li>\n<li>修改配置_config.yml，public_dir 为 ./</li>\n<li>修改主题 找到好的主题包，下载zip或者git，将下面主题相关的文件复制到themes/某主题名下</li>\n<li>修改root目录下的_congig.yml文件，修改<figure class=\"highlight plain\"><figcaption><span>spfk``` 并且修改deploy 为 </span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t</div></pre></td></tr></table></figure></li>\n</ol>\n<p>deploy:<br>  type: git<br>  repo: <a href=\"https://github.com/Guolei1130/Guolei1130.github.io.git\">https://github.com/Guolei1130/Guolei1130.github.io.git</a><br>  branch: master<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据需求或者主题需要，修改其他相应的配置</div><div class=\"line\"></div><div class=\"line\">8. hexo generate 重新生成静态网页</div><div class=\"line\">9. hexo new blogname，生成你的blog</div><div class=\"line\">10. push到github,进行测试</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 一些基本操作</div><div class=\"line\"></div><div class=\"line\">* hexo new blogname 生成blog</div><div class=\"line\">* hexo generate(g)  重新生成静态页面</div><div class=\"line\">* hexo server(s)  启动本地服务器</div><div class=\"line\"></div><div class=\"line\">### 关于博客中的图片</div><div class=\"line\"></div><div class=\"line\">个人建议放在_posts同级目录，规则按image/年/月/文章/来放</div><div class=\"line\"></div><div class=\"line\">### 关于删除文章</div><div class=\"line\"></div><div class=\"line\">直接删除_post下的即可</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 多说</div><div class=\"line\"></div><div class=\"line\">大部分主题支持pv统计和多说，pv统计，大多数我们不需要改</div><div class=\"line\">去http://duoshuo.com/create-site/注册，并修改theme中的配置</div></pre></td></tr></table></figure></p>\n<p>duoshuo:<br>  on: true<br>  domain: guolei1130</p>\n<h1 id=\"是否开启多说评论，http-duoshuo-com-create-site\"><a href=\"#是否开启多说评论，http-duoshuo-com-create-site\" class=\"headerlink\" title=\"是否开启多说评论，http://duoshuo.com/create-site/\"></a>是否开启多说评论，<a href=\"http://duoshuo.com/create-site/\">http://duoshuo.com/create-site/</a></h1><h1 id=\"使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\"><a href=\"#使用上面网址登陆你的多说，然后创建站点，在-domain-中填入你设定的域名前半部分\" class=\"headerlink\" title=\"使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分\"></a>使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分</h1><h1 id=\"http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\"><a href=\"#http-lt-要填的部分-gt-duoshuo-com-domain只填上-lt-gt-里的内容，不要填整个网址\" class=\"headerlink\" title=\"http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)\"></a>http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">配置完push到github，就可在多说管理后台进行管理</div><div class=\"line\"></div><div class=\"line\">### 关于全文模式</div><div class=\"line\">先在主题的配置文件中，添加</div></pre></td></tr></table></figure>\n<p>auto_excerpt:<br>enable: false<br>length: 150<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后在文章的最前面加</div></pre></td></tr></table></figure></p>\n<p><Excerpt in index | 首页摘要><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在文章最后增加</div></pre></td></tr></table></figure></p>\n<ul>\n<li><!-- more -->\n<The rest of contents | 余下全文>\n\n</li>\n</ul>\n<p>```</p>\n<h3 id=\"关于图片资源问题\"><a href=\"#关于图片资源问题\" class=\"headerlink\" title=\"关于图片资源问题\"></a>关于图片资源问题</h3><p>有两种办法</p>\n<ul>\n<li>将图片放在source/images／文件下，通过/images/xx.png 来引用，注意使用mackdown的语法</li>\n<li>找根目录的配置文件中，将post_asset_folder: true 打开，每次用命令生成post的时候就会生成一个对应的文件夹</li>\n</ul>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco图片decode的大体流程","date":"2016-12-13T08:10:51.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 从DecodeProducer说fresco的解码过程\n\nDecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n  @Override\n  public void produceResults(\n      final Consumer<CloseableReference<CloseableImage>> consumer,\n      final ProducerContext producerContext) {\n    final ImageRequest imageRequest = producerContext.getImageRequest();\n    ProgressiveDecoder progressiveDecoder;\n    if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {\n      progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);\n    } else {\n      ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);\n      progressiveDecoder = new NetworkImagesProgressiveDecoder(\n          consumer,\n          producerContext,\n          jpegParser,\n          mProgressiveJpegConfig);\n    }\n    mInputProducer.produceResults(progressiveDecoder, producerContext);\n  }\n```\n\n* 通过判断uri的类型 选择不同的渐近式解释器\n* local和network都继承自ProgressiveDecoder\n\n在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。\n\n### 2. ImageDecoder\n\n这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。\n\n```\n  public CloseableImage decodeImage(\n      final EncodedImage encodedImage,\n      final int length,\n      final QualityInfo qualityInfo,\n      final ImageDecodeOptions options) {\n    ImageFormat imageFormat = encodedImage.getImageFormat();\n    if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) {\n      imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(\n          encodedImage.getInputStream());\n      encodedImage.setImageFormat(imageFormat);\n    }\n    if (imageFormat == DefaultImageFormats.JPEG) {\n      return decodeJpeg(encodedImage, length, qualityInfo);\n    } else if (imageFormat == DefaultImageFormats.GIF) {\n      return decodeGif(encodedImage, options);\n    } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {\n      return decodeAnimatedWebp(encodedImage, options);\n    } else if (imageFormat == ImageFormat.UNKNOWN) {\n      throw new IllegalArgumentException(\"unknown image format\");\n    }\n    return decodeStaticImage(encodedImage);\n  }\n```\n\n* 先判断未解码的图片类型\n* 根据不同的图片类型选择不同的解码方式\n\n#### 2.1 ImageFormatChecker\n\n这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为\n\n```\n  private static final byte[] PNG_HEADER = new byte[] {\n      (byte) 0x89,\n      'P', 'N', 'G',\n      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};\n```\n\n如果不熟ascll表的话，可以去查阅'P''N''G'在ascll表中对应的16进制。\n\n\n#### 2.2 解析种类\n\n根据代码能看出，这里分为几种。\n\n* JPEG\n* GIF\n* WEBP_ANIMATED\n* 其他\n\n从是否静态图上来看，为两种，\n\n* 可动 ，用AnimatedImageFactory进行解析\n* 不可动，用PlatformDecoder进行解析\n\n\n### 3. AnimatedImageFactory\n\n\nAnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。\n\n在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。\n\n```\n  private static AnimatedImageDecoder loadIfPresent(final String className) {\n    try {\n      Class<?> clazz = Class.forName(className);\n      return (AnimatedImageDecoder) clazz.newInstance();\n    } catch (Throwable e) {\n      return null;\n    }\n  }\n\n  static {\n    sGifAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.gif.GifImage\");\n    sWebpAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.webp.WebPImage\");\n  }\n```\n\n解析分为两个步骤。\n\n* 通过AnimatedImageDecoder解析出AnimatedImage\n* 利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。\n\n关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。\n\ngetCloseableImage的逻辑如下：\n\n* 用decodeAllFrames解析出所有帧\n* 用createPreviewBitmap构造预览的bitmap\n* 构造AnimatedImageResult对象\n* 用AnimatedImageResult构造CloseableAnimatedImage对象。\n\n这里就不再多说了，等到后面学习webp和gif的时候再说。\n\n### 4.PlatformDecoder\n\nPlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。\n\n![](/images/fresco/fresco_3.png)\n\n从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。\n\n* 在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的\n* 5.0以下，则是存在Ashmem匿名共享内存中。\n\n\n5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，\n\n```\n  @Override\n  public CloseableReference<Bitmap> decodeFromEncodedImage(\n      final EncodedImage encodedImage,\n      Bitmap.Config bitmapConfig) {\n    BitmapFactory.Options options = getBitmapFactoryOptions(\n        encodedImage.getSampleSize(),\n        bitmapConfig);\n    CloseableReference<PooledByteBuffer> bytesRef = encodedImage.getByteBufferRef();\n    Preconditions.checkNotNull(bytesRef);\n    try {\n      Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);\n      return pinBitmap(bitmap);\n    } finally {\n      CloseableReference.closeSafely(bytesRef);\n    }\n  }\n```\n\n* getBitmapFactoryOptions 获取BitmapFactory.Options\n* decodeByteArrayAsPurgeable 获取bitmap\n* pinBitmap 真正的decode\n\n我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。\n\n而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","source":"_posts/fresco图片decode的大体流程.md","raw":"---\ntitle: fresco图片decode的大体流程\ndate: 2016-12-13 16:10:51\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 从DecodeProducer说fresco的解码过程\n\nDecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n```\n  @Override\n  public void produceResults(\n      final Consumer<CloseableReference<CloseableImage>> consumer,\n      final ProducerContext producerContext) {\n    final ImageRequest imageRequest = producerContext.getImageRequest();\n    ProgressiveDecoder progressiveDecoder;\n    if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {\n      progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);\n    } else {\n      ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);\n      progressiveDecoder = new NetworkImagesProgressiveDecoder(\n          consumer,\n          producerContext,\n          jpegParser,\n          mProgressiveJpegConfig);\n    }\n    mInputProducer.produceResults(progressiveDecoder, producerContext);\n  }\n```\n\n* 通过判断uri的类型 选择不同的渐近式解释器\n* local和network都继承自ProgressiveDecoder\n\n在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。\n\n### 2. ImageDecoder\n\n这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。\n\n```\n  public CloseableImage decodeImage(\n      final EncodedImage encodedImage,\n      final int length,\n      final QualityInfo qualityInfo,\n      final ImageDecodeOptions options) {\n    ImageFormat imageFormat = encodedImage.getImageFormat();\n    if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) {\n      imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(\n          encodedImage.getInputStream());\n      encodedImage.setImageFormat(imageFormat);\n    }\n    if (imageFormat == DefaultImageFormats.JPEG) {\n      return decodeJpeg(encodedImage, length, qualityInfo);\n    } else if (imageFormat == DefaultImageFormats.GIF) {\n      return decodeGif(encodedImage, options);\n    } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {\n      return decodeAnimatedWebp(encodedImage, options);\n    } else if (imageFormat == ImageFormat.UNKNOWN) {\n      throw new IllegalArgumentException(\"unknown image format\");\n    }\n    return decodeStaticImage(encodedImage);\n  }\n```\n\n* 先判断未解码的图片类型\n* 根据不同的图片类型选择不同的解码方式\n\n#### 2.1 ImageFormatChecker\n\n这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为\n\n```\n  private static final byte[] PNG_HEADER = new byte[] {\n      (byte) 0x89,\n      'P', 'N', 'G',\n      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};\n```\n\n如果不熟ascll表的话，可以去查阅'P''N''G'在ascll表中对应的16进制。\n\n\n#### 2.2 解析种类\n\n根据代码能看出，这里分为几种。\n\n* JPEG\n* GIF\n* WEBP_ANIMATED\n* 其他\n\n从是否静态图上来看，为两种，\n\n* 可动 ，用AnimatedImageFactory进行解析\n* 不可动，用PlatformDecoder进行解析\n\n\n### 3. AnimatedImageFactory\n\n\nAnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。\n\n在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。\n\n```\n  private static AnimatedImageDecoder loadIfPresent(final String className) {\n    try {\n      Class<?> clazz = Class.forName(className);\n      return (AnimatedImageDecoder) clazz.newInstance();\n    } catch (Throwable e) {\n      return null;\n    }\n  }\n\n  static {\n    sGifAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.gif.GifImage\");\n    sWebpAnimatedImageDecoder = loadIfPresent(\"com.facebook.animated.webp.WebPImage\");\n  }\n```\n\n解析分为两个步骤。\n\n* 通过AnimatedImageDecoder解析出AnimatedImage\n* 利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。\n\n关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。\n\ngetCloseableImage的逻辑如下：\n\n* 用decodeAllFrames解析出所有帧\n* 用createPreviewBitmap构造预览的bitmap\n* 构造AnimatedImageResult对象\n* 用AnimatedImageResult构造CloseableAnimatedImage对象。\n\n这里就不再多说了，等到后面学习webp和gif的时候再说。\n\n### 4.PlatformDecoder\n\nPlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。\n\n![](/images/fresco/fresco_3.png)\n\n从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。\n\n* 在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的\n* 5.0以下，则是存在Ashmem匿名共享内存中。\n\n\n5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，\n\n```\n  @Override\n  public CloseableReference<Bitmap> decodeFromEncodedImage(\n      final EncodedImage encodedImage,\n      Bitmap.Config bitmapConfig) {\n    BitmapFactory.Options options = getBitmapFactoryOptions(\n        encodedImage.getSampleSize(),\n        bitmapConfig);\n    CloseableReference<PooledByteBuffer> bytesRef = encodedImage.getByteBufferRef();\n    Preconditions.checkNotNull(bytesRef);\n    try {\n      Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);\n      return pinBitmap(bitmap);\n    } finally {\n      CloseableReference.closeSafely(bytesRef);\n    }\n  }\n```\n\n* getBitmapFactoryOptions 获取BitmapFactory.Options\n* decodeByteArrayAsPurgeable 获取bitmap\n* pinBitmap 真正的decode\n\n我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。\n\n而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。\n\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n","slug":"fresco图片decode的大体流程","published":1,"updated":"2017-01-07T06:58:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2q0022hws6tugxbcqr","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-从DecodeProducer说fresco的解码过程\"><a href=\"#1-从DecodeProducer说fresco的解码过程\" class=\"headerlink\" title=\"1. 从DecodeProducer说fresco的解码过程\"></a>1. 从DecodeProducer说fresco的解码过程</h3><p>DecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void produceResults(</div><div class=\"line\">    final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,</div><div class=\"line\">    final ProducerContext producerContext) &#123;</div><div class=\"line\">  final ImageRequest imageRequest = producerContext.getImageRequest();</div><div class=\"line\">  ProgressiveDecoder progressiveDecoder;</div><div class=\"line\">  if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) &#123;</div><div class=\"line\">    progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);</div><div class=\"line\">    progressiveDecoder = new NetworkImagesProgressiveDecoder(</div><div class=\"line\">        consumer,</div><div class=\"line\">        producerContext,</div><div class=\"line\">        jpegParser,</div><div class=\"line\">        mProgressiveJpegConfig);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mInputProducer.produceResults(progressiveDecoder, producerContext);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过判断uri的类型 选择不同的渐近式解释器</li>\n<li>local和network都继承自ProgressiveDecoder</li>\n</ul>\n<p>在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。</p>\n<h3 id=\"2-ImageDecoder\"><a href=\"#2-ImageDecoder\" class=\"headerlink\" title=\"2. ImageDecoder\"></a>2. ImageDecoder</h3><p>这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public CloseableImage decodeImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    final int length,</div><div class=\"line\">    final QualityInfo qualityInfo,</div><div class=\"line\">    final ImageDecodeOptions options) &#123;</div><div class=\"line\">  ImageFormat imageFormat = encodedImage.getImageFormat();</div><div class=\"line\">  if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(</div><div class=\"line\">        encodedImage.getInputStream());</div><div class=\"line\">    encodedImage.setImageFormat(imageFormat);</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (imageFormat == DefaultImageFormats.JPEG) &#123;</div><div class=\"line\">    return decodeJpeg(encodedImage, length, qualityInfo);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.GIF) &#123;</div><div class=\"line\">    return decodeGif(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) &#123;</div><div class=\"line\">    return decodeAnimatedWebp(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    throw new IllegalArgumentException(&quot;unknown image format&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return decodeStaticImage(encodedImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先判断未解码的图片类型</li>\n<li>根据不同的图片类型选择不同的解码方式</li>\n</ul>\n<h4 id=\"2-1-ImageFormatChecker\"><a href=\"#2-1-ImageFormatChecker\" class=\"headerlink\" title=\"2.1 ImageFormatChecker\"></a>2.1 ImageFormatChecker</h4><p>这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final byte[] PNG_HEADER = new byte[] &#123;</div><div class=\"line\">    (byte) 0x89,</div><div class=\"line\">    &apos;P&apos;, &apos;N&apos;, &apos;G&apos;,</div><div class=\"line\">    (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A&#125;;</div></pre></td></tr></table></figure>\n<p>如果不熟ascll表的话，可以去查阅’P’’N’’G’在ascll表中对应的16进制。</p>\n<h4 id=\"2-2-解析种类\"><a href=\"#2-2-解析种类\" class=\"headerlink\" title=\"2.2 解析种类\"></a>2.2 解析种类</h4><p>根据代码能看出，这里分为几种。</p>\n<ul>\n<li>JPEG</li>\n<li>GIF</li>\n<li>WEBP_ANIMATED</li>\n<li>其他</li>\n</ul>\n<p>从是否静态图上来看，为两种，</p>\n<ul>\n<li>可动 ，用AnimatedImageFactory进行解析</li>\n<li>不可动，用PlatformDecoder进行解析</li>\n</ul>\n<h3 id=\"3-AnimatedImageFactory\"><a href=\"#3-AnimatedImageFactory\" class=\"headerlink\" title=\"3. AnimatedImageFactory\"></a>3. AnimatedImageFactory</h3><p>AnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。</p>\n<p>在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static AnimatedImageDecoder loadIfPresent(final String className) &#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Class&lt;?&gt; clazz = Class.forName(className);</div><div class=\"line\">    return (AnimatedImageDecoder) clazz.newInstance();</div><div class=\"line\">  &#125; catch (Throwable e) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">  sGifAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.gif.GifImage&quot;);</div><div class=\"line\">  sWebpAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.webp.WebPImage&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析分为两个步骤。</p>\n<ul>\n<li>通过AnimatedImageDecoder解析出AnimatedImage</li>\n<li>利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。</li>\n</ul>\n<p>关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。</p>\n<p>getCloseableImage的逻辑如下：</p>\n<ul>\n<li>用decodeAllFrames解析出所有帧</li>\n<li>用createPreviewBitmap构造预览的bitmap</li>\n<li>构造AnimatedImageResult对象</li>\n<li>用AnimatedImageResult构造CloseableAnimatedImage对象。</li>\n</ul>\n<p>这里就不再多说了，等到后面学习webp和gif的时候再说。</p>\n<h3 id=\"4-PlatformDecoder\"><a href=\"#4-PlatformDecoder\" class=\"headerlink\" title=\"4.PlatformDecoder\"></a>4.PlatformDecoder</h3><p>PlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。</p>\n<p><img src=\"/images/fresco/fresco_3.png\" alt=\"\"></p>\n<p>从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。</p>\n<ul>\n<li>在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的</li>\n<li>5.0以下，则是存在Ashmem匿名共享内存中。</li>\n</ul>\n<p>5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    Bitmap.Config bitmapConfig) &#123;</div><div class=\"line\">  BitmapFactory.Options options = getBitmapFactoryOptions(</div><div class=\"line\">      encodedImage.getSampleSize(),</div><div class=\"line\">      bitmapConfig);</div><div class=\"line\">  CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef();</div><div class=\"line\">  Preconditions.checkNotNull(bytesRef);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);</div><div class=\"line\">    return pinBitmap(bitmap);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    CloseableReference.closeSafely(bytesRef);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getBitmapFactoryOptions 获取BitmapFactory.Options</li>\n<li>decodeByteArrayAsPurgeable 获取bitmap</li>\n<li>pinBitmap 真正的decode</li>\n</ul>\n<p>我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。</p>\n<p>而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-从DecodeProducer说fresco的解码过程\"><a href=\"#1-从DecodeProducer说fresco的解码过程\" class=\"headerlink\" title=\"1. 从DecodeProducer说fresco的解码过程\"></a>1. 从DecodeProducer说fresco的解码过程</h3><p>DecodeProducer负责用未解码的数据生产出解码的数据。先看produceResults方法。</p>","more":"<The rest of contents | 余下全文>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void produceResults(</div><div class=\"line\">    final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,</div><div class=\"line\">    final ProducerContext producerContext) &#123;</div><div class=\"line\">  final ImageRequest imageRequest = producerContext.getImageRequest();</div><div class=\"line\">  ProgressiveDecoder progressiveDecoder;</div><div class=\"line\">  if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) &#123;</div><div class=\"line\">    progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, producerContext);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);</div><div class=\"line\">    progressiveDecoder = new NetworkImagesProgressiveDecoder(</div><div class=\"line\">        consumer,</div><div class=\"line\">        producerContext,</div><div class=\"line\">        jpegParser,</div><div class=\"line\">        mProgressiveJpegConfig);</div><div class=\"line\">  &#125;</div><div class=\"line\">  mInputProducer.produceResults(progressiveDecoder, producerContext);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过判断uri的类型 选择不同的渐近式解释器</li>\n<li>local和network都继承自ProgressiveDecoder</li>\n</ul>\n<p>在ProgressiveDecoder的构造方法中，doDecode(encodedImage, isLast) 进行解析。而真正解析的则是ImageDecoder#decodeImage方法，这个方法将encodedImage解析成CloseableImage。</p>\n<h3 id=\"2-ImageDecoder\"><a href=\"#2-ImageDecoder\" class=\"headerlink\" title=\"2. ImageDecoder\"></a>2. ImageDecoder</h3><p>这个类是用来将未解码的EncodeImage,解码成对应的CloseableImage。解析的入口方法decodeImage。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public CloseableImage decodeImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    final int length,</div><div class=\"line\">    final QualityInfo qualityInfo,</div><div class=\"line\">    final ImageDecodeOptions options) &#123;</div><div class=\"line\">  ImageFormat imageFormat = encodedImage.getImageFormat();</div><div class=\"line\">  if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(</div><div class=\"line\">        encodedImage.getInputStream());</div><div class=\"line\">    encodedImage.setImageFormat(imageFormat);</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (imageFormat == DefaultImageFormats.JPEG) &#123;</div><div class=\"line\">    return decodeJpeg(encodedImage, length, qualityInfo);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.GIF) &#123;</div><div class=\"line\">    return decodeGif(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) &#123;</div><div class=\"line\">    return decodeAnimatedWebp(encodedImage, options);</div><div class=\"line\">  &#125; else if (imageFormat == ImageFormat.UNKNOWN) &#123;</div><div class=\"line\">    throw new IllegalArgumentException(&quot;unknown image format&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return decodeStaticImage(encodedImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先判断未解码的图片类型</li>\n<li>根据不同的图片类型选择不同的解码方式</li>\n</ul>\n<h4 id=\"2-1-ImageFormatChecker\"><a href=\"#2-1-ImageFormatChecker\" class=\"headerlink\" title=\"2.1 ImageFormatChecker\"></a>2.1 ImageFormatChecker</h4><p>这个类是根据输入流来确定图片的类型。基本原理是根据头标识去确定类型。如png的头标识为89 50 4E 47 0D 0A 1A 0A。对应的就为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final byte[] PNG_HEADER = new byte[] &#123;</div><div class=\"line\">    (byte) 0x89,</div><div class=\"line\">    &apos;P&apos;, &apos;N&apos;, &apos;G&apos;,</div><div class=\"line\">    (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A&#125;;</div></pre></td></tr></table></figure>\n<p>如果不熟ascll表的话，可以去查阅’P’’N’’G’在ascll表中对应的16进制。</p>\n<h4 id=\"2-2-解析种类\"><a href=\"#2-2-解析种类\" class=\"headerlink\" title=\"2.2 解析种类\"></a>2.2 解析种类</h4><p>根据代码能看出，这里分为几种。</p>\n<ul>\n<li>JPEG</li>\n<li>GIF</li>\n<li>WEBP_ANIMATED</li>\n<li>其他</li>\n</ul>\n<p>从是否静态图上来看，为两种，</p>\n<ul>\n<li>可动 ，用AnimatedImageFactory进行解析</li>\n<li>不可动，用PlatformDecoder进行解析</li>\n</ul>\n<h3 id=\"3-AnimatedImageFactory\"><a href=\"#3-AnimatedImageFactory\" class=\"headerlink\" title=\"3. AnimatedImageFactory\"></a>3. AnimatedImageFactory</h3><p>AnimatedImageFactory是一个接口，他的实现类是AnimatedImageFactoryImpl。</p>\n<p>在这个类的静态方法块种，通过如下代码 来构造其他依赖包中的对象，这个小技巧我们可以get一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static AnimatedImageDecoder loadIfPresent(final String className) &#123;</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Class&lt;?&gt; clazz = Class.forName(className);</div><div class=\"line\">    return (AnimatedImageDecoder) clazz.newInstance();</div><div class=\"line\">  &#125; catch (Throwable e) &#123;</div><div class=\"line\">    return null;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">  sGifAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.gif.GifImage&quot;);</div><div class=\"line\">  sWebpAnimatedImageDecoder = loadIfPresent(&quot;com.facebook.animated.webp.WebPImage&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析分为两个步骤。</p>\n<ul>\n<li>通过AnimatedImageDecoder解析出AnimatedImage</li>\n<li>利用getCloseableImage从AnimatedImage中构造出CloseableAnimatedImage。这是CloseableImage的之类。</li>\n</ul>\n<p>关于AnimatedImageDecoder解析gif和webp，我们后面的文章介绍。</p>\n<p>getCloseableImage的逻辑如下：</p>\n<ul>\n<li>用decodeAllFrames解析出所有帧</li>\n<li>用createPreviewBitmap构造预览的bitmap</li>\n<li>构造AnimatedImageResult对象</li>\n<li>用AnimatedImageResult构造CloseableAnimatedImage对象。</li>\n</ul>\n<p>这里就不再多说了，等到后面学习webp和gif的时候再说。</p>\n<h3 id=\"4-PlatformDecoder\"><a href=\"#4-PlatformDecoder\" class=\"headerlink\" title=\"4.PlatformDecoder\"></a>4.PlatformDecoder</h3><p>PlatformDecoder是一个接口，代表不同平台。我们看他的实现类有哪些。</p>\n<p><img src=\"/images/fresco/fresco_3.png\" alt=\"\"></p>\n<p>从图中可以看出，从虚拟机层次分为dalvik和art虚拟机，从版本来看，为2.3-4.0，5.0以上。</p>\n<ul>\n<li>在5.0 以后，也就是ArtDecoder的实现，缓存是直接存在java堆上的</li>\n<li>5.0以下，则是存在Ashmem匿名共享内存中。</li>\n</ul>\n<p>5.0 以上的实现这里就不说，这里先引出Ashmem。从decodeFromEncodedImage看起，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public CloseableReference&lt;Bitmap&gt; decodeFromEncodedImage(</div><div class=\"line\">    final EncodedImage encodedImage,</div><div class=\"line\">    Bitmap.Config bitmapConfig) &#123;</div><div class=\"line\">  BitmapFactory.Options options = getBitmapFactoryOptions(</div><div class=\"line\">      encodedImage.getSampleSize(),</div><div class=\"line\">      bitmapConfig);</div><div class=\"line\">  CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef();</div><div class=\"line\">  Preconditions.checkNotNull(bytesRef);</div><div class=\"line\">  try &#123;</div><div class=\"line\">    Bitmap bitmap = decodeByteArrayAsPurgeable(bytesRef, options);</div><div class=\"line\">    return pinBitmap(bitmap);</div><div class=\"line\">  &#125; finally &#123;</div><div class=\"line\">    CloseableReference.closeSafely(bytesRef);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getBitmapFactoryOptions 获取BitmapFactory.Options</li>\n<li>decodeByteArrayAsPurgeable 获取bitmap</li>\n<li>pinBitmap 真正的decode</li>\n</ul>\n<p>我们需要注意的BitmapFactory.Options参数是options.inPurgeable = true，这样decode出来的bitmap是在Ashmem内存中，gc是无法自动回收的。</p>\n<p>而在pinBitmap中，是通过Bitmaps调用native将bitmap pin住，这样即使在系统内存不够的时候 也不会回收，当我们不需要使用的时候，调用nativeReleaseByteBuffer这个native函数，将bitmap unpin，就可以被回收了。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"jvm垃圾回收","date":"2017-01-14T12:00:28.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\njava与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。\n\n### 如何判断对象已死\n\n#### 引用计数\n\n首先说明，jvm中并没有选择引用计数。\n\n给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。\n\n#### 可达性分析算法\n\n通过一系列\"GC Roots\"的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。\n\n![](http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n在java中，GC Roots对象包括以下几种:\n\n* 虚拟机栈(帧栈中的本地变量表)中的应用对象\n* 方法区中类静态属性引用的对象(static)\n* 方法区中常量引用的对象\n* 本地方法栈中(一般说的native方法)引用的对象\n\n#### 自我救赎\n\n在可达性分析中被标记不可达的对象，也不是非死不可。\n\n要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。\n\n#### 回收方法区\n\n方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。\n\n废弃常量-没有对象引用的话，就会被移除常量池，进行回收\n无用的类，类加载容易，卸载难，满足卸载的条件如下：\n\n* 该类的所有实例都被回收\n* 加载该类的ClassLoader被回收\n* 对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法\n\n### 垃圾回收算法\n\n#### 标记－清理算法\n\n![](http://images.cnitblog.com/i/288799/201406/181024382398115.jpg)\n\n首先标记出需要回收的对象，然后清理掉需要回收的对象。\n\n缺点：\n\n* 标记和回收的过程效率都不高\n* 会产生内存碎片\n\n#### 复制算法\n\n![](http://images.cnitblog.com/i/288799/201406/181041528488728.jpg)\n\n将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。\n\nhotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。\n\n但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)\n\n在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。\n\n#### 标记－整体算法\n\n![](http://images.cnitblog.com/i/288799/201406/181100129575916.jpg)\n\n先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。\n\n#### 分代算法\n\n将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。\n\n#### 总结\n\n新生代适合复制算法。老生代适合标记－清理、标记－整体之类。\n\n\n### HotSpot的算法实现\n\n* 枚举根节点,这个时候需要停止所有的执行线程(Stop The World)\n* 安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停\n* 安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc\n\n### 垃圾收集器\n\n![](http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg)\n\n####  Serial(old)收集器\n\n串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。\n\n![](http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg)\n\n图为Serial和Serial Old结合使用的图。\n\n#### ParNew收集器\n\n是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：\n\n![](http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg)\n\n\nParNew收集器在cpu核数多的情况下才有优势。\n\n#### Parallel Scavenge收集器\n\n目标：吞吐量\n\n参数：\n\n* -XX:MaxGCPauseMillis 控制最大停顿时间\n* -XX:GCTimeRatio 直接设置吞吐量大小\n\n#### Parallel Old\n\nParallel的老生代版本，使用多线程和标记－整理算法。\n\n#### CMS收集器\n\nCMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。\n\n过程：\n\n* 初始标记 cms initial mark\n* 并发标记 cms concurrent mark\n* 重新标记 cms remark\n* 并发清除 cms concurrent sweep\n\n![](http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg)\n\n缺点：\n\n* 对cpu资源敏感\n* 无法处理浮动垃圾\n* 大量碎片\n\n#### G1收集器\n\nG1(garbage first)，面向服务端的垃圾收集器。具备以下特点：\n\n* 并行与并发\n* 分代收集\n* 空间整合\n* 可预测停顿\n\ng1收集器的运作大致可划分为以下几个步骤:\n\n* 初始标记 initial marking\n* 并发标记 concurrent marking\n* 最终标记 final marking\n* 筛选会后 live data counting and evacuation\n\n\n\n\n\n### 内存分配策略\n\n* 对象优先在Eden分配(新生代)\n* 大对象直接进入老年代\n* 长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代\n* 动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代\n* 空间分配担保,在这里需要先介绍两个名词\n\t* Minor GC 新生代gc\n\t* Major GC 老生代gc\n\t* 在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。\n\t\n### 总结\n\n许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/jvm垃圾回收.md","raw":"---\ntitle: jvm垃圾回收\ndate: 2017-01-14 20:00:28\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\njava与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。\n\n### 如何判断对象已死\n\n#### 引用计数\n\n首先说明，jvm中并没有选择引用计数。\n\n给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。\n\n#### 可达性分析算法\n\n通过一系列\"GC Roots\"的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。\n\n![](http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n在java中，GC Roots对象包括以下几种:\n\n* 虚拟机栈(帧栈中的本地变量表)中的应用对象\n* 方法区中类静态属性引用的对象(static)\n* 方法区中常量引用的对象\n* 本地方法栈中(一般说的native方法)引用的对象\n\n#### 自我救赎\n\n在可达性分析中被标记不可达的对象，也不是非死不可。\n\n要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。\n\n#### 回收方法区\n\n方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。\n\n废弃常量-没有对象引用的话，就会被移除常量池，进行回收\n无用的类，类加载容易，卸载难，满足卸载的条件如下：\n\n* 该类的所有实例都被回收\n* 加载该类的ClassLoader被回收\n* 对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法\n\n### 垃圾回收算法\n\n#### 标记－清理算法\n\n![](http://images.cnitblog.com/i/288799/201406/181024382398115.jpg)\n\n首先标记出需要回收的对象，然后清理掉需要回收的对象。\n\n缺点：\n\n* 标记和回收的过程效率都不高\n* 会产生内存碎片\n\n#### 复制算法\n\n![](http://images.cnitblog.com/i/288799/201406/181041528488728.jpg)\n\n将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。\n\nhotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。\n\n但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)\n\n在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。\n\n#### 标记－整体算法\n\n![](http://images.cnitblog.com/i/288799/201406/181100129575916.jpg)\n\n先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。\n\n#### 分代算法\n\n将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。\n\n#### 总结\n\n新生代适合复制算法。老生代适合标记－清理、标记－整体之类。\n\n\n### HotSpot的算法实现\n\n* 枚举根节点,这个时候需要停止所有的执行线程(Stop The World)\n* 安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停\n* 安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc\n\n### 垃圾收集器\n\n![](http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg)\n\n####  Serial(old)收集器\n\n串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。\n\n![](http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg)\n\n图为Serial和Serial Old结合使用的图。\n\n#### ParNew收集器\n\n是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：\n\n![](http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg)\n\n\nParNew收集器在cpu核数多的情况下才有优势。\n\n#### Parallel Scavenge收集器\n\n目标：吞吐量\n\n参数：\n\n* -XX:MaxGCPauseMillis 控制最大停顿时间\n* -XX:GCTimeRatio 直接设置吞吐量大小\n\n#### Parallel Old\n\nParallel的老生代版本，使用多线程和标记－整理算法。\n\n#### CMS收集器\n\nCMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。\n\n过程：\n\n* 初始标记 cms initial mark\n* 并发标记 cms concurrent mark\n* 重新标记 cms remark\n* 并发清除 cms concurrent sweep\n\n![](http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg)\n\n缺点：\n\n* 对cpu资源敏感\n* 无法处理浮动垃圾\n* 大量碎片\n\n#### G1收集器\n\nG1(garbage first)，面向服务端的垃圾收集器。具备以下特点：\n\n* 并行与并发\n* 分代收集\n* 空间整合\n* 可预测停顿\n\ng1收集器的运作大致可划分为以下几个步骤:\n\n* 初始标记 initial marking\n* 并发标记 concurrent marking\n* 最终标记 final marking\n* 筛选会后 live data counting and evacuation\n\n\n\n\n\n### 内存分配策略\n\n* 对象优先在Eden分配(新生代)\n* 大对象直接进入老年代\n* 长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代\n* 动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代\n* 空间分配担保,在这里需要先介绍两个名词\n\t* Minor GC 新生代gc\n\t* Major GC 老生代gc\n\t* 在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。\n\t\n### 总结\n\n许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"jvm垃圾回收","published":1,"updated":"2017-01-14T12:01:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2s0027hws6ixjkovr8","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p>java与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。</p>\n<h3 id=\"如何判断对象已死\"><a href=\"#如何判断对象已死\" class=\"headerlink\" title=\"如何判断对象已死\"></a>如何判断对象已死</h3><h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>首先说明，jvm中并没有选择引用计数。</p>\n<p>给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。</p>\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>通过一系列”GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。</p>\n<p><img src=\"http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>在java中，GC Roots对象包括以下几种:</p>\n<ul>\n<li>虚拟机栈(帧栈中的本地变量表)中的应用对象</li>\n<li>方法区中类静态属性引用的对象(static)</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中(一般说的native方法)引用的对象</li>\n</ul>\n<h4 id=\"自我救赎\"><a href=\"#自我救赎\" class=\"headerlink\" title=\"自我救赎\"></a>自我救赎</h4><p>在可达性分析中被标记不可达的对象，也不是非死不可。</p>\n<p>要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。</p>\n<h4 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h4><p>方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。</p>\n<p>废弃常量-没有对象引用的话，就会被移除常量池，进行回收<br>无用的类，类加载容易，卸载难，满足卸载的条件如下：</p>\n<ul>\n<li>该类的所有实例都被回收</li>\n<li>加载该类的ClassLoader被回收</li>\n<li>对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><h4 id=\"标记－清理算法\"><a href=\"#标记－清理算法\" class=\"headerlink\" title=\"标记－清理算法\"></a>标记－清理算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181024382398115.jpg\" alt=\"\"></p>\n<p>首先标记出需要回收的对象，然后清理掉需要回收的对象。</p>\n<p>缺点：</p>\n<ul>\n<li>标记和回收的过程效率都不高</li>\n<li>会产生内存碎片</li>\n</ul>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181041528488728.jpg\" alt=\"\"></p>\n<p>将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。</p>\n<p>hotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。</p>\n<p>但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)</p>\n<p>在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。</p>\n<h4 id=\"标记－整体算法\"><a href=\"#标记－整体算法\" class=\"headerlink\" title=\"标记－整体算法\"></a>标记－整体算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181100129575916.jpg\" alt=\"\"></p>\n<p>先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。</p>\n<h4 id=\"分代算法\"><a href=\"#分代算法\" class=\"headerlink\" title=\"分代算法\"></a>分代算法</h4><p>将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>新生代适合复制算法。老生代适合标记－清理、标记－整体之类。</p>\n<h3 id=\"HotSpot的算法实现\"><a href=\"#HotSpot的算法实现\" class=\"headerlink\" title=\"HotSpot的算法实现\"></a>HotSpot的算法实现</h3><ul>\n<li>枚举根节点,这个时候需要停止所有的执行线程(Stop The World)</li>\n<li>安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停</li>\n<li>安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src=\"http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg\" alt=\"\"></p>\n<h4 id=\"Serial-old-收集器\"><a href=\"#Serial-old-收集器\" class=\"headerlink\" title=\"Serial(old)收集器\"></a>Serial(old)收集器</h4><p>串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。</p>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg\" alt=\"\"></p>\n<p>图为Serial和Serial Old结合使用的图。</p>\n<h4 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h4><p>是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：</p>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg\" alt=\"\"></p>\n<p>ParNew收集器在cpu核数多的情况下才有优势。</p>\n<h4 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h4><p>目标：吞吐量</p>\n<p>参数：</p>\n<ul>\n<li>-XX:MaxGCPauseMillis 控制最大停顿时间</li>\n<li>-XX:GCTimeRatio 直接设置吞吐量大小</li>\n</ul>\n<h4 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h4><p>Parallel的老生代版本，使用多线程和标记－整理算法。</p>\n<h4 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h4><p>CMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。</p>\n<p>过程：</p>\n<ul>\n<li>初始标记 cms initial mark</li>\n<li>并发标记 cms concurrent mark</li>\n<li>重新标记 cms remark</li>\n<li>并发清除 cms concurrent sweep</li>\n</ul>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg\" alt=\"\"></p>\n<p>缺点：</p>\n<ul>\n<li>对cpu资源敏感</li>\n<li>无法处理浮动垃圾</li>\n<li>大量碎片</li>\n</ul>\n<h4 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h4><p>G1(garbage first)，面向服务端的垃圾收集器。具备以下特点：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测停顿</li>\n</ul>\n<p>g1收集器的运作大致可划分为以下几个步骤:</p>\n<ul>\n<li>初始标记 initial marking</li>\n<li>并发标记 concurrent marking</li>\n<li>最终标记 final marking</li>\n<li>筛选会后 live data counting and evacuation</li>\n</ul>\n<h3 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h3><ul>\n<li>对象优先在Eden分配(新生代)</li>\n<li>大对象直接进入老年代</li>\n<li>长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代</li>\n<li>动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代</li>\n<li>空间分配担保,在这里需要先介绍两个名词<ul>\n<li>Minor GC 新生代gc</li>\n<li>Major GC 老生代gc</li>\n<li>在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。</p>","more":"<The rest of contents | 余下全文>\n\n\n<p>java与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。</p>\n<h3 id=\"如何判断对象已死\"><a href=\"#如何判断对象已死\" class=\"headerlink\" title=\"如何判断对象已死\"></a>如何判断对象已死</h3><h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>首先说明，jvm中并没有选择引用计数。</p>\n<p>给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。</p>\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>通过一系列”GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。</p>\n<p><img src=\"http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>在java中，GC Roots对象包括以下几种:</p>\n<ul>\n<li>虚拟机栈(帧栈中的本地变量表)中的应用对象</li>\n<li>方法区中类静态属性引用的对象(static)</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中(一般说的native方法)引用的对象</li>\n</ul>\n<h4 id=\"自我救赎\"><a href=\"#自我救赎\" class=\"headerlink\" title=\"自我救赎\"></a>自我救赎</h4><p>在可达性分析中被标记不可达的对象，也不是非死不可。</p>\n<p>要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。</p>\n<h4 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h4><p>方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。</p>\n<p>废弃常量-没有对象引用的话，就会被移除常量池，进行回收<br>无用的类，类加载容易，卸载难，满足卸载的条件如下：</p>\n<ul>\n<li>该类的所有实例都被回收</li>\n<li>加载该类的ClassLoader被回收</li>\n<li>对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><h4 id=\"标记－清理算法\"><a href=\"#标记－清理算法\" class=\"headerlink\" title=\"标记－清理算法\"></a>标记－清理算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181024382398115.jpg\" alt=\"\"></p>\n<p>首先标记出需要回收的对象，然后清理掉需要回收的对象。</p>\n<p>缺点：</p>\n<ul>\n<li>标记和回收的过程效率都不高</li>\n<li>会产生内存碎片</li>\n</ul>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181041528488728.jpg\" alt=\"\"></p>\n<p>将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。</p>\n<p>hotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。</p>\n<p>但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)</p>\n<p>在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。</p>\n<h4 id=\"标记－整体算法\"><a href=\"#标记－整体算法\" class=\"headerlink\" title=\"标记－整体算法\"></a>标记－整体算法</h4><p><img src=\"http://images.cnitblog.com/i/288799/201406/181100129575916.jpg\" alt=\"\"></p>\n<p>先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。</p>\n<h4 id=\"分代算法\"><a href=\"#分代算法\" class=\"headerlink\" title=\"分代算法\"></a>分代算法</h4><p>将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>新生代适合复制算法。老生代适合标记－清理、标记－整体之类。</p>\n<h3 id=\"HotSpot的算法实现\"><a href=\"#HotSpot的算法实现\" class=\"headerlink\" title=\"HotSpot的算法实现\"></a>HotSpot的算法实现</h3><ul>\n<li>枚举根节点,这个时候需要停止所有的执行线程(Stop The World)</li>\n<li>安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停</li>\n<li>安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src=\"http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg\" alt=\"\"></p>\n<h4 id=\"Serial-old-收集器\"><a href=\"#Serial-old-收集器\" class=\"headerlink\" title=\"Serial(old)收集器\"></a>Serial(old)收集器</h4><p>串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。</p>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg\" alt=\"\"></p>\n<p>图为Serial和Serial Old结合使用的图。</p>\n<h4 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h4><p>是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：</p>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg\" alt=\"\"></p>\n<p>ParNew收集器在cpu核数多的情况下才有优势。</p>\n<h4 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h4><p>目标：吞吐量</p>\n<p>参数：</p>\n<ul>\n<li>-XX:MaxGCPauseMillis 控制最大停顿时间</li>\n<li>-XX:GCTimeRatio 直接设置吞吐量大小</li>\n</ul>\n<h4 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h4><p>Parallel的老生代版本，使用多线程和标记－整理算法。</p>\n<h4 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h4><p>CMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。</p>\n<p>过程：</p>\n<ul>\n<li>初始标记 cms initial mark</li>\n<li>并发标记 cms concurrent mark</li>\n<li>重新标记 cms remark</li>\n<li>并发清除 cms concurrent sweep</li>\n</ul>\n<p><img src=\"http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg\" alt=\"\"></p>\n<p>缺点：</p>\n<ul>\n<li>对cpu资源敏感</li>\n<li>无法处理浮动垃圾</li>\n<li>大量碎片</li>\n</ul>\n<h4 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h4><p>G1(garbage first)，面向服务端的垃圾收集器。具备以下特点：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测停顿</li>\n</ul>\n<p>g1收集器的运作大致可划分为以下几个步骤:</p>\n<ul>\n<li>初始标记 initial marking</li>\n<li>并发标记 concurrent marking</li>\n<li>最终标记 final marking</li>\n<li>筛选会后 live data counting and evacuation</li>\n</ul>\n<h3 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h3><ul>\n<li>对象优先在Eden分配(新生代)</li>\n<li>大对象直接进入老年代</li>\n<li>长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代</li>\n<li>动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代</li>\n<li>空间分配担保,在这里需要先介绍两个名词<ul>\n<li>Minor GC 新生代gc</li>\n<li>Major GC 老生代gc</li>\n<li>在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"java内存区域","date":"2017-01-12T13:31:56.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n我决定停一段时间的framework，插播一些jvm的学习内容。首先，就是内存区域。学无止境，加油。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 运行时的数据区域\n\n根据jvm规范，java虚拟机所管理的内存区域包括图中的几个运行时数据区域，下面，来进行学习。\n\n![](/images/jvm/内存区域.png)\n\n#### 程序计数器\n\n* 线程私有\n\n>程序计数器(Program Counter Register)是一块较小的内存空间，可以看成是线程执行的字节码的行号指示器(执行到多少行字节码指令),在概念模型中，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来实现。\n\n>如果虚拟机执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native方法，这为空。\n\n#### Java虚拟机栈\n\n* 线程私有\n* 生命周期和线程相同\n* StackOverflowError\n* OutOfMemoryError\n\n>每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，就对应一个栈帧在虚拟机栈的入栈和出栈。\n\n局部变量表存放了编译时期的一些数据：\n\n* 8种基本数据类型，\n* 引用类型\n\t* 指向对象起点的引用指针\n\t* 代表对象的句柄或其他与此对象相关的地址\n\t* returnAddress类型(指向一条字节码指令的地址)\n\n>局部变量表所需要的空间在编译时完成分配，当进入一个方法时，这个方法说需要在帧中分配的空间时完全确定的，在方法运行时间不会修改局部变量表的大小。\n\n#### 本地方法栈\n\n>与虚拟机栈类似，只不过本地方法栈为虚拟机使用到的Native方法服务。\n\n#### Java堆\n\n* 大\n* 线程共享\n* OutOfMemoryError\n\n几乎所有的对象实例都在这里分配内存(包括数组)\n\n\n#### 方法区\n\n* 线程共享\n* OutOfMemoryError\n\n用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。\n\n##### 运行时常量池\n\n* OutOfMemoryError\n\n这是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n\n\n### 直接存储\n\n并不是运行时数据区的一部分，如使用nio。\n\n### hotspot虚拟机对象\n\n#### 对象的创建\n\n虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查是否经过了类加载，如果没有，则执行类加载过程。对象的大小在类加载完之后就确定了。\n\n解析来虚拟机为对象分配内存，(从java堆中划分),有两种分配方式:\n\n* 指针碰撞方式 内存是规整的，中间放着一个指示器，一边是分配了的，一边是空闲的，给对象分配内存的时候，只需要将指示器往空闲的一边移动对象大小的位置就好\n* 空闲列表方式 虚拟机维护着一个列表，列表纪录着哪块内存可用，分配内存时，在列表中找一个足够大的划分给对象，更新列表。\n\n\n这些分配方式，在并发的情况下并不是线程安全的。解决办法：\n\n* cas配合失败重试的方式保持原子性\n* 按线程分配在不同的空间中，每个线程在java堆预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)\n\n分配完毕之后，将分配到的内存空间初始化为0值(不包括对象头),如果使用了tlab，初始化过程将会提前到tlab分配时，\n\n接下来对对象进行必要的设置，如是哪个对象的实例、对象的hash值、对象的gc年龄代、这些存在对象头中。\n\n最后，进行对象的初始化。\n\n总结下，对象的创建过程如下：\n\n1. 碰到new指令\n2. 执行类加载过程(如果没加载过)\n3. 在java堆上分配内存\n4. 内存初始化为0值\n5. 设置对象头\n6. 进行对象初始化\n\n#### 对象的内存布局\n\n分为三块区域:\n\n* 对象头 Header\n\t* 对象自身的运行时数据 Mark World\n\t* 类型指针\n* 实例数据 Instance Data\n* 对齐填充 Padding\n\n![](http://img.blog.csdn.net/20160808174044369)\n\n##### Mark World\n \n存储了如hashcode、gc年龄代、锁状态标志、线程持有的锁，偏向线程id，偏向时间挫等\n\n##### 类型指针\n\n对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。但是，并不是所有的都有，如数组。\n\n##### 实例数据 \n\n对象正在存储的有效信息\n\n##### 对其填充\n\n起占位符的作用，保证对象的大小是8字节的整数倍。\n\n#### 对象的访问定位\n\n目前访问对象有两种方式：\n\n* 使用句柄\n* 直接指针\n\n##### 使用句柄\n\njava堆分配出一块区域当作句柄池，句柄中包含了对象实例数据与类型数据各自具体的地址信息。\n\n* 稳定，不需要根据对象移动而修改\n* 访问速度慢\n\n##### 直接地址\n\n存储的直接是对象地址。\n\n* 访问速度快\n\n\n### 参考资料\n\n* 深入理解java虚拟机\n\n \n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/java内存区域.md","raw":"---\ntitle: java内存区域\ndate: 2017-01-12 21:31:56\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n我决定停一段时间的framework，插播一些jvm的学习内容。首先，就是内存区域。学无止境，加油。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 运行时的数据区域\n\n根据jvm规范，java虚拟机所管理的内存区域包括图中的几个运行时数据区域，下面，来进行学习。\n\n![](/images/jvm/内存区域.png)\n\n#### 程序计数器\n\n* 线程私有\n\n>程序计数器(Program Counter Register)是一块较小的内存空间，可以看成是线程执行的字节码的行号指示器(执行到多少行字节码指令),在概念模型中，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来实现。\n\n>如果虚拟机执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native方法，这为空。\n\n#### Java虚拟机栈\n\n* 线程私有\n* 生命周期和线程相同\n* StackOverflowError\n* OutOfMemoryError\n\n>每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，就对应一个栈帧在虚拟机栈的入栈和出栈。\n\n局部变量表存放了编译时期的一些数据：\n\n* 8种基本数据类型，\n* 引用类型\n\t* 指向对象起点的引用指针\n\t* 代表对象的句柄或其他与此对象相关的地址\n\t* returnAddress类型(指向一条字节码指令的地址)\n\n>局部变量表所需要的空间在编译时完成分配，当进入一个方法时，这个方法说需要在帧中分配的空间时完全确定的，在方法运行时间不会修改局部变量表的大小。\n\n#### 本地方法栈\n\n>与虚拟机栈类似，只不过本地方法栈为虚拟机使用到的Native方法服务。\n\n#### Java堆\n\n* 大\n* 线程共享\n* OutOfMemoryError\n\n几乎所有的对象实例都在这里分配内存(包括数组)\n\n\n#### 方法区\n\n* 线程共享\n* OutOfMemoryError\n\n用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。\n\n##### 运行时常量池\n\n* OutOfMemoryError\n\n这是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n\n\n### 直接存储\n\n并不是运行时数据区的一部分，如使用nio。\n\n### hotspot虚拟机对象\n\n#### 对象的创建\n\n虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查是否经过了类加载，如果没有，则执行类加载过程。对象的大小在类加载完之后就确定了。\n\n解析来虚拟机为对象分配内存，(从java堆中划分),有两种分配方式:\n\n* 指针碰撞方式 内存是规整的，中间放着一个指示器，一边是分配了的，一边是空闲的，给对象分配内存的时候，只需要将指示器往空闲的一边移动对象大小的位置就好\n* 空闲列表方式 虚拟机维护着一个列表，列表纪录着哪块内存可用，分配内存时，在列表中找一个足够大的划分给对象，更新列表。\n\n\n这些分配方式，在并发的情况下并不是线程安全的。解决办法：\n\n* cas配合失败重试的方式保持原子性\n* 按线程分配在不同的空间中，每个线程在java堆预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)\n\n分配完毕之后，将分配到的内存空间初始化为0值(不包括对象头),如果使用了tlab，初始化过程将会提前到tlab分配时，\n\n接下来对对象进行必要的设置，如是哪个对象的实例、对象的hash值、对象的gc年龄代、这些存在对象头中。\n\n最后，进行对象的初始化。\n\n总结下，对象的创建过程如下：\n\n1. 碰到new指令\n2. 执行类加载过程(如果没加载过)\n3. 在java堆上分配内存\n4. 内存初始化为0值\n5. 设置对象头\n6. 进行对象初始化\n\n#### 对象的内存布局\n\n分为三块区域:\n\n* 对象头 Header\n\t* 对象自身的运行时数据 Mark World\n\t* 类型指针\n* 实例数据 Instance Data\n* 对齐填充 Padding\n\n![](http://img.blog.csdn.net/20160808174044369)\n\n##### Mark World\n \n存储了如hashcode、gc年龄代、锁状态标志、线程持有的锁，偏向线程id，偏向时间挫等\n\n##### 类型指针\n\n对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。但是，并不是所有的都有，如数组。\n\n##### 实例数据 \n\n对象正在存储的有效信息\n\n##### 对其填充\n\n起占位符的作用，保证对象的大小是8字节的整数倍。\n\n#### 对象的访问定位\n\n目前访问对象有两种方式：\n\n* 使用句柄\n* 直接指针\n\n##### 使用句柄\n\njava堆分配出一块区域当作句柄池，句柄中包含了对象实例数据与类型数据各自具体的地址信息。\n\n* 稳定，不需要根据对象移动而修改\n* 访问速度慢\n\n##### 直接地址\n\n存储的直接是对象地址。\n\n* 访问速度快\n\n\n### 参考资料\n\n* 深入理解java虚拟机\n\n \n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"java内存区域","published":1,"updated":"2017-01-12T13:33:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2t002ahws64rres9rw","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>我决定停一段时间的framework，插播一些jvm的学习内容。首先，就是内存区域。学无止境，加油。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"运行时的数据区域\"><a href=\"#运行时的数据区域\" class=\"headerlink\" title=\"运行时的数据区域\"></a>运行时的数据区域</h3><p>根据jvm规范，java虚拟机所管理的内存区域包括图中的几个运行时数据区域，下面，来进行学习。</p>\n<p><img src=\"/images/jvm/内存区域.png\" alt=\"\"></p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><ul>\n<li>线程私有</li>\n</ul>\n<blockquote>\n<p>程序计数器(Program Counter Register)是一块较小的内存空间，可以看成是线程执行的字节码的行号指示器(执行到多少行字节码指令),在概念模型中，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来实现。</p>\n<p>如果虚拟机执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native方法，这为空。</p>\n</blockquote>\n<h4 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h4><ul>\n<li>线程私有</li>\n<li>生命周期和线程相同</li>\n<li>StackOverflowError</li>\n<li>OutOfMemoryError</li>\n</ul>\n<blockquote>\n<p>每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，就对应一个栈帧在虚拟机栈的入栈和出栈。</p>\n</blockquote>\n<p>局部变量表存放了编译时期的一些数据：</p>\n<ul>\n<li>8种基本数据类型，</li>\n<li>引用类型<ul>\n<li>指向对象起点的引用指针</li>\n<li>代表对象的句柄或其他与此对象相关的地址</li>\n<li>returnAddress类型(指向一条字节码指令的地址)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>局部变量表所需要的空间在编译时完成分配，当进入一个方法时，这个方法说需要在帧中分配的空间时完全确定的，在方法运行时间不会修改局部变量表的大小。</p>\n</blockquote>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><blockquote>\n<p>与虚拟机栈类似，只不过本地方法栈为虚拟机使用到的Native方法服务。</p>\n</blockquote>\n<h4 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h4><ul>\n<li>大</li>\n<li>线程共享</li>\n<li>OutOfMemoryError</li>\n</ul>\n<p>几乎所有的对象实例都在这里分配内存(包括数组)</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><ul>\n<li>线程共享</li>\n<li>OutOfMemoryError</li>\n</ul>\n<p>用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。</p>\n<h5 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h5><ul>\n<li>OutOfMemoryError</li>\n</ul>\n<p>这是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>\n<h3 id=\"直接存储\"><a href=\"#直接存储\" class=\"headerlink\" title=\"直接存储\"></a>直接存储</h3><p>并不是运行时数据区的一部分，如使用nio。</p>\n<h3 id=\"hotspot虚拟机对象\"><a href=\"#hotspot虚拟机对象\" class=\"headerlink\" title=\"hotspot虚拟机对象\"></a>hotspot虚拟机对象</h3><h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查是否经过了类加载，如果没有，则执行类加载过程。对象的大小在类加载完之后就确定了。</p>\n<p>解析来虚拟机为对象分配内存，(从java堆中划分),有两种分配方式:</p>\n<ul>\n<li>指针碰撞方式 内存是规整的，中间放着一个指示器，一边是分配了的，一边是空闲的，给对象分配内存的时候，只需要将指示器往空闲的一边移动对象大小的位置就好</li>\n<li>空闲列表方式 虚拟机维护着一个列表，列表纪录着哪块内存可用，分配内存时，在列表中找一个足够大的划分给对象，更新列表。</li>\n</ul>\n<p>这些分配方式，在并发的情况下并不是线程安全的。解决办法：</p>\n<ul>\n<li>cas配合失败重试的方式保持原子性</li>\n<li>按线程分配在不同的空间中，每个线程在java堆预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</li>\n</ul>\n<p>分配完毕之后，将分配到的内存空间初始化为0值(不包括对象头),如果使用了tlab，初始化过程将会提前到tlab分配时，</p>\n<p>接下来对对象进行必要的设置，如是哪个对象的实例、对象的hash值、对象的gc年龄代、这些存在对象头中。</p>\n<p>最后，进行对象的初始化。</p>\n<p>总结下，对象的创建过程如下：</p>\n<ol>\n<li>碰到new指令</li>\n<li>执行类加载过程(如果没加载过)</li>\n<li>在java堆上分配内存</li>\n<li>内存初始化为0值</li>\n<li>设置对象头</li>\n<li>进行对象初始化</li>\n</ol>\n<h4 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h4><p>分为三块区域:</p>\n<ul>\n<li>对象头 Header<ul>\n<li>对象自身的运行时数据 Mark World</li>\n<li>类型指针</li>\n</ul>\n</li>\n<li>实例数据 Instance Data</li>\n<li>对齐填充 Padding</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20160808174044369\" alt=\"\"></p>\n<h5 id=\"Mark-World\"><a href=\"#Mark-World\" class=\"headerlink\" title=\"Mark World\"></a>Mark World</h5><p>存储了如hashcode、gc年龄代、锁状态标志、线程持有的锁，偏向线程id，偏向时间挫等</p>\n<h5 id=\"类型指针\"><a href=\"#类型指针\" class=\"headerlink\" title=\"类型指针\"></a>类型指针</h5><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。但是，并不是所有的都有，如数组。</p>\n<h5 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h5><p>对象正在存储的有效信息</p>\n<h5 id=\"对其填充\"><a href=\"#对其填充\" class=\"headerlink\" title=\"对其填充\"></a>对其填充</h5><p>起占位符的作用，保证对象的大小是8字节的整数倍。</p>\n<h4 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h4><p>目前访问对象有两种方式：</p>\n<ul>\n<li>使用句柄</li>\n<li>直接指针</li>\n</ul>\n<h5 id=\"使用句柄\"><a href=\"#使用句柄\" class=\"headerlink\" title=\"使用句柄\"></a>使用句柄</h5><p>java堆分配出一块区域当作句柄池，句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p>\n<ul>\n<li>稳定，不需要根据对象移动而修改</li>\n<li>访问速度慢</li>\n</ul>\n<h5 id=\"直接地址\"><a href=\"#直接地址\" class=\"headerlink\" title=\"直接地址\"></a>直接地址</h5><p>存储的直接是对象地址。</p>\n<ul>\n<li>访问速度快</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>深入理解java虚拟机</li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>我决定停一段时间的framework，插播一些jvm的学习内容。首先，就是内存区域。学无止境，加油。</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"运行时的数据区域\"><a href=\"#运行时的数据区域\" class=\"headerlink\" title=\"运行时的数据区域\"></a>运行时的数据区域</h3><p>根据jvm规范，java虚拟机所管理的内存区域包括图中的几个运行时数据区域，下面，来进行学习。</p>\n<p><img src=\"/images/jvm/内存区域.png\" alt=\"\"></p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><ul>\n<li>线程私有</li>\n</ul>\n<blockquote>\n<p>程序计数器(Program Counter Register)是一块较小的内存空间，可以看成是线程执行的字节码的行号指示器(执行到多少行字节码指令),在概念模型中，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来实现。</p>\n<p>如果虚拟机执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native方法，这为空。</p>\n</blockquote>\n<h4 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h4><ul>\n<li>线程私有</li>\n<li>生命周期和线程相同</li>\n<li>StackOverflowError</li>\n<li>OutOfMemoryError</li>\n</ul>\n<blockquote>\n<p>每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，就对应一个栈帧在虚拟机栈的入栈和出栈。</p>\n</blockquote>\n<p>局部变量表存放了编译时期的一些数据：</p>\n<ul>\n<li>8种基本数据类型，</li>\n<li>引用类型<ul>\n<li>指向对象起点的引用指针</li>\n<li>代表对象的句柄或其他与此对象相关的地址</li>\n<li>returnAddress类型(指向一条字节码指令的地址)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>局部变量表所需要的空间在编译时完成分配，当进入一个方法时，这个方法说需要在帧中分配的空间时完全确定的，在方法运行时间不会修改局部变量表的大小。</p>\n</blockquote>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><blockquote>\n<p>与虚拟机栈类似，只不过本地方法栈为虚拟机使用到的Native方法服务。</p>\n</blockquote>\n<h4 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h4><ul>\n<li>大</li>\n<li>线程共享</li>\n<li>OutOfMemoryError</li>\n</ul>\n<p>几乎所有的对象实例都在这里分配内存(包括数组)</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><ul>\n<li>线程共享</li>\n<li>OutOfMemoryError</li>\n</ul>\n<p>用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。</p>\n<h5 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h5><ul>\n<li>OutOfMemoryError</li>\n</ul>\n<p>这是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>\n<h3 id=\"直接存储\"><a href=\"#直接存储\" class=\"headerlink\" title=\"直接存储\"></a>直接存储</h3><p>并不是运行时数据区的一部分，如使用nio。</p>\n<h3 id=\"hotspot虚拟机对象\"><a href=\"#hotspot虚拟机对象\" class=\"headerlink\" title=\"hotspot虚拟机对象\"></a>hotspot虚拟机对象</h3><h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查是否经过了类加载，如果没有，则执行类加载过程。对象的大小在类加载完之后就确定了。</p>\n<p>解析来虚拟机为对象分配内存，(从java堆中划分),有两种分配方式:</p>\n<ul>\n<li>指针碰撞方式 内存是规整的，中间放着一个指示器，一边是分配了的，一边是空闲的，给对象分配内存的时候，只需要将指示器往空闲的一边移动对象大小的位置就好</li>\n<li>空闲列表方式 虚拟机维护着一个列表，列表纪录着哪块内存可用，分配内存时，在列表中找一个足够大的划分给对象，更新列表。</li>\n</ul>\n<p>这些分配方式，在并发的情况下并不是线程安全的。解决办法：</p>\n<ul>\n<li>cas配合失败重试的方式保持原子性</li>\n<li>按线程分配在不同的空间中，每个线程在java堆预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</li>\n</ul>\n<p>分配完毕之后，将分配到的内存空间初始化为0值(不包括对象头),如果使用了tlab，初始化过程将会提前到tlab分配时，</p>\n<p>接下来对对象进行必要的设置，如是哪个对象的实例、对象的hash值、对象的gc年龄代、这些存在对象头中。</p>\n<p>最后，进行对象的初始化。</p>\n<p>总结下，对象的创建过程如下：</p>\n<ol>\n<li>碰到new指令</li>\n<li>执行类加载过程(如果没加载过)</li>\n<li>在java堆上分配内存</li>\n<li>内存初始化为0值</li>\n<li>设置对象头</li>\n<li>进行对象初始化</li>\n</ol>\n<h4 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h4><p>分为三块区域:</p>\n<ul>\n<li>对象头 Header<ul>\n<li>对象自身的运行时数据 Mark World</li>\n<li>类型指针</li>\n</ul>\n</li>\n<li>实例数据 Instance Data</li>\n<li>对齐填充 Padding</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20160808174044369\" alt=\"\"></p>\n<h5 id=\"Mark-World\"><a href=\"#Mark-World\" class=\"headerlink\" title=\"Mark World\"></a>Mark World</h5><p>存储了如hashcode、gc年龄代、锁状态标志、线程持有的锁，偏向线程id，偏向时间挫等</p>\n<h5 id=\"类型指针\"><a href=\"#类型指针\" class=\"headerlink\" title=\"类型指针\"></a>类型指针</h5><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。但是，并不是所有的都有，如数组。</p>\n<h5 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h5><p>对象正在存储的有效信息</p>\n<h5 id=\"对其填充\"><a href=\"#对其填充\" class=\"headerlink\" title=\"对其填充\"></a>对其填充</h5><p>起占位符的作用，保证对象的大小是8字节的整数倍。</p>\n<h4 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h4><p>目前访问对象有两种方式：</p>\n<ul>\n<li>使用句柄</li>\n<li>直接指针</li>\n</ul>\n<h5 id=\"使用句柄\"><a href=\"#使用句柄\" class=\"headerlink\" title=\"使用句柄\"></a>使用句柄</h5><p>java堆分配出一块区域当作句柄池，句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p>\n<ul>\n<li>稳定，不需要根据对象移动而修改</li>\n<li>访问速度慢</li>\n</ul>\n<h5 id=\"直接地址\"><a href=\"#直接地址\" class=\"headerlink\" title=\"直接地址\"></a>直接地址</h5><p>存储的直接是对象地址。</p>\n<ul>\n<li>访问速度快</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>深入理解java虚拟机</li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"jvm类加载机制","date":"2017-01-17T14:59:18.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\n类加载机制是jvm中，非常重要的一部分，也是后面可能说道的分包、插件化、热修复等技术的基础。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的加载机制。\n\n### 类加载机制的时机\n\n类加载机制的整个生命周期如下：\n\n* 加载\n* 验证\n* 准备\n* 解析\n* 初始化\n* 使用\n* 卸载\n\n其中，卸载的条件比较难达到，在方法区gc的时候提到过。\n\n虚拟机规范中，严格规定了有且只有5种情况必须对类进行\"初始化\"(而加载、验证、准备、初始化需要在此之前)\n\n1. 遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果没有进行过初始化，则要先出发初始化，对应的操作为new对象、读取或设置static字段(被final修饰或编译器把结果放入到常量池的静态字段)，以及屌用一个类的静态方法的时候，PS：因为被final修饰的字段，在编译期会被优化，放入到类的常量池中。\n2. 使用java.lang.reflect包的方法对类进行反射调用\n3. 当初始化一个类时，如果其父类没有进行过初始化，则先初始化父类\n4. 当虚拟机启动时，需要指定一个执行的主类(入口)，虚拟机会先初始化这个类\n5. 使用动态语言支持时，动态代理，遇到REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄\n\n上面的几种为主动引用，而被动引用就不会触发初始化，被动引用的例子如：\n\n* 子类引用父类的静态字段\n* 通过数组定义引用类\n* 常量在编译时会被放入常量池，本质上并没有引用到类\n\n### 加载阶段\n\n在加载阶段，虚拟机需要完成三件事情：\n\n1. 通过类的全限定名来获取定义此类的二进制流(全限定名,用/替换.)\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据\n3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口\n\n加载二进制流的手段如下：\n\n* 从zip包中获取，如jar\n* 从网络中获取，Applet\n* 运行时计算生成，动态代理\n* 由其他文件生成，jsp\n* 从数据库中读取，较少\n\n对我们Android程序员来说，最常见的就是zip包和动态代理这种。\n\n<p style=\"color:red\">对于数组类，不一样了，数组类由不通过类加载器创建，而由虚拟机直接创建，</p>数组类的加载过程遵循以下规则：\n\n1. 如果数组的组件类型(每一个值)是引用类型，则递归采用类的家在过程去加载\n2. 如果不是引用类型，而是int[]中，将数组标记为与引导类加载器关联\n3. 如果不是引用类型，则数组的可见类型默认为public\n\n### 验证阶段\n\n这一阶段是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致分为四个检验工作，如下：\n\n1. 文件格式验证，验证字节流是否符合Class文件格式的规范，并且是否能被虚拟机处理(版本号是否在处理范围)\n\t* 是否以魔数0xCAFEBABE开头\n\t* 主次版本号是否在虚拟机处理范围内\n\t* 常量池中的常量是否有不被支持的类型\n\t* 指向常量的各种引用值中是否有不存在的常量或者不支持的类型\n\t* 等等\n\t后面会说道class文件结构\n2. 元数据验证 进行语义分析\n\t* 是否有父类(Object类除外)\n\t* 是否继承了不允许被继承的类\n\t* 如果不是抽象类，要求实现父类或者接口中要求实现的类\n\t* 类中的字段、方法是否与父类产生矛盾\n\t* ...\n3. 字节码验证 确定程序语义是否合法、符合逻辑\n\t* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作\n\t* 保证跳转指令不会跳转到方法体以外的字节码指令上\n\t* 保证方法体中类型转换是有效的\n\t* ...\n4. 符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候\n\t* 符号引用中能否通过字符串描述的全限定名找到对应的类\n\t* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段\n\t* 符号引用中的类、字段、方法的访问性是否可被当前类引用\n\t\n\n### 准备阶段 \n\n准备阶段正式为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都在方法区进行分配。这里只包括类变量，不包括实例变量，\n<span style=\"color:red\">如果被final修饰，则进行赋值操作，就不是零值了，千万注意<span>\n\n### 解析阶段\n\n解析阶段是讲常量池内的符号引用解析成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行。\n\n\n### 初始化阶段\n\n初始化阶段，根据程序的主观计划去初始化一个类变量和其他资源，也就是执行类构造器<clinit>()方法的过程\n\n* <clinit>(),由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合而成。顺序，有语句在源文件出现的顺序决定\n* <clinit>() 和<init>()不同，不需要显示的调用父类的这个方法，会保证子类的<clinit>()执行之前，父类的<clinit>()已经执行完毕。\n* 父类的静态语句块优与子类\n* <clinit>() 对类和接口来说并不是必须的，如果没有静态语句块和赋值操作，就不生成\n* 执行接口的<clinit>()之前，不需要先执行父类的\n* 保证类的<clinit>()在多线程环境中正确使用\n\n\n### 类与类加载器\n\n比较两个类是否相等，只有这两个类是由同一个类加载器加载，并且来自同一个Class文件。\n\n\n\n### 双亲委派模型\n\n![](http://img.blog.csdn.net/20160102154038185)\n\n* BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。\n* Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n* Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。\n\n加载过程如下：\n\n1. 如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。\n2. 每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器\n3. 如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载\n\n双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。\n\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/jvm类加载机制.md","raw":"---\ntitle: jvm类加载机制\ndate: 2017-01-17 22:59:18\ncategories: Java\ntags: jvm\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n>深入理解java虚拟机\n\n类加载机制是jvm中，非常重要的一部分，也是后面可能说道的分包、插件化、热修复等技术的基础。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的加载机制。\n\n### 类加载机制的时机\n\n类加载机制的整个生命周期如下：\n\n* 加载\n* 验证\n* 准备\n* 解析\n* 初始化\n* 使用\n* 卸载\n\n其中，卸载的条件比较难达到，在方法区gc的时候提到过。\n\n虚拟机规范中，严格规定了有且只有5种情况必须对类进行\"初始化\"(而加载、验证、准备、初始化需要在此之前)\n\n1. 遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果没有进行过初始化，则要先出发初始化，对应的操作为new对象、读取或设置static字段(被final修饰或编译器把结果放入到常量池的静态字段)，以及屌用一个类的静态方法的时候，PS：因为被final修饰的字段，在编译期会被优化，放入到类的常量池中。\n2. 使用java.lang.reflect包的方法对类进行反射调用\n3. 当初始化一个类时，如果其父类没有进行过初始化，则先初始化父类\n4. 当虚拟机启动时，需要指定一个执行的主类(入口)，虚拟机会先初始化这个类\n5. 使用动态语言支持时，动态代理，遇到REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄\n\n上面的几种为主动引用，而被动引用就不会触发初始化，被动引用的例子如：\n\n* 子类引用父类的静态字段\n* 通过数组定义引用类\n* 常量在编译时会被放入常量池，本质上并没有引用到类\n\n### 加载阶段\n\n在加载阶段，虚拟机需要完成三件事情：\n\n1. 通过类的全限定名来获取定义此类的二进制流(全限定名,用/替换.)\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据\n3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口\n\n加载二进制流的手段如下：\n\n* 从zip包中获取，如jar\n* 从网络中获取，Applet\n* 运行时计算生成，动态代理\n* 由其他文件生成，jsp\n* 从数据库中读取，较少\n\n对我们Android程序员来说，最常见的就是zip包和动态代理这种。\n\n<p style=\"color:red\">对于数组类，不一样了，数组类由不通过类加载器创建，而由虚拟机直接创建，</p>数组类的加载过程遵循以下规则：\n\n1. 如果数组的组件类型(每一个值)是引用类型，则递归采用类的家在过程去加载\n2. 如果不是引用类型，而是int[]中，将数组标记为与引导类加载器关联\n3. 如果不是引用类型，则数组的可见类型默认为public\n\n### 验证阶段\n\n这一阶段是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致分为四个检验工作，如下：\n\n1. 文件格式验证，验证字节流是否符合Class文件格式的规范，并且是否能被虚拟机处理(版本号是否在处理范围)\n\t* 是否以魔数0xCAFEBABE开头\n\t* 主次版本号是否在虚拟机处理范围内\n\t* 常量池中的常量是否有不被支持的类型\n\t* 指向常量的各种引用值中是否有不存在的常量或者不支持的类型\n\t* 等等\n\t后面会说道class文件结构\n2. 元数据验证 进行语义分析\n\t* 是否有父类(Object类除外)\n\t* 是否继承了不允许被继承的类\n\t* 如果不是抽象类，要求实现父类或者接口中要求实现的类\n\t* 类中的字段、方法是否与父类产生矛盾\n\t* ...\n3. 字节码验证 确定程序语义是否合法、符合逻辑\n\t* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作\n\t* 保证跳转指令不会跳转到方法体以外的字节码指令上\n\t* 保证方法体中类型转换是有效的\n\t* ...\n4. 符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候\n\t* 符号引用中能否通过字符串描述的全限定名找到对应的类\n\t* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段\n\t* 符号引用中的类、字段、方法的访问性是否可被当前类引用\n\t\n\n### 准备阶段 \n\n准备阶段正式为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都在方法区进行分配。这里只包括类变量，不包括实例变量，\n<span style=\"color:red\">如果被final修饰，则进行赋值操作，就不是零值了，千万注意<span>\n\n### 解析阶段\n\n解析阶段是讲常量池内的符号引用解析成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行。\n\n\n### 初始化阶段\n\n初始化阶段，根据程序的主观计划去初始化一个类变量和其他资源，也就是执行类构造器<clinit>()方法的过程\n\n* <clinit>(),由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合而成。顺序，有语句在源文件出现的顺序决定\n* <clinit>() 和<init>()不同，不需要显示的调用父类的这个方法，会保证子类的<clinit>()执行之前，父类的<clinit>()已经执行完毕。\n* 父类的静态语句块优与子类\n* <clinit>() 对类和接口来说并不是必须的，如果没有静态语句块和赋值操作，就不生成\n* 执行接口的<clinit>()之前，不需要先执行父类的\n* 保证类的<clinit>()在多线程环境中正确使用\n\n\n### 类与类加载器\n\n比较两个类是否相等，只有这两个类是由同一个类加载器加载，并且来自同一个Class文件。\n\n\n\n### 双亲委派模型\n\n![](http://img.blog.csdn.net/20160102154038185)\n\n* BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。\n* Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n* Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。\n\n加载过程如下：\n\n1. 如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。\n2. 每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器\n3. 如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载\n\n双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。\n\n\n### 参考资料\n\n来自经典好书 深入理解java虚拟机。建议入手一本，\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"jvm类加载机制","published":1,"updated":"2017-01-17T15:00:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2u002ehws6uflypwcl","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>类加载机制是jvm中，非常重要的一部分，也是后面可能说道的分包、插件化、热修复等技术的基础。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的加载机制。</p>\n<h3 id=\"类加载机制的时机\"><a href=\"#类加载机制的时机\" class=\"headerlink\" title=\"类加载机制的时机\"></a>类加载机制的时机</h3><p>类加载机制的整个生命周期如下：</p>\n<ul>\n<li>加载</li>\n<li>验证</li>\n<li>准备</li>\n<li>解析</li>\n<li>初始化</li>\n<li>使用</li>\n<li>卸载</li>\n</ul>\n<p>其中，卸载的条件比较难达到，在方法区gc的时候提到过。</p>\n<p>虚拟机规范中，严格规定了有且只有5种情况必须对类进行”初始化”(而加载、验证、准备、初始化需要在此之前)</p>\n<ol>\n<li>遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果没有进行过初始化，则要先出发初始化，对应的操作为new对象、读取或设置static字段(被final修饰或编译器把结果放入到常量池的静态字段)，以及屌用一个类的静态方法的时候，PS：因为被final修饰的字段，在编译期会被优化，放入到类的常量池中。</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用</li>\n<li>当初始化一个类时，如果其父类没有进行过初始化，则先初始化父类</li>\n<li>当虚拟机启动时，需要指定一个执行的主类(入口)，虚拟机会先初始化这个类</li>\n<li>使用动态语言支持时，动态代理，遇到REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄</li>\n</ol>\n<p>上面的几种为主动引用，而被动引用就不会触发初始化，被动引用的例子如：</p>\n<ul>\n<li>子类引用父类的静态字段</li>\n<li>通过数组定义引用类</li>\n<li>常量在编译时会被放入常量池，本质上并没有引用到类</li>\n</ul>\n<h3 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h3><p>在加载阶段，虚拟机需要完成三件事情：</p>\n<ol>\n<li>通过类的全限定名来获取定义此类的二进制流(全限定名,用/替换.)</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据</li>\n<li>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>加载二进制流的手段如下：</p>\n<ul>\n<li>从zip包中获取，如jar</li>\n<li>从网络中获取，Applet</li>\n<li>运行时计算生成，动态代理</li>\n<li>由其他文件生成，jsp</li>\n<li>从数据库中读取，较少</li>\n</ul>\n<p>对我们Android程序员来说，最常见的就是zip包和动态代理这种。</p>\n<p></p><p style=\"color:red\">对于数组类，不一样了，数组类由不通过类加载器创建，而由虚拟机直接创建，</p>数组类的加载过程遵循以下规则：<p></p>\n<ol>\n<li>如果数组的组件类型(每一个值)是引用类型，则递归采用类的家在过程去加载</li>\n<li>如果不是引用类型，而是int[]中，将数组标记为与引导类加载器关联</li>\n<li>如果不是引用类型，则数组的可见类型默认为public</li>\n</ol>\n<h3 id=\"验证阶段\"><a href=\"#验证阶段\" class=\"headerlink\" title=\"验证阶段\"></a>验证阶段</h3><p>这一阶段是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致分为四个检验工作，如下：</p>\n<ol>\n<li>文件格式验证，验证字节流是否符合Class文件格式的规范，并且是否能被虚拟机处理(版本号是否在处理范围)<ul>\n<li>是否以魔数0xCAFEBABE开头</li>\n<li>主次版本号是否在虚拟机处理范围内</li>\n<li>常量池中的常量是否有不被支持的类型</li>\n<li>指向常量的各种引用值中是否有不存在的常量或者不支持的类型</li>\n<li>等等<br>后面会说道class文件结构</li>\n</ul>\n</li>\n<li>元数据验证 进行语义分析<ul>\n<li>是否有父类(Object类除外)</li>\n<li>是否继承了不允许被继承的类</li>\n<li>如果不是抽象类，要求实现父类或者接口中要求实现的类</li>\n<li>类中的字段、方法是否与父类产生矛盾</li>\n<li>…</li>\n</ul>\n</li>\n<li>字节码验证 确定程序语义是否合法、符合逻辑<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>\n<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>\n<li>保证方法体中类型转换是有效的</li>\n<li>…</li>\n</ul>\n</li>\n<li>符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候<ul>\n<li>符号引用中能否通过字符串描述的全限定名找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>\n<li>符号引用中的类、字段、方法的访问性是否可被当前类引用</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h3><p>准备阶段正式为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都在方法区进行分配。这里只包括类变量，不包括实例变量，<br><span style=\"color:red\">如果被final修饰，则进行赋值操作，就不是零值了，千万注意<span></span></span></p>\n<h3 id=\"解析阶段\"><a href=\"#解析阶段\" class=\"headerlink\" title=\"解析阶段\"></a>解析阶段</h3><p>解析阶段是讲常量池内的符号引用解析成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行。</p>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>初始化阶段，根据程序的主观计划去初始化一个类变量和其他资源，也就是执行类构造器<clinit>()方法的过程</clinit></p>\n<ul>\n<li><clinit>(),由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合而成。顺序，有语句在源文件出现的顺序决定</clinit></li>\n<li><clinit>() 和<init>()不同，不需要显示的调用父类的这个方法，会保证子类的<clinit>()执行之前，父类的<clinit>()已经执行完毕。</clinit></clinit></init></clinit></li>\n<li>父类的静态语句块优与子类</li>\n<li><clinit>() 对类和接口来说并不是必须的，如果没有静态语句块和赋值操作，就不生成</clinit></li>\n<li>执行接口的<clinit>()之前，不需要先执行父类的</clinit></li>\n<li>保证类的<clinit>()在多线程环境中正确使用</clinit></li>\n</ul>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><p>比较两个类是否相等，只有这两个类是由同一个类加载器加载，并且来自同一个Class文件。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p><img src=\"http://img.blog.csdn.net/20160102154038185\" alt=\"\"></p>\n<ul>\n<li>BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。</li>\n<li>Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>\n<li>Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。</li>\n</ul>\n<p>加载过程如下：</p>\n<ol>\n<li>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。</li>\n<li>每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器</li>\n<li>如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载</li>\n</ol>\n<p>双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>深入理解java虚拟机</p>\n</blockquote>\n<p>类加载机制是jvm中，非常重要的一部分，也是后面可能说道的分包、插件化、热修复等技术的基础。</p>","more":"<The rest of contents | 余下全文>\n\n\n<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的加载机制。</p>\n<h3 id=\"类加载机制的时机\"><a href=\"#类加载机制的时机\" class=\"headerlink\" title=\"类加载机制的时机\"></a>类加载机制的时机</h3><p>类加载机制的整个生命周期如下：</p>\n<ul>\n<li>加载</li>\n<li>验证</li>\n<li>准备</li>\n<li>解析</li>\n<li>初始化</li>\n<li>使用</li>\n<li>卸载</li>\n</ul>\n<p>其中，卸载的条件比较难达到，在方法区gc的时候提到过。</p>\n<p>虚拟机规范中，严格规定了有且只有5种情况必须对类进行”初始化”(而加载、验证、准备、初始化需要在此之前)</p>\n<ol>\n<li>遇到new、getstatic、putstatic或者invokestatic这四条字节码指令时，如果没有进行过初始化，则要先出发初始化，对应的操作为new对象、读取或设置static字段(被final修饰或编译器把结果放入到常量池的静态字段)，以及屌用一个类的静态方法的时候，PS：因为被final修饰的字段，在编译期会被优化，放入到类的常量池中。</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用</li>\n<li>当初始化一个类时，如果其父类没有进行过初始化，则先初始化父类</li>\n<li>当虚拟机启动时，需要指定一个执行的主类(入口)，虚拟机会先初始化这个类</li>\n<li>使用动态语言支持时，动态代理，遇到REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄</li>\n</ol>\n<p>上面的几种为主动引用，而被动引用就不会触发初始化，被动引用的例子如：</p>\n<ul>\n<li>子类引用父类的静态字段</li>\n<li>通过数组定义引用类</li>\n<li>常量在编译时会被放入常量池，本质上并没有引用到类</li>\n</ul>\n<h3 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h3><p>在加载阶段，虚拟机需要完成三件事情：</p>\n<ol>\n<li>通过类的全限定名来获取定义此类的二进制流(全限定名,用/替换.)</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据</li>\n<li>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>加载二进制流的手段如下：</p>\n<ul>\n<li>从zip包中获取，如jar</li>\n<li>从网络中获取，Applet</li>\n<li>运行时计算生成，动态代理</li>\n<li>由其他文件生成，jsp</li>\n<li>从数据库中读取，较少</li>\n</ul>\n<p>对我们Android程序员来说，最常见的就是zip包和动态代理这种。</p>\n<p><p style=\"color:red\">对于数组类，不一样了，数组类由不通过类加载器创建，而由虚拟机直接创建，</p>数组类的加载过程遵循以下规则：</p>\n<ol>\n<li>如果数组的组件类型(每一个值)是引用类型，则递归采用类的家在过程去加载</li>\n<li>如果不是引用类型，而是int[]中，将数组标记为与引导类加载器关联</li>\n<li>如果不是引用类型，则数组的可见类型默认为public</li>\n</ol>\n<h3 id=\"验证阶段\"><a href=\"#验证阶段\" class=\"headerlink\" title=\"验证阶段\"></a>验证阶段</h3><p>这一阶段是为了保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致分为四个检验工作，如下：</p>\n<ol>\n<li>文件格式验证，验证字节流是否符合Class文件格式的规范，并且是否能被虚拟机处理(版本号是否在处理范围)<ul>\n<li>是否以魔数0xCAFEBABE开头</li>\n<li>主次版本号是否在虚拟机处理范围内</li>\n<li>常量池中的常量是否有不被支持的类型</li>\n<li>指向常量的各种引用值中是否有不存在的常量或者不支持的类型</li>\n<li>等等<br>后面会说道class文件结构</li>\n</ul>\n</li>\n<li>元数据验证 进行语义分析<ul>\n<li>是否有父类(Object类除外)</li>\n<li>是否继承了不允许被继承的类</li>\n<li>如果不是抽象类，要求实现父类或者接口中要求实现的类</li>\n<li>类中的字段、方法是否与父类产生矛盾</li>\n<li>…</li>\n</ul>\n</li>\n<li>字节码验证 确定程序语义是否合法、符合逻辑<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>\n<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>\n<li>保证方法体中类型转换是有效的</li>\n<li>…</li>\n</ul>\n</li>\n<li>符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候<ul>\n<li>符号引用中能否通过字符串描述的全限定名找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>\n<li>符号引用中的类、字段、方法的访问性是否可被当前类引用</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h3><p>准备阶段正式为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都在方法区进行分配。这里只包括类变量，不包括实例变量，<br><span style=\"color:red\">如果被final修饰，则进行赋值操作，就不是零值了，千万注意<span></p>\n<h3 id=\"解析阶段\"><a href=\"#解析阶段\" class=\"headerlink\" title=\"解析阶段\"></a>解析阶段</h3><p>解析阶段是讲常量池内的符号引用解析成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行。</p>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>初始化阶段，根据程序的主观计划去初始化一个类变量和其他资源，也就是执行类构造器<clinit>()方法的过程</p>\n<ul>\n<li><clinit>(),由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中的语句合而成。顺序，有语句在源文件出现的顺序决定</li>\n<li><clinit>() 和<init>()不同，不需要显示的调用父类的这个方法，会保证子类的<clinit>()执行之前，父类的<clinit>()已经执行完毕。</li>\n<li>父类的静态语句块优与子类</li>\n<li><clinit>() 对类和接口来说并不是必须的，如果没有静态语句块和赋值操作，就不生成</li>\n<li>执行接口的<clinit>()之前，不需要先执行父类的</li>\n<li>保证类的<clinit>()在多线程环境中正确使用</li>\n</ul>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><p>比较两个类是否相等，只有这两个类是由同一个类加载器加载，并且来自同一个Class文件。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p><img src=\"http://img.blog.csdn.net/20160102154038185\" alt=\"\"></p>\n<ul>\n<li>BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。</li>\n<li>Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>\n<li>Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。</li>\n</ul>\n<p>加载过程如下：</p>\n<ol>\n<li>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。</li>\n<li>每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器</li>\n<li>如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载</li>\n</ol>\n<p>双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>来自经典好书 深入理解java虚拟机。建议入手一本，</p>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解gradle（二）-扩展gradle","date":"2016-12-06T03:41:32.000Z","_content":"<Excerpt in index | 首页摘要>\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n```Groovy\ntask printString(type:GettingTask)\n```\n\n那么问题来了，我们如何向其中传递参数呢？\n\n* 首先，我们在class里面加成员变量\n* 然后，我们调用的时候，传入值\n\n\n\n\t```Groovy\n\ttask testPrint(type:GettingTask){\n\t// 这里用＝ 或者空格\n    string = \"guolei\"\n}\n\nclass GettingTask extends DefaultTask{\n\n    String string = \"xxxx\"\n\n    @TaskAction\n    def greet(){\n        println string\n    }\n}\n\t```\n\t\n\t\n\n### 2. 编写独立的插件程序\n\n可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。\n\n然后，在gradle中，依赖groovy\n\n```Groovy\napply plugin: 'groovy'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n```\n\n在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。\n\n接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建\"plugin_id\".properties目录，用来配置gradle插件，在文件中配置插件。\n\n```Groovy\nimplementation-class=com.gl.HelloPlugin\n```\n后面对应插件实现。\n\n最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。\n\n```Groovy\napply plugin: 'groovy'\napply plugin: 'maven'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n\nrepositories {\n    mavenCentral()\n}\n\ngroup='com.gl.HelloPlugin'\nversion='1.0.0'\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri('../repo'))\n        }\n    }\n}\n\n```\n\n在右侧图形界面或者命令执行uploadArchives，就发布成功了。\n\n如何使用，首先我们在跟目录下配置mevan仓库。\n\n```Groovy\nmaven {\n            url uri('./repo')\n        }\n        \n```\n\n然后依赖插件\n\n```Groovy\nclasspath 'com.gl.HelloPlugin:gradleplugin:1.0.0'\n```\n\n解释一下，后面分为三个部分\n\n* 第一部分，插件实现的路径\n* 你创建插件时候的model 名\n* 插件版本\n\n\n这三个也可以通过查看 repo下的路径得到，\n\n最后，在我们想用的地方\n\n```Groovy\napply plugin:'com.gl.plugin'\n```\n\n* 后面跟的是pluginid，也就是我们上面properties文件的前半部分。\n\n\n可以看到，开发过程基本和apt 编译时注解流程一致。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/了解gradle（二）-扩展gradle.md","raw":"---\ntitle: 了解gradle（二）-扩展gradle\ndate: 2016-12-06 11:41:32\ncategories: Gradle\ntags: gradle\n\n---\n<Excerpt in index | 首页摘要>\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1. 如何编写一个task类\n\n在我们的gradle文件里面，我\n\n```Groovy\nclass GreetingTask extends DefaultTask {\n\n}\n```\n\n即可定义一个task，我们可以在task中通过@注解实现一个方法。如：\n\n```Groovy\nclass GettingTask extends DefaultTask{\n    @TaskAction\n    def greet(){\n        println \"hello world\"\n    }\n}\n\n```\n\n那么，我们该如何调用呢？\n\n```Groovy\ntask printString(type:GettingTask)\n```\n\n那么问题来了，我们如何向其中传递参数呢？\n\n* 首先，我们在class里面加成员变量\n* 然后，我们调用的时候，传入值\n\n\n\n\t```Groovy\n\ttask testPrint(type:GettingTask){\n\t// 这里用＝ 或者空格\n    string = \"guolei\"\n}\n\nclass GettingTask extends DefaultTask{\n\n    String string = \"xxxx\"\n\n    @TaskAction\n    def greet(){\n        println string\n    }\n}\n\t```\n\t\n\t\n\n### 2. 编写独立的插件程序\n\n可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。\n\n然后，在gradle中，依赖groovy\n\n```Groovy\napply plugin: 'groovy'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n```\n\n在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。\n\n接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建\"plugin_id\".properties目录，用来配置gradle插件，在文件中配置插件。\n\n```Groovy\nimplementation-class=com.gl.HelloPlugin\n```\n后面对应插件实现。\n\n最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。\n\n```Groovy\napply plugin: 'groovy'\napply plugin: 'maven'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n}\n\nrepositories {\n    mavenCentral()\n}\n\ngroup='com.gl.HelloPlugin'\nversion='1.0.0'\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri('../repo'))\n        }\n    }\n}\n\n```\n\n在右侧图形界面或者命令执行uploadArchives，就发布成功了。\n\n如何使用，首先我们在跟目录下配置mevan仓库。\n\n```Groovy\nmaven {\n            url uri('./repo')\n        }\n        \n```\n\n然后依赖插件\n\n```Groovy\nclasspath 'com.gl.HelloPlugin:gradleplugin:1.0.0'\n```\n\n解释一下，后面分为三个部分\n\n* 第一部分，插件实现的路径\n* 你创建插件时候的model 名\n* 插件版本\n\n\n这三个也可以通过查看 repo下的路径得到，\n\n最后，在我们想用的地方\n\n```Groovy\napply plugin:'com.gl.plugin'\n```\n\n* 后面跟的是pluginid，也就是我们上面properties文件的前半部分。\n\n\n可以看到，开发过程基本和apt 编译时注解流程一致。\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"了解gradle（二）-扩展gradle","published":1,"updated":"2017-01-07T06:56:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2w002ihws6cadt4iau","content":"<excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\">\n\n<h3 id=\"1-如何编写一个task类\"><a href=\"#1-如何编写一个task类\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n<h3 id=\"1-如何编写一个task类-1\"><a href=\"#1-如何编写一个task类-1\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task printString(<span class=\"string\">type:</span>GettingTask)</div></pre></td></tr></table></figure>\n<p>那么问题来了，我们如何向其中传递参数呢？</p>\n<ul>\n<li>首先，我们在class里面加成员变量</li>\n<li>然后，我们调用的时候，传入值</li>\n</ul>\n<pre><code><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttask testPrint(<span class=\"string\">type:</span>GettingTask)&#123;</div><div class=\"line\">\t<span class=\"comment\">// 这里用＝ 或者空格</span></div><div class=\"line\">    string = <span class=\"string\">\"guolei\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\"></div><div class=\"line\">    String string = <span class=\"string\">\"xxxx\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println string</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</code></pre><h3 id=\"2-编写独立的插件程序\"><a href=\"#2-编写独立的插件程序\" class=\"headerlink\" title=\"2. 编写独立的插件程序\"></a>2. 编写独立的插件程序</h3><p>可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。</p>\n<p>然后，在gradle中，依赖groovy</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<project>接口，实现apply方法。</project></p>\n<p>接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建”plugin_id”.properties目录，用来配置gradle插件，在文件中配置插件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">implementation-<span class=\"class\"><span class=\"keyword\">class</span>=<span class=\"title\">com</span>.<span class=\"title\">gl</span>.<span class=\"title\">HelloPlugin</span></span></div></pre></td></tr></table></figure>\n<p>后面对应插件实现。</p>\n<p>最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'maven'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">group=<span class=\"string\">'com.gl.HelloPlugin'</span></div><div class=\"line\">version=<span class=\"string\">'1.0.0'</span></div><div class=\"line\">uploadArchives &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        mavenDeployer &#123;</div><div class=\"line\">            repository(<span class=\"string\">url:</span> uri(<span class=\"string\">'../repo'</span>))</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在右侧图形界面或者命令执行uploadArchives，就发布成功了。</p>\n<p>如何使用，首先我们在跟目录下配置mevan仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">maven &#123;</div><div class=\"line\">            url uri(<span class=\"string\">'./repo'</span>)</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>然后依赖插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classpath <span class=\"string\">'com.gl.HelloPlugin:gradleplugin:1.0.0'</span></div></pre></td></tr></table></figure>\n<p>解释一下，后面分为三个部分</p>\n<ul>\n<li>第一部分，插件实现的路径</li>\n<li>你创建插件时候的model 名</li>\n<li>插件版本</li>\n</ul>\n<p>这三个也可以通过查看 repo下的路径得到，</p>\n<p>最后，在我们想用的地方</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span><span class=\"string\">'com.gl.plugin'</span></div></pre></td></tr></table></figure>\n<ul>\n<li>后面跟的是pluginid，也就是我们上面properties文件的前半部分。</li>\n</ul>\n<p>可以看到，开发过程基本和apt 编译时注解流程一致。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the></excerpt>","excerpt":"<Excerpt in index | 首页摘要>\n\n<h3 id=\"1-如何编写一个task类\"><a href=\"#1-如何编写一个task类\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>","more":"<The rest of contents | 余下全文>\n\n\n<h3 id=\"1-如何编写一个task类-1\"><a href=\"#1-如何编写一个task类-1\" class=\"headerlink\" title=\"1. 如何编写一个task类\"></a>1. 如何编写一个task类</h3><p>在我们的gradle文件里面，我</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreetingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span> &#123;</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>即可定义一个task，我们可以在task中通过@注解实现一个方法。如：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println <span class=\"string\">\"hello world\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么，我们该如何调用呢？</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task printString(<span class=\"string\">type:</span>GettingTask)</div></pre></td></tr></table></figure>\n<p>那么问题来了，我们如何向其中传递参数呢？</p>\n<ul>\n<li>首先，我们在class里面加成员变量</li>\n<li>然后，我们调用的时候，传入值</li>\n</ul>\n<pre><code><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttask testPrint(<span class=\"string\">type:</span>GettingTask)&#123;</div><div class=\"line\">\t<span class=\"comment\">// 这里用＝ 或者空格</span></div><div class=\"line\">    string = <span class=\"string\">\"guolei\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GettingTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultTask</span>&#123;</span></div><div class=\"line\"></div><div class=\"line\">    String string = <span class=\"string\">\"xxxx\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@TaskAction</span></div><div class=\"line\">    <span class=\"keyword\">def</span> greet()&#123;</div><div class=\"line\">        println string</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</code></pre><h3 id=\"2-编写独立的插件程序\"><a href=\"#2-编写独立的插件程序\" class=\"headerlink\" title=\"2. 编写独立的插件程序\"></a>2. 编写独立的插件程序</h3><p>可以利用as编写插件，这里，我们可以新建 app model、android lib modle或者java lib model，都可以，并且把main下面全删掉，gradle里也全删掉。</p>\n<p>然后，在gradle中，依赖groovy</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在main下面新建groovy目录，在里面建包，建groovy类，然后实现Plugin<Project>接口，实现apply方法。</p>\n<p>接下来在groovy同级目录，新建resources目录，里面建META-INF目录，这个目录下面在建gradle-plugin目录，这个目录下建”plugin_id”.properties目录，用来配置gradle插件，在文件中配置插件。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">implementation-<span class=\"class\"><span class=\"keyword\">class</span>=<span class=\"title\">com</span>.<span class=\"title\">gl</span>.<span class=\"title\">HelloPlugin</span></span></div></pre></td></tr></table></figure>\n<p>后面对应插件实现。</p>\n<p>最后发布，这里就不发不到jcenter了，后面会专门写一篇关于发布的。发布到本地仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'groovy'</span></div><div class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'maven'</span></div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile gradleApi()</div><div class=\"line\">    compile localGroovy()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">group=<span class=\"string\">'com.gl.HelloPlugin'</span></div><div class=\"line\">version=<span class=\"string\">'1.0.0'</span></div><div class=\"line\">uploadArchives &#123;</div><div class=\"line\">    repositories &#123;</div><div class=\"line\">        mavenDeployer &#123;</div><div class=\"line\">            repository(<span class=\"string\">url:</span> uri(<span class=\"string\">'../repo'</span>))</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在右侧图形界面或者命令执行uploadArchives，就发布成功了。</p>\n<p>如何使用，首先我们在跟目录下配置mevan仓库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">maven &#123;</div><div class=\"line\">            url uri(<span class=\"string\">'./repo'</span>)</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>然后依赖插件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classpath <span class=\"string\">'com.gl.HelloPlugin:gradleplugin:1.0.0'</span></div></pre></td></tr></table></figure>\n<p>解释一下，后面分为三个部分</p>\n<ul>\n<li>第一部分，插件实现的路径</li>\n<li>你创建插件时候的model 名</li>\n<li>插件版本</li>\n</ul>\n<p>这三个也可以通过查看 repo下的路径得到，</p>\n<p>最后，在我们想用的地方</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply <span class=\"string\">plugin:</span><span class=\"string\">'com.gl.plugin'</span></div></pre></td></tr></table></figure>\n<ul>\n<li>后面跟的是pluginid，也就是我们上面properties文件的前半部分。</li>\n</ul>\n<p>可以看到，开发过程基本和apt 编译时注解流程一致。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"fresco用法","date":"2016-12-12T06:27:12.000Z","_content":"<Excerpt in index | 首页摘要>\n### 0.前言\n\n在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 1.fresco中的关键概念\n\n* Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式\n\t* DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可\n\t* DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。\n\t* DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。\n如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。\n\t* DraweeControllerBuilder \nDraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改\n\t* Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。\n* The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。\n在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。\nSimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 \n\n### 3.支持的URI类型\n\n* http|https\n* file://\n* content://\n* asset://\n* res://\n* data:mime/type;base64 uri中指定图片数据\n\n### 4.支持的xml属性\n\n[支持的xml属性](https://www.fresco-cn.org/docs/using-drawees-xml.html)\n\n### 5.在java中使用Drawees\n\n#### 5.1 自定义DraweeHierarchy\n\n```\n        GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());\n        GenericDraweeHierarchy hierarchy = builder\n                .setFadeDuration(300)\n                //and so on\n                .build();\n        image.setHierarchy(hierarchy);\n```\n\n从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\nxml中对应的属性，由hierarchy控制。\n\n#### 5.2 运行时修改 DraweeHierarchy\n\n要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。\n\n```\n        GenericDraweeHierarchy hierarchy = image.getHierarchy();\n        hierarchy.setFadeDuration(400);\n```\n\n其他属性同理。\n\n#### 5.3 配置效果\n\n我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。\n\n在ControllerBuilder 中如下设置:\n\n```\n.setTapToRetryEnabled(true)\n```\n\n* XML 中属性值: retryImage\n* Hierarchy builder中的方法: setRetryImage\n\n#### 5.4 进度条\n\n构建GenericDraweeHierarchy的时候\n\n\n```\n.setProgressBarImage(new ProgressBarDrawable())\n```\n，我们也可以自定义，实现Drawable.onLevelChange。\n\n\n### 6 DraweeController增加对图片的控制\n\n```\nControllerListener listener = new BaseControllerListener() {...}\n\nDraweeController controller = Fresco.newDraweeControllerBuilder()\n    .setUri(uri)\n    .setTapToRetryEnabled(true)\n    .setOldController(mSimpleDraweeView.getController())\n    .setControllerListener(listener)\n    .build();\n\nmSimpleDraweeView.setController(controller);\n```\n\n* 使用渐进式jpeg图。\n\n    ```\n    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(\"xxx\"))\n                //打开渐进 渲染\n                .setProgressiveRenderingEnabled(true)\n                .build();\n\t```\n\t\n* 动画自动播放\n\t\n\t```\n\tdraweeController.setAutoPlayAnimations(true)\n\t```\n* 动画手动播放，\n\n\t```\n\t        ControllerListener listener = new BaseControllerListener<ImageInfo>(){\n            @Override\n            public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) {\n                super.onFinalImageSet(id, imageInfo, animatable);\n                if (animatable != null){\n                    animatable.start();\n                }\n            }\n        };\n        \n        draweeController.setControllerListener(listener)\n\t```\n* 后处理器Postprocessor 对图片进行后期处理\n\n```\nPostprocessor redMeshPostprocessor = new BasePostprocessor() {\n  @Override\n  public String getName() {\n    return \"redMeshPostprocessor\";\n  }\n\n  @Override\n  public void process(Bitmap bitmap) {\n    for (int x = 0; x < bitmap.getWidth(); x+=2) {\n      for (int y = 0; y < bitmap.getHeight(); y+=2) {\n        bitmap.setPixel(x, y, Color.RED);\n      }\n    }\n  }\n}\n\nImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)\n    .setPostprocessor(redMeshPostprocessor)\n    .build();\n```\n\n### 7.Image Requests\n\n使用ImageRequestBuilder来做更多的事情。\n\n```\nUri uri;\n\nImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()\n    .setBackgroundColor(Color.GREEN)\n    .build();\n\nImageRequest request = ImageRequestBuilder\n    .newBuilderWithSource(uri)\n    .setImageDecodeOptions(decodeOptions)\n    .setAutoRotateEnabled(true)\n    .setLocalThumbnailPreviewsEnabled(true)\n    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    \n    .setProgressiveRenderingEnabled(false)\n    .setResizeOptions(new ResizeOptions(width, height))\n    .build();\n```\n\n### 8.Image Pipeline\nImage pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。\n\n```\nImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)\n    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)\n    .setCacheKeyFactory(cacheKeyFactory)\n    .setDownsampleEnabled(true)\n    .setWebpSupportEnabled(true)\n    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)\n    .setExecutorSupplier(executorSupplier)\n    .setImageCacheStatsTracker(imageCacheStatsTracker)\n    .setMainDiskCacheConfig(mainDiskCacheConfig)\n    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)\n    .setNetworkFetchProducer(networkFetchProducer)\n    .setPoolFactory(poolFactory)\n    .setProgressiveJpegConfig(progressiveJpegConfig)\n    .setRequestListeners(requestListeners)\n    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)\n    .build();\nFresco.initialize(context, config);\n```\n\n上面的可配置项会因为版本的不同有稍微的区别。\n\n#### 8.1 缓存\n\n在fresco里面，\n\n* bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上\n* 未解码图片的内存缓存\n* 磁盘缓存\n\n我们可以通过imagepipeline判断bitmap是否被缓存，\n\n```\n        ImagePipeline imagePipeline = Fresco.getImagePipeline();\n        imagePipeline.isInBitmapMemoryCache(Uri.parse(\"\"));\n        imagePipeline.isInDiskCache(Uri.parse(\"xxx\"));\n```\n\n删除指定缓存\n\n```\n        Uri uri = Uri.parse(\"xxx\");\n        imagePipeline.evictFromCache(uri);\n        imagePipeline.evictFromDiskCache(uri);\n```\n\n\n使用imagepipeline可以对整个工程加入一些控制。更多用法[文档](https://www.fresco-cn.org/docs/using-image-pipeline.html)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/fresco用法.md","raw":"---\ntitle: fresco用法\ndate: 2016-12-12 14:27:12\ncategories: Android\ntags: fresco\n\n---\n<Excerpt in index | 首页摘要>\n### 0.前言\n\n在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 1.fresco中的关键概念\n\n* Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式\n\t* DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可\n\t* DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。\n\t* DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。\n如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。\n\t* DraweeControllerBuilder \nDraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改\n\t* Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。\n* The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。\n在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。\nSimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 \n\n### 3.支持的URI类型\n\n* http|https\n* file://\n* content://\n* asset://\n* res://\n* data:mime/type;base64 uri中指定图片数据\n\n### 4.支持的xml属性\n\n[支持的xml属性](https://www.fresco-cn.org/docs/using-drawees-xml.html)\n\n### 5.在java中使用Drawees\n\n#### 5.1 自定义DraweeHierarchy\n\n```\n        GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());\n        GenericDraweeHierarchy hierarchy = builder\n                .setFadeDuration(300)\n                //and so on\n                .build();\n        image.setHierarchy(hierarchy);\n```\n\n从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。\n\n```\n  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {\n    GenericDraweeHierarchyBuilder builder =\n        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);\n    setAspectRatio(builder.getDesiredAspectRatio());\n    setHierarchy(builder.build());\n  }\n```\n\nxml中对应的属性，由hierarchy控制。\n\n#### 5.2 运行时修改 DraweeHierarchy\n\n要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。\n\n```\n        GenericDraweeHierarchy hierarchy = image.getHierarchy();\n        hierarchy.setFadeDuration(400);\n```\n\n其他属性同理。\n\n#### 5.3 配置效果\n\n我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。\n\n在ControllerBuilder 中如下设置:\n\n```\n.setTapToRetryEnabled(true)\n```\n\n* XML 中属性值: retryImage\n* Hierarchy builder中的方法: setRetryImage\n\n#### 5.4 进度条\n\n构建GenericDraweeHierarchy的时候\n\n\n```\n.setProgressBarImage(new ProgressBarDrawable())\n```\n，我们也可以自定义，实现Drawable.onLevelChange。\n\n\n### 6 DraweeController增加对图片的控制\n\n```\nControllerListener listener = new BaseControllerListener() {...}\n\nDraweeController controller = Fresco.newDraweeControllerBuilder()\n    .setUri(uri)\n    .setTapToRetryEnabled(true)\n    .setOldController(mSimpleDraweeView.getController())\n    .setControllerListener(listener)\n    .build();\n\nmSimpleDraweeView.setController(controller);\n```\n\n* 使用渐进式jpeg图。\n\n    ```\n    ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(\"xxx\"))\n                //打开渐进 渲染\n                .setProgressiveRenderingEnabled(true)\n                .build();\n\t```\n\t\n* 动画自动播放\n\t\n\t```\n\tdraweeController.setAutoPlayAnimations(true)\n\t```\n* 动画手动播放，\n\n\t```\n\t        ControllerListener listener = new BaseControllerListener<ImageInfo>(){\n            @Override\n            public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) {\n                super.onFinalImageSet(id, imageInfo, animatable);\n                if (animatable != null){\n                    animatable.start();\n                }\n            }\n        };\n        \n        draweeController.setControllerListener(listener)\n\t```\n* 后处理器Postprocessor 对图片进行后期处理\n\n```\nPostprocessor redMeshPostprocessor = new BasePostprocessor() {\n  @Override\n  public String getName() {\n    return \"redMeshPostprocessor\";\n  }\n\n  @Override\n  public void process(Bitmap bitmap) {\n    for (int x = 0; x < bitmap.getWidth(); x+=2) {\n      for (int y = 0; y < bitmap.getHeight(); y+=2) {\n        bitmap.setPixel(x, y, Color.RED);\n      }\n    }\n  }\n}\n\nImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)\n    .setPostprocessor(redMeshPostprocessor)\n    .build();\n```\n\n### 7.Image Requests\n\n使用ImageRequestBuilder来做更多的事情。\n\n```\nUri uri;\n\nImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()\n    .setBackgroundColor(Color.GREEN)\n    .build();\n\nImageRequest request = ImageRequestBuilder\n    .newBuilderWithSource(uri)\n    .setImageDecodeOptions(decodeOptions)\n    .setAutoRotateEnabled(true)\n    .setLocalThumbnailPreviewsEnabled(true)\n    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    \n    .setProgressiveRenderingEnabled(false)\n    .setResizeOptions(new ResizeOptions(width, height))\n    .build();\n```\n\n### 8.Image Pipeline\nImage pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。\n\n```\nImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)\n    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)\n    .setCacheKeyFactory(cacheKeyFactory)\n    .setDownsampleEnabled(true)\n    .setWebpSupportEnabled(true)\n    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)\n    .setExecutorSupplier(executorSupplier)\n    .setImageCacheStatsTracker(imageCacheStatsTracker)\n    .setMainDiskCacheConfig(mainDiskCacheConfig)\n    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)\n    .setNetworkFetchProducer(networkFetchProducer)\n    .setPoolFactory(poolFactory)\n    .setProgressiveJpegConfig(progressiveJpegConfig)\n    .setRequestListeners(requestListeners)\n    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)\n    .build();\nFresco.initialize(context, config);\n```\n\n上面的可配置项会因为版本的不同有稍微的区别。\n\n#### 8.1 缓存\n\n在fresco里面，\n\n* bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上\n* 未解码图片的内存缓存\n* 磁盘缓存\n\n我们可以通过imagepipeline判断bitmap是否被缓存，\n\n```\n        ImagePipeline imagePipeline = Fresco.getImagePipeline();\n        imagePipeline.isInBitmapMemoryCache(Uri.parse(\"\"));\n        imagePipeline.isInDiskCache(Uri.parse(\"xxx\"));\n```\n\n删除指定缓存\n\n```\n        Uri uri = Uri.parse(\"xxx\");\n        imagePipeline.evictFromCache(uri);\n        imagePipeline.evictFromDiskCache(uri);\n```\n\n\n使用imagepipeline可以对整个工程加入一些控制。更多用法[文档](https://www.fresco-cn.org/docs/using-image-pipeline.html)\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"fresco用法","published":1,"updated":"2017-01-07T06:58:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2x002mhws6o1xgo104","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0.前言\"></a>0.前言</h3><p>在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"1-fresco中的关键概念\"><a href=\"#1-fresco中的关键概念\" class=\"headerlink\" title=\"1.fresco中的关键概念\"></a>1.fresco中的关键概念</h3><ul>\n<li>Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式<ul>\n<li>DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可</li>\n<li>DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。</li>\n<li>DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。<br>如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。</li>\n<li>DraweeControllerBuilder<br>DraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改</li>\n<li>Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。</li>\n</ul>\n</li>\n<li>The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。<br>在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。<br>SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 </li>\n</ul>\n<h3 id=\"3-支持的URI类型\"><a href=\"#3-支持的URI类型\" class=\"headerlink\" title=\"3.支持的URI类型\"></a>3.支持的URI类型</h3><ul>\n<li>http|https</li>\n<li>file://</li>\n<li>content://</li>\n<li>asset://</li>\n<li>res://</li>\n<li>data:mime/type;base64 uri中指定图片数据</li>\n</ul>\n<h3 id=\"4-支持的xml属性\"><a href=\"#4-支持的xml属性\" class=\"headerlink\" title=\"4.支持的xml属性\"></a>4.支持的xml属性</h3><p><a href=\"https://www.fresco-cn.org/docs/using-drawees-xml.html\" target=\"_blank\" rel=\"external\">支持的xml属性</a></p>\n<h3 id=\"5-在java中使用Drawees\"><a href=\"#5-在java中使用Drawees\" class=\"headerlink\" title=\"5.在java中使用Drawees\"></a>5.在java中使用Drawees</h3><h4 id=\"5-1-自定义DraweeHierarchy\"><a href=\"#5-1-自定义DraweeHierarchy\" class=\"headerlink\" title=\"5.1 自定义DraweeHierarchy\"></a>5.1 自定义DraweeHierarchy</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());</div><div class=\"line\">GenericDraweeHierarchy hierarchy = builder</div><div class=\"line\">        .setFadeDuration(300)</div><div class=\"line\">        //and so on</div><div class=\"line\">        .build();</div><div class=\"line\">image.setHierarchy(hierarchy);</div></pre></td></tr></table></figure>\n<p>从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>xml中对应的属性，由hierarchy控制。</p>\n<h4 id=\"5-2-运行时修改-DraweeHierarchy\"><a href=\"#5-2-运行时修改-DraweeHierarchy\" class=\"headerlink\" title=\"5.2 运行时修改 DraweeHierarchy\"></a>5.2 运行时修改 DraweeHierarchy</h4><p>要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchy hierarchy = image.getHierarchy();</div><div class=\"line\">hierarchy.setFadeDuration(400);</div></pre></td></tr></table></figure>\n<p>其他属性同理。</p>\n<h4 id=\"5-3-配置效果\"><a href=\"#5-3-配置效果\" class=\"headerlink\" title=\"5.3 配置效果\"></a>5.3 配置效果</h4><p>我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。</p>\n<p>在ControllerBuilder 中如下设置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setTapToRetryEnabled(true)</div></pre></td></tr></table></figure>\n<ul>\n<li>XML 中属性值: retryImage</li>\n<li>Hierarchy builder中的方法: setRetryImage</li>\n</ul>\n<h4 id=\"5-4-进度条\"><a href=\"#5-4-进度条\" class=\"headerlink\" title=\"5.4 进度条\"></a>5.4 进度条</h4><p>构建GenericDraweeHierarchy的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setProgressBarImage(new ProgressBarDrawable())</div></pre></td></tr></table></figure>\n<p>，我们也可以自定义，实现Drawable.onLevelChange。</p>\n<h3 id=\"6-DraweeController增加对图片的控制\"><a href=\"#6-DraweeController增加对图片的控制\" class=\"headerlink\" title=\"6 DraweeController增加对图片的控制\"></a>6 DraweeController增加对图片的控制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ControllerListener listener = new BaseControllerListener() &#123;...&#125;</div><div class=\"line\"></div><div class=\"line\">DraweeController controller = Fresco.newDraweeControllerBuilder()</div><div class=\"line\">    .setUri(uri)</div><div class=\"line\">    .setTapToRetryEnabled(true)</div><div class=\"line\">    .setOldController(mSimpleDraweeView.getController())</div><div class=\"line\">    .setControllerListener(listener)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">mSimpleDraweeView.setController(controller);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>使用渐进式jpeg图。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(&quot;xxx&quot;))</div><div class=\"line\">            //打开渐进 渲染</div><div class=\"line\">            .setProgressiveRenderingEnabled(true)</div><div class=\"line\">            .build();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>动画自动播放</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">draweeController.setAutoPlayAnimations(true)</div></pre></td></tr></table></figure>\n</li>\n<li><p>动画手动播放，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ControllerListener listener = new BaseControllerListener&lt;ImageInfo&gt;()&#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) &#123;</div><div class=\"line\">        super.onFinalImageSet(id, imageInfo, animatable);</div><div class=\"line\">        if (animatable != null)&#123;</div><div class=\"line\">            animatable.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">draweeController.setControllerListener(listener)</div></pre></td></tr></table></figure>\n</li>\n<li><p>后处理器Postprocessor 对图片进行后期处理</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Postprocessor redMeshPostprocessor = new BasePostprocessor() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public String getName() &#123;</div><div class=\"line\">    return &quot;redMeshPostprocessor&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void process(Bitmap bitmap) &#123;</div><div class=\"line\">    for (int x = 0; x &lt; bitmap.getWidth(); x+=2) &#123;</div><div class=\"line\">      for (int y = 0; y &lt; bitmap.getHeight(); y+=2) &#123;</div><div class=\"line\">        bitmap.setPixel(x, y, Color.RED);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)</div><div class=\"line\">    .setPostprocessor(redMeshPostprocessor)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"7-Image-Requests\"><a href=\"#7-Image-Requests\" class=\"headerlink\" title=\"7.Image Requests\"></a>7.Image Requests</h3><p>使用ImageRequestBuilder来做更多的事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri;</div><div class=\"line\"></div><div class=\"line\">ImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()</div><div class=\"line\">    .setBackgroundColor(Color.GREEN)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder</div><div class=\"line\">    .newBuilderWithSource(uri)</div><div class=\"line\">    .setImageDecodeOptions(decodeOptions)</div><div class=\"line\">    .setAutoRotateEnabled(true)</div><div class=\"line\">    .setLocalThumbnailPreviewsEnabled(true)</div><div class=\"line\">    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    </div><div class=\"line\">    .setProgressiveRenderingEnabled(false)</div><div class=\"line\">    .setResizeOptions(new ResizeOptions(width, height))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"8-Image-Pipeline\"><a href=\"#8-Image-Pipeline\" class=\"headerlink\" title=\"8.Image Pipeline\"></a>8.Image Pipeline</h3><p>Image pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)</div><div class=\"line\">    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)</div><div class=\"line\">    .setCacheKeyFactory(cacheKeyFactory)</div><div class=\"line\">    .setDownsampleEnabled(true)</div><div class=\"line\">    .setWebpSupportEnabled(true)</div><div class=\"line\">    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)</div><div class=\"line\">    .setExecutorSupplier(executorSupplier)</div><div class=\"line\">    .setImageCacheStatsTracker(imageCacheStatsTracker)</div><div class=\"line\">    .setMainDiskCacheConfig(mainDiskCacheConfig)</div><div class=\"line\">    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)</div><div class=\"line\">    .setNetworkFetchProducer(networkFetchProducer)</div><div class=\"line\">    .setPoolFactory(poolFactory)</div><div class=\"line\">    .setProgressiveJpegConfig(progressiveJpegConfig)</div><div class=\"line\">    .setRequestListeners(requestListeners)</div><div class=\"line\">    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)</div><div class=\"line\">    .build();</div><div class=\"line\">Fresco.initialize(context, config);</div></pre></td></tr></table></figure>\n<p>上面的可配置项会因为版本的不同有稍微的区别。</p>\n<h4 id=\"8-1-缓存\"><a href=\"#8-1-缓存\" class=\"headerlink\" title=\"8.1 缓存\"></a>8.1 缓存</h4><p>在fresco里面，</p>\n<ul>\n<li>bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上</li>\n<li>未解码图片的内存缓存</li>\n<li>磁盘缓存</li>\n</ul>\n<p>我们可以通过imagepipeline判断bitmap是否被缓存，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipeline imagePipeline = Fresco.getImagePipeline();</div><div class=\"line\">imagePipeline.isInBitmapMemoryCache(Uri.parse(&quot;&quot;));</div><div class=\"line\">imagePipeline.isInDiskCache(Uri.parse(&quot;xxx&quot;));</div></pre></td></tr></table></figure>\n<p>删除指定缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(&quot;xxx&quot;);</div><div class=\"line\">imagePipeline.evictFromCache(uri);</div><div class=\"line\">imagePipeline.evictFromDiskCache(uri);</div></pre></td></tr></table></figure>\n<p>使用imagepipeline可以对整个工程加入一些控制。更多用法<a href=\"https://www.fresco-cn.org/docs/using-image-pipeline.html\" target=\"_blank\" rel=\"external\">文档</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0.前言\"></a>0.前言</h3><p>在很久之前，还是学生的时候，使用过fresco，自从来了公司，还没好好学习呢，于是，开始fresco学习之路。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"1-fresco中的关键概念\"><a href=\"#1-fresco中的关键概念\" class=\"headerlink\" title=\"1.fresco中的关键概念\"></a>1.fresco中的关键概念</h3><ul>\n<li>Drawees 负责图片的呈现，有三个元素组成，有点像mvc模式<ul>\n<li>DraweeView 继承view，负责图片的显示，一般情况下使用SimpleDraweeView即可</li>\n<li>DraweeHierarchy DraweeHierarchy 用于组织和维护最终绘制和呈现的 Drawable 对象，相当于MVC中的M。</li>\n<li>DraweeController DraweeController 负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的），可以创建一个这个类的实例，来实现对所要显示的图片做更多的控制。<br>如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类的。</li>\n<li>DraweeControllerBuilder<br>DraweeControllers 由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改</li>\n<li>Listeners 使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。</li>\n</ul>\n</li>\n<li>The Image Pipeline，Fresco 的 Image Pipeline 负责图片的获取和管理。图片可以来自远程服务器，本地文件，或者Content Provider，本地资源。压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。<br>在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。<br>SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。 </li>\n</ul>\n<h3 id=\"3-支持的URI类型\"><a href=\"#3-支持的URI类型\" class=\"headerlink\" title=\"3.支持的URI类型\"></a>3.支持的URI类型</h3><ul>\n<li>http|https</li>\n<li>file://</li>\n<li>content://</li>\n<li>asset://</li>\n<li>res://</li>\n<li>data:mime/type;base64 uri中指定图片数据</li>\n</ul>\n<h3 id=\"4-支持的xml属性\"><a href=\"#4-支持的xml属性\" class=\"headerlink\" title=\"4.支持的xml属性\"></a>4.支持的xml属性</h3><p><a href=\"https://www.fresco-cn.org/docs/using-drawees-xml.html\">支持的xml属性</a></p>\n<h3 id=\"5-在java中使用Drawees\"><a href=\"#5-在java中使用Drawees\" class=\"headerlink\" title=\"5.在java中使用Drawees\"></a>5.在java中使用Drawees</h3><h4 id=\"5-1-自定义DraweeHierarchy\"><a href=\"#5-1-自定义DraweeHierarchy\" class=\"headerlink\" title=\"5.1 自定义DraweeHierarchy\"></a>5.1 自定义DraweeHierarchy</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());</div><div class=\"line\">GenericDraweeHierarchy hierarchy = builder</div><div class=\"line\">        .setFadeDuration(300)</div><div class=\"line\">        //and so on</div><div class=\"line\">        .build();</div><div class=\"line\">image.setHierarchy(hierarchy);</div></pre></td></tr></table></figure>\n<p>从这里，从源码中都可以看出，源码中GenericDraweeView，初始化的时候会调用如下方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) &#123;</div><div class=\"line\">  GenericDraweeHierarchyBuilder builder =</div><div class=\"line\">      GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);</div><div class=\"line\">  setAspectRatio(builder.getDesiredAspectRatio());</div><div class=\"line\">  setHierarchy(builder.build());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>xml中对应的属性，由hierarchy控制。</p>\n<h4 id=\"5-2-运行时修改-DraweeHierarchy\"><a href=\"#5-2-运行时修改-DraweeHierarchy\" class=\"headerlink\" title=\"5.2 运行时修改 DraweeHierarchy\"></a>5.2 运行时修改 DraweeHierarchy</h4><p>要想修改，首先我们就需要获取DraweeHierarchy，然后对属性进行一些修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GenericDraweeHierarchy hierarchy = image.getHierarchy();</div><div class=\"line\">hierarchy.setFadeDuration(400);</div></pre></td></tr></table></figure>\n<p>其他属性同理。</p>\n<h4 id=\"5-3-配置效果\"><a href=\"#5-3-配置效果\" class=\"headerlink\" title=\"5.3 配置效果\"></a>5.3 配置效果</h4><p>我们可以通过xml或者java代码配置各种效果，这里就不介绍了。其中点击重新加载的功能比较新颖。</p>\n<p>在ControllerBuilder 中如下设置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setTapToRetryEnabled(true)</div></pre></td></tr></table></figure>\n<ul>\n<li>XML 中属性值: retryImage</li>\n<li>Hierarchy builder中的方法: setRetryImage</li>\n</ul>\n<h4 id=\"5-4-进度条\"><a href=\"#5-4-进度条\" class=\"headerlink\" title=\"5.4 进度条\"></a>5.4 进度条</h4><p>构建GenericDraweeHierarchy的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.setProgressBarImage(new ProgressBarDrawable())</div></pre></td></tr></table></figure>\n<p>，我们也可以自定义，实现Drawable.onLevelChange。</p>\n<h3 id=\"6-DraweeController增加对图片的控制\"><a href=\"#6-DraweeController增加对图片的控制\" class=\"headerlink\" title=\"6 DraweeController增加对图片的控制\"></a>6 DraweeController增加对图片的控制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ControllerListener listener = new BaseControllerListener() &#123;...&#125;</div><div class=\"line\"></div><div class=\"line\">DraweeController controller = Fresco.newDraweeControllerBuilder()</div><div class=\"line\">    .setUri(uri)</div><div class=\"line\">    .setTapToRetryEnabled(true)</div><div class=\"line\">    .setOldController(mSimpleDraweeView.getController())</div><div class=\"line\">    .setControllerListener(listener)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">mSimpleDraweeView.setController(controller);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>使用渐进式jpeg图。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImageRequest imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(&quot;xxx&quot;))</div><div class=\"line\">            //打开渐进 渲染</div><div class=\"line\">            .setProgressiveRenderingEnabled(true)</div><div class=\"line\">            .build();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>动画自动播放</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">draweeController.setAutoPlayAnimations(true)</div></pre></td></tr></table></figure>\n</li>\n<li><p>动画手动播放，</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ControllerListener listener = new BaseControllerListener&lt;ImageInfo&gt;()&#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onFinalImageSet(String id, ImageInfo imageInfo, Animatable animatable) &#123;</div><div class=\"line\">        super.onFinalImageSet(id, imageInfo, animatable);</div><div class=\"line\">        if (animatable != null)&#123;</div><div class=\"line\">            animatable.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">draweeController.setControllerListener(listener)</div></pre></td></tr></table></figure>\n</li>\n<li><p>后处理器Postprocessor 对图片进行后期处理</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Postprocessor redMeshPostprocessor = new BasePostprocessor() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public String getName() &#123;</div><div class=\"line\">    return &quot;redMeshPostprocessor&quot;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void process(Bitmap bitmap) &#123;</div><div class=\"line\">    for (int x = 0; x &lt; bitmap.getWidth(); x+=2) &#123;</div><div class=\"line\">      for (int y = 0; y &lt; bitmap.getHeight(); y+=2) &#123;</div><div class=\"line\">        bitmap.setPixel(x, y, Color.RED);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)</div><div class=\"line\">    .setPostprocessor(redMeshPostprocessor)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"7-Image-Requests\"><a href=\"#7-Image-Requests\" class=\"headerlink\" title=\"7.Image Requests\"></a>7.Image Requests</h3><p>使用ImageRequestBuilder来做更多的事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri;</div><div class=\"line\"></div><div class=\"line\">ImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder()</div><div class=\"line\">    .setBackgroundColor(Color.GREEN)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">ImageRequest request = ImageRequestBuilder</div><div class=\"line\">    .newBuilderWithSource(uri)</div><div class=\"line\">    .setImageDecodeOptions(decodeOptions)</div><div class=\"line\">    .setAutoRotateEnabled(true)</div><div class=\"line\">    .setLocalThumbnailPreviewsEnabled(true)</div><div class=\"line\">    .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)    </div><div class=\"line\">    .setProgressiveRenderingEnabled(false)</div><div class=\"line\">    .setResizeOptions(new ResizeOptions(width, height))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<h3 id=\"8-Image-Pipeline\"><a href=\"#8-Image-Pipeline\" class=\"headerlink\" title=\"8.Image Pipeline\"></a>8.Image Pipeline</h3><p>Image pipeline 负责完成加载图像，变成Android设备可呈现的形式所要做的每个事情。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipelineConfig config = ImagePipelineConfig.newBuilder(context)</div><div class=\"line\">    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)</div><div class=\"line\">    .setCacheKeyFactory(cacheKeyFactory)</div><div class=\"line\">    .setDownsampleEnabled(true)</div><div class=\"line\">    .setWebpSupportEnabled(true)</div><div class=\"line\">    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)</div><div class=\"line\">    .setExecutorSupplier(executorSupplier)</div><div class=\"line\">    .setImageCacheStatsTracker(imageCacheStatsTracker)</div><div class=\"line\">    .setMainDiskCacheConfig(mainDiskCacheConfig)</div><div class=\"line\">    .setMemoryTrimmableRegistry(memoryTrimmableRegistry)</div><div class=\"line\">    .setNetworkFetchProducer(networkFetchProducer)</div><div class=\"line\">    .setPoolFactory(poolFactory)</div><div class=\"line\">    .setProgressiveJpegConfig(progressiveJpegConfig)</div><div class=\"line\">    .setRequestListeners(requestListeners)</div><div class=\"line\">    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)</div><div class=\"line\">    .build();</div><div class=\"line\">Fresco.initialize(context, config);</div></pre></td></tr></table></figure>\n<p>上面的可配置项会因为版本的不同有稍微的区别。</p>\n<h4 id=\"8-1-缓存\"><a href=\"#8-1-缓存\" class=\"headerlink\" title=\"8.1 缓存\"></a>8.1 缓存</h4><p>在fresco里面，</p>\n<ul>\n<li>bitmap缓存，直接存的就是bitmap对象，5.0 一下，这些位于ashmem，5.0以上，直接位于java的heap上</li>\n<li>未解码图片的内存缓存</li>\n<li>磁盘缓存</li>\n</ul>\n<p>我们可以通过imagepipeline判断bitmap是否被缓存，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ImagePipeline imagePipeline = Fresco.getImagePipeline();</div><div class=\"line\">imagePipeline.isInBitmapMemoryCache(Uri.parse(&quot;&quot;));</div><div class=\"line\">imagePipeline.isInDiskCache(Uri.parse(&quot;xxx&quot;));</div></pre></td></tr></table></figure>\n<p>删除指定缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(&quot;xxx&quot;);</div><div class=\"line\">imagePipeline.evictFromCache(uri);</div><div class=\"line\">imagePipeline.evictFromDiskCache(uri);</div></pre></td></tr></table></figure>\n<p>使用imagepipeline可以对整个工程加入一些控制。更多用法<a href=\"https://www.fresco-cn.org/docs/using-image-pipeline.html\">文档</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"了解gradle（一）","date":"2016-12-05T13:27:31.000Z","_content":"<Excerpt in index | 首页摘要>\n想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。\n\n### 1.依赖管理\n\n```\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n    testCompile group: 'junit', name: 'junit', version: '4.+'\n}\n```\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n* respositories 声明我们要使用的仓库\n* dependencies 我们要依赖的一些东西\n\t* compile 依赖需要编译生产项目的来源\n\t* runtime 依赖运行时字节码\n\t* testCompile 依赖测试代码\n\t* testRuntime \n\t\n通常，我们声明仓库有两种方式\n\n* 使用中央仓库 mavenCentral()\n* 使用自己的仓库\n\t* 使用远程仓库\n\t\n\t\t```\n\trepositories {\n    maven {\n    \t// 自己远程仓库地址\n        url \"http://repo.mycompany.com/maven2\"\n    }\n}\n\t```\n\t* 使用本地仓库\t \n\t\n\t\t```\n\t\trepositories {\n    ivy {\n        // URL can refer to a local directory\n        url \"../local-repo\"\n    }\n}\n\t\t```\n\t\t\n\t\t\n\t\t\n再说我们的依赖包管理，同样有两种方式\n\n```\n// 1\ncompile 'org.hibernate:hibernate-core:3.6.7.Final'\n// 2\ncompile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n```\n\n我们最常用的是第一种方法。\n\n有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除\n\n```\n    compile(\"com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version\") {\n        exclude group: 'com.squareup.retrofit2'\n    }\n```\n\n关于如何上传仓库这里暂时不介绍,[可以看这里](https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle)\n\n### 2.编写gradle脚本\n\n#### 2.1 Project API\n\n```\nprintln project.buildDir\n```\n\n我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。\n\n#### 2.2 如何定义变量\n\n\n\n和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。\n\n```\ndef my_name = \"guolei\"\nprintln my_nme\n```\n\n#### 2.3 Extra 属性\n\n```\next {\n    my_name = \"guolei\"\n}\n\nprintln ext.my_name;\n```\n\n#### 2.4 TASK \n\ngradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。[gradle api文档地址](https://docs.gradle.org/current/javadoc/)，关于Api的使用，这里就不介绍了，文档上使用方法很全。\n\n#### 2.5 TASK之间的依赖关系\n\n我们可以使用dependsOn来指明task之间的关系。\n\n```\ntaskX.dependsOn taskY\n\n```\n\n如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。\n\n\n#### 2.6 有序的TASKS\n\n* shouldRunAfter\n* mustRunAfter\n\n\n#### 2.7 给task添加描述\n\n```\ntask a {\n\tdescription \"xxx\"\n\tprintln \"xx\"\n}\n\n```\n\n#### 2.8 跳过task不执行\n\n* onlyIf,满足条件的情况下才执行\n\n```\ntask hello {\n    doLast {\n        println 'hello world'\n    }\n}\n\nhello.onlyIf { !project.hasProperty('skipHello') }\n```\n\n* 用异常\n\n```\ncompile.doFirst {\n    // Here you would put arbitrary conditions in real life.\n    // But this is used in an integration test so we want defined behavior.\n    if (true) { throw new StopExecutionException() }\n}\n```\n\n* enabled属性\n\n```\ntask.enabled = false\n```\n\n### 3.如何操作文件\n\n\n我们可以利用Project.file 方法去获取文件\n\n```\n// Using a relative path\nFile configFile = file('src/config.xml')\n\n// Using an absolute path\nconfigFile = file(configFile.absolutePath)\n\n// Using a File object with a relative path\nconfigFile = file(new File('src/config.xml'))\n```\n\n\n然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）\n\n```\n\nFileCollection collection = files('src/file1.txt',new File('src/file2.txt'),['src/file3.txt', 'src/file4.txt'])\n```\n\n可以利用Project.fileTree获取文件树。\n\n```\n// Create a file tree with a base directory\nFileTree tree = fileTree(dir: 'src/main')\n\n// Add include and exclude patterns to the tree\ntree.include '**/*.java'\ntree.exclude '**/Abstract*'\n\n// Create a tree using path\ntree = fileTree('src').include('**/*.java')\n\n// Create a tree using closure\ntree = fileTree('src') {\n    include '**/*.java'\n}\n\n// Create a tree using a map\ntree = fileTree(dir: 'src', include: '**/*.java')\ntree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])\ntree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')\n\n```\n\n我们可以操作压缩文件。\n\n```\n\n// Create a ZIP file tree using path\nFileTree zip = zipTree('someFile.zip')\n\n// Create a TAR file tree using path\nFileTree tar = tarTree('someFile.tar')\n\n//tar tree attempts to guess the compression based on the file extension\n//however if you must specify the compression explicitly you can:\nFileTree someTar = tarTree(resources.gzip('someTar.ext'))\n```\n\n文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。\n\n关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。\n\n\n### 4. 如何打log\n\n我们可以通过logger的一些方法输出log日志\n\n```\nogger.quiet('An info log message which is always logged.')\nlogger.error('An error log message.')\nlogger.warn('A warning log message.')\nlogger.lifecycle('A lifecycle info log message.')\nlogger.info('An info log message.')\nlogger.debug('A debug log message.')\nlogger.trace('A trace log message.')\n```\n\n### 5. gradle plugins\n\n```\napply from: 'other.gradle'\n```\n\n```\nplugins {\n    id «plugin id» version «plugin version» [apply «false»]\n}\n```\n\n```\n apply plugin: 'org.gradle.sample.goodbye'\n```\n\n三种方式。\n\n### 6.总结 \n\n上面的一些用法，全部来自于文档.\n\n[gradle 文档地址](https://docs.gradle.org/current/userguide/)\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","source":"_posts/了解gradle（一）.md","raw":"---\ntitle: 了解gradle（一）\ndate: 2016-12-05 21:27:31\ncategories: Gradle\ntags: gradle\n\n---\n<Excerpt in index | 首页摘要>\n想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。\n\n### 1.依赖管理\n\n```\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n    testCompile group: 'junit', name: 'junit', version: '4.+'\n}\n```\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n* respositories 声明我们要使用的仓库\n* dependencies 我们要依赖的一些东西\n\t* compile 依赖需要编译生产项目的来源\n\t* runtime 依赖运行时字节码\n\t* testCompile 依赖测试代码\n\t* testRuntime \n\t\n通常，我们声明仓库有两种方式\n\n* 使用中央仓库 mavenCentral()\n* 使用自己的仓库\n\t* 使用远程仓库\n\t\n\t\t```\n\trepositories {\n    maven {\n    \t// 自己远程仓库地址\n        url \"http://repo.mycompany.com/maven2\"\n    }\n}\n\t```\n\t* 使用本地仓库\t \n\t\n\t\t```\n\t\trepositories {\n    ivy {\n        // URL can refer to a local directory\n        url \"../local-repo\"\n    }\n}\n\t\t```\n\t\t\n\t\t\n\t\t\n再说我们的依赖包管理，同样有两种方式\n\n```\n// 1\ncompile 'org.hibernate:hibernate-core:3.6.7.Final'\n// 2\ncompile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n```\n\n我们最常用的是第一种方法。\n\n有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除\n\n```\n    compile(\"com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version\") {\n        exclude group: 'com.squareup.retrofit2'\n    }\n```\n\n关于如何上传仓库这里暂时不介绍,[可以看这里](https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle)\n\n### 2.编写gradle脚本\n\n#### 2.1 Project API\n\n```\nprintln project.buildDir\n```\n\n我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。\n\n#### 2.2 如何定义变量\n\n\n\n和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。\n\n```\ndef my_name = \"guolei\"\nprintln my_nme\n```\n\n#### 2.3 Extra 属性\n\n```\next {\n    my_name = \"guolei\"\n}\n\nprintln ext.my_name;\n```\n\n#### 2.4 TASK \n\ngradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。[gradle api文档地址](https://docs.gradle.org/current/javadoc/)，关于Api的使用，这里就不介绍了，文档上使用方法很全。\n\n#### 2.5 TASK之间的依赖关系\n\n我们可以使用dependsOn来指明task之间的关系。\n\n```\ntaskX.dependsOn taskY\n\n```\n\n如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。\n\n\n#### 2.6 有序的TASKS\n\n* shouldRunAfter\n* mustRunAfter\n\n\n#### 2.7 给task添加描述\n\n```\ntask a {\n\tdescription \"xxx\"\n\tprintln \"xx\"\n}\n\n```\n\n#### 2.8 跳过task不执行\n\n* onlyIf,满足条件的情况下才执行\n\n```\ntask hello {\n    doLast {\n        println 'hello world'\n    }\n}\n\nhello.onlyIf { !project.hasProperty('skipHello') }\n```\n\n* 用异常\n\n```\ncompile.doFirst {\n    // Here you would put arbitrary conditions in real life.\n    // But this is used in an integration test so we want defined behavior.\n    if (true) { throw new StopExecutionException() }\n}\n```\n\n* enabled属性\n\n```\ntask.enabled = false\n```\n\n### 3.如何操作文件\n\n\n我们可以利用Project.file 方法去获取文件\n\n```\n// Using a relative path\nFile configFile = file('src/config.xml')\n\n// Using an absolute path\nconfigFile = file(configFile.absolutePath)\n\n// Using a File object with a relative path\nconfigFile = file(new File('src/config.xml'))\n```\n\n\n然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）\n\n```\n\nFileCollection collection = files('src/file1.txt',new File('src/file2.txt'),['src/file3.txt', 'src/file4.txt'])\n```\n\n可以利用Project.fileTree获取文件树。\n\n```\n// Create a file tree with a base directory\nFileTree tree = fileTree(dir: 'src/main')\n\n// Add include and exclude patterns to the tree\ntree.include '**/*.java'\ntree.exclude '**/Abstract*'\n\n// Create a tree using path\ntree = fileTree('src').include('**/*.java')\n\n// Create a tree using closure\ntree = fileTree('src') {\n    include '**/*.java'\n}\n\n// Create a tree using a map\ntree = fileTree(dir: 'src', include: '**/*.java')\ntree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])\ntree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')\n\n```\n\n我们可以操作压缩文件。\n\n```\n\n// Create a ZIP file tree using path\nFileTree zip = zipTree('someFile.zip')\n\n// Create a TAR file tree using path\nFileTree tar = tarTree('someFile.tar')\n\n//tar tree attempts to guess the compression based on the file extension\n//however if you must specify the compression explicitly you can:\nFileTree someTar = tarTree(resources.gzip('someTar.ext'))\n```\n\n文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。\n\n关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。\n\n\n### 4. 如何打log\n\n我们可以通过logger的一些方法输出log日志\n\n```\nogger.quiet('An info log message which is always logged.')\nlogger.error('An error log message.')\nlogger.warn('A warning log message.')\nlogger.lifecycle('A lifecycle info log message.')\nlogger.info('An info log message.')\nlogger.debug('A debug log message.')\nlogger.trace('A trace log message.')\n```\n\n### 5. gradle plugins\n\n```\napply from: 'other.gradle'\n```\n\n```\nplugins {\n    id «plugin id» version «plugin version» [apply «false»]\n}\n```\n\n```\n apply plugin: 'org.gradle.sample.goodbye'\n```\n\n三种方式。\n\n### 6.总结 \n\n上面的一些用法，全部来自于文档.\n\n[gradle 文档地址](https://docs.gradle.org/current/userguide/)\n\n\n\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n","slug":"了解gradle（一）","published":1,"updated":"2017-01-07T06:56:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2x002qhws64pjnxzsp","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"><br>想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。</excerpt></p>\n<h3 id=\"1-依赖管理\"><a href=\"#1-依赖管理\" class=\"headerlink\" title=\"1.依赖管理\"></a>1.依赖管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div><div class=\"line\">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.+&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<ul>\n<li>respositories 声明我们要使用的仓库</li>\n<li>dependencies 我们要依赖的一些东西<ul>\n<li>compile 依赖需要编译生产项目的来源</li>\n<li>runtime 依赖运行时字节码</li>\n<li>testCompile 依赖测试代码</li>\n<li>testRuntime </li>\n</ul>\n</li>\n</ul>\n<p>通常，我们声明仓库有两种方式</p>\n<ul>\n<li>使用中央仓库 mavenCentral()</li>\n<li><p>使用自己的仓库</p>\n<ul>\n<li><p>使用远程仓库</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\trepositories &#123;</div><div class=\"line\">    maven &#123;</div><div class=\"line\">    \t// 自己远程仓库地址</div><div class=\"line\">        url &quot;http://repo.mycompany.com/maven2&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用本地仓库     </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\trepositories &#123;</div><div class=\"line\">    ivy &#123;</div><div class=\"line\">        // URL can refer to a local directory</div><div class=\"line\">        url &quot;../local-repo&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>再说我们的依赖包管理，同样有两种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos;</div><div class=\"line\">// 2</div><div class=\"line\">compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div></pre></td></tr></table></figure>\n<p>我们最常用的是第一种方法。</p>\n<p>有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile(&quot;com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version&quot;) &#123;</div><div class=\"line\">    exclude group: &apos;com.squareup.retrofit2&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于如何上传仓库这里暂时不介绍,<a href=\"https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle\" target=\"_blank\" rel=\"external\">可以看这里</a></p>\n<h3 id=\"2-编写gradle脚本\"><a href=\"#2-编写gradle脚本\" class=\"headerlink\" title=\"2.编写gradle脚本\"></a>2.编写gradle脚本</h3><h4 id=\"2-1-Project-API\"><a href=\"#2-1-Project-API\" class=\"headerlink\" title=\"2.1 Project API\"></a>2.1 Project API</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">println project.buildDir</div></pre></td></tr></table></figure>\n<p>我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。</p>\n<h4 id=\"2-2-如何定义变量\"><a href=\"#2-2-如何定义变量\" class=\"headerlink\" title=\"2.2 如何定义变量\"></a>2.2 如何定义变量</h4><p>和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def my_name = &quot;guolei&quot;</div><div class=\"line\">println my_nme</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-Extra-属性\"><a href=\"#2-3-Extra-属性\" class=\"headerlink\" title=\"2.3 Extra 属性\"></a>2.3 Extra 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ext &#123;</div><div class=\"line\">    my_name = &quot;guolei&quot;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">println ext.my_name;</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-TASK\"><a href=\"#2-4-TASK\" class=\"headerlink\" title=\"2.4 TASK\"></a>2.4 TASK</h4><p>gradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。<a href=\"https://docs.gradle.org/current/javadoc/\" target=\"_blank\" rel=\"external\">gradle api文档地址</a>，关于Api的使用，这里就不介绍了，文档上使用方法很全。</p>\n<h4 id=\"2-5-TASK之间的依赖关系\"><a href=\"#2-5-TASK之间的依赖关系\" class=\"headerlink\" title=\"2.5 TASK之间的依赖关系\"></a>2.5 TASK之间的依赖关系</h4><p>我们可以使用dependsOn来指明task之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">taskX.dependsOn taskY</div></pre></td></tr></table></figure>\n<p>如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。</p>\n<h4 id=\"2-6-有序的TASKS\"><a href=\"#2-6-有序的TASKS\" class=\"headerlink\" title=\"2.6 有序的TASKS\"></a>2.6 有序的TASKS</h4><ul>\n<li>shouldRunAfter</li>\n<li>mustRunAfter</li>\n</ul>\n<h4 id=\"2-7-给task添加描述\"><a href=\"#2-7-给task添加描述\" class=\"headerlink\" title=\"2.7 给task添加描述\"></a>2.7 给task添加描述</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">task a &#123;</div><div class=\"line\">\tdescription &quot;xxx&quot;</div><div class=\"line\">\tprintln &quot;xx&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-8-跳过task不执行\"><a href=\"#2-8-跳过task不执行\" class=\"headerlink\" title=\"2.8 跳过task不执行\"></a>2.8 跳过task不执行</h4><ul>\n<li>onlyIf,满足条件的情况下才执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">task hello &#123;</div><div class=\"line\">    doLast &#123;</div><div class=\"line\">        println &apos;hello world&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">hello.onlyIf &#123; !project.hasProperty(&apos;skipHello&apos;) &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>用异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile.doFirst &#123;</div><div class=\"line\">    // Here you would put arbitrary conditions in real life.</div><div class=\"line\">    // But this is used in an integration test so we want defined behavior.</div><div class=\"line\">    if (true) &#123; throw new StopExecutionException() &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>enabled属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task.enabled = false</div></pre></td></tr></table></figure>\n<h3 id=\"3-如何操作文件\"><a href=\"#3-如何操作文件\" class=\"headerlink\" title=\"3.如何操作文件\"></a>3.如何操作文件</h3><p>我们可以利用Project.file 方法去获取文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Using a relative path</div><div class=\"line\">File configFile = file(&apos;src/config.xml&apos;)</div><div class=\"line\"></div><div class=\"line\">// Using an absolute path</div><div class=\"line\">configFile = file(configFile.absolutePath)</div><div class=\"line\"></div><div class=\"line\">// Using a File object with a relative path</div><div class=\"line\">configFile = file(new File(&apos;src/config.xml&apos;))</div></pre></td></tr></table></figure>\n<p>然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">FileCollection collection = files(&apos;src/file1.txt&apos;,new File(&apos;src/file2.txt&apos;),[&apos;src/file3.txt&apos;, &apos;src/file4.txt&apos;])</div></pre></td></tr></table></figure>\n<p>可以利用Project.fileTree获取文件树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Create a file tree with a base directory</div><div class=\"line\">FileTree tree = fileTree(dir: &apos;src/main&apos;)</div><div class=\"line\"></div><div class=\"line\">// Add include and exclude patterns to the tree</div><div class=\"line\">tree.include &apos;**/*.java&apos;</div><div class=\"line\">tree.exclude &apos;**/Abstract*&apos;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using path</div><div class=\"line\">tree = fileTree(&apos;src&apos;).include(&apos;**/*.java&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a tree using closure</div><div class=\"line\">tree = fileTree(&apos;src&apos;) &#123;</div><div class=\"line\">    include &apos;**/*.java&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using a map</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;)</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, includes: [&apos;**/*.java&apos;, &apos;**/*.xml&apos;])</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;, exclude: &apos;**/*test*/**&apos;)</div></pre></td></tr></table></figure>\n<p>我们可以操作压缩文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// Create a ZIP file tree using path</div><div class=\"line\">FileTree zip = zipTree(&apos;someFile.zip&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a TAR file tree using path</div><div class=\"line\">FileTree tar = tarTree(&apos;someFile.tar&apos;)</div><div class=\"line\"></div><div class=\"line\">//tar tree attempts to guess the compression based on the file extension</div><div class=\"line\">//however if you must specify the compression explicitly you can:</div><div class=\"line\">FileTree someTar = tarTree(resources.gzip(&apos;someTar.ext&apos;))</div></pre></td></tr></table></figure>\n<p>文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。</p>\n<p>关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。</p>\n<h3 id=\"4-如何打log\"><a href=\"#4-如何打log\" class=\"headerlink\" title=\"4. 如何打log\"></a>4. 如何打log</h3><p>我们可以通过logger的一些方法输出log日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ogger.quiet(&apos;An info log message which is always logged.&apos;)</div><div class=\"line\">logger.error(&apos;An error log message.&apos;)</div><div class=\"line\">logger.warn(&apos;A warning log message.&apos;)</div><div class=\"line\">logger.lifecycle(&apos;A lifecycle info log message.&apos;)</div><div class=\"line\">logger.info(&apos;An info log message.&apos;)</div><div class=\"line\">logger.debug(&apos;A debug log message.&apos;)</div><div class=\"line\">logger.trace(&apos;A trace log message.&apos;)</div></pre></td></tr></table></figure>\n<h3 id=\"5-gradle-plugins\"><a href=\"#5-gradle-plugins\" class=\"headerlink\" title=\"5. gradle plugins\"></a>5. gradle plugins</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply from: &apos;other.gradle&apos;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins &#123;</div><div class=\"line\">    id «plugin id» version «plugin version» [apply «false»]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;org.gradle.sample.goodbye&apos;</div></pre></td></tr></table></figure>\n<p>三种方式。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>上面的一些用法，全部来自于文档.</p>\n<p><a href=\"https://docs.gradle.org/current/userguide/\" target=\"_blank\" rel=\"external\">gradle 文档地址</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要><br>想写gardle很长时间了，但是一直没写，现在，是时候写一下gradle文档中，重要的部分了。</p>\n<h3 id=\"1-依赖管理\"><a href=\"#1-依赖管理\" class=\"headerlink\" title=\"1.依赖管理\"></a>1.依赖管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div><div class=\"line\">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.+&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<The rest of contents | 余下全文>\n\n\n\n<ul>\n<li>respositories 声明我们要使用的仓库</li>\n<li>dependencies 我们要依赖的一些东西<ul>\n<li>compile 依赖需要编译生产项目的来源</li>\n<li>runtime 依赖运行时字节码</li>\n<li>testCompile 依赖测试代码</li>\n<li>testRuntime </li>\n</ul>\n</li>\n</ul>\n<p>通常，我们声明仓库有两种方式</p>\n<ul>\n<li>使用中央仓库 mavenCentral()</li>\n<li><p>使用自己的仓库</p>\n<ul>\n<li><p>使用远程仓库</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\trepositories &#123;</div><div class=\"line\">    maven &#123;</div><div class=\"line\">    \t// 自己远程仓库地址</div><div class=\"line\">        url &quot;http://repo.mycompany.com/maven2&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用本地仓库     </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\trepositories &#123;</div><div class=\"line\">    ivy &#123;</div><div class=\"line\">        // URL can refer to a local directory</div><div class=\"line\">        url &quot;../local-repo&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>再说我们的依赖包管理，同样有两种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1</div><div class=\"line\">compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos;</div><div class=\"line\">// 2</div><div class=\"line\">compile group: &apos;org.hibernate&apos;, name: &apos;hibernate-core&apos;, version: &apos;3.6.7.Final&apos;</div></pre></td></tr></table></figure>\n<p>我们最常用的是第一种方法。</p>\n<p>有的时候，可能会存在包冲突，这时候我们可以通过如下代码，排除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile(&quot;com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofit2Version&quot;) &#123;</div><div class=\"line\">    exclude group: &apos;com.squareup.retrofit2&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于如何上传仓库这里暂时不介绍,<a href=\"https://github.com/JakeWharton/butterknife/blob/master/gradle/gradle-mvn-push.gradle\">可以看这里</a></p>\n<h3 id=\"2-编写gradle脚本\"><a href=\"#2-编写gradle脚本\" class=\"headerlink\" title=\"2.编写gradle脚本\"></a>2.编写gradle脚本</h3><h4 id=\"2-1-Project-API\"><a href=\"#2-1-Project-API\" class=\"headerlink\" title=\"2.1 Project API\"></a>2.1 Project API</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">println project.buildDir</div></pre></td></tr></table></figure>\n<p>我们可以通过project得到我们project的一些属性，关于可以得到哪些舒心，我这里就不说了。动手才是王道。</p>\n<h4 id=\"2-2-如何定义变量\"><a href=\"#2-2-如何定义变量\" class=\"headerlink\" title=\"2.2 如何定义变量\"></a>2.2 如何定义变量</h4><p>和大多数脚本语言一下，groovy也是弱类型语言，同样通过def关键字定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def my_name = &quot;guolei&quot;</div><div class=\"line\">println my_nme</div></pre></td></tr></table></figure>\n<h4 id=\"2-3-Extra-属性\"><a href=\"#2-3-Extra-属性\" class=\"headerlink\" title=\"2.3 Extra 属性\"></a>2.3 Extra 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ext &#123;</div><div class=\"line\">    my_name = &quot;guolei&quot;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">println ext.my_name;</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-TASK\"><a href=\"#2-4-TASK\" class=\"headerlink\" title=\"2.4 TASK\"></a>2.4 TASK</h4><p>gradle内置了许多现成的tasks，在org.gradle.api.tasks包下面，需要的时候我们可以查阅用法。<a href=\"https://docs.gradle.org/current/javadoc/\">gradle api文档地址</a>，关于Api的使用，这里就不介绍了，文档上使用方法很全。</p>\n<h4 id=\"2-5-TASK之间的依赖关系\"><a href=\"#2-5-TASK之间的依赖关系\" class=\"headerlink\" title=\"2.5 TASK之间的依赖关系\"></a>2.5 TASK之间的依赖关系</h4><p>我们可以使用dependsOn来指明task之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">taskX.dependsOn taskY</div></pre></td></tr></table></figure>\n<p>如例子，taskX是依赖y的，也就是说，在执行x的时候，会先执行y。</p>\n<h4 id=\"2-6-有序的TASKS\"><a href=\"#2-6-有序的TASKS\" class=\"headerlink\" title=\"2.6 有序的TASKS\"></a>2.6 有序的TASKS</h4><ul>\n<li>shouldRunAfter</li>\n<li>mustRunAfter</li>\n</ul>\n<h4 id=\"2-7-给task添加描述\"><a href=\"#2-7-给task添加描述\" class=\"headerlink\" title=\"2.7 给task添加描述\"></a>2.7 给task添加描述</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">task a &#123;</div><div class=\"line\">\tdescription &quot;xxx&quot;</div><div class=\"line\">\tprintln &quot;xx&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-8-跳过task不执行\"><a href=\"#2-8-跳过task不执行\" class=\"headerlink\" title=\"2.8 跳过task不执行\"></a>2.8 跳过task不执行</h4><ul>\n<li>onlyIf,满足条件的情况下才执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">task hello &#123;</div><div class=\"line\">    doLast &#123;</div><div class=\"line\">        println &apos;hello world&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">hello.onlyIf &#123; !project.hasProperty(&apos;skipHello&apos;) &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>用异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile.doFirst &#123;</div><div class=\"line\">    // Here you would put arbitrary conditions in real life.</div><div class=\"line\">    // But this is used in an integration test so we want defined behavior.</div><div class=\"line\">    if (true) &#123; throw new StopExecutionException() &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>enabled属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">task.enabled = false</div></pre></td></tr></table></figure>\n<h3 id=\"3-如何操作文件\"><a href=\"#3-如何操作文件\" class=\"headerlink\" title=\"3.如何操作文件\"></a>3.如何操作文件</h3><p>我们可以利用Project.file 方法去获取文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Using a relative path</div><div class=\"line\">File configFile = file(&apos;src/config.xml&apos;)</div><div class=\"line\"></div><div class=\"line\">// Using an absolute path</div><div class=\"line\">configFile = file(configFile.absolutePath)</div><div class=\"line\"></div><div class=\"line\">// Using a File object with a relative path</div><div class=\"line\">configFile = file(new File(&apos;src/config.xml&apos;))</div></pre></td></tr></table></figure>\n<p>然后利用Project.files方法去获取FileCollection（文件集合，一些列文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">FileCollection collection = files(&apos;src/file1.txt&apos;,new File(&apos;src/file2.txt&apos;),[&apos;src/file3.txt&apos;, &apos;src/file4.txt&apos;])</div></pre></td></tr></table></figure>\n<p>可以利用Project.fileTree获取文件树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Create a file tree with a base directory</div><div class=\"line\">FileTree tree = fileTree(dir: &apos;src/main&apos;)</div><div class=\"line\"></div><div class=\"line\">// Add include and exclude patterns to the tree</div><div class=\"line\">tree.include &apos;**/*.java&apos;</div><div class=\"line\">tree.exclude &apos;**/Abstract*&apos;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using path</div><div class=\"line\">tree = fileTree(&apos;src&apos;).include(&apos;**/*.java&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a tree using closure</div><div class=\"line\">tree = fileTree(&apos;src&apos;) &#123;</div><div class=\"line\">    include &apos;**/*.java&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Create a tree using a map</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;)</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, includes: [&apos;**/*.java&apos;, &apos;**/*.xml&apos;])</div><div class=\"line\">tree = fileTree(dir: &apos;src&apos;, include: &apos;**/*.java&apos;, exclude: &apos;**/*test*/**&apos;)</div></pre></td></tr></table></figure>\n<p>我们可以操作压缩文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// Create a ZIP file tree using path</div><div class=\"line\">FileTree zip = zipTree(&apos;someFile.zip&apos;)</div><div class=\"line\"></div><div class=\"line\">// Create a TAR file tree using path</div><div class=\"line\">FileTree tar = tarTree(&apos;someFile.tar&apos;)</div><div class=\"line\"></div><div class=\"line\">//tar tree attempts to guess the compression based on the file extension</div><div class=\"line\">//however if you must specify the compression explicitly you can:</div><div class=\"line\">FileTree someTar = tarTree(resources.gzip(&apos;someTar.ext&apos;))</div></pre></td></tr></table></figure>\n<p>文件复制，这里我们要用到gradle api里面的copy去做。关于如何使用这就不介绍了，上面有说到过api地址。</p>\n<p>关于文件的复制、删除、重命名、过滤等都是api的使用，这里就不说了。</p>\n<h3 id=\"4-如何打log\"><a href=\"#4-如何打log\" class=\"headerlink\" title=\"4. 如何打log\"></a>4. 如何打log</h3><p>我们可以通过logger的一些方法输出log日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ogger.quiet(&apos;An info log message which is always logged.&apos;)</div><div class=\"line\">logger.error(&apos;An error log message.&apos;)</div><div class=\"line\">logger.warn(&apos;A warning log message.&apos;)</div><div class=\"line\">logger.lifecycle(&apos;A lifecycle info log message.&apos;)</div><div class=\"line\">logger.info(&apos;An info log message.&apos;)</div><div class=\"line\">logger.debug(&apos;A debug log message.&apos;)</div><div class=\"line\">logger.trace(&apos;A trace log message.&apos;)</div></pre></td></tr></table></figure>\n<h3 id=\"5-gradle-plugins\"><a href=\"#5-gradle-plugins\" class=\"headerlink\" title=\"5. gradle plugins\"></a>5. gradle plugins</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply from: &apos;other.gradle&apos;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins &#123;</div><div class=\"line\">    id «plugin id» version «plugin version» [apply «false»]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apply plugin: &apos;org.gradle.sample.goodbye&apos;</div></pre></td></tr></table></figure>\n<p>三种方式。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>上面的一些用法，全部来自于文档.</p>\n<p><a href=\"https://docs.gradle.org/current/userguide/\">gradle 文档地址</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"消息机制在多进程的应用","date":"2017-01-01T13:40:11.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2. 如何使用Messenger\n\n#### 2.1 Messenger 服务端\n\n首先我们需要一个messenger，并传入一个handler。\n\n```java\nprivate Messenger messenger = new Messenger(new MessengerHandler());\n```\n\n其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。\n\n```java\n    @Override\n    public IBinder onBind(Intent intent) {\n        return messenger.getBinder();\n    }\n```\n\n在这个handler的handleMessage方法中，获取客户端发送的消息。\n\n```java\n    private class MessengerHandler extends Handler{\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_CLIENT:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    Messenger client = msg.replyTo;\n                    if (client != null){\n                        Message message = Message.obtain(null,Constants.MSG_FROM_SERVER);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(Constants.MSG_DATA,\"from server\");\n                        message.setData(bundle);\n                        try {\n                            client.send(message);\n                        } catch (RemoteException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    }\n```\n\n最后，在配置文件中，将这个service开启process，开启另一个进程。\n\n#### 2.2 客户端\n\n想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，\n\n```java\n    public Handler getFromServer = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_SERVER:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    };\n\n    private Messenger getReplyMessenger = new Messenger(getFromServer);\n\n    public ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            messenger = new Messenger(service);\n            Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);\n            Bundle bundle = new Bundle();\n            bundle.putString(Constants.MSG_DATA,\"from client\");\n            msg.setData(bundle);\n            msg.replyTo=getReplyMessenger;\n            try {\n                messenger.send(msg);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n```\n\n### 3. 简单分析\n\n之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。\n\n首先是Messenger的getBinder方法，这个方法返回一个binder对象。\n\n```java\n    public IBinder getBinder() {\n        return mTarget.asBinder();\n    }\n```\n\n其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。\n\n```java\n    private final class MessengerImpl extends IMessenger.Stub {\n        public void send(Message msg) {\n            msg.sendingUid = Binder.getCallingUid();\n            Handler.this.sendMessage(msg);\n        }\n    }\n```\n\n而Messenger的send方法。就是调用这里的send方法。\n\n\n### 4. 总结\n\n其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","source":"_posts/消息机制在多进程的应用.md","raw":"---\ntitle: 消息机制在多进程的应用\ndate: 2017-01-01 21:40:11\ncategories: Android\ntags: [android,消息机制]\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2. 如何使用Messenger\n\n#### 2.1 Messenger 服务端\n\n首先我们需要一个messenger，并传入一个handler。\n\n```java\nprivate Messenger messenger = new Messenger(new MessengerHandler());\n```\n\n其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。\n\n```java\n    @Override\n    public IBinder onBind(Intent intent) {\n        return messenger.getBinder();\n    }\n```\n\n在这个handler的handleMessage方法中，获取客户端发送的消息。\n\n```java\n    private class MessengerHandler extends Handler{\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_CLIENT:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    Messenger client = msg.replyTo;\n                    if (client != null){\n                        Message message = Message.obtain(null,Constants.MSG_FROM_SERVER);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(Constants.MSG_DATA,\"from server\");\n                        message.setData(bundle);\n                        try {\n                            client.send(message);\n                        } catch (RemoteException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    }\n```\n\n最后，在配置文件中，将这个service开启process，开启另一个进程。\n\n#### 2.2 客户端\n\n想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，\n\n```java\n    public Handler getFromServer = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what){\n                case Constants.MSG_FROM_SERVER:\n                    Log.e(TAG, \"handleMessage: \" + msg.getData().getString(Constants.MSG_DATA,\"\") );\n                    break;\n                default:\n                    super.handleMessage(msg);\n                    break;\n            }\n        }\n    };\n\n    private Messenger getReplyMessenger = new Messenger(getFromServer);\n\n    public ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            messenger = new Messenger(service);\n            Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);\n            Bundle bundle = new Bundle();\n            bundle.putString(Constants.MSG_DATA,\"from client\");\n            msg.setData(bundle);\n            msg.replyTo=getReplyMessenger;\n            try {\n                messenger.send(msg);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n```\n\n### 3. 简单分析\n\n之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。\n\n首先是Messenger的getBinder方法，这个方法返回一个binder对象。\n\n```java\n    public IBinder getBinder() {\n        return mTarget.asBinder();\n    }\n```\n\n其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。\n\n```java\n    private final class MessengerImpl extends IMessenger.Stub {\n        public void send(Message msg) {\n            msg.sendingUid = Binder.getCallingUid();\n            Handler.this.sendMessage(msg);\n        }\n    }\n```\n\n而Messenger的send方法。就是调用这里的send方法。\n\n\n### 4. 总结\n\n其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n","slug":"消息机制在多进程的应用","published":1,"updated":"2017-01-07T06:56:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy2z002thws6vxmxf7ob","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"2-如何使用Messenger\"><a href=\"#2-如何使用Messenger\" class=\"headerlink\" title=\"2. 如何使用Messenger\"></a>2. 如何使用Messenger</h3><h4 id=\"2-1-Messenger-服务端\"><a href=\"#2-1-Messenger-服务端\" class=\"headerlink\" title=\"2.1 Messenger 服务端\"></a>2.1 Messenger 服务端</h4><p>首先我们需要一个messenger，并传入一个handler。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Messenger messenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> MessengerHandler());</div></pre></td></tr></table></figure>\n<p>其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> messenger.getBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个handler的handleMessage方法中，获取客户端发送的消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_CLIENT:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                Messenger client = msg.replyTo;</div><div class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">                    Message message = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_SERVER);</div><div class=\"line\">                    Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">                    bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from server\"</span>);</div><div class=\"line\">                    message.setData(bundle);</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        client.send(message);</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">                        e.printStackTrace();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在配置文件中，将这个service开启process，开启另一个进程。</p>\n<h4 id=\"2-2-客户端\"><a href=\"#2-2-客户端\" class=\"headerlink\" title=\"2.2 客户端\"></a>2.2 客户端</h4><p>想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> Handler getFromServer = <span class=\"keyword\">new</span> Handler()&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_SERVER:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Messenger getReplyMessenger = <span class=\"keyword\">new</span> Messenger(getFromServer);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> ServiceConnection connection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class=\"line\">        messenger = <span class=\"keyword\">new</span> Messenger(service);</div><div class=\"line\">        Message msg = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_CLIENT);</div><div class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">        bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from client\"</span>);</div><div class=\"line\">        msg.setData(bundle);</div><div class=\"line\">        msg.replyTo=getReplyMessenger;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            messenger.send(msg);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-简单分析\"><a href=\"#3-简单分析\" class=\"headerlink\" title=\"3. 简单分析\"></a>3. 简单分析</h3><p>之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。</p>\n<p>首先是Messenger的getBinder方法，这个方法返回一个binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">getBinder</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mTarget.asBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        msg.sendingUid = Binder.getCallingUid();</div><div class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而Messenger的send方法。就是调用这里的send方法。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>一般情况下，我们利用handler，是在单进程情况下，但是，在多进程的模型下，也有消息机制的身影。那就是Messenger。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"2-如何使用Messenger\"><a href=\"#2-如何使用Messenger\" class=\"headerlink\" title=\"2. 如何使用Messenger\"></a>2. 如何使用Messenger</h3><h4 id=\"2-1-Messenger-服务端\"><a href=\"#2-1-Messenger-服务端\" class=\"headerlink\" title=\"2.1 Messenger 服务端\"></a>2.1 Messenger 服务端</h4><p>首先我们需要一个messenger，并传入一个handler。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Messenger messenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> MessengerHandler());</div></pre></td></tr></table></figure>\n<p>其次，我们在onBind中，用Messenger的getBinder方法返回binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> messenger.getBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个handler的handleMessage方法中，获取客户端发送的消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_CLIENT:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                Messenger client = msg.replyTo;</div><div class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">                    Message message = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_SERVER);</div><div class=\"line\">                    Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">                    bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from server\"</span>);</div><div class=\"line\">                    message.setData(bundle);</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        client.send(message);</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">                        e.printStackTrace();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在配置文件中，将这个service开启process，开启另一个进程。</p>\n<h4 id=\"2-2-客户端\"><a href=\"#2-2-客户端\" class=\"headerlink\" title=\"2.2 客户端\"></a>2.2 客户端</h4><p>想要实现向服务端发送消息，只需要我们在ServiceConnection的onServiceConnected方法中，用IBinder对象，构造出一个Messenger，并用这个Messenger的send方法即可。如果我们还想服务端接收到我们的消息能返回的话，我们需要给Message设置replyTo，并且在服务端用这个对象去发送消息给客户端，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> Handler getFromServer = <span class=\"keyword\">new</span> Handler()&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (msg.what)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> Constants.MSG_FROM_SERVER:</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"handleMessage: \"</span> + msg.getData().getString(Constants.MSG_DATA,<span class=\"string\">\"\"</span>) );</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Messenger getReplyMessenger = <span class=\"keyword\">new</span> Messenger(getFromServer);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> ServiceConnection connection = <span class=\"keyword\">new</span> ServiceConnection() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class=\"line\">        messenger = <span class=\"keyword\">new</span> Messenger(service);</div><div class=\"line\">        Message msg = Message.obtain(<span class=\"keyword\">null</span>,Constants.MSG_FROM_CLIENT);</div><div class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">        bundle.putString(Constants.MSG_DATA,<span class=\"string\">\"from client\"</span>);</div><div class=\"line\">        msg.setData(bundle);</div><div class=\"line\">        msg.replyTo=getReplyMessenger;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            messenger.send(msg);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"3-简单分析\"><a href=\"#3-简单分析\" class=\"headerlink\" title=\"3. 简单分析\"></a>3. 简单分析</h3><p>之所以我们能够通过Messenger在两个进程之间通信，一是因为Messenger和Handler内部分装来binder，并且Messenger和Message都实现了Parcelable接口，下面我们来简单的看下。</p>\n<p>首先是Messenger的getBinder方法，这个方法返回一个binder对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">getBinder</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mTarget.asBinder();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，mTarget是Handler#getIMessenger返回的MessengerImpl对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">IMessenger</span>.<span class=\"title\">Stub</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        msg.sendingUid = Binder.getCallingUid();</div><div class=\"line\">        Handler.<span class=\"keyword\">this</span>.sendMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而Messenger的send方法。就是调用这里的send方法。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>其实，Messenger就是对binder的上层封装，让我们更加简单的使用。这里就不介绍AsyncChannel了，这个类是internal包下的内容，并没有对我们开放。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"记不住adb命令？试试shell吧","date":"2016-12-20T15:06:36.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1. 前言\n\n我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. push and pull file\n\n要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。\n\n```shell\n#!/bin/bash\n\nbasedir=\"pull_dir\"\n\nmkdir ${basedir}\n\ntopath=\"./${basedir}/\"\n\nif [ $# = 0 ]\nthen\n\techo 'please input fromfile'\n\texit\nfi\n\nfrompath=$1\n\nadb pull $1 ${topath}\n\n```\n\n```shell\ntopath=\"sdcard/\"\n\nif [ $# = 0 ]\nthen\n\techo \"please input file path\"\n\texit\nfi\n\nfilepath=$1\n\nif [ $# = 2 ]\nthen\n\ttopath=$2\nfi\n\nadb push ${filepath} ${topath}\n\n```\n\n### 3. dumps 一些信息\n\n有时候我们需要dump一些信息出来，比如内存，电量等等。\n\n```shell\n\nfilepath=`./custom.sh`\n\nresult=\"\"\n\nfilename=\"\"\n\nif [ $# = 0 ]\nthen\n\tfilename=\"meminfo_all\"\n\tresult=`adb shell dumpsys meminfo`\nelse\n\tfilename=\"memoinfo_pkg\"\n\tresult=`adb shell dumpsys meminfo $1`\nfi\n\n#echo \"hello\" >> \"${filepath}${filename}\"\necho \"$result\" >> \"${filepath}${filename}\"\n```\n\n```shell\nfilepath=`./custom.sh`\n\nresult=`adb shell dumpsys power`\n\nfilename=\"power_state\"\n\n```\n\n### 4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\n\n[Android测试中常用到的脚本](https://github.com/gb112211/AndroidTestScripts)\n\n### 5. 总结\n\n总之，用shell 和 python等一些脚本，能够做出很多好玩的事。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","source":"_posts/记不住adb命令？试试shell吧.md","raw":"---\ntitle: 记不住adb命令？试试shell吧\ndate: 2016-12-20 23:06:36\ncategories: shell\ntags: shell\n\n---\n<Excerpt in index | 首页摘要>\n### 1. 前言\n\n我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 2. push and pull file\n\n要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。\n\n```shell\n#!/bin/bash\n\nbasedir=\"pull_dir\"\n\nmkdir ${basedir}\n\ntopath=\"./${basedir}/\"\n\nif [ $# = 0 ]\nthen\n\techo 'please input fromfile'\n\texit\nfi\n\nfrompath=$1\n\nadb pull $1 ${topath}\n\n```\n\n```shell\ntopath=\"sdcard/\"\n\nif [ $# = 0 ]\nthen\n\techo \"please input file path\"\n\texit\nfi\n\nfilepath=$1\n\nif [ $# = 2 ]\nthen\n\ttopath=$2\nfi\n\nadb push ${filepath} ${topath}\n\n```\n\n### 3. dumps 一些信息\n\n有时候我们需要dump一些信息出来，比如内存，电量等等。\n\n```shell\n\nfilepath=`./custom.sh`\n\nresult=\"\"\n\nfilename=\"\"\n\nif [ $# = 0 ]\nthen\n\tfilename=\"meminfo_all\"\n\tresult=`adb shell dumpsys meminfo`\nelse\n\tfilename=\"memoinfo_pkg\"\n\tresult=`adb shell dumpsys meminfo $1`\nfi\n\n#echo \"hello\" >> \"${filepath}${filename}\"\necho \"$result\" >> \"${filepath}${filename}\"\n```\n\n```shell\nfilepath=`./custom.sh`\n\nresult=`adb shell dumpsys power`\n\nfilename=\"power_state\"\n\n```\n\n### 4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\n\n[Android测试中常用到的脚本](https://github.com/gb112211/AndroidTestScripts)\n\n### 5. 总结\n\n总之，用shell 和 python等一些脚本，能够做出很多好玩的事。\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n","slug":"记不住adb命令？试试shell吧","published":1,"updated":"2017-01-07T06:56:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy32002xhws6jjpd2qyb","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n<h3 id=\"2-push-and-pull-file\"><a href=\"#2-push-and-pull-file\" class=\"headerlink\" title=\"2. push and pull file\"></a>2. push and pull file</h3><p>要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">basedir=&quot;pull_dir&quot;</div><div class=\"line\"></div><div class=\"line\">mkdir $&#123;basedir&#125;</div><div class=\"line\"></div><div class=\"line\">topath=&quot;./$&#123;basedir&#125;/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &apos;please input fromfile&apos;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">frompath=$1</div><div class=\"line\"></div><div class=\"line\">adb pull $1 $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">topath=&quot;sdcard/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &quot;please input file path&quot;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">filepath=$1</div><div class=\"line\"></div><div class=\"line\">if [ $# = 2 ]</div><div class=\"line\">then</div><div class=\"line\">\ttopath=$2</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">adb push $&#123;filepath&#125; $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-dumps-一些信息\"><a href=\"#3-dumps-一些信息\" class=\"headerlink\" title=\"3. dumps 一些信息\"></a>3. dumps 一些信息</h3><p>有时候我们需要dump一些信息出来，比如内存，电量等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">filename=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\tfilename=&quot;meminfo_all&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo`</div><div class=\"line\">else</div><div class=\"line\">\tfilename=&quot;memoinfo_pkg&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo $1`</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">#echo &quot;hello&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div><div class=\"line\">echo &quot;$result&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=`adb shell dumpsys power`</div><div class=\"line\"></div><div class=\"line\">filename=&quot;power_state&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"4-可以利用python-＋-adb命令，实现自动化一些自动化测试\"><a href=\"#4-可以利用python-＋-adb命令，实现自动化一些自动化测试\" class=\"headerlink\" title=\"4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\"></a>4. 可以利用python ＋ adb命令，实现自动化一些自动化测试</h3><p><a href=\"https://github.com/gb112211/AndroidTestScripts\" target=\"_blank\" rel=\"external\">Android测试中常用到的脚本</a></p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>总之，用shell 和 python等一些脚本，能够做出很多好玩的事。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>\n\n\n\n</the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>我们日常开发中，经常会需要使用adb工具做一些操作，比如，push文件、pull文件、安装apk、dump一些信息等等，命令太长记不住怎么办？没关系，我们可以把这些东西写成shell脚本。这里我就简单举几个例子。</p>","more":"<The rest of contents | 余下全文>\n\n<h3 id=\"2-push-and-pull-file\"><a href=\"#2-push-and-pull-file\" class=\"headerlink\" title=\"2. push and pull file\"></a>2. push and pull file</h3><p>要写一些shell脚本其实也是很简单的，比如push文件、pull文件等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">basedir=&quot;pull_dir&quot;</div><div class=\"line\"></div><div class=\"line\">mkdir $&#123;basedir&#125;</div><div class=\"line\"></div><div class=\"line\">topath=&quot;./$&#123;basedir&#125;/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &apos;please input fromfile&apos;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">frompath=$1</div><div class=\"line\"></div><div class=\"line\">adb pull $1 $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">topath=&quot;sdcard/&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\techo &quot;please input file path&quot;</div><div class=\"line\">\texit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">filepath=$1</div><div class=\"line\"></div><div class=\"line\">if [ $# = 2 ]</div><div class=\"line\">then</div><div class=\"line\">\ttopath=$2</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">adb push $&#123;filepath&#125; $&#123;topath&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-dumps-一些信息\"><a href=\"#3-dumps-一些信息\" class=\"headerlink\" title=\"3. dumps 一些信息\"></a>3. dumps 一些信息</h3><p>有时候我们需要dump一些信息出来，比如内存，电量等等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">filename=&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">if [ $# = 0 ]</div><div class=\"line\">then</div><div class=\"line\">\tfilename=&quot;meminfo_all&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo`</div><div class=\"line\">else</div><div class=\"line\">\tfilename=&quot;memoinfo_pkg&quot;</div><div class=\"line\">\tresult=`adb shell dumpsys meminfo $1`</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">#echo &quot;hello&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div><div class=\"line\">echo &quot;$result&quot; &gt;&gt; &quot;$&#123;filepath&#125;$&#123;filename&#125;&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">filepath=`./custom.sh`</div><div class=\"line\"></div><div class=\"line\">result=`adb shell dumpsys power`</div><div class=\"line\"></div><div class=\"line\">filename=&quot;power_state&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"4-可以利用python-＋-adb命令，实现自动化一些自动化测试\"><a href=\"#4-可以利用python-＋-adb命令，实现自动化一些自动化测试\" class=\"headerlink\" title=\"4. 可以利用python ＋ adb命令，实现自动化一些自动化测试\"></a>4. 可以利用python ＋ adb命令，实现自动化一些自动化测试</h3><p><a href=\"https://github.com/gb112211/AndroidTestScripts\">Android测试中常用到的脚本</a></p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><p>总之，用shell 和 python等一些脚本，能够做出很多好玩的事。</p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"脚本打怪-shell篇","date":"2016-12-02T17:05:38.000Z","_content":"<Excerpt in index | 首页摘要>\n### 1.什么是shell\n\n什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.shell能干什么\n\nshell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。\n\n### 3.shell基础语法\n\n#### 3.1 变量\n```shell\n#变量名＝变量值\nmyname=\"guolei\"\necho ${myname}\n```\nshell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。\n\n如果我们想要定义一个数组怎么办？\n\n```shell\narr=(1 2 3 4)\necho $arr[0]\n```\n\n注意，元素之间没有逗号。\n\n#### 3.2 传递参数\n\n作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0... ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件\n\n\n#### 3.3 输出\n\nshell中有两种输出方式，\n\n* echo \n* printf\n\necho是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。\n\n\n\n### 4.shell运算符\n\n这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 ` `之内，如\n\n```shell\n`expr 2 + 2`\n```\n\n要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。\n\n而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算\n\n* -eq 是否相等,\n* -ne 是否不等\n* -gt 左边是否大于右边\n* -ge 左边是否大于等于右边\n* -lt 左边是否小于右边\n* -le 左边是否小于等于右边\n\n\n老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。\n\n布尔运算也是同理。\n\n* ! 非\n* -o 或\n* -a 与\n\nshell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。\n\n\n\n### 5.shell流程控制\n\nshell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。\n\n```shell\nif\nthen\n\tcommend...\nelse\n\tcommend...\nelif\n\tcommend...\nfi\n\nfor var in 1 2 3 4\ndo\n\tcommend...\ndone\n\nwhile xxx\ndo\n\tcommend...\ndone\n\n//until循环，\nuntil xxx\ndo\n\tcommend\ndone\n\n//case 比较恶心，我很不喜欢，需要用我再去学，嘿\n\nbreak，continue 什么也是有的\n```\n\n\n\n### 6.函数\n\n```shell\nsay(){\n\techo $i\n}\n\nsay 1\n```\n没错，上面就是函数的简单用法。\n\n* 我们不需要手动指定参数\n* 同样用$i 去获取参数\n* 像命令一样say 1 2 3，传递参数\n\n但是，从${10}开始，我们需要用大括号，扩起来。。\n\n### 7. 输入输出重定向\n\n略过略过，> < 将输入输出定向到其他位置（文件）\n\n### 8. 总结\n\nshell脚本学起来 编写起来都挺简单的。\n\n* \\* @，这些都表示全部，比如 $* $@,\n* \\# 哈，可以表示长度，如字符串长度，数组容量\n* 变量赋值 key=value 注意 中间不能有空格\n* 大小比较 -ge那些\n* 函数，通过$? 能获取到返回值，而不能通过赋值来获取\n* 如果参数大于10个，要用$(n)去获取\n\n不过，shell最好的一点是批命令处理。\n\n### 9. 举个小例子？\n\n```shell\ngit pull\n\ngit add ./\n\ngit commit -m \"xxx\"\n\ngit push\n```\n\n很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？\n\n```shell\ncms=\"update\"\n\nhexo g\n\ngit add ./\n\nif [ $# -ge 1 ]\nthen\n\tcms=$1\nfi\n\ngit commit -m $cms\n\ngit push\n\n```\n\n这不，我们通过shell 脚本，每次./update.sh ,多方便啊。\n\n### 10. 想法\n\n想什么呢？还不赶紧去get shell脚本这个技巧。\n\n不写脚本释放双手的程序员，不是好程序员。\n\n\n### 11. 入门链接\n\n[入门教程，看了还不会就可以转行了](http://www.runoob.com/linux/linux-shell.html)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/脚本打怪-shell篇.md","raw":"---\ntitle: 脚本打怪-shell篇\ndate: 2016-12-03 01:05:38\ncategories: shell\ntags: shell\n\n---\n<Excerpt in index | 首页摘要>\n### 1.什么是shell\n\n什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n### 2.shell能干什么\n\nshell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。\n\n### 3.shell基础语法\n\n#### 3.1 变量\n```shell\n#变量名＝变量值\nmyname=\"guolei\"\necho ${myname}\n```\nshell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。\n\n如果我们想要定义一个数组怎么办？\n\n```shell\narr=(1 2 3 4)\necho $arr[0]\n```\n\n注意，元素之间没有逗号。\n\n#### 3.2 传递参数\n\n作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0... ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件\n\n\n#### 3.3 输出\n\nshell中有两种输出方式，\n\n* echo \n* printf\n\necho是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。\n\n\n\n### 4.shell运算符\n\n这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 ` `之内，如\n\n```shell\n`expr 2 + 2`\n```\n\n要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。\n\n而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算\n\n* -eq 是否相等,\n* -ne 是否不等\n* -gt 左边是否大于右边\n* -ge 左边是否大于等于右边\n* -lt 左边是否小于右边\n* -le 左边是否小于等于右边\n\n\n老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。\n\n布尔运算也是同理。\n\n* ! 非\n* -o 或\n* -a 与\n\nshell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。\n\n\n\n### 5.shell流程控制\n\nshell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。\n\n```shell\nif\nthen\n\tcommend...\nelse\n\tcommend...\nelif\n\tcommend...\nfi\n\nfor var in 1 2 3 4\ndo\n\tcommend...\ndone\n\nwhile xxx\ndo\n\tcommend...\ndone\n\n//until循环，\nuntil xxx\ndo\n\tcommend\ndone\n\n//case 比较恶心，我很不喜欢，需要用我再去学，嘿\n\nbreak，continue 什么也是有的\n```\n\n\n\n### 6.函数\n\n```shell\nsay(){\n\techo $i\n}\n\nsay 1\n```\n没错，上面就是函数的简单用法。\n\n* 我们不需要手动指定参数\n* 同样用$i 去获取参数\n* 像命令一样say 1 2 3，传递参数\n\n但是，从${10}开始，我们需要用大括号，扩起来。。\n\n### 7. 输入输出重定向\n\n略过略过，> < 将输入输出定向到其他位置（文件）\n\n### 8. 总结\n\nshell脚本学起来 编写起来都挺简单的。\n\n* \\* @，这些都表示全部，比如 $* $@,\n* \\# 哈，可以表示长度，如字符串长度，数组容量\n* 变量赋值 key=value 注意 中间不能有空格\n* 大小比较 -ge那些\n* 函数，通过$? 能获取到返回值，而不能通过赋值来获取\n* 如果参数大于10个，要用$(n)去获取\n\n不过，shell最好的一点是批命令处理。\n\n### 9. 举个小例子？\n\n```shell\ngit pull\n\ngit add ./\n\ngit commit -m \"xxx\"\n\ngit push\n```\n\n很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？\n\n```shell\ncms=\"update\"\n\nhexo g\n\ngit add ./\n\nif [ $# -ge 1 ]\nthen\n\tcms=$1\nfi\n\ngit commit -m $cms\n\ngit push\n\n```\n\n这不，我们通过shell 脚本，每次./update.sh ,多方便啊。\n\n### 10. 想法\n\n想什么呢？还不赶紧去get shell脚本这个技巧。\n\n不写脚本释放双手的程序员，不是好程序员。\n\n\n### 11. 入门链接\n\n[入门教程，看了还不会就可以转行了](http://www.runoob.com/linux/linux-shell.html)\n\n\n---\r\r### 最近访客\r\r<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"脚本打怪-shell篇","published":1,"updated":"2017-01-07T06:56:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy330030hws69227guug","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"1-什么是shell\"><a href=\"#1-什么是shell\" class=\"headerlink\" title=\"1.什么是shell\"></a>1.什么是shell</h3><p>什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"2-shell能干什么\"><a href=\"#2-shell能干什么\" class=\"headerlink\" title=\"2.shell能干什么\"></a>2.shell能干什么</h3><p>shell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。</p>\n<h3 id=\"3-shell基础语法\"><a href=\"#3-shell基础语法\" class=\"headerlink\" title=\"3.shell基础语法\"></a>3.shell基础语法</h3><h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#变量名＝变量值</div><div class=\"line\">myname=&quot;guolei&quot;</div><div class=\"line\">echo $&#123;myname&#125;</div></pre></td></tr></table></figure>\n<p>shell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。</p>\n<p>如果我们想要定义一个数组怎么办？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr=(1 2 3 4)</div><div class=\"line\">echo $arr[0]</div></pre></td></tr></table></figure>\n<p>注意，元素之间没有逗号。</p>\n<h4 id=\"3-2-传递参数\"><a href=\"#3-2-传递参数\" class=\"headerlink\" title=\"3.2 传递参数\"></a>3.2 传递参数</h4><p>作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0… ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件</p>\n<h4 id=\"3-3-输出\"><a href=\"#3-3-输出\" class=\"headerlink\" title=\"3.3 输出\"></a>3.3 输出</h4><p>shell中有两种输出方式，</p>\n<ul>\n<li>echo </li>\n<li>printf</li>\n</ul>\n<p>echo是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。</p>\n<h3 id=\"4-shell运算符\"><a href=\"#4-shell运算符\" class=\"headerlink\" title=\"4.shell运算符\"></a>4.shell运算符</h3><p>这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 <code> </code>之内，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">`expr 2 + 2`</div></pre></td></tr></table></figure>\n<p>要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。</p>\n<p>而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算</p>\n<ul>\n<li>-eq 是否相等,</li>\n<li>-ne 是否不等</li>\n<li>-gt 左边是否大于右边</li>\n<li>-ge 左边是否大于等于右边</li>\n<li>-lt 左边是否小于右边</li>\n<li>-le 左边是否小于等于右边</li>\n</ul>\n<p>老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。</p>\n<p>布尔运算也是同理。</p>\n<ul>\n<li>! 非</li>\n<li>-o 或</li>\n<li>-a 与</li>\n</ul>\n<p>shell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。</p>\n<h3 id=\"5-shell流程控制\"><a href=\"#5-shell流程控制\" class=\"headerlink\" title=\"5.shell流程控制\"></a>5.shell流程控制</h3><p>shell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">if</div><div class=\"line\">then</div><div class=\"line\">\tcommend...</div><div class=\"line\">else</div><div class=\"line\">\tcommend...</div><div class=\"line\">elif</div><div class=\"line\">\tcommend...</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">for var in 1 2 3 4</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">while xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//until循环，</div><div class=\"line\">until xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//case 比较恶心，我很不喜欢，需要用我再去学，嘿</div><div class=\"line\"></div><div class=\"line\">break，continue 什么也是有的</div></pre></td></tr></table></figure>\n<h3 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6.函数\"></a>6.函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">say()&#123;</div><div class=\"line\">\techo $i</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">say 1</div></pre></td></tr></table></figure>\n<p>没错，上面就是函数的简单用法。</p>\n<ul>\n<li>我们不需要手动指定参数</li>\n<li>同样用$i 去获取参数</li>\n<li>像命令一样say 1 2 3，传递参数</li>\n</ul>\n<p>但是，从${10}开始，我们需要用大括号，扩起来。。</p>\n<h3 id=\"7-输入输出重定向\"><a href=\"#7-输入输出重定向\" class=\"headerlink\" title=\"7. 输入输出重定向\"></a>7. 输入输出重定向</h3><p>略过略过，&gt; &lt; 将输入输出定向到其他位置（文件）</p>\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h3><p>shell脚本学起来 编写起来都挺简单的。</p>\n<ul>\n<li>* @，这些都表示全部，比如 $* $@,</li>\n<li># 哈，可以表示长度，如字符串长度，数组容量</li>\n<li>变量赋值 key=value 注意 中间不能有空格</li>\n<li>大小比较 -ge那些</li>\n<li>函数，通过$? 能获取到返回值，而不能通过赋值来获取</li>\n<li>如果参数大于10个，要用$(n)去获取</li>\n</ul>\n<p>不过，shell最好的一点是批命令处理。</p>\n<h3 id=\"9-举个小例子？\"><a href=\"#9-举个小例子？\" class=\"headerlink\" title=\"9. 举个小例子？\"></a>9. 举个小例子？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">git commit -m &quot;xxx&quot;</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cms=&quot;update&quot;</div><div class=\"line\"></div><div class=\"line\">hexo g</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">if [ $# -ge 1 ]</div><div class=\"line\">then</div><div class=\"line\">\tcms=$1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">git commit -m $cms</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>这不，我们通过shell 脚本，每次./update.sh ,多方便啊。</p>\n<h3 id=\"10-想法\"><a href=\"#10-想法\" class=\"headerlink\" title=\"10. 想法\"></a>10. 想法</h3><p>想什么呢？还不赶紧去get shell脚本这个技巧。</p>\n<p>不写脚本释放双手的程序员，不是好程序员。</p>\n<h3 id=\"11-入门链接\"><a href=\"#11-入门链接\" class=\"headerlink\" title=\"11. 入门链接\"></a>11. 入门链接</h3><p><a href=\"http://www.runoob.com/linux/linux-shell.html\" target=\"_blank\" rel=\"external\">入门教程，看了还不会就可以转行了</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"1-什么是shell\"><a href=\"#1-什么是shell\" class=\"headerlink\" title=\"1.什么是shell\"></a>1.什么是shell</h3><p>什么是shell呢？我们这里说的shell是指shell脚本，和window下的bat批命令处理类似，shell用于linux／unix系统，用来方便我们的操作，试想一下，原来需要一堆的命令，我们将其写成一个shell脚本，轻松搞定，是不是很带感。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"2-shell能干什么\"><a href=\"#2-shell能干什么\" class=\"headerlink\" title=\"2.shell能干什么\"></a>2.shell能干什么</h3><p>shell能干什么？shell能干的就是简化我们的操作，将我们从繁琐、单一的操作中解放出来。</p>\n<h3 id=\"3-shell基础语法\"><a href=\"#3-shell基础语法\" class=\"headerlink\" title=\"3.shell基础语法\"></a>3.shell基础语法</h3><h4 id=\"3-1-变量\"><a href=\"#3-1-变量\" class=\"headerlink\" title=\"3.1 变量\"></a>3.1 变量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#变量名＝变量值</div><div class=\"line\">myname=&quot;guolei&quot;</div><div class=\"line\">echo $&#123;myname&#125;</div></pre></td></tr></table></figure>\n<p>shell的变量很有意识，和我们其他语言不通的一点，等号两边不能有空格，奇怪吧。如果我们想要使用这个变量，我们可以在变量名前＋$，大括号是用来区分界限的。</p>\n<p>如果我们想要定义一个数组怎么办？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr=(1 2 3 4)</div><div class=\"line\">echo $arr[0]</div></pre></td></tr></table></figure>\n<p>注意，元素之间没有逗号。</p>\n<h4 id=\"3-2-传递参数\"><a href=\"#3-2-传递参数\" class=\"headerlink\" title=\"3.2 传递参数\"></a>3.2 传递参数</h4><p>作为一个脚本，当然需要接受接受我们终端输入参数，我们通过 $i的形式去获取参数，i＝0… ，需要注意的是，i为1时才是我们输入的第一个参数，因为$0代表的是我们当前的执行脚本文件</p>\n<h4 id=\"3-3-输出\"><a href=\"#3-3-输出\" class=\"headerlink\" title=\"3.3 输出\"></a>3.3 输出</h4><p>shell中有两种输出方式，</p>\n<ul>\n<li>echo </li>\n<li>printf</li>\n</ul>\n<p>echo是一种普通的输出，而printf是一种格式化的输出，这里就不在多说了，这里和其他的语言并没有太大的区别。</p>\n<h3 id=\"4-shell运算符\"><a href=\"#4-shell运算符\" class=\"headerlink\" title=\"4.shell运算符\"></a>4.shell运算符</h3><p>这里和我们平常见到的语言是不一样的，原声的bash（一种shell解释器）是不支持简单的数学运算的。我们通常通过awk 和 expr，expr等来实现，我们将表达式放在 <code> </code>之内，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">`expr 2 + 2`</div></pre></td></tr></table></figure>\n<p>要注意，*，我们需要用\\来进行转移，因为他和某个东西冲突，我们后面会提到。</p>\n<p>而关系运算符这就大不相同了，因为和命令或者是其他什么冲突的原因，shell脚本中采用下面这种方式来实现关系运算</p>\n<ul>\n<li>-eq 是否相等,</li>\n<li>-ne 是否不等</li>\n<li>-gt 左边是否大于右边</li>\n<li>-ge 左边是否大于等于右边</li>\n<li>-lt 左边是否小于右边</li>\n<li>-le 左边是否小于等于右边</li>\n</ul>\n<p>老司机们一定发现规律么，没错，就是-+英文缩写,这里就不多叨叨了。</p>\n<p>布尔运算也是同理。</p>\n<ul>\n<li>! 非</li>\n<li>-o 或</li>\n<li>-a 与</li>\n</ul>\n<p>shell中还有字符串运算符,文件测试运算符什么的，这里就不多说了。</p>\n<h3 id=\"5-shell流程控制\"><a href=\"#5-shell流程控制\" class=\"headerlink\" title=\"5.shell流程控制\"></a>5.shell流程控制</h3><p>shell脚本的流程控制和其他如python、php还是有一点区别滴，最明显的区别就是 要有结束标志，对，结束表示，这是啥类，看语法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">if</div><div class=\"line\">then</div><div class=\"line\">\tcommend...</div><div class=\"line\">else</div><div class=\"line\">\tcommend...</div><div class=\"line\">elif</div><div class=\"line\">\tcommend...</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">for var in 1 2 3 4</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">while xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend...</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//until循环，</div><div class=\"line\">until xxx</div><div class=\"line\">do</div><div class=\"line\">\tcommend</div><div class=\"line\">done</div><div class=\"line\"></div><div class=\"line\">//case 比较恶心，我很不喜欢，需要用我再去学，嘿</div><div class=\"line\"></div><div class=\"line\">break，continue 什么也是有的</div></pre></td></tr></table></figure>\n<h3 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6.函数\"></a>6.函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">say()&#123;</div><div class=\"line\">\techo $i</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">say 1</div></pre></td></tr></table></figure>\n<p>没错，上面就是函数的简单用法。</p>\n<ul>\n<li>我们不需要手动指定参数</li>\n<li>同样用$i 去获取参数</li>\n<li>像命令一样say 1 2 3，传递参数</li>\n</ul>\n<p>但是，从${10}开始，我们需要用大括号，扩起来。。</p>\n<h3 id=\"7-输入输出重定向\"><a href=\"#7-输入输出重定向\" class=\"headerlink\" title=\"7. 输入输出重定向\"></a>7. 输入输出重定向</h3><p>略过略过，&gt; &lt; 将输入输出定向到其他位置（文件）</p>\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h3><p>shell脚本学起来 编写起来都挺简单的。</p>\n<ul>\n<li>* @，这些都表示全部，比如 $* $@,</li>\n<li># 哈，可以表示长度，如字符串长度，数组容量</li>\n<li>变量赋值 key=value 注意 中间不能有空格</li>\n<li>大小比较 -ge那些</li>\n<li>函数，通过$? 能获取到返回值，而不能通过赋值来获取</li>\n<li>如果参数大于10个，要用$(n)去获取</li>\n</ul>\n<p>不过，shell最好的一点是批命令处理。</p>\n<h3 id=\"9-举个小例子？\"><a href=\"#9-举个小例子？\" class=\"headerlink\" title=\"9. 举个小例子？\"></a>9. 举个小例子？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">git commit -m &quot;xxx&quot;</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>很常见吧，加入我们把上面的写成shell脚本，是不是会简单很多？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cms=&quot;update&quot;</div><div class=\"line\"></div><div class=\"line\">hexo g</div><div class=\"line\"></div><div class=\"line\">git add ./</div><div class=\"line\"></div><div class=\"line\">if [ $# -ge 1 ]</div><div class=\"line\">then</div><div class=\"line\">\tcms=$1</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">git commit -m $cms</div><div class=\"line\"></div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>这不，我们通过shell 脚本，每次./update.sh ,多方便啊。</p>\n<h3 id=\"10-想法\"><a href=\"#10-想法\" class=\"headerlink\" title=\"10. 想法\"></a>10. 想法</h3><p>想什么呢？还不赶紧去get shell脚本这个技巧。</p>\n<p>不写脚本释放双手的程序员，不是好程序员。</p>\n<h3 id=\"11-入门链接\"><a href=\"#11-入门链接\" class=\"headerlink\" title=\"11. 入门链接\"></a>11. 入门链接</h3><p><a href=\"http://www.runoob.com/linux/linux-shell.html\">入门教程，看了还不会就可以转行了</a></p>\n<hr>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"},{"title":"系统资源的预加载过程","date":"2017-01-09T04:29:31.000Z","_content":"<Excerpt in index | 首页摘要>\n### 前言\n\n在Zygote进程那篇文章中，提到过，在初始化的时候会预加载系统资源，这样，应用进程在fork了之后，不需要通过加载过程，就可以直接使用这些资源，那么，今天就来看下，这个过程是怎么样的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n \n\n### ZygoteInit#preloadResources\n\n```\n    private static void preloadResources() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        try {\n            mResources = Resources.getSystem();\n            mResources.startPreloading();\n            if (PRELOAD_RESOURCES) {\n                Log.i(TAG, \"Preloading resources...\");\n\n                long startTime = SystemClock.uptimeMillis();\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);\n                int N = preloadDrawables(runtime, ar);\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");\n\n                startTime = SystemClock.uptimeMillis();\n                ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_color_state_lists);\n                N = preloadColorStateLists(runtime, ar);\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");\n            }\n            mResources.finishPreloading();\n        } catch (RuntimeException e) {\n            Log.w(TAG, \"Failure preloading resources\", e);\n        }\n    }\n```\n\n上面的过程分为三步\n\n* 得到Resources对象\n* 得到TypedArray对象\n* preloadDrawables，preloadColorStateLists 加载资源\n\n现在，按照上面的三部分来学习下。\n\n### Resources#getSystem\n\nResources代码资源，提供了许多方法让我们获取，这里获取的是经过映射的资源，resources.arsc。\n\n```\n    public static Resources getSystem() {\n        synchronized (sSync) {\n            Resources ret = mSystem;\n            if (ret == null) {\n                ret = new Resources();\n                mSystem = ret;\n            }\n\n            return ret;\n        }\n    }\n```\n\n在这里初始化了一个Resources对象，并且赋值给mSystem变量，那么我们现在看下Resources的构造方法。\n\n```\n    private Resources() {\n        mAssets = AssetManager.getSystem();\n        // NOTE: Intentionally leaving this uninitialized (all values set\n        // to zero), so that anyone who tries to do something that requires\n        // metrics will get a very wrong value.\n        mConfiguration.setToDefaults();\n        mMetrics.setToDefaults();\n        updateConfiguration(null, null);\n        mAssets.ensureStringBlocks();\n    }\n```\n\n在初始化方法中，通过AssetManager.getSystem获取一个AssetManager对象，这个是用来访问原始资源的(assets目录)。并且，将Configuration和DisplayMetrics都设置默认，更新配置，初始化StringBlocks。那么，我们来看下AssetManager.getSystem。这个方法中调用ensureSystemAssets，ensureSystemAssets代码如下：\n\n```\n    private static void ensureSystemAssets() {\n        synchronized (sSync) {\n            if (sSystem == null) {\n                AssetManager system = new AssetManager(true);\n                system.makeStringBlocks(null);\n                sSystem = system;\n            }\n        }\n    }\n\n```\n\n可以看到，这里初始化了一个AssetManager，好吧，接着看AssetManager的构造函数。\n\n```\n    private AssetManager(boolean isSystem) {\n        if (DEBUG_REFS) {\n            synchronized (this) {\n                mNumRefs = 0;\n                incRefsLocked(this.hashCode());\n            }\n        }\n        init(true);\n        if (localLOGV) Log.v(TAG, \"New asset manager: \" + this);\n    }\n```\n\n这里调用init去初始化，这是个native函数，实现在android_util_AssetManager.cpp中，对应的方法为android_content_AssetManager_init\n\n#### android_content_AssetManager_init\n\n```\nstatic void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)\n{\n    if (isSystem) {\n        verifySystemIdmaps();\n    }\n    AssetManager* am = new AssetManager();\n    if (am == NULL) {\n        jniThrowException(env, \"java/lang/OutOfMemoryError\", \"\");\n        return;\n    }\n\n    am->addDefaultAssets();\n\n    ALOGV(\"Created AssetManager %p for Java object %p\\n\", am, clazz);\n    env->SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast<jlong>(am));\n}\n```\n\n从代码中来看，分为四步\n\n* 验证idmaps\n* 生成c++的AssetManager对象\n* 添加默认的assets\n* 设置java层AssetManager的mObject为c++的AssetManager地址。\n\n我们看添加默认的assets那一步。\n\n```\nbool AssetManager::addDefaultAssets()\n{\n    const char* root = getenv(\"ANDROID_ROOT\");\n    LOG_ALWAYS_FATAL_IF(root == NULL, \"ANDROID_ROOT not set\");\n\n    String8 path(root);\n    path.appendPath(kSystemAssets);\n\n    return addAssetPath(path, NULL);\n}\n```\n\n* ANDROID_ROOT为system\n* static const char* kSystemAssets = \"framework/framework-res.apk\";\n\n然后调用addAssetPath两个参数的方法，将framework-res.apk加进去。\n\n```\nbool AssetManager::addAssetPath(const String8& path, int32_t* cookie)\n{\n    AutoMutex _l(mLock);\n\n    asset_path ap;\n\n    String8 realPath(path);\n    if (kAppZipName) {\n        realPath.appendPath(kAppZipName);\n    }\n    ap.type = ::getFileType(realPath.string());\n    if (ap.type == kFileTypeRegular) {\n        ap.path = realPath;\n    } else {\n        ap.path = path;\n        ap.type = ::getFileType(path.string());\n        if (ap.type != kFileTypeDirectory && ap.type != kFileTypeRegular) {\n            ALOGW(\"Asset path %s is neither a directory nor file (type=%d).\",\n                 path.string(), (int)ap.type);\n            return false;\n        }\n    }\n\n    // Skip if we have it already.\n    for (size_t i=0; i<mAssetPaths.size(); i++) {\n        if (mAssetPaths[i].path == ap.path) {\n            if (cookie) {\n                *cookie = static_cast<int32_t>(i+1);\n            }\n            return true;\n        }\n    }\n\n    ALOGV(\"In %p Asset %s path: %s\", this,\n         ap.type == kFileTypeDirectory ? \"dir\" : \"zip\", ap.path.string());\n\n    // Check that the path has an AndroidManifest.xml\n    Asset* manifestAsset = const_cast<AssetManager*>(this)->openNonAssetInPathLocked(\n            kAndroidManifest, Asset::ACCESS_BUFFER, ap);\n    if (manifestAsset == NULL) {\n        // This asset path does not contain any resources.\n        delete manifestAsset;\n        return false;\n    }\n    delete manifestAsset;\n\n    mAssetPaths.add(ap);\n\n    // new paths are always added at the end\n    if (cookie) {\n        *cookie = static_cast<int32_t>(mAssetPaths.size());\n    }\n\n#ifdef HAVE_ANDROID_OS\n    // Load overlays, if any\n    asset_path oap;\n    for (size_t idx = 0; mZipSet.getOverlay(ap.path, idx, &oap); idx++) {\n        mAssetPaths.add(oap);\n    }\n#endif\n\n    if (mResources != NULL) {\n        appendPathToResTable(ap);\n    }\n\n    return true;\n}\n```\n\n* asset_path结构体存储文件路径、文件类型等，结构体定义如下\n\n\t```\n    struct asset_path\n    {\n        asset_path() : path(\"\"), type(kFileTypeRegular), idmap(\"\"), isSystemOverlay(false) {}\n        String8 path;\n        FileType type;\n        String8 idmap;\n        bool isSystemOverlay;\n    };\n```\n* kAppZipName一般为null，static const char* kAppZipName = NULL; //\"classes.jar\";\n* 如果已经在mAssetPaths，就反悔\n* 如果路径下没有AndroidManifest.xml文件，返回false\n* 添加到mAssetPaths中\n* appendPathToResTable将资源进行解析添加\n\n#### AssetManager::appendPathToResTable\n\n```\nbool AssetManager::appendPathToResTable(const asset_path& ap) const {\n    // skip those ap's that correspond to system overlays\n    if (ap.isSystemOverlay) {\n        return true;\n    }\n\n    Asset* ass = NULL;\n    ResTable* sharedRes = NULL;\n    bool shared = true;\n    bool onlyEmptyResources = true;\n    MY_TRACE_BEGIN(ap.path.string());\n    Asset* idmap = openIdmapLocked(ap);\n    size_t nextEntryIdx = mResources->getTableCount();\n    ALOGV(\"Looking for resource asset in '%s'\\n\", ap.path.string());\n    if (ap.type != kFileTypeDirectory) {\n        if (nextEntryIdx == 0) {\n            // The first item is typically the framework resources,\n            // which we want to avoid parsing every time.\n            sharedRes = const_cast<AssetManager*>(this)->\n                mZipSet.getZipResourceTable(ap.path);\n            if (sharedRes != NULL) {\n                // skip ahead the number of system overlay packages preloaded\n                nextEntryIdx = sharedRes->getTableCount();\n            }\n        }\n        if (sharedRes == NULL) {\n            ass = const_cast<AssetManager*>(this)->\n                mZipSet.getZipResourceTableAsset(ap.path);\n            if (ass == NULL) {\n                ALOGV(\"loading resource table %s\\n\", ap.path.string());\n                ass = const_cast<AssetManager*>(this)->\n                    openNonAssetInPathLocked(\"resources.arsc\",\n                                             Asset::ACCESS_BUFFER,\n                                             ap);\n                if (ass != NULL && ass != kExcludedAsset) {\n                    ass = const_cast<AssetManager*>(this)->\n                        mZipSet.setZipResourceTableAsset(ap.path, ass);\n                }\n            }\n            \n            if (nextEntryIdx == 0 && ass != NULL) {\n                // If this is the first resource table in the asset\n                // manager, then we are going to cache it so that we\n                // can quickly copy it out for others.\n                ALOGV(\"Creating shared resources for %s\", ap.path.string());\n                sharedRes = new ResTable();\n                sharedRes->add(ass, idmap, nextEntryIdx + 1, false);\n#ifdef HAVE_ANDROID_OS\n                const char* data = getenv(\"ANDROID_DATA\");\n                LOG_ALWAYS_FATAL_IF(data == NULL, \"ANDROID_DATA not set\");\n                String8 overlaysListPath(data);\n                overlaysListPath.appendPath(kResourceCache);\n                overlaysListPath.appendPath(\"overlays.list\");\n                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);\n#endif\n                sharedRes = const_cast<AssetManager*>(this)->\n                    mZipSet.setZipResourceTable(ap.path, sharedRes);\n            }\n        }\n    } else {\n        ALOGV(\"loading resource table %s\\n\", ap.path.string());\n        ass = const_cast<AssetManager*>(this)->\n            openNonAssetInPathLocked(\"resources.arsc\",\n                                     Asset::ACCESS_BUFFER,\n                                     ap);\n        shared = false;\n    }\n\n    if ((ass != NULL || sharedRes != NULL) && ass != kExcludedAsset) {\n        ALOGV(\"Installing resource asset %p in to table %p\\n\", ass, mResources);\n        if (sharedRes != NULL) {\n            ALOGV(\"Copying existing resources for %s\", ap.path.string());\n            mResources->add(sharedRes);\n        } else {\n            ALOGV(\"Parsing resources for %s\", ap.path.string());\n            mResources->add(ass, idmap, nextEntryIdx + 1, !shared);\n        }\n        onlyEmptyResources = false;\n\n        if (!shared) {\n            delete ass;\n        }\n    } else {\n        ALOGV(\"Installing empty resources in to table %p\\n\", mResources);\n        mResources->addEmpty(nextEntryIdx + 1);\n    }\n\n    if (idmap != NULL) {\n        delete idmap;\n    }\n    MY_TRACE_END();\n\n    return onlyEmptyResources;\n}\n```\n\n* 通过openIdmapLocked解析资源包中的idmap表\n* ap.type != kFileTypeDirectory，不是目录，就是资源包，如果nextEntryIdx为0，则为framework.apk资源包，解析并保存在sharedRes中，这个是共享的资源。\n* sharedRes == NULL 表示为应用资源包，这解析保存在ass中，\n* nextEntryIdx == 0 && ass != NULL，在zygote进程第一次调用才成立，也就是预加载资源，这个时候把framework.apk的资源索引表创建起来，并添加到mZipSet中\n* 如果是目录，就创建resources.arsc的asset对象，这个不是共享的。\n* 如果存在sharedRes，就保存到mResources中，否则，这是应用的资源，则把应用的资源加入到mResources中。\n\n上面的比较乱，总结一下。简单来说就是这样的，就是对资源包进行解析，并加入到mResources中，如果是framework.apk，就是共享的，否则就是应用的资源包，不共享。\n\n### TypedArray\n\n```\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);\n```\nmResources.obtainTypedArray的代码如下：\n\n```\n    public TypedArray obtainTypedArray(@ArrayRes int id)\n            throws NotFoundException {\n        int len = mAssets.getArraySize(id);\n        if (len < 0) {\n            throw new NotFoundException(\"Array resource ID #0x\"\n                                        + Integer.toHexString(id));\n        }\n        \n        TypedArray array = TypedArray.obtain(this, len);\n        array.mLength = mAssets.retrieveArray(id, array.mData);\n        array.mIndices[0] = 0;\n        \n        return array;\n    }\n```\n\n* 先获取id对应的数组长度\n* 然后根据长度生成TypedArray\n* 最后mAssets.retrieveArray赋值，将资源对应的id写入到java层array.mData中。写入部分代码如下\n\n\t```\n\t    dest[STYLE_TYPE] = value.dataType;\n        dest[STYLE_DATA] = value.data;\n        dest[STYLE_ASSET_COOKIE] = block != kXmlBlock ?\n            static_cast<jint>(res.getTableCookie(block)) : -1;\n        dest[STYLE_RESOURCE_ID] = resid;\n        dest[STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;\n        dest[STYLE_DENSITY] = config.density;\n```\n\n\n\n\n#### getArraySize获取资源id对应的数组长度\n\n这是个native方法，对应的实现在android_util_AssetManager.cpp的android_content_AssetManager_getArraySize方法中，代码如下：\n\n```\nstatic jint android_content_AssetManager_getArraySize(JNIEnv* env, jobject clazz,\n                                                       jint id)\n{\n    AssetManager* am = assetManagerForJavaObject(env, clazz);\n    if (am == NULL) {\n        return 0;\n    }\n    const ResTable& res(am->getResources());\n\n    res.lock();\n    const ResTable::bag_entry* defStyleEnt = NULL;\n    ssize_t bagOff = res.getBagLocked(id, &defStyleEnt);\n    res.unlock();\n\n    return static_cast<jint>(bagOff);\n}\n```\n\n* 首先将java对象转换为对应的c++对象，上面有说到过，AssetManager中的mobject字段存的是对应c++中，AssetManager对象的地址，因此，我们很容易做到转换\n* 通过ResTable的getBagLocked方法获取id，对应的数组长度(该方法的实现在ResourceTypes.cpp中)，实现太长，看不懂，略过。\n\n### preloadDrawables来说明资源的预加载过程\n\n```\n    private static int preloadDrawables(VMRuntime runtime, TypedArray ar) {\n        int N = ar.length();\n        for (int i=0; i<N; i++) {\n            int id = ar.getResourceId(i, 0);\n            if (false) {\n                Log.v(TAG, \"Preloading resource #\" + Integer.toHexString(id));\n            }\n            if (id != 0) {\n                if (mResources.getDrawable(id, null) == null) {\n                    throw new IllegalArgumentException(\n                            \"Unable to find preloaded drawable resource #0x\"\n                            + Integer.toHexString(id)\n                            + \" (\" + ar.getString(i) + \")\");\n                }\n            }\n        }\n        return N;\n    }\n```\n\n* 首先通过getResourceId获取资源id\n* getDrawable获取资源\n\n#### getResourceId 获取资源id\n\n```\n    public int getResourceId(int index, int defValue) {\n        if (mRecycled) {\n            throw new RuntimeException(\"Cannot make calls to a recycled instance!\");\n        }\n\n        index *= AssetManager.STYLE_NUM_ENTRIES;\n        final int[] data = mData;\n        if (data[index+AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {\n            final int resid = data[index+AssetManager.STYLE_RESOURCE_ID];\n            if (resid != 0) {\n                return resid;\n            }\n        }\n        return defValue;\n    }\n```\n\n* 其中STYLE_NUM_ENTRIES为6，\n* 从赋值id的代码中，知道第四个为id值，因此STYLE_RESOURCE_ID为3\n\n\n\n#### getDrawable\n\n```\n    public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme) throws NotFoundException {\n        TypedValue value;\n        synchronized (mAccessLock) {\n            value = mTmpValue;\n            if (value == null) {\n                value = new TypedValue();\n            } else {\n                mTmpValue = null;\n            }\n            getValue(id, value, true);\n        }\n        final Drawable res = loadDrawable(value, id, theme);\n        synchronized (mAccessLock) {\n            if (mTmpValue == null) {\n                mTmpValue = value;\n            }\n        }\n        return res;\n    }\n```\n\n* getValue查找与id对应的资源，没找到对应的就抛出NotFoundException异常\n* loadDrawable 去加载\n\n在getValue中，会调用AssetManager的getResourceValue方法，这个是native方法，实现在android_uitl_AssetManager.cpp的android_content_AssetManager_loadResourceValue中\n\n##### android_content_AssetManager_loadResourceValue\n\n```\nstatic jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,\n                                                           jint ident,\n                                                           jshort density,\n                                                           jobject outValue,\n                                                           jboolean resolve)\n{\n    if (outValue == NULL) {\n         jniThrowNullPointerException(env, \"outValue\");\n         return 0;\n    }\n    AssetManager* am = assetManagerForJavaObject(env, clazz);\n    if (am == NULL) {\n        return 0;\n    }\n    const ResTable& res(am->getResources());\n\n    Res_value value;\n    ResTable_config config;\n    uint32_t typeSpecFlags;\n    ssize_t block = res.getResource(ident, &value, false, density, &typeSpecFlags, &config);\n    if (kThrowOnBadId) {\n        if (block == BAD_INDEX) {\n            jniThrowException(env, \"java/lang/IllegalStateException\", \"Bad resource!\");\n            return 0;\n        }\n    }\n    uint32_t ref = ident;\n    if (resolve) {\n        block = res.resolveReference(&value, block, &ref, &typeSpecFlags, &config);\n        if (kThrowOnBadId) {\n            if (block == BAD_INDEX) {\n                jniThrowException(env, \"java/lang/IllegalStateException\", \"Bad resource!\");\n                return 0;\n            }\n        }\n    }\n    if (block >= 0) {\n        return copyValue(env, outValue, &res, value, ref, block, typeSpecFlags, &config);\n    }\n\n    return static_cast<jint>(block);\n}\n```\n\n* 得到ResTable对象\n* resolveReference查找是否有匹配的资源\n* 如果有，就将数据复制给copyValue这个java层对象\n\n具体的代码就不往下追了。\n\n##### loadDrawable\n\n经过上面的步骤，资源的信息就保存在了TypedValue中，解析来就是通过loadDrawable去加载了。\n\n```\n    Drawable loadDrawable(TypedValue value, int id, Theme theme) throws NotFoundException {\n        if (TRACE_FOR_PRELOAD) {\n            // Log only framework resources\n            if ((id >>> 24) == 0x1) {\n                final String name = getResourceName(id);\n                if (name != null) {\n                    Log.d(\"PreloadDrawable\", name);\n                }\n            }\n        }\n\n        final boolean isColorDrawable;\n        final DrawableCache caches;\n        final long key;\n        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT\n                && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {\n            isColorDrawable = true;\n            caches = mColorDrawableCache;\n            key = value.data;\n        } else {\n            isColorDrawable = false;\n            caches = mDrawableCache;\n            key = (((long) value.assetCookie) << 32) | value.data;\n        }\n\n        // First, check whether we have a cached version of this drawable\n        // that was inflated against the specified theme.\n        if (!mPreloading) {\n            final Drawable cachedDrawable = caches.getInstance(key, theme);\n            if (cachedDrawable != null) {\n                return cachedDrawable;\n            }\n        }\n\n        // Next, check preloaded drawables. These may contain unresolved theme\n        // attributes.\n        final ConstantState cs;\n        if (isColorDrawable) {\n            cs = sPreloadedColorDrawables.get(key);\n        } else {\n            cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);\n        }\n\n        Drawable dr;\n        if (cs != null) {\n            dr = cs.newDrawable(this);\n        } else if (isColorDrawable) {\n            dr = new ColorDrawable(value.data);\n        } else {\n            dr = loadDrawableForCookie(value, id, null);\n        }\n\n        // Determine if the drawable has unresolved theme attributes. If it\n        // does, we'll need to apply a theme and store it in a theme-specific\n        // cache.\n        final boolean canApplyTheme = dr != null && dr.canApplyTheme();\n        if (canApplyTheme && theme != null) {\n            dr = dr.mutate();\n            dr.applyTheme(theme);\n            dr.clearMutated();\n        }\n\n        // If we were able to obtain a drawable, store it in the appropriate\n        // cache: preload, not themed, null theme, or theme-specific.\n        if (dr != null) {\n            dr.setChangingConfigurations(value.changingConfigurations);\n            cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);\n        }\n\n        return dr;\n    }\n```\n\n* 根据判断是否是ColorDrawable，赋值不同的cache和key\n* 如果不是预加载，就从cache中找，找到返回\n* 从预加载数组中得到key对应的ConstantState\n* 根据cs是否为null以及是不是ColorDrawable，来得到的Drawable\n* 设置主题相关的\n* 进行缓存\n\n而我们预加载资源的主要过程是loadDrawableForCookie。这个方法是从xml或者流里面加载Drawable。\n\n核心代码如下：\n\n```\n            if (file.endsWith(\".xml\")) {\n                final XmlResourceParser rp = loadXmlResourceParser(\n                        file, id, value.assetCookie, \"drawable\");\n                dr = Drawable.createFromXml(this, rp, theme);\n                rp.close();\n            } else {\n                final InputStream is = mAssets.openNonAsset(\n                        value.assetCookie, file, AssetManager.ACCESS_STREAMING);\n                dr = Drawable.createFromResourceStream(this, value, is, file, null);\n                is.close();\n            }\n```\n\n关于Drawable的生成过程，这里就不说了。\n\n### 占坑\n\n* aapt资源打包过程\n* 其他\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","source":"_posts/系统资源的预加载过程.md","raw":"---\ntitle: 系统资源的预加载过程\ndate: 2017-01-09 12:29:31\ncategories: Android\ntags: framework\n\n---\n<Excerpt in index | 首页摘要>\n### 前言\n\n在Zygote进程那篇文章中，提到过，在初始化的时候会预加载系统资源，这样，应用进程在fork了之后，不需要通过加载过程，就可以直接使用这些资源，那么，今天就来看下，这个过程是怎么样的。\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n \n\n### ZygoteInit#preloadResources\n\n```\n    private static void preloadResources() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        try {\n            mResources = Resources.getSystem();\n            mResources.startPreloading();\n            if (PRELOAD_RESOURCES) {\n                Log.i(TAG, \"Preloading resources...\");\n\n                long startTime = SystemClock.uptimeMillis();\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);\n                int N = preloadDrawables(runtime, ar);\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");\n\n                startTime = SystemClock.uptimeMillis();\n                ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_color_state_lists);\n                N = preloadColorStateLists(runtime, ar);\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");\n            }\n            mResources.finishPreloading();\n        } catch (RuntimeException e) {\n            Log.w(TAG, \"Failure preloading resources\", e);\n        }\n    }\n```\n\n上面的过程分为三步\n\n* 得到Resources对象\n* 得到TypedArray对象\n* preloadDrawables，preloadColorStateLists 加载资源\n\n现在，按照上面的三部分来学习下。\n\n### Resources#getSystem\n\nResources代码资源，提供了许多方法让我们获取，这里获取的是经过映射的资源，resources.arsc。\n\n```\n    public static Resources getSystem() {\n        synchronized (sSync) {\n            Resources ret = mSystem;\n            if (ret == null) {\n                ret = new Resources();\n                mSystem = ret;\n            }\n\n            return ret;\n        }\n    }\n```\n\n在这里初始化了一个Resources对象，并且赋值给mSystem变量，那么我们现在看下Resources的构造方法。\n\n```\n    private Resources() {\n        mAssets = AssetManager.getSystem();\n        // NOTE: Intentionally leaving this uninitialized (all values set\n        // to zero), so that anyone who tries to do something that requires\n        // metrics will get a very wrong value.\n        mConfiguration.setToDefaults();\n        mMetrics.setToDefaults();\n        updateConfiguration(null, null);\n        mAssets.ensureStringBlocks();\n    }\n```\n\n在初始化方法中，通过AssetManager.getSystem获取一个AssetManager对象，这个是用来访问原始资源的(assets目录)。并且，将Configuration和DisplayMetrics都设置默认，更新配置，初始化StringBlocks。那么，我们来看下AssetManager.getSystem。这个方法中调用ensureSystemAssets，ensureSystemAssets代码如下：\n\n```\n    private static void ensureSystemAssets() {\n        synchronized (sSync) {\n            if (sSystem == null) {\n                AssetManager system = new AssetManager(true);\n                system.makeStringBlocks(null);\n                sSystem = system;\n            }\n        }\n    }\n\n```\n\n可以看到，这里初始化了一个AssetManager，好吧，接着看AssetManager的构造函数。\n\n```\n    private AssetManager(boolean isSystem) {\n        if (DEBUG_REFS) {\n            synchronized (this) {\n                mNumRefs = 0;\n                incRefsLocked(this.hashCode());\n            }\n        }\n        init(true);\n        if (localLOGV) Log.v(TAG, \"New asset manager: \" + this);\n    }\n```\n\n这里调用init去初始化，这是个native函数，实现在android_util_AssetManager.cpp中，对应的方法为android_content_AssetManager_init\n\n#### android_content_AssetManager_init\n\n```\nstatic void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)\n{\n    if (isSystem) {\n        verifySystemIdmaps();\n    }\n    AssetManager* am = new AssetManager();\n    if (am == NULL) {\n        jniThrowException(env, \"java/lang/OutOfMemoryError\", \"\");\n        return;\n    }\n\n    am->addDefaultAssets();\n\n    ALOGV(\"Created AssetManager %p for Java object %p\\n\", am, clazz);\n    env->SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast<jlong>(am));\n}\n```\n\n从代码中来看，分为四步\n\n* 验证idmaps\n* 生成c++的AssetManager对象\n* 添加默认的assets\n* 设置java层AssetManager的mObject为c++的AssetManager地址。\n\n我们看添加默认的assets那一步。\n\n```\nbool AssetManager::addDefaultAssets()\n{\n    const char* root = getenv(\"ANDROID_ROOT\");\n    LOG_ALWAYS_FATAL_IF(root == NULL, \"ANDROID_ROOT not set\");\n\n    String8 path(root);\n    path.appendPath(kSystemAssets);\n\n    return addAssetPath(path, NULL);\n}\n```\n\n* ANDROID_ROOT为system\n* static const char* kSystemAssets = \"framework/framework-res.apk\";\n\n然后调用addAssetPath两个参数的方法，将framework-res.apk加进去。\n\n```\nbool AssetManager::addAssetPath(const String8& path, int32_t* cookie)\n{\n    AutoMutex _l(mLock);\n\n    asset_path ap;\n\n    String8 realPath(path);\n    if (kAppZipName) {\n        realPath.appendPath(kAppZipName);\n    }\n    ap.type = ::getFileType(realPath.string());\n    if (ap.type == kFileTypeRegular) {\n        ap.path = realPath;\n    } else {\n        ap.path = path;\n        ap.type = ::getFileType(path.string());\n        if (ap.type != kFileTypeDirectory && ap.type != kFileTypeRegular) {\n            ALOGW(\"Asset path %s is neither a directory nor file (type=%d).\",\n                 path.string(), (int)ap.type);\n            return false;\n        }\n    }\n\n    // Skip if we have it already.\n    for (size_t i=0; i<mAssetPaths.size(); i++) {\n        if (mAssetPaths[i].path == ap.path) {\n            if (cookie) {\n                *cookie = static_cast<int32_t>(i+1);\n            }\n            return true;\n        }\n    }\n\n    ALOGV(\"In %p Asset %s path: %s\", this,\n         ap.type == kFileTypeDirectory ? \"dir\" : \"zip\", ap.path.string());\n\n    // Check that the path has an AndroidManifest.xml\n    Asset* manifestAsset = const_cast<AssetManager*>(this)->openNonAssetInPathLocked(\n            kAndroidManifest, Asset::ACCESS_BUFFER, ap);\n    if (manifestAsset == NULL) {\n        // This asset path does not contain any resources.\n        delete manifestAsset;\n        return false;\n    }\n    delete manifestAsset;\n\n    mAssetPaths.add(ap);\n\n    // new paths are always added at the end\n    if (cookie) {\n        *cookie = static_cast<int32_t>(mAssetPaths.size());\n    }\n\n#ifdef HAVE_ANDROID_OS\n    // Load overlays, if any\n    asset_path oap;\n    for (size_t idx = 0; mZipSet.getOverlay(ap.path, idx, &oap); idx++) {\n        mAssetPaths.add(oap);\n    }\n#endif\n\n    if (mResources != NULL) {\n        appendPathToResTable(ap);\n    }\n\n    return true;\n}\n```\n\n* asset_path结构体存储文件路径、文件类型等，结构体定义如下\n\n\t```\n    struct asset_path\n    {\n        asset_path() : path(\"\"), type(kFileTypeRegular), idmap(\"\"), isSystemOverlay(false) {}\n        String8 path;\n        FileType type;\n        String8 idmap;\n        bool isSystemOverlay;\n    };\n```\n* kAppZipName一般为null，static const char* kAppZipName = NULL; //\"classes.jar\";\n* 如果已经在mAssetPaths，就反悔\n* 如果路径下没有AndroidManifest.xml文件，返回false\n* 添加到mAssetPaths中\n* appendPathToResTable将资源进行解析添加\n\n#### AssetManager::appendPathToResTable\n\n```\nbool AssetManager::appendPathToResTable(const asset_path& ap) const {\n    // skip those ap's that correspond to system overlays\n    if (ap.isSystemOverlay) {\n        return true;\n    }\n\n    Asset* ass = NULL;\n    ResTable* sharedRes = NULL;\n    bool shared = true;\n    bool onlyEmptyResources = true;\n    MY_TRACE_BEGIN(ap.path.string());\n    Asset* idmap = openIdmapLocked(ap);\n    size_t nextEntryIdx = mResources->getTableCount();\n    ALOGV(\"Looking for resource asset in '%s'\\n\", ap.path.string());\n    if (ap.type != kFileTypeDirectory) {\n        if (nextEntryIdx == 0) {\n            // The first item is typically the framework resources,\n            // which we want to avoid parsing every time.\n            sharedRes = const_cast<AssetManager*>(this)->\n                mZipSet.getZipResourceTable(ap.path);\n            if (sharedRes != NULL) {\n                // skip ahead the number of system overlay packages preloaded\n                nextEntryIdx = sharedRes->getTableCount();\n            }\n        }\n        if (sharedRes == NULL) {\n            ass = const_cast<AssetManager*>(this)->\n                mZipSet.getZipResourceTableAsset(ap.path);\n            if (ass == NULL) {\n                ALOGV(\"loading resource table %s\\n\", ap.path.string());\n                ass = const_cast<AssetManager*>(this)->\n                    openNonAssetInPathLocked(\"resources.arsc\",\n                                             Asset::ACCESS_BUFFER,\n                                             ap);\n                if (ass != NULL && ass != kExcludedAsset) {\n                    ass = const_cast<AssetManager*>(this)->\n                        mZipSet.setZipResourceTableAsset(ap.path, ass);\n                }\n            }\n            \n            if (nextEntryIdx == 0 && ass != NULL) {\n                // If this is the first resource table in the asset\n                // manager, then we are going to cache it so that we\n                // can quickly copy it out for others.\n                ALOGV(\"Creating shared resources for %s\", ap.path.string());\n                sharedRes = new ResTable();\n                sharedRes->add(ass, idmap, nextEntryIdx + 1, false);\n#ifdef HAVE_ANDROID_OS\n                const char* data = getenv(\"ANDROID_DATA\");\n                LOG_ALWAYS_FATAL_IF(data == NULL, \"ANDROID_DATA not set\");\n                String8 overlaysListPath(data);\n                overlaysListPath.appendPath(kResourceCache);\n                overlaysListPath.appendPath(\"overlays.list\");\n                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);\n#endif\n                sharedRes = const_cast<AssetManager*>(this)->\n                    mZipSet.setZipResourceTable(ap.path, sharedRes);\n            }\n        }\n    } else {\n        ALOGV(\"loading resource table %s\\n\", ap.path.string());\n        ass = const_cast<AssetManager*>(this)->\n            openNonAssetInPathLocked(\"resources.arsc\",\n                                     Asset::ACCESS_BUFFER,\n                                     ap);\n        shared = false;\n    }\n\n    if ((ass != NULL || sharedRes != NULL) && ass != kExcludedAsset) {\n        ALOGV(\"Installing resource asset %p in to table %p\\n\", ass, mResources);\n        if (sharedRes != NULL) {\n            ALOGV(\"Copying existing resources for %s\", ap.path.string());\n            mResources->add(sharedRes);\n        } else {\n            ALOGV(\"Parsing resources for %s\", ap.path.string());\n            mResources->add(ass, idmap, nextEntryIdx + 1, !shared);\n        }\n        onlyEmptyResources = false;\n\n        if (!shared) {\n            delete ass;\n        }\n    } else {\n        ALOGV(\"Installing empty resources in to table %p\\n\", mResources);\n        mResources->addEmpty(nextEntryIdx + 1);\n    }\n\n    if (idmap != NULL) {\n        delete idmap;\n    }\n    MY_TRACE_END();\n\n    return onlyEmptyResources;\n}\n```\n\n* 通过openIdmapLocked解析资源包中的idmap表\n* ap.type != kFileTypeDirectory，不是目录，就是资源包，如果nextEntryIdx为0，则为framework.apk资源包，解析并保存在sharedRes中，这个是共享的资源。\n* sharedRes == NULL 表示为应用资源包，这解析保存在ass中，\n* nextEntryIdx == 0 && ass != NULL，在zygote进程第一次调用才成立，也就是预加载资源，这个时候把framework.apk的资源索引表创建起来，并添加到mZipSet中\n* 如果是目录，就创建resources.arsc的asset对象，这个不是共享的。\n* 如果存在sharedRes，就保存到mResources中，否则，这是应用的资源，则把应用的资源加入到mResources中。\n\n上面的比较乱，总结一下。简单来说就是这样的，就是对资源包进行解析，并加入到mResources中，如果是framework.apk，就是共享的，否则就是应用的资源包，不共享。\n\n### TypedArray\n\n```\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);\n```\nmResources.obtainTypedArray的代码如下：\n\n```\n    public TypedArray obtainTypedArray(@ArrayRes int id)\n            throws NotFoundException {\n        int len = mAssets.getArraySize(id);\n        if (len < 0) {\n            throw new NotFoundException(\"Array resource ID #0x\"\n                                        + Integer.toHexString(id));\n        }\n        \n        TypedArray array = TypedArray.obtain(this, len);\n        array.mLength = mAssets.retrieveArray(id, array.mData);\n        array.mIndices[0] = 0;\n        \n        return array;\n    }\n```\n\n* 先获取id对应的数组长度\n* 然后根据长度生成TypedArray\n* 最后mAssets.retrieveArray赋值，将资源对应的id写入到java层array.mData中。写入部分代码如下\n\n\t```\n\t    dest[STYLE_TYPE] = value.dataType;\n        dest[STYLE_DATA] = value.data;\n        dest[STYLE_ASSET_COOKIE] = block != kXmlBlock ?\n            static_cast<jint>(res.getTableCookie(block)) : -1;\n        dest[STYLE_RESOURCE_ID] = resid;\n        dest[STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;\n        dest[STYLE_DENSITY] = config.density;\n```\n\n\n\n\n#### getArraySize获取资源id对应的数组长度\n\n这是个native方法，对应的实现在android_util_AssetManager.cpp的android_content_AssetManager_getArraySize方法中，代码如下：\n\n```\nstatic jint android_content_AssetManager_getArraySize(JNIEnv* env, jobject clazz,\n                                                       jint id)\n{\n    AssetManager* am = assetManagerForJavaObject(env, clazz);\n    if (am == NULL) {\n        return 0;\n    }\n    const ResTable& res(am->getResources());\n\n    res.lock();\n    const ResTable::bag_entry* defStyleEnt = NULL;\n    ssize_t bagOff = res.getBagLocked(id, &defStyleEnt);\n    res.unlock();\n\n    return static_cast<jint>(bagOff);\n}\n```\n\n* 首先将java对象转换为对应的c++对象，上面有说到过，AssetManager中的mobject字段存的是对应c++中，AssetManager对象的地址，因此，我们很容易做到转换\n* 通过ResTable的getBagLocked方法获取id，对应的数组长度(该方法的实现在ResourceTypes.cpp中)，实现太长，看不懂，略过。\n\n### preloadDrawables来说明资源的预加载过程\n\n```\n    private static int preloadDrawables(VMRuntime runtime, TypedArray ar) {\n        int N = ar.length();\n        for (int i=0; i<N; i++) {\n            int id = ar.getResourceId(i, 0);\n            if (false) {\n                Log.v(TAG, \"Preloading resource #\" + Integer.toHexString(id));\n            }\n            if (id != 0) {\n                if (mResources.getDrawable(id, null) == null) {\n                    throw new IllegalArgumentException(\n                            \"Unable to find preloaded drawable resource #0x\"\n                            + Integer.toHexString(id)\n                            + \" (\" + ar.getString(i) + \")\");\n                }\n            }\n        }\n        return N;\n    }\n```\n\n* 首先通过getResourceId获取资源id\n* getDrawable获取资源\n\n#### getResourceId 获取资源id\n\n```\n    public int getResourceId(int index, int defValue) {\n        if (mRecycled) {\n            throw new RuntimeException(\"Cannot make calls to a recycled instance!\");\n        }\n\n        index *= AssetManager.STYLE_NUM_ENTRIES;\n        final int[] data = mData;\n        if (data[index+AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {\n            final int resid = data[index+AssetManager.STYLE_RESOURCE_ID];\n            if (resid != 0) {\n                return resid;\n            }\n        }\n        return defValue;\n    }\n```\n\n* 其中STYLE_NUM_ENTRIES为6，\n* 从赋值id的代码中，知道第四个为id值，因此STYLE_RESOURCE_ID为3\n\n\n\n#### getDrawable\n\n```\n    public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme) throws NotFoundException {\n        TypedValue value;\n        synchronized (mAccessLock) {\n            value = mTmpValue;\n            if (value == null) {\n                value = new TypedValue();\n            } else {\n                mTmpValue = null;\n            }\n            getValue(id, value, true);\n        }\n        final Drawable res = loadDrawable(value, id, theme);\n        synchronized (mAccessLock) {\n            if (mTmpValue == null) {\n                mTmpValue = value;\n            }\n        }\n        return res;\n    }\n```\n\n* getValue查找与id对应的资源，没找到对应的就抛出NotFoundException异常\n* loadDrawable 去加载\n\n在getValue中，会调用AssetManager的getResourceValue方法，这个是native方法，实现在android_uitl_AssetManager.cpp的android_content_AssetManager_loadResourceValue中\n\n##### android_content_AssetManager_loadResourceValue\n\n```\nstatic jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,\n                                                           jint ident,\n                                                           jshort density,\n                                                           jobject outValue,\n                                                           jboolean resolve)\n{\n    if (outValue == NULL) {\n         jniThrowNullPointerException(env, \"outValue\");\n         return 0;\n    }\n    AssetManager* am = assetManagerForJavaObject(env, clazz);\n    if (am == NULL) {\n        return 0;\n    }\n    const ResTable& res(am->getResources());\n\n    Res_value value;\n    ResTable_config config;\n    uint32_t typeSpecFlags;\n    ssize_t block = res.getResource(ident, &value, false, density, &typeSpecFlags, &config);\n    if (kThrowOnBadId) {\n        if (block == BAD_INDEX) {\n            jniThrowException(env, \"java/lang/IllegalStateException\", \"Bad resource!\");\n            return 0;\n        }\n    }\n    uint32_t ref = ident;\n    if (resolve) {\n        block = res.resolveReference(&value, block, &ref, &typeSpecFlags, &config);\n        if (kThrowOnBadId) {\n            if (block == BAD_INDEX) {\n                jniThrowException(env, \"java/lang/IllegalStateException\", \"Bad resource!\");\n                return 0;\n            }\n        }\n    }\n    if (block >= 0) {\n        return copyValue(env, outValue, &res, value, ref, block, typeSpecFlags, &config);\n    }\n\n    return static_cast<jint>(block);\n}\n```\n\n* 得到ResTable对象\n* resolveReference查找是否有匹配的资源\n* 如果有，就将数据复制给copyValue这个java层对象\n\n具体的代码就不往下追了。\n\n##### loadDrawable\n\n经过上面的步骤，资源的信息就保存在了TypedValue中，解析来就是通过loadDrawable去加载了。\n\n```\n    Drawable loadDrawable(TypedValue value, int id, Theme theme) throws NotFoundException {\n        if (TRACE_FOR_PRELOAD) {\n            // Log only framework resources\n            if ((id >>> 24) == 0x1) {\n                final String name = getResourceName(id);\n                if (name != null) {\n                    Log.d(\"PreloadDrawable\", name);\n                }\n            }\n        }\n\n        final boolean isColorDrawable;\n        final DrawableCache caches;\n        final long key;\n        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT\n                && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {\n            isColorDrawable = true;\n            caches = mColorDrawableCache;\n            key = value.data;\n        } else {\n            isColorDrawable = false;\n            caches = mDrawableCache;\n            key = (((long) value.assetCookie) << 32) | value.data;\n        }\n\n        // First, check whether we have a cached version of this drawable\n        // that was inflated against the specified theme.\n        if (!mPreloading) {\n            final Drawable cachedDrawable = caches.getInstance(key, theme);\n            if (cachedDrawable != null) {\n                return cachedDrawable;\n            }\n        }\n\n        // Next, check preloaded drawables. These may contain unresolved theme\n        // attributes.\n        final ConstantState cs;\n        if (isColorDrawable) {\n            cs = sPreloadedColorDrawables.get(key);\n        } else {\n            cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);\n        }\n\n        Drawable dr;\n        if (cs != null) {\n            dr = cs.newDrawable(this);\n        } else if (isColorDrawable) {\n            dr = new ColorDrawable(value.data);\n        } else {\n            dr = loadDrawableForCookie(value, id, null);\n        }\n\n        // Determine if the drawable has unresolved theme attributes. If it\n        // does, we'll need to apply a theme and store it in a theme-specific\n        // cache.\n        final boolean canApplyTheme = dr != null && dr.canApplyTheme();\n        if (canApplyTheme && theme != null) {\n            dr = dr.mutate();\n            dr.applyTheme(theme);\n            dr.clearMutated();\n        }\n\n        // If we were able to obtain a drawable, store it in the appropriate\n        // cache: preload, not themed, null theme, or theme-specific.\n        if (dr != null) {\n            dr.setChangingConfigurations(value.changingConfigurations);\n            cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);\n        }\n\n        return dr;\n    }\n```\n\n* 根据判断是否是ColorDrawable，赋值不同的cache和key\n* 如果不是预加载，就从cache中找，找到返回\n* 从预加载数组中得到key对应的ConstantState\n* 根据cs是否为null以及是不是ColorDrawable，来得到的Drawable\n* 设置主题相关的\n* 进行缓存\n\n而我们预加载资源的主要过程是loadDrawableForCookie。这个方法是从xml或者流里面加载Drawable。\n\n核心代码如下：\n\n```\n            if (file.endsWith(\".xml\")) {\n                final XmlResourceParser rp = loadXmlResourceParser(\n                        file, id, value.assetCookie, \"drawable\");\n                dr = Drawable.createFromXml(this, rp, theme);\n                rp.close();\n            } else {\n                final InputStream is = mAssets.openNonAsset(\n                        value.assetCookie, file, AssetManager.ACCESS_STREAMING);\n                dr = Drawable.createFromResourceStream(this, value, is, file, null);\n                is.close();\n            }\n```\n\n关于Drawable的生成过程，这里就不说了。\n\n### 占坑\n\n* aapt资源打包过程\n* 其他\n\n\n\n\n\n\n\n\n### 最近访客\n<ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>","slug":"系统资源的预加载过程","published":1,"updated":"2017-01-09T07:18:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy1ncy350034hws6d73kvpbm","content":"<p><excerpt in=\"\" index=\"\" |=\"\" 首页摘要=\"\"></excerpt></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在Zygote进程那篇文章中，提到过，在初始化的时候会预加载系统资源，这样，应用进程在fork了之后，不需要通过加载过程，就可以直接使用这些资源，那么，今天就来看下，这个过程是怎么样的。</p>\n<a id=\"more\"></a>\n<the rest=\"\" of=\"\" contents=\"\" |=\"\" 余下全文=\"\">\n\n\n\n<h3 id=\"ZygoteInit-preloadResources\"><a href=\"#ZygoteInit-preloadResources\" class=\"headerlink\" title=\"ZygoteInit#preloadResources\"></a>ZygoteInit#preloadResources</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void preloadResources() &#123;</div><div class=\"line\">    final VMRuntime runtime = VMRuntime.getRuntime();</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        mResources = Resources.getSystem();</div><div class=\"line\">        mResources.startPreloading();</div><div class=\"line\">        if (PRELOAD_RESOURCES) &#123;</div><div class=\"line\">            Log.i(TAG, &quot;Preloading resources...&quot;);</div><div class=\"line\"></div><div class=\"line\">            long startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_drawables);</div><div class=\"line\">            int N = preloadDrawables(runtime, ar);</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);</div><div class=\"line\"></div><div class=\"line\">            startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_color_state_lists);</div><div class=\"line\">            N = preloadColorStateLists(runtime, ar);</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mResources.finishPreloading();</div><div class=\"line\">    &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">        Log.w(TAG, &quot;Failure preloading resources&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的过程分为三步</p>\n<ul>\n<li>得到Resources对象</li>\n<li>得到TypedArray对象</li>\n<li>preloadDrawables，preloadColorStateLists 加载资源</li>\n</ul>\n<p>现在，按照上面的三部分来学习下。</p>\n<h3 id=\"Resources-getSystem\"><a href=\"#Resources-getSystem\" class=\"headerlink\" title=\"Resources#getSystem\"></a>Resources#getSystem</h3><p>Resources代码资源，提供了许多方法让我们获取，这里获取的是经过映射的资源，resources.arsc。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Resources getSystem() &#123;</div><div class=\"line\">    synchronized (sSync) &#123;</div><div class=\"line\">        Resources ret = mSystem;</div><div class=\"line\">        if (ret == null) &#123;</div><div class=\"line\">            ret = new Resources();</div><div class=\"line\">            mSystem = ret;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里初始化了一个Resources对象，并且赋值给mSystem变量，那么我们现在看下Resources的构造方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Resources() &#123;</div><div class=\"line\">    mAssets = AssetManager.getSystem();</div><div class=\"line\">    // NOTE: Intentionally leaving this uninitialized (all values set</div><div class=\"line\">    // to zero), so that anyone who tries to do something that requires</div><div class=\"line\">    // metrics will get a very wrong value.</div><div class=\"line\">    mConfiguration.setToDefaults();</div><div class=\"line\">    mMetrics.setToDefaults();</div><div class=\"line\">    updateConfiguration(null, null);</div><div class=\"line\">    mAssets.ensureStringBlocks();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在初始化方法中，通过AssetManager.getSystem获取一个AssetManager对象，这个是用来访问原始资源的(assets目录)。并且，将Configuration和DisplayMetrics都设置默认，更新配置，初始化StringBlocks。那么，我们来看下AssetManager.getSystem。这个方法中调用ensureSystemAssets，ensureSystemAssets代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void ensureSystemAssets() &#123;</div><div class=\"line\">    synchronized (sSync) &#123;</div><div class=\"line\">        if (sSystem == null) &#123;</div><div class=\"line\">            AssetManager system = new AssetManager(true);</div><div class=\"line\">            system.makeStringBlocks(null);</div><div class=\"line\">            sSystem = system;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这里初始化了一个AssetManager，好吧，接着看AssetManager的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AssetManager(boolean isSystem) &#123;</div><div class=\"line\">    if (DEBUG_REFS) &#123;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            mNumRefs = 0;</div><div class=\"line\">            incRefsLocked(this.hashCode());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    init(true);</div><div class=\"line\">    if (localLOGV) Log.v(TAG, &quot;New asset manager: &quot; + this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里调用init去初始化，这是个native函数，实现在android_util_AssetManager.cpp中，对应的方法为android_content_AssetManager_init</p>\n<h4 id=\"android-content-AssetManager-init\"><a href=\"#android-content-AssetManager-init\" class=\"headerlink\" title=\"android_content_AssetManager_init\"></a>android_content_AssetManager_init</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (isSystem) &#123;</div><div class=\"line\">        verifySystemIdmaps();</div><div class=\"line\">    &#125;</div><div class=\"line\">    AssetManager* am = new AssetManager();</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        jniThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, &quot;&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    am-&gt;addDefaultAssets();</div><div class=\"line\"></div><div class=\"line\">    ALOGV(&quot;Created AssetManager %p for Java object %p\\n&quot;, am, clazz);</div><div class=\"line\">    env-&gt;SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast&lt;jlong&gt;(am));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从代码中来看，分为四步</p>\n<ul>\n<li>验证idmaps</li>\n<li>生成c++的AssetManager对象</li>\n<li>添加默认的assets</li>\n<li>设置java层AssetManager的mObject为c++的AssetManager地址。</li>\n</ul>\n<p>我们看添加默认的assets那一步。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::addDefaultAssets()</div><div class=\"line\">&#123;</div><div class=\"line\">    const char* root = getenv(&quot;ANDROID_ROOT&quot;);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(root == NULL, &quot;ANDROID_ROOT not set&quot;);</div><div class=\"line\"></div><div class=\"line\">    String8 path(root);</div><div class=\"line\">    path.appendPath(kSystemAssets);</div><div class=\"line\"></div><div class=\"line\">    return addAssetPath(path, NULL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>ANDROID_ROOT为system</li>\n<li>static const char* kSystemAssets = “framework/framework-res.apk”;</li>\n</ul>\n<p>然后调用addAssetPath两个参数的方法，将framework-res.apk加进去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::addAssetPath(const String8&amp; path, int32_t* cookie)</div><div class=\"line\">&#123;</div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\"></div><div class=\"line\">    asset_path ap;</div><div class=\"line\"></div><div class=\"line\">    String8 realPath(path);</div><div class=\"line\">    if (kAppZipName) &#123;</div><div class=\"line\">        realPath.appendPath(kAppZipName);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ap.type = ::getFileType(realPath.string());</div><div class=\"line\">    if (ap.type == kFileTypeRegular) &#123;</div><div class=\"line\">        ap.path = realPath;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ap.path = path;</div><div class=\"line\">        ap.type = ::getFileType(path.string());</div><div class=\"line\">        if (ap.type != kFileTypeDirectory &amp;&amp; ap.type != kFileTypeRegular) &#123;</div><div class=\"line\">            ALOGW(&quot;Asset path %s is neither a directory nor file (type=%d).&quot;,</div><div class=\"line\">                 path.string(), (int)ap.type);</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Skip if we have it already.</div><div class=\"line\">    for (size_t i=0; i&lt;mAssetPaths.size(); i++) &#123;</div><div class=\"line\">        if (mAssetPaths[i].path == ap.path) &#123;</div><div class=\"line\">            if (cookie) &#123;</div><div class=\"line\">                *cookie = static_cast&lt;int32_t&gt;(i+1);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ALOGV(&quot;In %p Asset %s path: %s&quot;, this,</div><div class=\"line\">         ap.type == kFileTypeDirectory ? &quot;dir&quot; : &quot;zip&quot;, ap.path.string());</div><div class=\"line\"></div><div class=\"line\">    // Check that the path has an AndroidManifest.xml</div><div class=\"line\">    Asset* manifestAsset = const_cast&lt;AssetManager*&gt;(this)-&gt;openNonAssetInPathLocked(</div><div class=\"line\">            kAndroidManifest, Asset::ACCESS_BUFFER, ap);</div><div class=\"line\">    if (manifestAsset == NULL) &#123;</div><div class=\"line\">        // This asset path does not contain any resources.</div><div class=\"line\">        delete manifestAsset;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    delete manifestAsset;</div><div class=\"line\"></div><div class=\"line\">    mAssetPaths.add(ap);</div><div class=\"line\"></div><div class=\"line\">    // new paths are always added at the end</div><div class=\"line\">    if (cookie) &#123;</div><div class=\"line\">        *cookie = static_cast&lt;int32_t&gt;(mAssetPaths.size());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">#ifdef HAVE_ANDROID_OS</div><div class=\"line\">    // Load overlays, if any</div><div class=\"line\">    asset_path oap;</div><div class=\"line\">    for (size_t idx = 0; mZipSet.getOverlay(ap.path, idx, &amp;oap); idx++) &#123;</div><div class=\"line\">        mAssetPaths.add(oap);</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">    if (mResources != NULL) &#123;</div><div class=\"line\">        appendPathToResTable(ap);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>asset_path结构体存储文件路径、文件类型等，结构体定义如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct asset_path</div><div class=\"line\">&#123;</div><div class=\"line\">    asset_path() : path(&quot;&quot;), type(kFileTypeRegular), idmap(&quot;&quot;), isSystemOverlay(false) &#123;&#125;</div><div class=\"line\">    String8 path;</div><div class=\"line\">    FileType type;</div><div class=\"line\">    String8 idmap;</div><div class=\"line\">    bool isSystemOverlay;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>kAppZipName一般为null，static const char* kAppZipName = NULL; //“classes.jar”;</p>\n</li>\n<li>如果已经在mAssetPaths，就反悔</li>\n<li>如果路径下没有AndroidManifest.xml文件，返回false</li>\n<li>添加到mAssetPaths中</li>\n<li>appendPathToResTable将资源进行解析添加</li>\n</ul>\n<h4 id=\"AssetManager-appendPathToResTable\"><a href=\"#AssetManager-appendPathToResTable\" class=\"headerlink\" title=\"AssetManager::appendPathToResTable\"></a>AssetManager::appendPathToResTable</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::appendPathToResTable(const asset_path&amp; ap) const &#123;</div><div class=\"line\">    // skip those ap&apos;s that correspond to system overlays</div><div class=\"line\">    if (ap.isSystemOverlay) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Asset* ass = NULL;</div><div class=\"line\">    ResTable* sharedRes = NULL;</div><div class=\"line\">    bool shared = true;</div><div class=\"line\">    bool onlyEmptyResources = true;</div><div class=\"line\">    MY_TRACE_BEGIN(ap.path.string());</div><div class=\"line\">    Asset* idmap = openIdmapLocked(ap);</div><div class=\"line\">    size_t nextEntryIdx = mResources-&gt;getTableCount();</div><div class=\"line\">    ALOGV(&quot;Looking for resource asset in &apos;%s&apos;\\n&quot;, ap.path.string());</div><div class=\"line\">    if (ap.type != kFileTypeDirectory) &#123;</div><div class=\"line\">        if (nextEntryIdx == 0) &#123;</div><div class=\"line\">            // The first item is typically the framework resources,</div><div class=\"line\">            // which we want to avoid parsing every time.</div><div class=\"line\">            sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                mZipSet.getZipResourceTable(ap.path);</div><div class=\"line\">            if (sharedRes != NULL) &#123;</div><div class=\"line\">                // skip ahead the number of system overlay packages preloaded</div><div class=\"line\">                nextEntryIdx = sharedRes-&gt;getTableCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (sharedRes == NULL) &#123;</div><div class=\"line\">            ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                mZipSet.getZipResourceTableAsset(ap.path);</div><div class=\"line\">            if (ass == NULL) &#123;</div><div class=\"line\">                ALOGV(&quot;loading resource table %s\\n&quot;, ap.path.string());</div><div class=\"line\">                ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                    openNonAssetInPathLocked(&quot;resources.arsc&quot;,</div><div class=\"line\">                                             Asset::ACCESS_BUFFER,</div><div class=\"line\">                                             ap);</div><div class=\"line\">                if (ass != NULL &amp;&amp; ass != kExcludedAsset) &#123;</div><div class=\"line\">                    ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                        mZipSet.setZipResourceTableAsset(ap.path, ass);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            if (nextEntryIdx == 0 &amp;&amp; ass != NULL) &#123;</div><div class=\"line\">                // If this is the first resource table in the asset</div><div class=\"line\">                // manager, then we are going to cache it so that we</div><div class=\"line\">                // can quickly copy it out for others.</div><div class=\"line\">                ALOGV(&quot;Creating shared resources for %s&quot;, ap.path.string());</div><div class=\"line\">                sharedRes = new ResTable();</div><div class=\"line\">                sharedRes-&gt;add(ass, idmap, nextEntryIdx + 1, false);</div><div class=\"line\">#ifdef HAVE_ANDROID_OS</div><div class=\"line\">                const char* data = getenv(&quot;ANDROID_DATA&quot;);</div><div class=\"line\">                LOG_ALWAYS_FATAL_IF(data == NULL, &quot;ANDROID_DATA not set&quot;);</div><div class=\"line\">                String8 overlaysListPath(data);</div><div class=\"line\">                overlaysListPath.appendPath(kResourceCache);</div><div class=\"line\">                overlaysListPath.appendPath(&quot;overlays.list&quot;);</div><div class=\"line\">                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);</div><div class=\"line\">#endif</div><div class=\"line\">                sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                    mZipSet.setZipResourceTable(ap.path, sharedRes);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ALOGV(&quot;loading resource table %s\\n&quot;, ap.path.string());</div><div class=\"line\">        ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">            openNonAssetInPathLocked(&quot;resources.arsc&quot;,</div><div class=\"line\">                                     Asset::ACCESS_BUFFER,</div><div class=\"line\">                                     ap);</div><div class=\"line\">        shared = false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if ((ass != NULL || sharedRes != NULL) &amp;&amp; ass != kExcludedAsset) &#123;</div><div class=\"line\">        ALOGV(&quot;Installing resource asset %p in to table %p\\n&quot;, ass, mResources);</div><div class=\"line\">        if (sharedRes != NULL) &#123;</div><div class=\"line\">            ALOGV(&quot;Copying existing resources for %s&quot;, ap.path.string());</div><div class=\"line\">            mResources-&gt;add(sharedRes);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ALOGV(&quot;Parsing resources for %s&quot;, ap.path.string());</div><div class=\"line\">            mResources-&gt;add(ass, idmap, nextEntryIdx + 1, !shared);</div><div class=\"line\">        &#125;</div><div class=\"line\">        onlyEmptyResources = false;</div><div class=\"line\"></div><div class=\"line\">        if (!shared) &#123;</div><div class=\"line\">            delete ass;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ALOGV(&quot;Installing empty resources in to table %p\\n&quot;, mResources);</div><div class=\"line\">        mResources-&gt;addEmpty(nextEntryIdx + 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (idmap != NULL) &#123;</div><div class=\"line\">        delete idmap;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MY_TRACE_END();</div><div class=\"line\"></div><div class=\"line\">    return onlyEmptyResources;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过openIdmapLocked解析资源包中的idmap表</li>\n<li>ap.type != kFileTypeDirectory，不是目录，就是资源包，如果nextEntryIdx为0，则为framework.apk资源包，解析并保存在sharedRes中，这个是共享的资源。</li>\n<li>sharedRes == NULL 表示为应用资源包，这解析保存在ass中，</li>\n<li>nextEntryIdx == 0 &amp;&amp; ass != NULL，在zygote进程第一次调用才成立，也就是预加载资源，这个时候把framework.apk的资源索引表创建起来，并添加到mZipSet中</li>\n<li>如果是目录，就创建resources.arsc的asset对象，这个不是共享的。</li>\n<li>如果存在sharedRes，就保存到mResources中，否则，这是应用的资源，则把应用的资源加入到mResources中。</li>\n</ul>\n<p>上面的比较乱，总结一下。简单来说就是这样的，就是对资源包进行解析，并加入到mResources中，如果是framework.apk，就是共享的，否则就是应用的资源包，不共享。</p>\n<h3 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">        com.android.internal.R.array.preloaded_drawables);</div></pre></td></tr></table></figure>\n<p>mResources.obtainTypedArray的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public TypedArray obtainTypedArray(@ArrayRes int id)</div><div class=\"line\">        throws NotFoundException &#123;</div><div class=\"line\">    int len = mAssets.getArraySize(id);</div><div class=\"line\">    if (len &lt; 0) &#123;</div><div class=\"line\">        throw new NotFoundException(&quot;Array resource ID #0x&quot;</div><div class=\"line\">                                    + Integer.toHexString(id));</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    TypedArray array = TypedArray.obtain(this, len);</div><div class=\"line\">    array.mLength = mAssets.retrieveArray(id, array.mData);</div><div class=\"line\">    array.mIndices[0] = 0;</div><div class=\"line\">    </div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先获取id对应的数组长度</li>\n<li>然后根据长度生成TypedArray</li>\n<li><p>最后mAssets.retrieveArray赋值，将资源对应的id写入到java层array.mData中。写入部分代码如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dest[STYLE_TYPE] = value.dataType;</div><div class=\"line\">   dest[STYLE_DATA] = value.data;</div><div class=\"line\">   dest[STYLE_ASSET_COOKIE] = block != kXmlBlock ?</div><div class=\"line\">       static_cast&lt;jint&gt;(res.getTableCookie(block)) : -1;</div><div class=\"line\">   dest[STYLE_RESOURCE_ID] = resid;</div><div class=\"line\">   dest[STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;</div><div class=\"line\">   dest[STYLE_DENSITY] = config.density;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"getArraySize获取资源id对应的数组长度\"><a href=\"#getArraySize获取资源id对应的数组长度\" class=\"headerlink\" title=\"getArraySize获取资源id对应的数组长度\"></a>getArraySize获取资源id对应的数组长度</h4><p>这是个native方法，对应的实现在android_util_AssetManager.cpp的android_content_AssetManager_getArraySize方法中，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jint android_content_AssetManager_getArraySize(JNIEnv* env, jobject clazz,</div><div class=\"line\">                                                       jint id)</div><div class=\"line\">&#123;</div><div class=\"line\">    AssetManager* am = assetManagerForJavaObject(env, clazz);</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const ResTable&amp; res(am-&gt;getResources());</div><div class=\"line\"></div><div class=\"line\">    res.lock();</div><div class=\"line\">    const ResTable::bag_entry* defStyleEnt = NULL;</div><div class=\"line\">    ssize_t bagOff = res.getBagLocked(id, &amp;defStyleEnt);</div><div class=\"line\">    res.unlock();</div><div class=\"line\"></div><div class=\"line\">    return static_cast&lt;jint&gt;(bagOff);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先将java对象转换为对应的c++对象，上面有说到过，AssetManager中的mobject字段存的是对应c++中，AssetManager对象的地址，因此，我们很容易做到转换</li>\n<li>通过ResTable的getBagLocked方法获取id，对应的数组长度(该方法的实现在ResourceTypes.cpp中)，实现太长，看不懂，略过。</li>\n</ul>\n<h3 id=\"preloadDrawables来说明资源的预加载过程\"><a href=\"#preloadDrawables来说明资源的预加载过程\" class=\"headerlink\" title=\"preloadDrawables来说明资源的预加载过程\"></a>preloadDrawables来说明资源的预加载过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static int preloadDrawables(VMRuntime runtime, TypedArray ar) &#123;</div><div class=\"line\">    int N = ar.length();</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        int id = ar.getResourceId(i, 0);</div><div class=\"line\">        if (false) &#123;</div><div class=\"line\">            Log.v(TAG, &quot;Preloading resource #&quot; + Integer.toHexString(id));</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (id != 0) &#123;</div><div class=\"line\">            if (mResources.getDrawable(id, null) == null) &#123;</div><div class=\"line\">                throw new IllegalArgumentException(</div><div class=\"line\">                        &quot;Unable to find preloaded drawable resource #0x&quot;</div><div class=\"line\">                        + Integer.toHexString(id)</div><div class=\"line\">                        + &quot; (&quot; + ar.getString(i) + &quot;)&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return N;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先通过getResourceId获取资源id</li>\n<li>getDrawable获取资源</li>\n</ul>\n<h4 id=\"getResourceId-获取资源id\"><a href=\"#getResourceId-获取资源id\" class=\"headerlink\" title=\"getResourceId 获取资源id\"></a>getResourceId 获取资源id</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int getResourceId(int index, int defValue) &#123;</div><div class=\"line\">    if (mRecycled) &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Cannot make calls to a recycled instance!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    index *= AssetManager.STYLE_NUM_ENTRIES;</div><div class=\"line\">    final int[] data = mData;</div><div class=\"line\">    if (data[index+AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) &#123;</div><div class=\"line\">        final int resid = data[index+AssetManager.STYLE_RESOURCE_ID];</div><div class=\"line\">        if (resid != 0) &#123;</div><div class=\"line\">            return resid;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return defValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>其中STYLE_NUM_ENTRIES为6，</li>\n<li>从赋值id的代码中，知道第四个为id值，因此STYLE_RESOURCE_ID为3</li>\n</ul>\n<h4 id=\"getDrawable\"><a href=\"#getDrawable\" class=\"headerlink\" title=\"getDrawable\"></a>getDrawable</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme) throws NotFoundException &#123;</div><div class=\"line\">    TypedValue value;</div><div class=\"line\">    synchronized (mAccessLock) &#123;</div><div class=\"line\">        value = mTmpValue;</div><div class=\"line\">        if (value == null) &#123;</div><div class=\"line\">            value = new TypedValue();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mTmpValue = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        getValue(id, value, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    final Drawable res = loadDrawable(value, id, theme);</div><div class=\"line\">    synchronized (mAccessLock) &#123;</div><div class=\"line\">        if (mTmpValue == null) &#123;</div><div class=\"line\">            mTmpValue = value;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getValue查找与id对应的资源，没找到对应的就抛出NotFoundException异常</li>\n<li>loadDrawable 去加载</li>\n</ul>\n<p>在getValue中，会调用AssetManager的getResourceValue方法，这个是native方法，实现在android_uitl_AssetManager.cpp的android_content_AssetManager_loadResourceValue中</p>\n<h5 id=\"android-content-AssetManager-loadResourceValue\"><a href=\"#android-content-AssetManager-loadResourceValue\" class=\"headerlink\" title=\"android_content_AssetManager_loadResourceValue\"></a>android_content_AssetManager_loadResourceValue</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,</div><div class=\"line\">                                                           jint ident,</div><div class=\"line\">                                                           jshort density,</div><div class=\"line\">                                                           jobject outValue,</div><div class=\"line\">                                                           jboolean resolve)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (outValue == NULL) &#123;</div><div class=\"line\">         jniThrowNullPointerException(env, &quot;outValue&quot;);</div><div class=\"line\">         return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    AssetManager* am = assetManagerForJavaObject(env, clazz);</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const ResTable&amp; res(am-&gt;getResources());</div><div class=\"line\"></div><div class=\"line\">    Res_value value;</div><div class=\"line\">    ResTable_config config;</div><div class=\"line\">    uint32_t typeSpecFlags;</div><div class=\"line\">    ssize_t block = res.getResource(ident, &amp;value, false, density, &amp;typeSpecFlags, &amp;config);</div><div class=\"line\">    if (kThrowOnBadId) &#123;</div><div class=\"line\">        if (block == BAD_INDEX) &#123;</div><div class=\"line\">            jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    uint32_t ref = ident;</div><div class=\"line\">    if (resolve) &#123;</div><div class=\"line\">        block = res.resolveReference(&amp;value, block, &amp;ref, &amp;typeSpecFlags, &amp;config);</div><div class=\"line\">        if (kThrowOnBadId) &#123;</div><div class=\"line\">            if (block == BAD_INDEX) &#123;</div><div class=\"line\">                jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (block &gt;= 0) &#123;</div><div class=\"line\">        return copyValue(env, outValue, &amp;res, value, ref, block, typeSpecFlags, &amp;config);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return static_cast&lt;jint&gt;(block);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>得到ResTable对象</li>\n<li>resolveReference查找是否有匹配的资源</li>\n<li>如果有，就将数据复制给copyValue这个java层对象</li>\n</ul>\n<p>具体的代码就不往下追了。</p>\n<h5 id=\"loadDrawable\"><a href=\"#loadDrawable\" class=\"headerlink\" title=\"loadDrawable\"></a>loadDrawable</h5><p>经过上面的步骤，资源的信息就保存在了TypedValue中，解析来就是通过loadDrawable去加载了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\">Drawable loadDrawable(TypedValue value, int id, Theme theme) throws NotFoundException &#123;</div><div class=\"line\">    if (TRACE_FOR_PRELOAD) &#123;</div><div class=\"line\">        // Log only framework resources</div><div class=\"line\">        if ((id &gt;&gt;&gt; 24) == 0x1) &#123;</div><div class=\"line\">            final String name = getResourceName(id);</div><div class=\"line\">            if (name != null) &#123;</div><div class=\"line\">                Log.d(&quot;PreloadDrawable&quot;, name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final boolean isColorDrawable;</div><div class=\"line\">    final DrawableCache caches;</div><div class=\"line\">    final long key;</div><div class=\"line\">    if (value.type &gt;= TypedValue.TYPE_FIRST_COLOR_INT</div><div class=\"line\">            &amp;&amp; value.type &lt;= TypedValue.TYPE_LAST_COLOR_INT) &#123;</div><div class=\"line\">        isColorDrawable = true;</div><div class=\"line\">        caches = mColorDrawableCache;</div><div class=\"line\">        key = value.data;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        isColorDrawable = false;</div><div class=\"line\">        caches = mDrawableCache;</div><div class=\"line\">        key = (((long) value.assetCookie) &lt;&lt; 32) | value.data;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // First, check whether we have a cached version of this drawable</div><div class=\"line\">    // that was inflated against the specified theme.</div><div class=\"line\">    if (!mPreloading) &#123;</div><div class=\"line\">        final Drawable cachedDrawable = caches.getInstance(key, theme);</div><div class=\"line\">        if (cachedDrawable != null) &#123;</div><div class=\"line\">            return cachedDrawable;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Next, check preloaded drawables. These may contain unresolved theme</div><div class=\"line\">    // attributes.</div><div class=\"line\">    final ConstantState cs;</div><div class=\"line\">    if (isColorDrawable) &#123;</div><div class=\"line\">        cs = sPreloadedColorDrawables.get(key);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Drawable dr;</div><div class=\"line\">    if (cs != null) &#123;</div><div class=\"line\">        dr = cs.newDrawable(this);</div><div class=\"line\">    &#125; else if (isColorDrawable) &#123;</div><div class=\"line\">        dr = new ColorDrawable(value.data);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        dr = loadDrawableForCookie(value, id, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Determine if the drawable has unresolved theme attributes. If it</div><div class=\"line\">    // does, we&apos;ll need to apply a theme and store it in a theme-specific</div><div class=\"line\">    // cache.</div><div class=\"line\">    final boolean canApplyTheme = dr != null &amp;&amp; dr.canApplyTheme();</div><div class=\"line\">    if (canApplyTheme &amp;&amp; theme != null) &#123;</div><div class=\"line\">        dr = dr.mutate();</div><div class=\"line\">        dr.applyTheme(theme);</div><div class=\"line\">        dr.clearMutated();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If we were able to obtain a drawable, store it in the appropriate</div><div class=\"line\">    // cache: preload, not themed, null theme, or theme-specific.</div><div class=\"line\">    if (dr != null) &#123;</div><div class=\"line\">        dr.setChangingConfigurations(value.changingConfigurations);</div><div class=\"line\">        cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return dr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据判断是否是ColorDrawable，赋值不同的cache和key</li>\n<li>如果不是预加载，就从cache中找，找到返回</li>\n<li>从预加载数组中得到key对应的ConstantState</li>\n<li>根据cs是否为null以及是不是ColorDrawable，来得到的Drawable</li>\n<li>设置主题相关的</li>\n<li>进行缓存</li>\n</ul>\n<p>而我们预加载资源的主要过程是loadDrawableForCookie。这个方法是从xml或者流里面加载Drawable。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (file.endsWith(&quot;.xml&quot;)) &#123;</div><div class=\"line\">    final XmlResourceParser rp = loadXmlResourceParser(</div><div class=\"line\">            file, id, value.assetCookie, &quot;drawable&quot;);</div><div class=\"line\">    dr = Drawable.createFromXml(this, rp, theme);</div><div class=\"line\">    rp.close();</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    final InputStream is = mAssets.openNonAsset(</div><div class=\"line\">            value.assetCookie, file, AssetManager.ACCESS_STREAMING);</div><div class=\"line\">    dr = Drawable.createFromResourceStream(this, value, is, file, null);</div><div class=\"line\">    is.close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于Drawable的生成过程，这里就不说了。</p>\n<h3 id=\"占坑\"><a href=\"#占坑\" class=\"headerlink\" title=\"占坑\"></a>占坑</h3><ul>\n<li>aapt资源打包过程</li>\n<li>其他</li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul></the>","excerpt":"<p><Excerpt in index | 首页摘要></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在Zygote进程那篇文章中，提到过，在初始化的时候会预加载系统资源，这样，应用进程在fork了之后，不需要通过加载过程，就可以直接使用这些资源，那么，今天就来看下，这个过程是怎么样的。</p>","more":"<The rest of contents | 余下全文>\n\n\n\n<h3 id=\"ZygoteInit-preloadResources\"><a href=\"#ZygoteInit-preloadResources\" class=\"headerlink\" title=\"ZygoteInit#preloadResources\"></a>ZygoteInit#preloadResources</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void preloadResources() &#123;</div><div class=\"line\">    final VMRuntime runtime = VMRuntime.getRuntime();</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        mResources = Resources.getSystem();</div><div class=\"line\">        mResources.startPreloading();</div><div class=\"line\">        if (PRELOAD_RESOURCES) &#123;</div><div class=\"line\">            Log.i(TAG, &quot;Preloading resources...&quot;);</div><div class=\"line\"></div><div class=\"line\">            long startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_drawables);</div><div class=\"line\">            int N = preloadDrawables(runtime, ar);</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);</div><div class=\"line\"></div><div class=\"line\">            startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_color_state_lists);</div><div class=\"line\">            N = preloadColorStateLists(runtime, ar);</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mResources.finishPreloading();</div><div class=\"line\">    &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">        Log.w(TAG, &quot;Failure preloading resources&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的过程分为三步</p>\n<ul>\n<li>得到Resources对象</li>\n<li>得到TypedArray对象</li>\n<li>preloadDrawables，preloadColorStateLists 加载资源</li>\n</ul>\n<p>现在，按照上面的三部分来学习下。</p>\n<h3 id=\"Resources-getSystem\"><a href=\"#Resources-getSystem\" class=\"headerlink\" title=\"Resources#getSystem\"></a>Resources#getSystem</h3><p>Resources代码资源，提供了许多方法让我们获取，这里获取的是经过映射的资源，resources.arsc。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Resources getSystem() &#123;</div><div class=\"line\">    synchronized (sSync) &#123;</div><div class=\"line\">        Resources ret = mSystem;</div><div class=\"line\">        if (ret == null) &#123;</div><div class=\"line\">            ret = new Resources();</div><div class=\"line\">            mSystem = ret;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里初始化了一个Resources对象，并且赋值给mSystem变量，那么我们现在看下Resources的构造方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Resources() &#123;</div><div class=\"line\">    mAssets = AssetManager.getSystem();</div><div class=\"line\">    // NOTE: Intentionally leaving this uninitialized (all values set</div><div class=\"line\">    // to zero), so that anyone who tries to do something that requires</div><div class=\"line\">    // metrics will get a very wrong value.</div><div class=\"line\">    mConfiguration.setToDefaults();</div><div class=\"line\">    mMetrics.setToDefaults();</div><div class=\"line\">    updateConfiguration(null, null);</div><div class=\"line\">    mAssets.ensureStringBlocks();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在初始化方法中，通过AssetManager.getSystem获取一个AssetManager对象，这个是用来访问原始资源的(assets目录)。并且，将Configuration和DisplayMetrics都设置默认，更新配置，初始化StringBlocks。那么，我们来看下AssetManager.getSystem。这个方法中调用ensureSystemAssets，ensureSystemAssets代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void ensureSystemAssets() &#123;</div><div class=\"line\">    synchronized (sSync) &#123;</div><div class=\"line\">        if (sSystem == null) &#123;</div><div class=\"line\">            AssetManager system = new AssetManager(true);</div><div class=\"line\">            system.makeStringBlocks(null);</div><div class=\"line\">            sSystem = system;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这里初始化了一个AssetManager，好吧，接着看AssetManager的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AssetManager(boolean isSystem) &#123;</div><div class=\"line\">    if (DEBUG_REFS) &#123;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            mNumRefs = 0;</div><div class=\"line\">            incRefsLocked(this.hashCode());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    init(true);</div><div class=\"line\">    if (localLOGV) Log.v(TAG, &quot;New asset manager: &quot; + this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里调用init去初始化，这是个native函数，实现在android_util_AssetManager.cpp中，对应的方法为android_content_AssetManager_init</p>\n<h4 id=\"android-content-AssetManager-init\"><a href=\"#android-content-AssetManager-init\" class=\"headerlink\" title=\"android_content_AssetManager_init\"></a>android_content_AssetManager_init</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (isSystem) &#123;</div><div class=\"line\">        verifySystemIdmaps();</div><div class=\"line\">    &#125;</div><div class=\"line\">    AssetManager* am = new AssetManager();</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        jniThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, &quot;&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    am-&gt;addDefaultAssets();</div><div class=\"line\"></div><div class=\"line\">    ALOGV(&quot;Created AssetManager %p for Java object %p\\n&quot;, am, clazz);</div><div class=\"line\">    env-&gt;SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast&lt;jlong&gt;(am));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从代码中来看，分为四步</p>\n<ul>\n<li>验证idmaps</li>\n<li>生成c++的AssetManager对象</li>\n<li>添加默认的assets</li>\n<li>设置java层AssetManager的mObject为c++的AssetManager地址。</li>\n</ul>\n<p>我们看添加默认的assets那一步。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::addDefaultAssets()</div><div class=\"line\">&#123;</div><div class=\"line\">    const char* root = getenv(&quot;ANDROID_ROOT&quot;);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(root == NULL, &quot;ANDROID_ROOT not set&quot;);</div><div class=\"line\"></div><div class=\"line\">    String8 path(root);</div><div class=\"line\">    path.appendPath(kSystemAssets);</div><div class=\"line\"></div><div class=\"line\">    return addAssetPath(path, NULL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>ANDROID_ROOT为system</li>\n<li>static const char* kSystemAssets = “framework/framework-res.apk”;</li>\n</ul>\n<p>然后调用addAssetPath两个参数的方法，将framework-res.apk加进去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::addAssetPath(const String8&amp; path, int32_t* cookie)</div><div class=\"line\">&#123;</div><div class=\"line\">    AutoMutex _l(mLock);</div><div class=\"line\"></div><div class=\"line\">    asset_path ap;</div><div class=\"line\"></div><div class=\"line\">    String8 realPath(path);</div><div class=\"line\">    if (kAppZipName) &#123;</div><div class=\"line\">        realPath.appendPath(kAppZipName);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ap.type = ::getFileType(realPath.string());</div><div class=\"line\">    if (ap.type == kFileTypeRegular) &#123;</div><div class=\"line\">        ap.path = realPath;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ap.path = path;</div><div class=\"line\">        ap.type = ::getFileType(path.string());</div><div class=\"line\">        if (ap.type != kFileTypeDirectory &amp;&amp; ap.type != kFileTypeRegular) &#123;</div><div class=\"line\">            ALOGW(&quot;Asset path %s is neither a directory nor file (type=%d).&quot;,</div><div class=\"line\">                 path.string(), (int)ap.type);</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Skip if we have it already.</div><div class=\"line\">    for (size_t i=0; i&lt;mAssetPaths.size(); i++) &#123;</div><div class=\"line\">        if (mAssetPaths[i].path == ap.path) &#123;</div><div class=\"line\">            if (cookie) &#123;</div><div class=\"line\">                *cookie = static_cast&lt;int32_t&gt;(i+1);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ALOGV(&quot;In %p Asset %s path: %s&quot;, this,</div><div class=\"line\">         ap.type == kFileTypeDirectory ? &quot;dir&quot; : &quot;zip&quot;, ap.path.string());</div><div class=\"line\"></div><div class=\"line\">    // Check that the path has an AndroidManifest.xml</div><div class=\"line\">    Asset* manifestAsset = const_cast&lt;AssetManager*&gt;(this)-&gt;openNonAssetInPathLocked(</div><div class=\"line\">            kAndroidManifest, Asset::ACCESS_BUFFER, ap);</div><div class=\"line\">    if (manifestAsset == NULL) &#123;</div><div class=\"line\">        // This asset path does not contain any resources.</div><div class=\"line\">        delete manifestAsset;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    delete manifestAsset;</div><div class=\"line\"></div><div class=\"line\">    mAssetPaths.add(ap);</div><div class=\"line\"></div><div class=\"line\">    // new paths are always added at the end</div><div class=\"line\">    if (cookie) &#123;</div><div class=\"line\">        *cookie = static_cast&lt;int32_t&gt;(mAssetPaths.size());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">#ifdef HAVE_ANDROID_OS</div><div class=\"line\">    // Load overlays, if any</div><div class=\"line\">    asset_path oap;</div><div class=\"line\">    for (size_t idx = 0; mZipSet.getOverlay(ap.path, idx, &amp;oap); idx++) &#123;</div><div class=\"line\">        mAssetPaths.add(oap);</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">    if (mResources != NULL) &#123;</div><div class=\"line\">        appendPathToResTable(ap);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>asset_path结构体存储文件路径、文件类型等，结构体定义如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct asset_path</div><div class=\"line\">&#123;</div><div class=\"line\">    asset_path() : path(&quot;&quot;), type(kFileTypeRegular), idmap(&quot;&quot;), isSystemOverlay(false) &#123;&#125;</div><div class=\"line\">    String8 path;</div><div class=\"line\">    FileType type;</div><div class=\"line\">    String8 idmap;</div><div class=\"line\">    bool isSystemOverlay;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>kAppZipName一般为null，static const char* kAppZipName = NULL; //“classes.jar”;</p>\n</li>\n<li>如果已经在mAssetPaths，就反悔</li>\n<li>如果路径下没有AndroidManifest.xml文件，返回false</li>\n<li>添加到mAssetPaths中</li>\n<li>appendPathToResTable将资源进行解析添加</li>\n</ul>\n<h4 id=\"AssetManager-appendPathToResTable\"><a href=\"#AssetManager-appendPathToResTable\" class=\"headerlink\" title=\"AssetManager::appendPathToResTable\"></a>AssetManager::appendPathToResTable</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool AssetManager::appendPathToResTable(const asset_path&amp; ap) const &#123;</div><div class=\"line\">    // skip those ap&apos;s that correspond to system overlays</div><div class=\"line\">    if (ap.isSystemOverlay) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Asset* ass = NULL;</div><div class=\"line\">    ResTable* sharedRes = NULL;</div><div class=\"line\">    bool shared = true;</div><div class=\"line\">    bool onlyEmptyResources = true;</div><div class=\"line\">    MY_TRACE_BEGIN(ap.path.string());</div><div class=\"line\">    Asset* idmap = openIdmapLocked(ap);</div><div class=\"line\">    size_t nextEntryIdx = mResources-&gt;getTableCount();</div><div class=\"line\">    ALOGV(&quot;Looking for resource asset in &apos;%s&apos;\\n&quot;, ap.path.string());</div><div class=\"line\">    if (ap.type != kFileTypeDirectory) &#123;</div><div class=\"line\">        if (nextEntryIdx == 0) &#123;</div><div class=\"line\">            // The first item is typically the framework resources,</div><div class=\"line\">            // which we want to avoid parsing every time.</div><div class=\"line\">            sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                mZipSet.getZipResourceTable(ap.path);</div><div class=\"line\">            if (sharedRes != NULL) &#123;</div><div class=\"line\">                // skip ahead the number of system overlay packages preloaded</div><div class=\"line\">                nextEntryIdx = sharedRes-&gt;getTableCount();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (sharedRes == NULL) &#123;</div><div class=\"line\">            ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                mZipSet.getZipResourceTableAsset(ap.path);</div><div class=\"line\">            if (ass == NULL) &#123;</div><div class=\"line\">                ALOGV(&quot;loading resource table %s\\n&quot;, ap.path.string());</div><div class=\"line\">                ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                    openNonAssetInPathLocked(&quot;resources.arsc&quot;,</div><div class=\"line\">                                             Asset::ACCESS_BUFFER,</div><div class=\"line\">                                             ap);</div><div class=\"line\">                if (ass != NULL &amp;&amp; ass != kExcludedAsset) &#123;</div><div class=\"line\">                    ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                        mZipSet.setZipResourceTableAsset(ap.path, ass);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            if (nextEntryIdx == 0 &amp;&amp; ass != NULL) &#123;</div><div class=\"line\">                // If this is the first resource table in the asset</div><div class=\"line\">                // manager, then we are going to cache it so that we</div><div class=\"line\">                // can quickly copy it out for others.</div><div class=\"line\">                ALOGV(&quot;Creating shared resources for %s&quot;, ap.path.string());</div><div class=\"line\">                sharedRes = new ResTable();</div><div class=\"line\">                sharedRes-&gt;add(ass, idmap, nextEntryIdx + 1, false);</div><div class=\"line\">#ifdef HAVE_ANDROID_OS</div><div class=\"line\">                const char* data = getenv(&quot;ANDROID_DATA&quot;);</div><div class=\"line\">                LOG_ALWAYS_FATAL_IF(data == NULL, &quot;ANDROID_DATA not set&quot;);</div><div class=\"line\">                String8 overlaysListPath(data);</div><div class=\"line\">                overlaysListPath.appendPath(kResourceCache);</div><div class=\"line\">                overlaysListPath.appendPath(&quot;overlays.list&quot;);</div><div class=\"line\">                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);</div><div class=\"line\">#endif</div><div class=\"line\">                sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">                    mZipSet.setZipResourceTable(ap.path, sharedRes);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ALOGV(&quot;loading resource table %s\\n&quot;, ap.path.string());</div><div class=\"line\">        ass = const_cast&lt;AssetManager*&gt;(this)-&gt;</div><div class=\"line\">            openNonAssetInPathLocked(&quot;resources.arsc&quot;,</div><div class=\"line\">                                     Asset::ACCESS_BUFFER,</div><div class=\"line\">                                     ap);</div><div class=\"line\">        shared = false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if ((ass != NULL || sharedRes != NULL) &amp;&amp; ass != kExcludedAsset) &#123;</div><div class=\"line\">        ALOGV(&quot;Installing resource asset %p in to table %p\\n&quot;, ass, mResources);</div><div class=\"line\">        if (sharedRes != NULL) &#123;</div><div class=\"line\">            ALOGV(&quot;Copying existing resources for %s&quot;, ap.path.string());</div><div class=\"line\">            mResources-&gt;add(sharedRes);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ALOGV(&quot;Parsing resources for %s&quot;, ap.path.string());</div><div class=\"line\">            mResources-&gt;add(ass, idmap, nextEntryIdx + 1, !shared);</div><div class=\"line\">        &#125;</div><div class=\"line\">        onlyEmptyResources = false;</div><div class=\"line\"></div><div class=\"line\">        if (!shared) &#123;</div><div class=\"line\">            delete ass;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ALOGV(&quot;Installing empty resources in to table %p\\n&quot;, mResources);</div><div class=\"line\">        mResources-&gt;addEmpty(nextEntryIdx + 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (idmap != NULL) &#123;</div><div class=\"line\">        delete idmap;</div><div class=\"line\">    &#125;</div><div class=\"line\">    MY_TRACE_END();</div><div class=\"line\"></div><div class=\"line\">    return onlyEmptyResources;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>通过openIdmapLocked解析资源包中的idmap表</li>\n<li>ap.type != kFileTypeDirectory，不是目录，就是资源包，如果nextEntryIdx为0，则为framework.apk资源包，解析并保存在sharedRes中，这个是共享的资源。</li>\n<li>sharedRes == NULL 表示为应用资源包，这解析保存在ass中，</li>\n<li>nextEntryIdx == 0 &amp;&amp; ass != NULL，在zygote进程第一次调用才成立，也就是预加载资源，这个时候把framework.apk的资源索引表创建起来，并添加到mZipSet中</li>\n<li>如果是目录，就创建resources.arsc的asset对象，这个不是共享的。</li>\n<li>如果存在sharedRes，就保存到mResources中，否则，这是应用的资源，则把应用的资源加入到mResources中。</li>\n</ul>\n<p>上面的比较乱，总结一下。简单来说就是这样的，就是对资源包进行解析，并加入到mResources中，如果是framework.apk，就是共享的，否则就是应用的资源包，不共享。</p>\n<h3 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">        com.android.internal.R.array.preloaded_drawables);</div></pre></td></tr></table></figure>\n<p>mResources.obtainTypedArray的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public TypedArray obtainTypedArray(@ArrayRes int id)</div><div class=\"line\">        throws NotFoundException &#123;</div><div class=\"line\">    int len = mAssets.getArraySize(id);</div><div class=\"line\">    if (len &lt; 0) &#123;</div><div class=\"line\">        throw new NotFoundException(&quot;Array resource ID #0x&quot;</div><div class=\"line\">                                    + Integer.toHexString(id));</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    TypedArray array = TypedArray.obtain(this, len);</div><div class=\"line\">    array.mLength = mAssets.retrieveArray(id, array.mData);</div><div class=\"line\">    array.mIndices[0] = 0;</div><div class=\"line\">    </div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>先获取id对应的数组长度</li>\n<li>然后根据长度生成TypedArray</li>\n<li><p>最后mAssets.retrieveArray赋值，将资源对应的id写入到java层array.mData中。写入部分代码如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dest[STYLE_TYPE] = value.dataType;</div><div class=\"line\">   dest[STYLE_DATA] = value.data;</div><div class=\"line\">   dest[STYLE_ASSET_COOKIE] = block != kXmlBlock ?</div><div class=\"line\">       static_cast&lt;jint&gt;(res.getTableCookie(block)) : -1;</div><div class=\"line\">   dest[STYLE_RESOURCE_ID] = resid;</div><div class=\"line\">   dest[STYLE_CHANGING_CONFIGURATIONS] = typeSetFlags;</div><div class=\"line\">   dest[STYLE_DENSITY] = config.density;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"getArraySize获取资源id对应的数组长度\"><a href=\"#getArraySize获取资源id对应的数组长度\" class=\"headerlink\" title=\"getArraySize获取资源id对应的数组长度\"></a>getArraySize获取资源id对应的数组长度</h4><p>这是个native方法，对应的实现在android_util_AssetManager.cpp的android_content_AssetManager_getArraySize方法中，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jint android_content_AssetManager_getArraySize(JNIEnv* env, jobject clazz,</div><div class=\"line\">                                                       jint id)</div><div class=\"line\">&#123;</div><div class=\"line\">    AssetManager* am = assetManagerForJavaObject(env, clazz);</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const ResTable&amp; res(am-&gt;getResources());</div><div class=\"line\"></div><div class=\"line\">    res.lock();</div><div class=\"line\">    const ResTable::bag_entry* defStyleEnt = NULL;</div><div class=\"line\">    ssize_t bagOff = res.getBagLocked(id, &amp;defStyleEnt);</div><div class=\"line\">    res.unlock();</div><div class=\"line\"></div><div class=\"line\">    return static_cast&lt;jint&gt;(bagOff);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先将java对象转换为对应的c++对象，上面有说到过，AssetManager中的mobject字段存的是对应c++中，AssetManager对象的地址，因此，我们很容易做到转换</li>\n<li>通过ResTable的getBagLocked方法获取id，对应的数组长度(该方法的实现在ResourceTypes.cpp中)，实现太长，看不懂，略过。</li>\n</ul>\n<h3 id=\"preloadDrawables来说明资源的预加载过程\"><a href=\"#preloadDrawables来说明资源的预加载过程\" class=\"headerlink\" title=\"preloadDrawables来说明资源的预加载过程\"></a>preloadDrawables来说明资源的预加载过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static int preloadDrawables(VMRuntime runtime, TypedArray ar) &#123;</div><div class=\"line\">    int N = ar.length();</div><div class=\"line\">    for (int i=0; i&lt;N; i++) &#123;</div><div class=\"line\">        int id = ar.getResourceId(i, 0);</div><div class=\"line\">        if (false) &#123;</div><div class=\"line\">            Log.v(TAG, &quot;Preloading resource #&quot; + Integer.toHexString(id));</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (id != 0) &#123;</div><div class=\"line\">            if (mResources.getDrawable(id, null) == null) &#123;</div><div class=\"line\">                throw new IllegalArgumentException(</div><div class=\"line\">                        &quot;Unable to find preloaded drawable resource #0x&quot;</div><div class=\"line\">                        + Integer.toHexString(id)</div><div class=\"line\">                        + &quot; (&quot; + ar.getString(i) + &quot;)&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return N;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>首先通过getResourceId获取资源id</li>\n<li>getDrawable获取资源</li>\n</ul>\n<h4 id=\"getResourceId-获取资源id\"><a href=\"#getResourceId-获取资源id\" class=\"headerlink\" title=\"getResourceId 获取资源id\"></a>getResourceId 获取资源id</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int getResourceId(int index, int defValue) &#123;</div><div class=\"line\">    if (mRecycled) &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Cannot make calls to a recycled instance!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    index *= AssetManager.STYLE_NUM_ENTRIES;</div><div class=\"line\">    final int[] data = mData;</div><div class=\"line\">    if (data[index+AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) &#123;</div><div class=\"line\">        final int resid = data[index+AssetManager.STYLE_RESOURCE_ID];</div><div class=\"line\">        if (resid != 0) &#123;</div><div class=\"line\">            return resid;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return defValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>其中STYLE_NUM_ENTRIES为6，</li>\n<li>从赋值id的代码中，知道第四个为id值，因此STYLE_RESOURCE_ID为3</li>\n</ul>\n<h4 id=\"getDrawable\"><a href=\"#getDrawable\" class=\"headerlink\" title=\"getDrawable\"></a>getDrawable</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Drawable getDrawable(@DrawableRes int id, @Nullable Theme theme) throws NotFoundException &#123;</div><div class=\"line\">    TypedValue value;</div><div class=\"line\">    synchronized (mAccessLock) &#123;</div><div class=\"line\">        value = mTmpValue;</div><div class=\"line\">        if (value == null) &#123;</div><div class=\"line\">            value = new TypedValue();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mTmpValue = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        getValue(id, value, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    final Drawable res = loadDrawable(value, id, theme);</div><div class=\"line\">    synchronized (mAccessLock) &#123;</div><div class=\"line\">        if (mTmpValue == null) &#123;</div><div class=\"line\">            mTmpValue = value;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>getValue查找与id对应的资源，没找到对应的就抛出NotFoundException异常</li>\n<li>loadDrawable 去加载</li>\n</ul>\n<p>在getValue中，会调用AssetManager的getResourceValue方法，这个是native方法，实现在android_uitl_AssetManager.cpp的android_content_AssetManager_loadResourceValue中</p>\n<h5 id=\"android-content-AssetManager-loadResourceValue\"><a href=\"#android-content-AssetManager-loadResourceValue\" class=\"headerlink\" title=\"android_content_AssetManager_loadResourceValue\"></a>android_content_AssetManager_loadResourceValue</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">static jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,</div><div class=\"line\">                                                           jint ident,</div><div class=\"line\">                                                           jshort density,</div><div class=\"line\">                                                           jobject outValue,</div><div class=\"line\">                                                           jboolean resolve)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (outValue == NULL) &#123;</div><div class=\"line\">         jniThrowNullPointerException(env, &quot;outValue&quot;);</div><div class=\"line\">         return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    AssetManager* am = assetManagerForJavaObject(env, clazz);</div><div class=\"line\">    if (am == NULL) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    const ResTable&amp; res(am-&gt;getResources());</div><div class=\"line\"></div><div class=\"line\">    Res_value value;</div><div class=\"line\">    ResTable_config config;</div><div class=\"line\">    uint32_t typeSpecFlags;</div><div class=\"line\">    ssize_t block = res.getResource(ident, &amp;value, false, density, &amp;typeSpecFlags, &amp;config);</div><div class=\"line\">    if (kThrowOnBadId) &#123;</div><div class=\"line\">        if (block == BAD_INDEX) &#123;</div><div class=\"line\">            jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    uint32_t ref = ident;</div><div class=\"line\">    if (resolve) &#123;</div><div class=\"line\">        block = res.resolveReference(&amp;value, block, &amp;ref, &amp;typeSpecFlags, &amp;config);</div><div class=\"line\">        if (kThrowOnBadId) &#123;</div><div class=\"line\">            if (block == BAD_INDEX) &#123;</div><div class=\"line\">                jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (block &gt;= 0) &#123;</div><div class=\"line\">        return copyValue(env, outValue, &amp;res, value, ref, block, typeSpecFlags, &amp;config);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return static_cast&lt;jint&gt;(block);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>得到ResTable对象</li>\n<li>resolveReference查找是否有匹配的资源</li>\n<li>如果有，就将数据复制给copyValue这个java层对象</li>\n</ul>\n<p>具体的代码就不往下追了。</p>\n<h5 id=\"loadDrawable\"><a href=\"#loadDrawable\" class=\"headerlink\" title=\"loadDrawable\"></a>loadDrawable</h5><p>经过上面的步骤，资源的信息就保存在了TypedValue中，解析来就是通过loadDrawable去加载了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\">Drawable loadDrawable(TypedValue value, int id, Theme theme) throws NotFoundException &#123;</div><div class=\"line\">    if (TRACE_FOR_PRELOAD) &#123;</div><div class=\"line\">        // Log only framework resources</div><div class=\"line\">        if ((id &gt;&gt;&gt; 24) == 0x1) &#123;</div><div class=\"line\">            final String name = getResourceName(id);</div><div class=\"line\">            if (name != null) &#123;</div><div class=\"line\">                Log.d(&quot;PreloadDrawable&quot;, name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final boolean isColorDrawable;</div><div class=\"line\">    final DrawableCache caches;</div><div class=\"line\">    final long key;</div><div class=\"line\">    if (value.type &gt;= TypedValue.TYPE_FIRST_COLOR_INT</div><div class=\"line\">            &amp;&amp; value.type &lt;= TypedValue.TYPE_LAST_COLOR_INT) &#123;</div><div class=\"line\">        isColorDrawable = true;</div><div class=\"line\">        caches = mColorDrawableCache;</div><div class=\"line\">        key = value.data;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        isColorDrawable = false;</div><div class=\"line\">        caches = mDrawableCache;</div><div class=\"line\">        key = (((long) value.assetCookie) &lt;&lt; 32) | value.data;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // First, check whether we have a cached version of this drawable</div><div class=\"line\">    // that was inflated against the specified theme.</div><div class=\"line\">    if (!mPreloading) &#123;</div><div class=\"line\">        final Drawable cachedDrawable = caches.getInstance(key, theme);</div><div class=\"line\">        if (cachedDrawable != null) &#123;</div><div class=\"line\">            return cachedDrawable;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Next, check preloaded drawables. These may contain unresolved theme</div><div class=\"line\">    // attributes.</div><div class=\"line\">    final ConstantState cs;</div><div class=\"line\">    if (isColorDrawable) &#123;</div><div class=\"line\">        cs = sPreloadedColorDrawables.get(key);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Drawable dr;</div><div class=\"line\">    if (cs != null) &#123;</div><div class=\"line\">        dr = cs.newDrawable(this);</div><div class=\"line\">    &#125; else if (isColorDrawable) &#123;</div><div class=\"line\">        dr = new ColorDrawable(value.data);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        dr = loadDrawableForCookie(value, id, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Determine if the drawable has unresolved theme attributes. If it</div><div class=\"line\">    // does, we&apos;ll need to apply a theme and store it in a theme-specific</div><div class=\"line\">    // cache.</div><div class=\"line\">    final boolean canApplyTheme = dr != null &amp;&amp; dr.canApplyTheme();</div><div class=\"line\">    if (canApplyTheme &amp;&amp; theme != null) &#123;</div><div class=\"line\">        dr = dr.mutate();</div><div class=\"line\">        dr.applyTheme(theme);</div><div class=\"line\">        dr.clearMutated();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If we were able to obtain a drawable, store it in the appropriate</div><div class=\"line\">    // cache: preload, not themed, null theme, or theme-specific.</div><div class=\"line\">    if (dr != null) &#123;</div><div class=\"line\">        dr.setChangingConfigurations(value.changingConfigurations);</div><div class=\"line\">        cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return dr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>根据判断是否是ColorDrawable，赋值不同的cache和key</li>\n<li>如果不是预加载，就从cache中找，找到返回</li>\n<li>从预加载数组中得到key对应的ConstantState</li>\n<li>根据cs是否为null以及是不是ColorDrawable，来得到的Drawable</li>\n<li>设置主题相关的</li>\n<li>进行缓存</li>\n</ul>\n<p>而我们预加载资源的主要过程是loadDrawableForCookie。这个方法是从xml或者流里面加载Drawable。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (file.endsWith(&quot;.xml&quot;)) &#123;</div><div class=\"line\">    final XmlResourceParser rp = loadXmlResourceParser(</div><div class=\"line\">            file, id, value.assetCookie, &quot;drawable&quot;);</div><div class=\"line\">    dr = Drawable.createFromXml(this, rp, theme);</div><div class=\"line\">    rp.close();</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    final InputStream is = mAssets.openNonAsset(</div><div class=\"line\">            value.assetCookie, file, AssetManager.ACCESS_STREAMING);</div><div class=\"line\">    dr = Drawable.createFromResourceStream(this, value, is, file, null);</div><div class=\"line\">    is.close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于Drawable的生成过程，这里就不说了。</p>\n<h3 id=\"占坑\"><a href=\"#占坑\" class=\"headerlink\" title=\"占坑\"></a>占坑</h3><ul>\n<li>aapt资源打包过程</li>\n<li>其他</li>\n</ul>\n<h3 id=\"最近访客\"><a href=\"#最近访客\" class=\"headerlink\" title=\"最近访客\"></a>最近访客</h3><ul class=\"ds-recent-visitors\" data-num-items=\"46\" data-avatar-size=\"40\"></ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciy1ncy0x0001hws6fbjewxfb","category_id":"ciy1ncy130003hws6hfoeq6f7","_id":"ciy1ncy1o000chws6c1msmwiz"},{"post_id":"ciy1ncy1l000bhws6elqdnk59","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy1r000ihws6770ovf18"},{"post_id":"ciy1ncy110002hws6a6zyfwqu","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy1u000nhws6uhyc1bqf"},{"post_id":"ciy1ncy1o000dhws6l7m1v33u","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy1x000qhws6tvok6g6q"},{"post_id":"ciy1ncy1q000hhws6ke0hw1wi","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy23000vhws6cxegs970"},{"post_id":"ciy1ncy170005hws6j3hsp7em","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy25000yhws6tq2vqalf"},{"post_id":"ciy1ncy1s000khws6wsklhiqu","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy270012hws630gt38ps"},{"post_id":"ciy1ncy1v000phws63rf9lk5b","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2a0015hws6ah4hzf2h"},{"post_id":"ciy1ncy1h0006hws6f7dvf3jq","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2c0019hws6ef1t8ptc"},{"post_id":"ciy1ncy1y000shws600aawelc","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2d001chws61r3q3aa5"},{"post_id":"ciy1ncy23000xhws6rp4on9ze","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2e001fhws6tdmblu8q"},{"post_id":"ciy1ncy1i0007hws6xvjw9d5b","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2h001jhws6uxaack7p"},{"post_id":"ciy1ncy250010hws6wgzsjnwl","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2j001mhws6hb9zttwr"},{"post_id":"ciy1ncy2b0017hws6a1v2jjxq","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2l001qhws67m1zg3uw"},{"post_id":"ciy1ncy2c001bhws658xk526i","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2m001thws6oq0xqu4o"},{"post_id":"ciy1ncy2d001ehws601hdgblp","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2o001xhws6mog8349e"},{"post_id":"ciy1ncy2f001ihws6zszfl4kb","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2p0020hws6uy85jgpu"},{"post_id":"ciy1ncy2h001lhws6akaaqpj1","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2s0025hws6if2fetep"},{"post_id":"ciy1ncy2k001phws62dm1qq73","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2t0028hws6zn5gr3lb"},{"post_id":"ciy1ncy2l001shws6jnqu9ilu","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2u002chws6iswgs94h"},{"post_id":"ciy1ncy2n001vhws608neprhk","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2v002ghws6tnxu2d7k"},{"post_id":"ciy1ncy2q0022hws6tugxbcqr","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy2w002khws6ez9459lc"},{"post_id":"ciy1ncy2o001zhws6w71r8ojz","category_id":"ciy1ncy2s0024hws69b4i8ihg","_id":"ciy1ncy2x002ohws6mawgf6xk"},{"post_id":"ciy1ncy2s0027hws6ixjkovr8","category_id":"ciy1ncy2v002fhws6jijcil10","_id":"ciy1ncy32002uhws676i7fa97"},{"post_id":"ciy1ncy2x002mhws6o1xgo104","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy33002yhws66b90o7ys"},{"post_id":"ciy1ncy2t002ahws64rres9rw","category_id":"ciy1ncy2v002fhws6jijcil10","_id":"ciy1ncy340031hws6r36qhrn5"},{"post_id":"ciy1ncy2z002thws6vxmxf7ob","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy350035hws68upiwq0i"},{"post_id":"ciy1ncy2u002ehws6uflypwcl","category_id":"ciy1ncy2v002fhws6jijcil10","_id":"ciy1ncy360037hws6bmazi0s0"},{"post_id":"ciy1ncy350034hws6d73kvpbm","category_id":"ciy1ncy1j0008hws6s9o6guw4","_id":"ciy1ncy37003bhws6x05mqoi4"},{"post_id":"ciy1ncy2w002ihws6cadt4iau","category_id":"ciy1ncy340032hws6jqro36uw","_id":"ciy1ncy38003fhws6ysvschqt"},{"post_id":"ciy1ncy2x002qhws64pjnxzsp","category_id":"ciy1ncy340032hws6jqro36uw","_id":"ciy1ncy38003hhws6h881ndcr"},{"post_id":"ciy1ncy32002xhws6jjpd2qyb","category_id":"ciy1ncy37003dhws6onzphdwu","_id":"ciy1ncy39003lhws6ac4yx2du"},{"post_id":"ciy1ncy330030hws69227guug","category_id":"ciy1ncy37003dhws6onzphdwu","_id":"ciy1ncy3a003nhws6c2u13nld"}],"PostTag":[{"post_id":"ciy1ncy0x0001hws6fbjewxfb","tag_id":"ciy1ncy160004hws6bp7xi4ht","_id":"ciy1ncy1k000ahws6z2zxe2ge"},{"post_id":"ciy1ncy1l000bhws6elqdnk59","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy1q000ghws6bpjc2n3g"},{"post_id":"ciy1ncy110002hws6a6zyfwqu","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy1r000jhws6rsodujzd"},{"post_id":"ciy1ncy1q000hhws6ke0hw1wi","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy1u000ohws6ms8ci8j9"},{"post_id":"ciy1ncy170005hws6j3hsp7em","tag_id":"ciy1ncy1p000fhws6or18lyi1","_id":"ciy1ncy1x000rhws6ed2u33et"},{"post_id":"ciy1ncy1s000khws6wsklhiqu","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy23000whws62eqo24fn"},{"post_id":"ciy1ncy1h0006hws6f7dvf3jq","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy25000zhws6yvmxa1cn"},{"post_id":"ciy1ncy1y000shws600aawelc","tag_id":"ciy1ncy1p000fhws6or18lyi1","_id":"ciy1ncy280013hws6tao2np47"},{"post_id":"ciy1ncy23000xhws6rp4on9ze","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy2a0016hws6kgxccjdu"},{"post_id":"ciy1ncy1i0007hws6xvjw9d5b","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy2c001ahws6d17zuxjt"},{"post_id":"ciy1ncy250010hws6wgzsjnwl","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy2d001dhws60obykpiu"},{"post_id":"ciy1ncy1o000dhws6l7m1v33u","tag_id":"ciy1ncy1p000fhws6or18lyi1","_id":"ciy1ncy2e001ghws6zmy03tbc"},{"post_id":"ciy1ncy2b0017hws6a1v2jjxq","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy2h001khws61xqahgnl"},{"post_id":"ciy1ncy1v000phws63rf9lk5b","tag_id":"ciy1ncy2b0018hws66be3bcr8","_id":"ciy1ncy2j001nhws6wfwkslak"},{"post_id":"ciy1ncy2d001ehws601hdgblp","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy2l001rhws64n8s7xo7"},{"post_id":"ciy1ncy280014hws6jvb9u5cy","tag_id":"ciy1ncy2b0018hws66be3bcr8","_id":"ciy1ncy2m001uhws6tdtcsmk0"},{"post_id":"ciy1ncy2k001phws62dm1qq73","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy2o001yhws6qww772rk"},{"post_id":"ciy1ncy2l001shws6jnqu9ilu","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy2p0021hws6gkjyw2ea"},{"post_id":"ciy1ncy2c001bhws658xk526i","tag_id":"ciy1ncy2j001ohws6p6566l0j","_id":"ciy1ncy2s0026hws68kxrwfc5"},{"post_id":"ciy1ncy2n001vhws608neprhk","tag_id":"ciy1ncy2j001ohws6p6566l0j","_id":"ciy1ncy2t0029hws6jq0yvs7q"},{"post_id":"ciy1ncy2f001ihws6zszfl4kb","tag_id":"ciy1ncy2j001ohws6p6566l0j","_id":"ciy1ncy2u002dhws6ngl55q2l"},{"post_id":"ciy1ncy2q0022hws6tugxbcqr","tag_id":"ciy1ncy2j001ohws6p6566l0j","_id":"ciy1ncy2w002hhws66elpt1ad"},{"post_id":"ciy1ncy2h001lhws6akaaqpj1","tag_id":"ciy1ncy2j001ohws6p6566l0j","_id":"ciy1ncy2w002lhws6z9jlu0oo"},{"post_id":"ciy1ncy2o001zhws6w71r8ojz","tag_id":"ciy1ncy2u002bhws6jagswc1z","_id":"ciy1ncy2x002phws6sq03igmd"},{"post_id":"ciy1ncy2x002mhws6o1xgo104","tag_id":"ciy1ncy2j001ohws6p6566l0j","_id":"ciy1ncy2z002shws6tbd6wqqv"},{"post_id":"ciy1ncy2s0027hws6ixjkovr8","tag_id":"ciy1ncy2w002jhws6na0do9wl","_id":"ciy1ncy32002whws6zp0y37qc"},{"post_id":"ciy1ncy2t002ahws64rres9rw","tag_id":"ciy1ncy2w002jhws6na0do9wl","_id":"ciy1ncy350033hws6fzvctcf7"},{"post_id":"ciy1ncy2u002ehws6uflypwcl","tag_id":"ciy1ncy2w002jhws6na0do9wl","_id":"ciy1ncy360038hws6na76x222"},{"post_id":"ciy1ncy350034hws6d73kvpbm","tag_id":"ciy1ncy1j0009hws6gb61isyd","_id":"ciy1ncy37003ahws65eq8t4u6"},{"post_id":"ciy1ncy2w002ihws6cadt4iau","tag_id":"ciy1ncy360036hws66u9lq82w","_id":"ciy1ncy38003ehws65aawyxk4"},{"post_id":"ciy1ncy2x002qhws64pjnxzsp","tag_id":"ciy1ncy360036hws66u9lq82w","_id":"ciy1ncy38003ihws6pfk9fn8p"},{"post_id":"ciy1ncy2z002thws6vxmxf7ob","tag_id":"ciy1ncy38003ghws638asiwe0","_id":"ciy1ncy3b003ohws6y9ksd105"},{"post_id":"ciy1ncy2z002thws6vxmxf7ob","tag_id":"ciy1ncy39003khws6ddhecmg5","_id":"ciy1ncy3b003phws6hlh4lw89"},{"post_id":"ciy1ncy32002xhws6jjpd2qyb","tag_id":"ciy1ncy39003mhws6tuvc7bli","_id":"ciy1ncy3c003rhws6u0mc5arz"},{"post_id":"ciy1ncy330030hws69227guug","tag_id":"ciy1ncy39003mhws6tuvc7bli","_id":"ciy1ncy3c003shws6dntgy77v"}],"Tag":[{"name":"计划总结","_id":"ciy1ncy160004hws6bp7xi4ht"},{"name":"framework","_id":"ciy1ncy1j0009hws6gb61isyd"},{"name":"jni","_id":"ciy1ncy1p000fhws6or18lyi1"},{"name":"源码","_id":"ciy1ncy2b0018hws66be3bcr8"},{"name":"fresco","_id":"ciy1ncy2j001ohws6p6566l0j"},{"name":"hexo","_id":"ciy1ncy2u002bhws6jagswc1z"},{"name":"jvm","_id":"ciy1ncy2w002jhws6na0do9wl"},{"name":"gradle","_id":"ciy1ncy360036hws66u9lq82w"},{"name":"android","_id":"ciy1ncy38003ghws638asiwe0"},{"name":"消息机制","_id":"ciy1ncy39003khws6ddhecmg5"},{"name":"shell","_id":"ciy1ncy39003mhws6tuvc7bli"}]}}