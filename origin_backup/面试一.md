
### java基础部分

#### io & nio

* NIO
	* buffer
		* byte char double float int long short 
		* mark标记、position位置、limit界限、capacity容量
		* 读取写入buffer中的数据的时候，要调用flip函数
	* channel
		* filechannel datagramchannel udp，socketchannel tcp client、serversocketchannel tcp server	
	* selector  
* pipe 管道，
* 内存映射文件 MappedByteBuffer

#### 并发类

* atomic 原子类，靠sun的unsafe类基于cas实现的,基于cpu的cas指令，可以看成是无阻塞的
* locks
	* condition 条件
	* reentrantlock 可重入锁，同一线程，外层函数获取锁之后，内层函数仍然可以获取锁。synchronized也是可重入锁。
	* ReentrantReadWriteLock 可重入读写所，可以实现公平锁。
	* 锁升级、锁降级、比如说写入锁，在不释放的情况下，可使用读锁，这时候并不会阻塞，因为写入锁降级成了读锁。
* 并发集合类，
* 线程池Executors,静态方法创建线程池，
	* newFixedThreadPool 指定线程数目
	* newCachedThreadPool 可缓存线程池
	* newScheduledThreadPool 可周期性执行任务的线程池
	* newSingleThreadExecutor 单一工作线程的线程池
	* newWorkStealingPool
	* ThreadPoolExecutor参数
		* corePoolSize 核心线程数
		* maximumPoolSize 最大线程数
		* keepAliveTime 存活时间
		* unit 时间单位
		* workQueue 阻塞队列
		
* Exchanger 交换器，两个线程都到达公共点，即可实现数据交换
* CyclicBarrier 可重复使用的屏障，reset方法重置。
* CountDownLatch 计数的同步工具
* Phaser 同步工具，可实现CyclicBarrier和CountDownLatch的功能。相位器
* Fork/Join 工作窃取，是空闲线程也做一些任务，提高CPU利用率。
* semaphore 信号量
* 阻塞队列
* cas(compare and swap) aba问题
	* 解决办法 加修改值计数器 
* volatile 最轻量的同步机制，
	* 运算结果 不依赖当前值
	* 变量不需要与其他的状态变量共同参与不变约束
	* 第二个语义是禁止指令集重排
* 锁优化
	* 自旋锁与自适应旋转，线程执行一个循环(自旋)，循环到一定次数挂起(自适应旋转)
	* 锁消除 检测不到竞争资源的时候，取消锁
	* 锁粗化 检测到一串操作都对一个对象进行加锁，就会把加锁操作扩展都整个操作序列的外部。
	* 轻量级锁，
	* 偏向锁 偏向第一个获取它的线程，如果接下来的过程，没有被其他线程获取，持有偏向锁的线程讲永远不需要进行同步。  

#### 集合类

* ArrayList 基于数组，访问速度快，插入数据需要进行数组copy操作，慢
* LinkedList 实现了list、deque、queue几个接口，可做链表、队列、双端队列,双向链表
* HashMap 刚开始是散列表，超过8个之后，转化为红黑树。
* LinkedHashMap 保存了记录的插入顺序


### jvm部分

#### 内存模型

jvm内存区域分为：

* 线程私有
	* 程序计数器 记录字节码指令的行号指示器
	* 虚拟机栈 方法的执行帧栈，每一帧包括，局部变量表、操作数栈、动态链接、返回地址
	* 本地方法栈 对应native方法
* 线程共享 
	* 方法区，包括运行时常量池，被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据
	* java堆 对象

#### gc策略

* 引用计数(java中未使用)
* 标记-清理 标记出需要gc的，然后进行清理，内存碎片
* 复制 两块小+一块大。每次使用一块小Survivor和一块大区域Eden，讲存活对象赋值到另外的
* 标记-整理 标记，存活对象向一端移动

新生代适合复制，老生代适合标记-清理，标记-整理这些

可达性分析，判断gc root

* 虚拟机栈(帧栈中的本地变量表)中的引用对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中引用的对象

自我救赎，就是在finalize方法中，重新引用，只能救赎一次。

方法区的回收，对应类的卸载，触发条件比较难。

* 该类的所有实例都被回收
* 该类classloader被回收
* 对象的java.lang.class对象在任何地方都没被引用，无法反射


垃圾收集器:

* Serial(old) 串行 新生代 复制，老生代 标记-整理
* ParNew 并行复制
* Parallel(old)  复制、标记整理，并发
* CMS Concurrent Mark Sweep，初始标记 并发标记 重新标记 并发清除
* G1 面向服务端的收集器，初始标记 并发标记 最终标记 删选

内存分配策略：

* 优先在Survivor(新生代)分配
* 大对象进入老生代
* 长期存活的对象进入老生代，年龄计数，每躲过一个gc+1，到达阈值进入老生代
* 动态年龄判断，如果某个年龄段的大于空间的一半，则大于等于这个的进入老生代
* 空间分配担保
	* minor gc 新生代gc
	* major gc 老生代gc
	* 如果Eden连续内存小于新生代存活的，看是否允许进行担保，如果大，看是否允许进行担保，如果允许，看连续空间是否大于历次晋升的平均值
	 
 
#### 类加载机制

加载 验证 准备 解析 初始化 使用 卸载

* 加载
	* 通过类的全限定名来获取类的二进制流
	* 将这个二进制流所代表的静态存储结构转化为方法区的运行时数据
	* 在内存中生成一个Class对象，作为访问这个类的各种数据的入口
	* 从zip包
	* 从网络中
	* 运行时计算生成 动态代理
	* 由其他文件生成 jsp
	* 从数据库中读取
	* 数组类有jvm创建
* 验证
	* 看Class文件的字节流中包含的信息符合当前虚拟机规范，不会影响虚拟机安全
	* 文件格式验证
		* 魔数开头，主次版本号、常量池中的类型等等
	* 元数据验证 语义分析
		* 是否有父类
		* 继承了不被允许的类
		* 如果不是抽象类，是否实现了所有方法
		* 方法 字段是否和父类产生矛盾
	* 字节码验证 语法分析
		* 类型转换安全、跳转指定不会跳转到方法以外的字节码上
	* 符号引用验证 
		* 符号引用中能否通过字符串描述的全限定名找到类
		* 符号引用中的类、字段、方法的访问性是否可被当前类引用 
* 准备
	* 为类变量分配内存并设置变量的初值(零值)，不包括实例变量，如果被final修饰就不是零值了 
* 解析
	* 将常量池中的符号引用解析为直接引用的过程，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符
* 初始化
	* 初始化类变量和其他资源，执行构造器方法 
	* 构造器方法 由所有类变量的赋值操作和静态语句块合成。
* 使用 
* 卸载

双亲委托模型

* bootstarp classloader
* extenion classloader
* application classloader

#### jvm优化

* 编译时优化
	* 常量折叠 
	* 泛型擦除、自动拆箱装箱、
	* 条件编译
* 运行时优化 C1\C2编译器，热点代码进行jit优化
	* 热点代码，被多次调用的方法体，将代码编译成本地代码，进行简单、可靠的优化，多次执行的循环体，栈上替换
	* 判断热点代码的方法
		* 基于采样的热点探测
		* 基于计数器的热点探测
	* 编译优化技术
		* 方法内联、去除方法调用成本
		* 冗余访问消除
		* 复写传播
		* 无用代码消除
		* 公共子表达式消除
		* 数据边界检查消除
		* 逃逸分析，分析对象的动态作用域，
			* 栈上分配
			* 同步消除
			* 标量替换

		
#### 高效并发部分

volatile:

### android基础部分


#### Jsbridge

通过js的几个回调函数。

* shouldOverrideUrlLoading
* onConsoleMessage
* onJsPrompt
* https://gold.xitu.io/entry/573534f82e958a0069b27646

#### AsyncTask

之前串行，后来改成并行，4.1之后又改回串行，防止并行时错误。handler和thread的替换，但是仍然合一并发执行。

缺点:

* 耗费cpu资源，容易fc
* 如果已经执行，cancel取消了，doinbackgroun还会继续执行
* 内存泄漏
* 并行串行问题

#### 5.0、6.0、7.0 特性

5.0 的metraildesign
6.0 的运行时动态权限
7.0 的fileprovider

#### XML解析

dom 一次性全加载进内存，
sax 无法跳跃 修改 删除
pull 

#### recyclerview源码解析

多级缓存，

listview的recyclerbin，两层

* 当前活动的
* 废弃的


recyclerview的recycler

* mAttachedScrap 屏幕内itemview快速复用，
* mCachedViews 默认上线为2，即缓存屏幕外2个itemview
* mViewCacheExtension 不直接使用，需要用户在定制
* mRecyclerPool 默认上限为5，可以共享


#### view方面

* View的绘制原理

	view经过三个步骤，onmeasure,onlayout,ondraw三个步骤。测量 布局 绘制。测量模式，unspecified 不指定大小，想要多大就多大，exactly，指定大小，但是最大不会超过父布局，at_most，想要多大就多大，相当于wrap_content，measurespec 为32位，高二位为模式，低30位为大小。在onmeasure里进行布局的计算，在onlayout里进行布局，然后ondraw进行绘制。
	touchslop 滑动的最小距离
	velocitytracker 速度追踪
	gesturedetector 手势检测
	scroller
	motionevent 事件
	
	ondraw过程，绘制背景、绘制自己、绘制child，绘制装饰如	scrollerbar.
	invalidate和postinvalidate，
	reqeustlayout
* View的事件分发
	dispatchtouchevent 分发事件
	onintercepttouchevent 拦截事件
	ontouchevent 消耗事件
	
	事件传递的顺序，activity->window->view，冒泡的方式，如果没人处理，就反向冒泡
* 滑动冲突和处理办法
* 自定义view
	* 继承现有的view，重写部分方法，如listview嵌套问题
	* 继承现有的view并进行扩展 展开更多textview
	* 对view进行组合，形成layout
	* 继承viewgroup
	* 自己draw的view
* viewroot、链接phonewindow和decorview的桥梁，viewroot的实现类是viewrootimpl，window的实现类是phonewindow，decorview是view的最上层，包括状态栏和contentview两个部分。
	viewrootimpl#performMeasure->view#measure# ->view#onmeasure
	
	layout就是确定，top，left，right，bottom四个位置。
	
	

#### 事件分发机制

* dispatchtouchevent  分发
* oninterceptevent 拦截
* ontouchevent 消耗

ontouchlistener>ontouchevent>onclicklistener


```
dispatchtouchevent(){
	boolean custom = false;
	if(onintercepttouchevent()){
		custom = ontouch()
	}else{
		custom = child.dispatchouchevent
	}
	
	return custom;
	
}

```

activity->window->view

如果都没处理，就向上。如果都不处理，就会调用activity的ontouch方法。


viewm没有onintercepttouchevent,传给他就必须处理。

内部拦截法 设置标志位 让父控件不拦截事件，父控件不拦截

外部拦截法 父控件拦截








#### 消息机制

* java部分 
	* 一个Looper对应一个MessageQueue，并不断从MessageQueue中取出消息，交给handler处理 
	* Looper loop方法从MessageQueue中不断取出消息进行处理，死循环，从消息队列中取出消息并交给handler处理
	* Handler 发送消息、处理消息
	* MessageQueue 消息队列，会在空闲的情况下执行一些空闲任务。单链表
		* 插入消息，根据时间点来插入消息，如果native是阻塞状态，则进行nativewake，在epoll监听的管道一端写入一个字符，就唤醒epoll了,然后nativepollonce就会返回，然后继续处理java层的消息了。
		* next 取出消息.如果没有消息，native的messagequeue就会进入阻塞状态
* native部分
	* NativeMessageQueue
	* Looper 初始化epoll句柄，
	* 在java层的next方法中，会调用nativePollOnce去提取native层的消息，当java层的messagequeue为空的时候，就会进入阻塞状态，
* ThreadLocal 
* nativemessage>nativerequest>javamessage
* epoll/select/poll
	* epoll监听的句柄数没有限制
	* IO效率不会随着监听fd的数目增长而下降
	* epoll_create()\epoll_ctl()	 


#### 动画

* 插值器 Interpolator 计算关键帧
* 估值器 TypeEvaluator 根据时间的流逝来计算改变后的值
* 属性动画 valueanimator objectanimator
* 补间动画
* 帧动画

属性动画的工作原理:通过修改属性值来达到动画的效果。KeyframeSet 关键帧集合,通过set方法来修改值。


### Android里的classloader

* basedexclassloader
	* pathclassloader
	* dexclassloader 

### 性能优化部分

#### VSYNC垂直同步和三级缓存


#### 图片OOM 内存优化

* 图片压缩,options
* 三级缓存,disklrucache,lrucache
* OnTrimMemory
* 及时回收(如广告页的图片)
* lrucache的原理，LinkedHashMap第三个参数传true，可以按照最近最少访问去排序。

#### 内存泄漏

* LeackCancry ，构建若引用队列，通过查看队列中的对象来判断
* MAT工具，查看GC Root的方式
* context使用不当的内存泄漏
* 非静态内部类造成的内存泄漏
* thread、handler、timer等造成的内存泄漏
* 对象的注册、反注册
* 游标、资源等

#### 布局优化

* HierarchyViewer查看布局
* 开发者选项 打开过度绘制
* Lint进行检查
* Traceview 查看耗时方法
* 减少布局层次
* 去除不必要的背景
* inflate、merge、viewstub

#### ANR 查看

traces.txt文件，查看ANR

#### 电量优化



#### 其他

* SparseArray
* 预先加载
* 延时加载

### 开源框架部分

#### retrofit

retrofit通过动态代理和运行时注解，讲注解方法的注解信息解析出来，拼成完整的http 请求头和请求体，通过okhttp去发送和接受请求，并进行后续处理。

性能问题呢？

不用考虑性能问题，现在运行时注解效率也不是很差，而且会将使用过的方法进行缓存。

适配器问题？

用适配器模式，进行适配。

#### okhttp

* 拦截器的设计
* 缓存的设计
* socket通道复用
* 失败重连机制
* 缓存 disklrucache

#### eventbus

讲注册的方法收集起来，发送消息的时候，找到匹配的，调用。

#### fresco

三级缓存。已解码的数据、未解码的数据、disklrucache

已解码的数据，在android 5.0 之下，存在匿名共享内存中，在5.0之上，存在java堆，

未解码的数据，存在native堆中。

匿名共享内存，通过BitmapFactory.options的inPurgeable属性，设为true之后，将存在匿共享内存中，通过pin和unpin两个native操作，对应bitmap.h中的AndroidBitmap_lockPixels,和AndroidBitmap_unlockPixels两个方法去实现，并且需要开启inMutable，因为复用问题。

native堆：通过malloc，memcpy，free等函数去做内存操作。这部分内存需要需要手动管理。

1 2 4 8 16 等大小，去选择存放的桶。

如何控制优先级呢？

通过DraweeHolder的onVisibilityChange中，根据可见性调用DraweeController的onAttach或者onDetach方法，去控制下载还是暂停等。

流水线式的生产方式?

当一个处理完之后，就交给下一个去处理。

根据不同的图片类型，选择不同的decode方法，图片类型可以根据前几个字节判断出来。

学到了什么？

* 通过反射构造类对象的方法
* 匿名共享内存、native内存操作
* 类似智能指针一样的cloaseableimage

#### deeplinkdispatch

在一个activity里接收，通过不同的url和参数来启动不同的activity。
	
### framework

#### binder

* IOCTL
* kernel BINDER驱动
* native层 BpBinder(客户端) BBinder(服务端) IBinder
* java层 BinderProxy(客户端) Binder 服务端
* servicemanager 启动和管理系统服务



  ActivityManagerService(服务端)对象，继承自ActivityManagerNative，他的asInterface方法返回AMN的内部类，AMP，这是一个代理类，在ActivityManagerProxy中，传入了远程的binder对象，amp类的一些方法中，会通过远程binder对象的transact方法，调用到onTransact方法，amn的这个方法根据code选择不同的方法，具体的实现在ams中。
  
  aidl文件来说binder。
  
  	* DESCRIPTOR
  	* stub类 服务端
  		* asInterface 如果是本线程，就返回binder本身，如果不是，就返回proxy代理类，
  		* asBinder 返回binder本身
  		* onTransact 根据code去处理
  	* Proxy类 客户端
  	* 死亡代理  DeathDecipient
  	
binder线程池，一个service服务端，根据不同的code，返回不同的binder远程对象。

* servicemanager
* servicemanagerproxy
* servicemanagernative，servicemanagerservice
* binder
* binderinternal
* ibinder
  	
  	
binder的好处？

* 性能好，管道 消息队列等都需要拷贝两次数据，而binder只需要一次，仅次于匿名共享内存
* 稳定性 binder是c/s架构，稳定性高于共享内存
* 安全性 通过uid来保证安全性

binder实现跨进程数据传输的流程?

* bp 写入数据调用transact方法，传输code，数据，返回数据，flag，然后等待数据传回结果。
* bn端 触发ontransact方法，根据code处理数据，将结果写入reply，传回
* 如果发生异常，则写入异常信息。通过Parcel#writeException方法






 
  	
#### ams

管理四大组件。

AMS的启动，instrumentation调用amn，amn通过binder调用 ams，ams中查询ass，ass调用as，然后ams中调用schedulelaunchactivity方法调用到applicationthread中，applicationthread发送一个消息，H类来处理这个消息，创建对象，并通过instrumentation这个类去执行activity的生命周期方法。

Service的启动，service的启动和activity差不多，比activity简单，contextimpl类通过startservice调用amn，amn通过binder调用调用ams的startservice方法，ams调用as方法，as中调用applicationthread方法，去发送一个消息，h类接受到消息进行处理，创建service对象并调用生命周期方法。

进程管理：新建进程，调整oom_adj值，杀进程、

#### pms

负责app的安装、扫描、配置文件收集、dex优化等

应用程序的安装过程，讲代码、so等copy到指定目录，扫描配置文件 收集信息，进行dex优化等。

安装系统 app，已经安装的app，收集组件信息等，dex优化

#### zygote进程初始化

* 启动虚拟机
* 注册jni函数
* 启动scoketserver
* preload 预加载一些资源
* 启动systemserver
* 进入循环，等待介入

#### SystemServer启动

启动各种系统服务。





#### 进程

进程是如何启动的。当ams启动四大组件时，会查询是是否有ProcessRecord，如果没找到匹配的，就会通过Process#start方法去启动进程，进行整理参数，链接zygote进程的socket server端，写入参数，zygote server端接收到参数之后，在native层进行fork操作，并进行初始化，最后通过抛出异常的方式，清理掉虚拟机栈，并调用入口类的main方法(ActivityThread)。

### 网络部分

#### socket

* 三次握手
* 四次挥手
* SSL TSL

#### http

#### https


### 数据结构基础算法

### JNI & NDK 开发

* 数据映射
* Cmake和Makefile
* 动态注册 JNI_OnLoad，JNI_OnUnload，JNINativeMethod("native方法名","方法签名(描述)","对应的c&c++方法")，RegisterNatives方法注册，jni.h文件里的方法，如FindClass,GetXXXField,CallXXXMethod、SetXXX、生成对象，NewObject,CallNovirtualMethod,(AllocObject分配内存)，然后调用构造函数初始化。
* JavaVM 对象，JNIEnv，线程私有
* find_library找到ndk中的lib


### 常用设计模式

* 工厂方法
* 抽象工厂
* 单例
* 简朝哲模式
* 原型模式
* 适配器模式
* 装饰模式 动态给对象添加额外的职责
* 代理模式
* 外观模式 每一个子系统的外部与其内部的通信必须通过一个统一的对象进行
* 桥接模式 抽象部分与现实部分分离
* 组合模式 讲对象以树结构的形式组织起来
* 享元模式 共享对象
* 策略模式
* 模板方法模式
* 观察者模式
* 迭代器模式
* 责任链模式
* 命令模式
* 备忘录模式
* 状态模式
* 访问者模式
* 中介者模式
* 解释器模式


### 其他

* 屏幕适配
* 插件化热修复
	* droidplugin hook系统服务
	* zeusplugin hook classloader，修改aapt源码 
	* 资源问题，构造不同的assetmanager，隔离
	* 热修复
		* native 修复
		* tinker
		* 通过aop，在方法的前后插入代码，修复
* python shell gradle脚本问题
* 组件化的考虑
	* 模块间组件通信问题 ，通过router解决
	* ID冲突问题，加资源前缀
	* 资源共享问题，放在basemodel里 
* android系统架构
	* kernel 
	* lib android runtimr 
	* framework ams，pms，wms，
	* application  
