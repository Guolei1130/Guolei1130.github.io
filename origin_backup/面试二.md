### hash

#### hash表的构造方法

* 直接定址
* 数字分析
* 平方取中
* 折叠
* 随机数
* 除留取余法

#### hash冲突的解决办法

* 开放定址法
	* 线性探测
	* 二次探测
	* 随机探测 
* 链地址法
* 再hash法
* 建立公共溢出区

### kmp算法

### bm算法 Boyer-Moore


### 图

图的邻接矩阵表示。

DFS 深度遍历，BFS广度遍历。

最小生成树 prim算法

Dijkstra算法

### 树

红黑树、b树、二叉查找树、哈夫曼树、BST 二叉搜索树


### 常用算法

* 分治法  将问题分割成小问题
* 动态规划 每次决策依赖当前状态，分割成n个阶段，初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态
* 贪心算法 每次求解，都是当前的最好
* 回溯法
* 分支限界法

### tcp/IP

* tcp是面向链接的，可靠地
* udp是不可靠的，非连接的

	tcp在传输之间，需要先建立连接，而udp是直接将数据抛出。可靠性是指tcp中接收端在接受到数据之后会应答，失败重发。
	
* 三次握手?

客户端发送syn包，服务端接收到之后，发送syn+AcK(确认应答)，并建立服务端到客户端的链接，当客户端收到服务端的链接请求时，发送ack给服务端，并建立客户端到服务端的连接。


* 四次挥手？

客户端发送fin，服务端接受到，发送ack并断开连接。

服务端发送fin，客户端收到发送ack，并断开连接。

* 可靠性靠什么保证，如何提高传输效率？

可靠性靠ack应答包和序列化号保证。利用窗口提高速度，无需等待服务端应答就发送。如果丢包了，服务端就会发哦少年宫重复的应答包，然后客户端进行重发。328页

* 路由表、静态路由表、动态路由表
* HTTP 请求报文响应报文
	* 报文首部
		* 请求行、状态行
		* 请求、响应首部字段
		* 通用首部字段
		* 实体首部字段 
	* 空行 
	* 报文主体

* 状态吗
	* 1xx 接收的请求正在处理
	* 2XX 请求正常处理
	* 3XX 重定向
	* 4xx 客户端错误状态码 服务器无法处理请求
	* 5XX 服务端处理请求出错

* http 1.0、1.1、2.0 有什么区别
	* http 1.0
		* 连接无法复用
	* http1.1
		* 支持持久化链接
	* http 2.0 
		* 多路复用
		* 二进制分帧
		* 首部压缩 HAPACK
		* 服务端推送
* https 原理 
	http+加密+认证+完整性保护=https
	ssl tls
	相互交换密钥
	https采用混合加密，使用公开密钥加密的方式安全地交换在稍后的共享密钥中药使用的密钥，确保交换的密钥是阿全的前提下，使用共享密钥加密的方式进行通信。证明公开密钥正确性的证书。
	* 服务器把自己的公开密钥登录至数字证书认证机构
	* 认证机构使用私钥向服务器的公开密码签署数字签名并颁发公钥证书
	* 客户端使用服务器的公钥证书向证书认证机构公钥证书上的数字签名，确定服务器的公开密钥的真实性
	* 客户端使用服务器的公开密钥对报文加密
	* 服务端使用私有密钥解密
	* 证书=服务器的公开密钥+数字认证机构的数字签名
* HTTPS的通信步骤
	* 证书验证
	* 客户端生成随机数
	* 客户端随机数加密
	* 服务端随机数解密 
	* 客户端生成 加密随机数，进行加密
	* 服务端生成 加密随机数进行解密 

### zeusplugin 

* 替换系统的的classloader，反射吊parent，改变双亲委托机制，让我们自己的classloader来加载类
* 资源，通过替换resources，创建AssetManager，并把插件中的资源也add进来，这样就可以在宿主中使用插件的资源了。
* hotfix 功能的实现，
	* 替换classloader 在加载的时候 优先查找补丁中的类
### droidplugin

基本原理是hook掉 系统服务，

类加载原理 就讲apk文件加载。

通过构建LoadedApk对象，一个插件就是一个Apk，并且需要hook下pms，让系统认为我们这个插件就是一个已经安装过的apk。

多ClassLoader，每个插件都有自己的ClassLoader

### nuwa

qq空间的补丁方案，基于dex分包方案的

讲补丁包，插入到dexElements的第一个位置。

如何防止被打上CLASS_ISPREVERIFIED标志？

引用者和被引用者都需要在一个dex文件中。

往所有类的构造方法中插入一段代码，来防止被打上标志。

### Tinker 

生成差分dex，和旧的dex和成新的dex，完成代码的修复。

* 类替换
	* dexdiff 
* So替换
	* 资源diff 	
* 资源替换


### dalvik 和art虚拟机

	 
dalvik和jvm的区别？

* dalvik是基于寄存器的，jvm是基于栈的
* dalvik运行dex文件，jvm运行java字节码
* android 2.2 开始，dalvik支持jit编译


art android runtime 4.4 加入。dalvik每次运行都通过jit编译转化为机器码，拖慢运行效率，art在第一次安装就进行预编。

ART优点？

* 提高系统性能
* 应用启动、运行快、体验流畅
* 电池续航能力强
* 支持更低的硬件

ART缺点：

* 机器码占用存储空间大
* 应用的安装时间变长


### 修复总结

dex的热修复？

* QQ空间的插桩
* 微信的dex文件差分合成


so的热修复？

* 在6.0之前，和dex的一样，进行插桩。4.0-5.1中，插入到nativeLibraryDirectories最前面6.0，转化为Element，插入到数组前面。 
* 依赖多classloader，

资源的热修复?

* 全量替换
* 替换AssetManager，加载patch资源

增量资源的生成？

* 利用 public.xml 文件固定资源id，aapt 添加 -p参数，生成public.xml


### String、StringBuffer、StringBuildr

StringBuffer线程安全，StringBuiler非线程安全。

string对象不可变，每次都是新的，导致常量池中有大量的，stringbuffer每次都是对对象本身进行，而不是生成新的对象，stringbuffer比较慢，有些情况下，自动生成了stirng buffer。
String = “hello” + "world" + "!";

StringBuffer是类型安全的，里面的核心方法都被synchronized方法修饰了。

StringBuilder 可变的字符序列。不保证同步，用作stringbuffer的建议替换，比stringbuffer快。

* hashmap中采用的 hash值算法是线性探测 二次hash




AsyncTask不足之处？

* AsyncTask可能存在新开大量线程消耗系统资源和导致应用FC的风险
* AsyncTask一旦执行了 doInBackground，就算调用取消方法，也会将 doInBackground里面的代码执行完毕，才会停止。
* 线程池不经维护，当大量异步发生时，导致线程池满了，会出异常

Bitmap占内存大小?

宽*高\*4

没个像素占4个字节，8个bit位



HashMap hash冲突的处理办法？

二次hash，

数据一致性如何保证？synchronized关键字，类锁、方法锁、重入锁。

同步的方法？多进程开发以及多进程应用场景？

同步工具，CountDownLatch(闭锁)，CyclicBarrier 三颗粒百瑞(循环栏栅)、Phaser feize、信号量 三么for等。

服务器只提供数据接收接口，如何保证数据的有序到达？

优先级阻塞队列。


死锁的四个条件？

* 互斥条件
* 请求与保持调节
* 不剥夺条件
* 循环等待条件


### 计数排序

* 拉票环节
* 入桶环节

### 线程池的实现原理

线程池的线程调度。

* 线程优先级
* join
* yied等
* 使用闭锁



### 最小生成树算法

* 普里姆(Prim)算法，以某个点为顶点，找最短的边
* 克鲁斯卡尔(Kruskal)算法，每次找最短的边，不以某个点为顶点

### 最短路径


* 迪杰斯特拉(Dijkstra)算法 找vx 到vy的最短路径
* 弗洛伊德(Floyd)算法 


### 排序算法

* 冒泡排序
* 简单选择排序 在未排序序列中，选出最小的一个 进行交换
* 直接插入排序 将数插入到已排好序的序列中合适的位置
* 希尔排序 分段+直接插入排序
* 堆排序 反复构造大顶堆的过程
* 归并排序 两两比较 进行归并
* 快速排序 关键字，一部分比这个小，一部分比这个大


### 自我介绍

我叫郭蕾，软件工程专业，本科。工作一年半，对Android有浓厚的兴趣，平常利用空闲时间学一些jvm、framework的知识，也偶尔学习一些脚本语言如python、shell等，今天来应聘的岗位是Android开发工程师。






