---
title: jvm垃圾回收
date: 2017-01-14 20:00:28
categories: Java
tags: jvm

---
<Excerpt in index | 首页摘要>
### 前言

这篇依旧是深入理解java虚拟机一书的内容，这本书很好，我也看了几篇了，但是每次看，都有不同的理解，不同的收获，建议大家买一本。

<!-- more -->
<The rest of contents | 余下全文>


java与c++、c这些语言不同的一点就在于，java具有自动管理内存的功能，这其中就包括垃圾回收。下面，就记录下垃圾回收的算法以及垃圾回收器。

### 如何判断对象已死

#### 引用计数

首先说明，jvm中并没有选择引用计数。

给对象添加一个引用计数器，当被引用时，计数器+1,引用失效时，计数器-1。但是这种存在循环引用的问题。

#### 可达性分析算法

通过一系列"GC Roots"的对象作为起始点，从这个节点开始向下搜索，搜索走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明对象是不可用的。

![](http://img.blog.csdn.net/20150130181410620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnRpYW5kamF2YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在java中，GC Roots对象包括以下几种:

* 虚拟机栈(帧栈中的本地变量表)中的应用对象
* 方法区中类静态属性引用的对象(static)
* 方法区中常量引用的对象
* 本地方法栈中(一般说的native方法)引用的对象

#### 自我救赎

在可达性分析中被标记不可达的对象，也不是非死不可。

要宣告一个对象死亡，至少要经历两次标记过程:GC Roots之后，会被第一次标记并且进行筛选，筛选的条件-是否有必要执行finalize方法，当对象没有覆盖finalize方法的时候，或者已经执行过，就不会筛选。(finalize方法只会被系统执行一次)，想实现救赎，可以在finalize之中，重新与引用链上的对象建立关联，因为finalize只会被系统执行一次，所以只能救赎一次。

#### 回收方法区

方法区存储的是被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。这部分的回收主要有两部分:废弃常量和无用的类。

废弃常量-没有对象引用的话，就会被移除常量池，进行回收
无用的类，类加载容易，卸载难，满足卸载的条件如下：

* 该类的所有实例都被回收
* 加载该类的ClassLoader被回收
* 对象的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法

### 垃圾回收算法

#### 标记－清理算法

![](http://images.cnitblog.com/i/288799/201406/181024382398115.jpg)

首先标记出需要回收的对象，然后清理掉需要回收的对象。

缺点：

* 标记和回收的过程效率都不高
* 会产生内存碎片

#### 复制算法

![](http://images.cnitblog.com/i/288799/201406/181041528488728.jpg)

将内存划分为两块内存，使用其中一块，当一块用完时，将存活的对象复制到另一块上面，并将用过的内存空间一次清理掉。

hotspot虚拟机，会将内存分为一块Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor，回收时，将存活的对象复制到另一块Survivor上，然后清理。

但是这样存在问题，无法确定存活的对象小于Survivor的空间，所以需要分配担保(将多余的对象放入其他内存空间,比如老年代)

在对象存活率较高时，要进行较多的复制操作，因此不适合老生代。

#### 标记－整体算法

![](http://images.cnitblog.com/i/288799/201406/181100129575916.jpg)

先标记死亡的对象，然后存活的对象向一端移动，最后清理掉另一端。

#### 分代算法

将内存根据生命周期分为几种，一般为新生代和老生代，然后根据特性，选择不同的回收算法。

#### 总结

新生代适合复制算法。老生代适合标记－清理、标记－整体之类。


### HotSpot的算法实现

* 枚举根节点,这个时候需要停止所有的执行线程(Stop The World)
* 安全点，程序执行时并非在所有地方都能停顿下来开始gc，直邮到达特定的点(安全点)才能暂停
* 安全区域，指在一段代码之中，引用关系不会发生变化，所以在这段区域的人和地方都可以停下来gc

### 垃圾收集器

![](http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg)

####  Serial(old)收集器

串行收集器,新生代和老生代都有，不过新生代用的是复制算法，老生代用的是标记－整理算法。

![](http://my.csdn.net/uploads/201208/19/1345372405_7285.jpg)

图为Serial和Serial Old结合使用的图。

#### ParNew收集器

是Serial收集器的多线程版本，ParNewh和Serial Old结合使用的图如下：

![](http://my.csdn.net/uploads/201208/19/1345372429_9105.jpg)


ParNew收集器在cpu核数多的情况下才有优势。

#### Parallel Scavenge收集器

目标：吞吐量

参数：

* -XX:MaxGCPauseMillis 控制最大停顿时间
* -XX:GCTimeRatio 直接设置吞吐量大小

#### Parallel Old

Parallel的老生代版本，使用多线程和标记－整理算法。

#### CMS收集器

CMS(Concurrent Mark Sweep)以获取最短停顿时间为目标的收集器。

过程：

* 初始标记 cms initial mark
* 并发标记 cms concurrent mark
* 重新标记 cms remark
* 并发清除 cms concurrent sweep

![](http://my.csdn.net/uploads/201208/19/1345372484_6375.jpg)

缺点：

* 对cpu资源敏感
* 无法处理浮动垃圾
* 大量碎片

#### G1收集器

G1(garbage first)，面向服务端的垃圾收集器。具备以下特点：

* 并行与并发
* 分代收集
* 空间整合
* 可预测停顿

g1收集器的运作大致可划分为以下几个步骤:

* 初始标记 initial marking
* 并发标记 concurrent marking
* 最终标记 final marking
* 筛选会后 live data counting and evacuation





### 内存分配策略

* 对象优先在Eden分配(新生代)
* 大对象直接进入老年代
* 长期存活的对象进入老年代，每个对象都有一个年龄计数器，当躲过一次gc，加一，当大于阀值，则进入老生代
* 动态对象年龄判断 Survivor空间中相同年龄所有对象大小和大于空间的一半，则大于等于这个年龄的都进去老年代
* 空间分配担保,在这里需要先介绍两个名词
	* Minor GC 新生代gc
	* Major GC 老生代gc
	* 在进行Minor GC时，会检查老生代的连续内存是否大于新生代所有对象总空间(可能会有对象晋升到老生代，这是一种保守的做法(悲观？))，如果大，就是安全的，不成立，则看HandlePromotionFailure设置值是否允许担保失败，如果允许，就看老生代的连续内存大小是否大于历次晋升的平均大小，如果大于，进行 Minor GC ，但是这时还存在风险(乐观做法)。如果不允许，进行 Major GC。
	
### 总结

许多虚拟机参数，这里并没有说明。建议大家买本这个书看，真的，每次都有收获。








### 最近访客
<ul class="ds-recent-visitors" data-num-items="46" data-avatar-size="40"></ul>